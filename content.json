{"pages":[{"title":"","text":".highlight .hll { background-color: #ffffcc } .highlight { background: #f8f8f8; } .highlight .c { color: #408080; font-style: italic } /* Comment */ .highlight .err { border: 1px solid #FF0000 } /* Error */ .highlight .k { color: #008000; font-weight: bold } /* Keyword */ .highlight .o { color: #666666 } /* Operator */ .highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */ .highlight .cp { color: #BC7A00 } /* Comment.Preproc */ .highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */ .highlight .cs { color: #408080; font-style: italic } /* Comment.Special */ .highlight .gd { color: #A00000 } /* Generic.Deleted */ .highlight .ge { font-style: italic } /* Generic.Emph */ .highlight .gr { color: #FF0000 } /* Generic.Error */ .highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */ .highlight .gi { color: #00A000 } /* Generic.Inserted */ .highlight .go { color: #808080 } /* Generic.Output */ .highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */ .highlight .gs { font-weight: bold } /* Generic.Strong */ .highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */ .highlight .gt { color: #0040D0 } /* Generic.Traceback */ .highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */ .highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */ .highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */ .highlight .kp { color: #008000 } /* Keyword.Pseudo */ .highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */ .highlight .kt { color: #B00040 } /* Keyword.Type */ .highlight .m { color: #666666 } /* Literal.Number */ .highlight .s { color: #BA2121 } /* Literal.String */ .highlight .na { color: #7D9029 } /* Name.Attribute */ .highlight .nb { color: #008000 } /* Name.Builtin */ .highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */ .highlight .no { color: #880000 } /* Name.Constant */ .highlight .nd { color: #AA22FF } /* Name.Decorator */ .highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */ .highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */ .highlight .nf { color: #0000FF } /* Name.Function */ .highlight .nl { color: #A0A000 } /* Name.Label */ .highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */ .highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */ .highlight .nv { color: #19177C } /* Name.Variable */ .highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */ .highlight .w { color: #bbbbbb } /* Text.Whitespace */ .highlight .mf { color: #666666 } /* Literal.Number.Float */ .highlight .mh { color: #666666 } /* Literal.Number.Hex */ .highlight .mi { color: #666666 } /* Literal.Number.Integer */ .highlight .mo { color: #666666 } /* Literal.Number.Oct */ .highlight .sb { color: #BA2121 } /* Literal.String.Backtick */ .highlight .sc { color: #BA2121 } /* Literal.String.Char */ .highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */ .highlight .s2 { color: #BA2121 } /* Literal.String.Double */ .highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */ .highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */ .highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */ .highlight .sx { color: #008000 } /* Literal.String.Other */ .highlight .sr { color: #BB6688 } /* Literal.String.Regex */ .highlight .s1 { color: #BA2121 } /* Literal.String.Single */ .highlight .ss { color: #19177C } /* Literal.String.Symbol */ .highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */ .highlight .vc { color: #19177C } /* Name.Variable.Class */ .highlight .vg { color: #19177C } /* Name.Variable.Global */ .highlight .vi { color: #19177C } /* Name.Variable.Instance */ .highlight .il { color: #666666 } /* Literal.Number.Integer.Long */","link":"/media/css/highlight.css"},{"title":"","text":"/*------------------------------------ * sext * * @author skywang * @link http://wangkuiwu.github.com * @update 2011-12-20 * * |/ | (~ (~ * |\\.|._)._) * --------------------------------- */ body{font-size:14px;word-spacing:1px; margin-left:auto; margin-right:auto; font-family:\"Hiragino Sans GB\",\"Microsoft YaHei\",Trebuchet,\"Trebuchet MS\",Tahoma,\"Lucida Grande\",\"Lucida Sans Unicode\",Verdana,sans-serif;color:#000000;background-color:#ffffff;} *{padding:0;margin: 0;border:none;outline:none;} a{color:#dd0000;text-decoration:none;} a:hover{color:#333333;text-decoration:underline;} hr{margin:.7em 0;border-top:1px dashed #d0d0d0;border-bottom:1px dashed #f9f9f9;} p{padding:.5em 0;} li{padding:.2em 0;} ol,ul{list-style-position:inside;} ol ul, ul ol, ul ul, ol ol {margin-left:1em;} pre code{margin:1em 0;font-size:13px;line-height:1.6;display:block;overflow:auto;} blockquote{display:block;text-align:justify;border-left:4px solid #eeeeee;} blockquote{margin:1em 0em;padding-left:1.5em;} blockquote p{margin:0;padding:.5em 0;} #container{width:960px;margin:2em auto;display:block;padding:0 2em;} .content{font-size:16px;line-height:24px;} .content h1{padding:1.2em 0 .5em;} .content h2{padding:.2em 0;} .content img{max-width:960px;display:block;margin:4px auto;-webkit-box-shadow:#999 1px 1px 4px;-moz-box-shadow:#999 1px 1px 4px;box-shadow:#999 1px 1px 4px;} #tag_cloud{margin-bottom: 1em;} #tag_cloud a:hover{color:#333333 !important;text-decoration:none;} .listing-item,.listing-seperator{list-style-type:none;} .listing-item a{ padding:.2em 1em; } table { font-size:16px; color:#333333; border-width: 1px; border-color: #666666; border-collapse: collapse; } table th { border-width: 1px; padding: 8px; border-style: solid; border-color: #666666; background-color: #dedede; } table td { border-width: 1px; padding: 8px; border-style: solid; border-color: #666666; background-color: #ffffff; } .listing-item time{color:#999999;} .listing-seperator{font-weight:bold;} .meta{text-align:right;font-size:12px;} .pageNav{font-weight:bold;font-size:17px;} .pageNavInvalid{font-weight:bold;font-size:17px;color:#D0D0D0;} header{padding:.5em 0;border-bottom: 1px solid #cccccc;} nav{font-family:sans-serif;font-size:1.1em;text-transform:uppercase;float:left;margin-left:-12em;width:9em;text-align:right;} nav a{display:block;padding:.7em 1em;color:#000000;} nav a:hover{background-color:#ff0000;text-decoration:none;color:#f9f9f9;-webkit-transition:color .2s linear;} .post{padding:.5em 0em;} h1{font-family:\"Hiragino Sans GB\",\"Microsoft YaHei\",sans-serif;font-size:1.6em;color:#000;} h2{font-family:\"Hiragino Sans GB\",\"Microsoft YaHei\",sans-serif;font-size:1.3em;color:#111;} h3{font-family:\"Hiragino Sans GB\",\"Microsoft YaHei\",sans-serif;font-size:1.1em;color:#222;} h4{font-family:\"Hiragino Sans GB\",\"Microsoft YaHei\",sans-serif;font-size:1em;color:#333;} pre,code{font-family:Menlo,\"Andale Mono\",Consolas,\"Courier New\",Monaco,monospace;font-size:13px;} code{background-color:#D0D0D0;} embed,object,iframe{display:block;margin:4px auto;} .gist{font-size: 12px;line-height:1.6;} footer{ display:block; border-top: 1px dashed #CCC; } footer small { font-size: 13px; color: #999; } footer a { margin: 1px; border: 1px solid rgba(1,1,1,0); border-bottom: 1px dashed #BBB; color: #B9221F; text-decoration: none; } footer a:hover { color: rgba(250,250,250,1.0) !important; -webkit-border-radius: 4px; border: 1px solid rgba(0,0,0,0.45); text-shadow: rgba(0,0,0,0.6) 0px -1px 0px; background: -webkit-gradient(linear, left top, left bottom, from(rgba(110,110,110,1.0)), to(rgba(100,100,100,1.0))); -webkit-box-shadow: rgba(0,0,0,1.0) 0px 0px 2px,rgba(255,255,255,0.15) 0px 1px 1px inset; text-decoration: none; } .label { font-size:11.25px; font-weight:700; color:#fff; text-transform:uppercase; background-color:#999; -webkit-border-radius:3px; -moz-border-radius:3px; border-radius:3px; padding:1px 3px 2px; } .label-important { background-color:#b94a48; } .label-warning { background-color:#f89406; } .label-success { background-color:#468847; } .label-info { background-color:#3a87ad; } .paginator { font: 14px Arial,Helvetica,sans-serif; color: #AAA; margin: 20px 0; line-height: 150%; display: block; } .paginator a,.paginator span{ padding: 0 4px; margin: 2px; text-decoration: none; } .paginator .current-page { color: white; background: #ff0000; } .paginator a:hover{ color: white; background: #83BF73; }","link":"/media/css/style.css"},{"title":"","text":"@media screen { .container { width:auto; padding:20px; } h1 { font-size:20px; line-height:30px; } .sitename { font-size:24px; font-weight:700; } } html { font-size:100%; -webkit-text-size-adjust:100%; -ms-text-size-adjust:100%; } a:focus { outline:5px auto 0; outline-offset:-2px; } a:hover,a:active { outline:0; } img { max-width:100%; height:auto; border:0; -ms-interpolation-mode:bicubic; -webkit-border-radius:4px; -moz-border-radius:4px; border-radius:4px; } p img { clear:both; display:block; margin-left:auto; margin-right:auto; border:4px solid #FFF; -webkit-box-shadow:0 1px 3px #ccc; -moz-box-shadow:0 1px 3px #ccc; } body { font-family:\"Hiragino Sans GB\",\"Microsoft YaHei\",Trebuchet,\"Trebuchet MS\",Tahoma,\"Lucida Grande\",\"Lucida Sans Unicode\",Verdana,sans-serif; font-size:15px; line-height:30px; color:#555; background-color:#fff; margin:0; } a { color:#b9221f; text-decoration:none; } a:hover { color:#771614; text-decoration:none; } p a { border-bottom:1px dashed #bbb; } .container { margin-left:auto; margin-right:auto; zoom:1px; width:1024px; } p { font-size:15px; line-height:30px; color:#555; margin:0 0 15px; } p small { font-size:13px; color:#999; } .lead { margin-bottom:30px; font-size:20px; font-weight:200; line-height:45px; } h1,h2,h3,h4,h5,h6 { font-weight:400; color:#555; text-rendering:optimizelegibility; margin:0; } h1 small,h2 small,h3 small,h4 small,h5 small,h6 small { font-weight:400; color:#999; } h1 { font-size:30px; line-height:60px; } h2 { font-size:24px; line-height:60px; } h3 { line-height:45px; font-size:18px; } h6 { font-size:11px; color:#999; text-transform:uppercase; } ul,ol { margin:0 0 15px 25px; padding:0; } ul ul,ul ol,ol ol,ol ul { margin-bottom:0; } ul { list-style:disc; } ol { list-style:decimal; } ul.unstyled { margin-left:0; list-style:none; } dl { margin-bottom:30px; } dd { margin-left:15px; } hr { border:0; border-top:1px solid #e5e5e5; border-bottom:1px solid #fff; margin:30px 0; } em { font-style:italic; } .muted { color:#999; } abbr { font-size:90%; text-transform:uppercase; border-bottom:1px dotted #ddd; cursor:help; } blockquote { border-left:5px solid #eee; margin:0 0 30px; padding:0 0 0 15px; } blockquote p { margin-bottom:0; font-size:13px; font-weight:300; line-height:25px; } blockquote small { display:block; line-height:30px; color:#999; } blockquote small:before { content:'\\2014 \\00A0'; } blockquote.pull-right { float:right; padding-left:0; padding-right:15px; border-left:0; border-right:5px solid #eee; } blockquote.pull-right p,blockquote.pull-right small { text-align:right; } q:before,q:after,blockquote:before,blockquote:after { content:\"\"; } address { display:block; margin-bottom:30px; line-height:30px; font-style:normal; } small { font-size:100%; } cite { font-style:normal; } code,pre { font-family:Monaco,Menlo,\"Courier New\",monospace; font-size:12px; color:#333; -webkit-border-radius:3px; -moz-border-radius:3px; border-radius:3px; padding:0 3px 2px; } code { color:#d14; background-color:#D0D0D0; border:1px solid #e1e1e8; padding:3px 4px; } pre { display:block; font-size:12px; line-height:20px; background-color:#f5f5f5; border:1px solid rgba(0,0,0,0.15); -webkit-border-radius:4px; -moz-border-radius:4px; border-radius:4px; white-space:pre-wrap; word-break:break-all; margin:0 0 15px; padding:14.5px; } pre.prettyprint { margin-bottom:30px; background-color:#f7f7f9; border:1px solid #e1e1e8; padding:8px; } pre code { background-color:transparent; padding:0; border: none; } .lit { color:#195f91; } .fun { color:#dc322f; } .str,.atv { color:#D14; } .kwd,.linenums .tag { color:#1e347b; } .typ,.atn,.dec,.var { color:teal; } .pln { color:#48484c; } .prettyprint.linenums { -webkit-box-shadow:inset 40px 0 0 #fbfbfc,inset 41px 0 0 #ececf0; -moz-box-shadow:inset 40px 0 0 #fbfbfc,inset 41px 0 0 #ececf0; box-shadow:inset 40px 0 0 #fbfbfc,inset 41px 0 0 #ececf0; } .fade { -webkit-transition:opacity .15s linear; -moz-transition:opacity .15s linear; -ms-transition:opacity .15s linear; -o-transition:opacity .15s linear; transition:opacity .15s linear; opacity:0; } .fade.in { opacity:1px; } .collapse { -webkit-transition:height .35s ease; -moz-transition:height .35s ease; -ms-transition:height .35s ease; -o-transition:height .35s ease; transition:height .35s ease; position:relative; overflow:hidden; height:0; } .collapse.in { height:auto; } .nav { margin-left:0; margin-bottom:20px; list-style:none; } .nav>li>a { display:block; background-color:#eee; } .nav>li>a:hover { text-decoration:none; color:#fff; background-color:#b9221f; } .pills { zoom:1px; } .pills>li>a { margin-right:2px; line-height:14px; margin-top:2px; margin-bottom:2px; -webkit-border-radius:5px; -moz-border-radius:5px; border-radius:5px; padding:8px 12px; } .pager { margin-left:0; margin-bottom:30px; list-style:none; text-align:center; zoom:1px; } .pager li { display:inline; } .pager a { display:inline-block; background-color:#f8f8f6; border:1px solid #ddd; -webkit-border-radius:15px; -moz-border-radius:15px; border-radius:15px; padding:5px 14px; } .pager a:hover { text-decoration:none; background-color:#f5f5f5; } .label { font-size:11.25px; font-weight:700; color:#fff; text-transform:uppercase; background-color:#999; -webkit-border-radius:3px; -moz-border-radius:3px; border-radius:3px; padding:1px 3px 2px; } .label-important { background-color:#b94a48; } .label-warning { background-color:#f89406; } .label-success { background-color:#468847; } .label-info { background-color:#3a87ad; } .hide { display:none; } .invisible { visibility:hidden; } .sitename { font-size:40px; font-weight:700; } footer,header,nav,.show { display:block; } a.label:hover,.pills .active>a,.pills .active>a:hover { color:#fff; background-color:#b9221f; } h1 small,h2 small { font-size:18px; } h3 small,h4 { font-size:14px; } h4,h5,h6,li,dt,dd { line-height:30px; } h4 small,h5 { font-size:12px; } dt,strong { font-weight:700; } .com,.pun,.opn,.clo { color:#93a1a1; } .pills:before,.pills:after,.pager:before,.pager:after { display:table; content:\"\"; } .pills:after,.pager:after { clear:both; } .pills>li,.pager .previous a,.pull-left { float:left; } .pager .next a,.pull-right { float:right; }","link":"/media/css/home.css"},{"title":"","text":"(function($) { $.fn.tagcloud = function(options) { var opts = $.extend({}, $.fn.tagcloud.defaults, options); tagWeights = this.map(function(){ return $(this).attr(\"rel\"); }); tagWeights = jQuery.makeArray(tagWeights).sort(compareWeights); lowest = tagWeights[0]; highest = tagWeights.pop(); range = highest - lowest; if(range === 0) {range = 1;} // Sizes if (opts.size) { fontIncr = (opts.size.end - opts.size.start)/range; } // Colors if (opts.color) { colorIncr = colorIncrement (opts.color, range); } return this.each(function() { weighting = $(this).attr(\"rel\") - lowest; if (opts.size) { $(this).css({\"font-size\": opts.size.start + (weighting * fontIncr) + opts.size.unit}); } if (opts.color) { $(this).css({\"color\": tagColor(opts.color, colorIncr, weighting)}); } }); }; $.fn.tagcloud.defaults = { size: {start: 14, end: 18, unit: \"pt\"} }; // Converts hex to an RGB array function toRGB (code) { if (code.length == 4) { code = jQuery.map(/\\w+/.exec(code), function(el) {return el + el; }).join(\"\"); } hex = /(\\w{2})(\\w{2})(\\w{2})/.exec(code); return [parseInt(hex[1], 16), parseInt(hex[2], 16), parseInt(hex[3], 16)]; } // Converts an RGB array to hex function toHex (ary) { return \"#\" + jQuery.map(ary, function(i) { hex = i.toString(16); hex = (hex.length == 1) ? \"0\" + hex : hex; return hex; }).join(\"\"); } function colorIncrement (color, range) { return jQuery.map(toRGB(color.end), function(n, i) { return (n - toRGB(color.start)[i])/range; }); } function tagColor (color, increment, weighting) { rgb = jQuery.map(toRGB(color.start), function(n, i) { ref = Math.round(n + (increment[i] * weighting)); if (ref > 255) { ref = 255; } else { if (ref < 0) { ref = 0; } } return ref; }); return toHex(rgb); } function compareWeights(a, b) { return a - b; } })(jQuery);","link":"/media/js/jquery.tagcloud.js"},{"title":"","text":"var hljs=new function(){var p={};var a={};function n(c){return c.replace(/&/gm,\"&amp;\").replace(//gm,\"&gt;\")}function k(s,r){if(!s){return false}for(var c=0;c","link":"/media/js/highlight.pack.js"},{"title":"","text":"/*! jQuery v1.7.1 jquery.com | jquery.org/license */ (function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f(\"\").appendTo(b),e=d.css(\"display\");d.remove();if(e===\"none\"||e===\"\"){cl||(cl=c.createElement(\"iframe\"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode===\"CSS1Compat\"?\"\":\"\")+\"\"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,\"display\"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g0){if(c!==\"border\")for(;g=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+\"defer\",e=b+\"queue\",g=b+\"mark\",h=f._data(a,d);h&&(c===\"queue\"||!f._data(a,e))&&(c===\"mark\"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b===\"data\"&&f.isEmptyObject(a[b]))continue;if(b!==\"toJSON\")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e=\"data-\"+c.replace(k,\"-$1\").toLowerCase();d=a.getAttribute(e);if(typeof d==\"string\"){try{d=d===\"true\"?!0:d===\"false\"?!1:d===\"null\"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\\s+/);for(c=0,d=a.length;c)[^>]*$|#([\\w\\-]*)$)/,j=/\\S/,k=/^\\s+/,l=/\\s+$/,m=/^(?:)?$/,n=/^[\\],:{}\\s]*$/,o=/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,q=/(?:^|:|,)(?:\\s*\\[)+/g,r=/(webkit)[ \\/]([\\w.]+)/,s=/(opera)(?:.*version)?[ \\/]([\\w.]+)/,t=/(msie) ([\\w.]+)/,u=/(mozilla)(?:.*? rv:([\\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+\"\").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a===\"body\"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a==\"string\"){a.charAt(0)!==\"\"||a.length0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger(\"ready\").off(\"ready\")}},bindReady:function(){if(!A){A=e.Callbacks(\"once memory\");if(c.readyState===\"complete\")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener(\"DOMContentLoaded\",B,!1),a.addEventListener(\"load\",e.ready,!1);else if(c.attachEvent){c.attachEvent(\"onreadystatechange\",B),a.attachEvent(\"onload\",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)===\"function\"},isArray:Array.isArray||function(a){return e.type(a)===\"array\"},isWindow:function(a){return a&&typeof a==\"object\"&&\"setInterval\"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||\"object\"},isPlainObject:function(a){if(!a||e.type(a)!==\"object\"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,\"constructor\")&&!D.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!=\"string\"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,\"@\").replace(p,\"]\").replace(q,\"\")))return(new Function(\"return \"+b))();e.error(\"Invalid JSON: \"+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,\"text/xml\")):(d=new ActiveXObject(\"Microsoft.XMLDOM\"),d.async=\"false\",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName(\"parsererror\").length)&&e.error(\"Invalid XML: \"+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,\"ms-\").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,d=\"sizcache\"+(Math.random()+\"\").replace(\".\",\"\"),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\\\/g,k=/\\r\\n/g,l=/\\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!=\"string\")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(\"\"),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]===\"~\"||w[0]===\"+\")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q=\"\",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)===\"[object Array]\")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e","link":"/media/js/jquery-1.7.1.min.js"}],"posts":[{"title":"Futter快速入门学习指南","text":"flutter是什么？ flutter是google退出的一款跨平台app开发框架，他采用自己绘制界面的方式，采用了Android的skia绘制引擎，性能较高，同时不是像react native一样渲染成原生组件，所以跨平台兼容性较好，不需要依赖原生实现。 （一）flutter基础flutter项目目录介绍 项目结构 常用命令 flutter doctor、flutter build、flutter —version flutter packages get hot reload如何进行的 flutter —help演示 程序是如何运行的 main函数 入口 演示demo的布局讲解 flutter inspector使用 （二）flutter布局介绍Text Textfield. Container Column Row Stack ListView Scofford 页面传值与原生交互 Flutter平台特定的API支持不依赖于代码生成，而是依赖于灵活的消息传递的方式： 应用的Flutter部分通过平台通道（platform channel）将消息发送到其应用程序的所在的宿主（iOS或Android）。 宿主监听的平台通道，并接收该消息。然后它会调用特定于该平台的API（使用原生编程语言） - 并将响应发送回客户端，即应用程序的Flutter部分。 用平台通道在客户端（Flutter UI）和宿主（平台）之间传递消息，如下图所示： 界面绘制：","link":"/2019/02/21/Flutter快速入门文档/"},{"title":"Flutter 开发桌面应用对比","text":"前言最近用flutter做了一款App，已经发布了Android和iOS的版本，因为有计划支持全部平台。所以开始尝试flutter desktop的解决方案。在github上我们能发现两个方案，一个是flutter官方的方案flutter-desktop-embedding还有一个是使用go和glfw开发的go-flutter 两种方案对比在选择使用flutter-desktop还是go-flutter之前，我们先对两种方案做一些介绍和对比。 两种方式的项目结构： Flutter Desktop Embedding:在flutter desktop中我们可以看到目录结构和flutter开发手机App的结构是类似的，一个主项目下有各个平台的壳工程(这里面也可以包含Android和iOS)，然后由壳工程集成flutter的渲染引擎。flutter的代码写在lib目录中。 如果我们懂一些macOS开发或者windows开发，可以直接在项目中修改原生代码，比如你想修改整个程序的window的样式直接在原工程中就能修改，又比如macOS你要集成苹果的IAP，可以直接在原生项目中实现即可。 它的缺点就是三个平台的开发你最好都得懂一些 Go Flutter:Go Flutter由于本身Go语言就是跨平台的，所有它只有一个desktop目录，表示桌面版，相比于flutter desktop它让开发者完全不需要去关心macOS或者windows开发了，desktop中全是go语言编写的内容，最后desktop可以编译成三中平台的可执行文件。开发者只需要会Go语言即可。 它的缺点就是如果win或者mac或者linux你要在不同的平台做一些特殊的功能或者界面，会特别麻烦，不像在Flutter desktop中直接在宿主项目中实现即可。 对比结果如何选择首先我们要明确，两种方案都不太成熟，但是如果要用来开发，也不是用不了。大家选择的时候可以根据自身技术栈，以及产品的特性来选择。 如果你懂Go语言，同时你的程序是阅读类，或者偏业务类，基本不需要和本身Native交互的，选 Go Flutter真的很爽。 如果你懂一点macOS或者windows开发，同时你的程序经常三个桌面端各有特色，而且需要修改本身整个window的一些样式，那么选择Flutter desktop embedding。 Go Flutter实际使用上面说了这么多，我们来实际体验一下Go flutter。先说一下背景，我已经使用flutter开发了一款App，现在我要把App变成可以运行到桌面的版本。我写的软件叫做Everything是一款记录类软件，在这里可以下载到https://everything.apppills.com大家可以先看一下效果。 安装Go ，由于Go flutter使用Go编写，所以需要安装Go工具包。大家可以在官网下载安装 安装hover，hover是 Go Flutter的一个命令行工具，简化了项目初始化以及运行等步骤。 使用下面命令安装 1go get -u github.com/go-flutter-desktop/hover 注意如果上面的命令卡住下载不下来，大家可以设置一下代理，设置命令行代理可以开启ss或者v2ray，然后在命令行输入命令设置 12export http_proxy=\"http://127.0.0.1:8001\"; export HTTP_PROXY=\"http://127.0.0.1:8001\"; export https_proxy=\"http://127.0.0.1:8001\"; export HTTPS_PROXY=\"http://127.0.0.1:8001\"//8001改成你的ss或者v2ray监听的端口 ⚠️ 注意：安装好hover之后，官网上说就可以使用hover命令了，但是可能你在命令行里敲hover可能还是得到的是command not found。 这里我用的是mac系统，在安装好之后，在home目录多了一个go的目录，需要在你的环境变量里加入一下go的包路径。 123export PATH=$PATH:/usr/local/go/binexport PATH=$PATH:/Users/&#123;你的用户名&#125;/go/bin//可以检查一下你的home目录是否有了go的目录，里面有个bin，将那个目录加入到环境变量即可 进入你以前开发App的flutter项目，执行命令初始化项目 12hover init github.com/my-organization/simpleApplication//后面这个github.com xxxx就是你的项目仓库地址。没有的话随便写也行 初始化项目完成后，你会在你的项目中发现一个desktop目录，和以前的iOS和Android是平级的。这个desktop目录就是桌面版的项目。 把你的main.dart复制一份名字改为main_desktop.dart，Go flutter有个特别的地方，就是程序的入口不是用的main.dart，而是用的main_desktop.dart。 修改main_desktop.dart为使用桌面版运行 12345void main() &#123; // 关键是下面这一句 debugDefaultTargetPlatformOverride = TargetPlatform.fuchsia; runApp(new MyApp());&#125; 大功告成，运行项目吧。 12hover run//执行 hover run 可以运行项目 我们先来看一下运行效果下面是App的运行效果和桌面版的运行效果。 手机版本身效果： Go Flutter运行的桌面版效果： FAQ：1.程序按照上面那样迁移完成就能跑？当然不是，我们都知道我们用了很多插件，其实是只支持Android或者iOS的，如果你用得比较多的这种插件，那么你可能迁移到桌面端过来会比较麻烦。我的整体迁移的时间大概只用了2-3个小时，我用到了sqflite和shared preference，这两个插件Go flutter已有实现，所以很容易替换。 2.如何使用Go flutter的插件我们知道我们所有和原生通信都是通过定义一个method channel来通信的。如果你用到的插件只支持Android或者iOS，那么你就需要在desktop中去实现这个插件的method channel的所有方法。目前Go flutter只有三个插件可以用，在这里可以找到。https://github.com/go-flutter-desktop/plugins 点击某个插件，就可以看到使用方法，就是把对应代码贴到，desktop里面的option文件中即可，不要找错地方了，官网没说得太清楚。 最后感谢大家的阅读，我们用flutter开发了个小App也欢迎大家试用： Everything 把记账本日记本，行程，待办等等都装进一个App里。 https://everything.apppills.com/","link":"/2019/06/09/Flutter 开发桌面应用初步体验——Go Flutter还是Flutter Desktop Embedding/"},{"title":"使用Appium进行App自动化测试体验","text":"1.为什么选择Appium 脚本编写支持多种语言方便测试人员使用自己喜欢的语言维护脚本 跨平台同事支持Android和iOS的测试、并且支持应用内嵌RN或者webview等的测试 纯黑盒，不需要依赖项目源码，可以完全由测试人员控制和维护脚本 基于seleium如果有做过web自动化测试经验会很容易上手 2.Appium简介Appium是一款基于seleium采用C/S架构的测试工具。有多种语言的客户端比如python和java还有javascript等等，客户端使用rest接口与server端进行通信。server端根据rest请求使用对应的driver和Android真机或者iOS模拟器等设备进行交互。 目前Appium支持如下驱动： XCUITest (iOS) XCUITest Real Devices(iOS) UIAutomation (iOS) UIAutomation Safari Launcher(iOS) UIAutomatar（Android） Espresso …等等 3.环境搭建要使用appium进行自动化测试首先需要安装AppiumServer，然后配置对应的开发环境，安装对应的client客户端以及配置环境，最后编写用咧脚本，然后运行测试。下面我们采用python做为客户端语言，使用Appium Desktop做为server为Android编写测试用例。 1.安装Appium Server Desktop选择适合自己系统的最新版本进行下载 下载好后双击打开后点击startServer即可启动该服务 2.安装Android Studio和Java SDK(如果以及配置好这些环境可跳过该步骤) 下载Android Studio，包含有Android SDK以及可以方便的使用Layout Inspector查找界面id https://www.androiddevtools.cn/选择适合自己电脑的最新版本，旧版本没有Layout Inspector 安装好后配置一下Android Home环境变量 123# Android Homeexport ANDROID_HOME=/Users/zhiqiangdeng/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools 下载JDK并配置Java Home环境变变量 123# Java Homeexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Homeexport PATH=$PATH:$JAVA_HOME/bin 3.安装Appium Client这里我们使用python版本的clienthttps://github.com/appium/python-client 在使用pip安装appium python client之前，建议先安装pyenv用于管理python的版本。使用pyenv-virtualenv管理python的虚拟环境。如果嫌麻烦可跳过。 1pip install Appium-Python-Client 4.开发测试脚本安装好后创建一个目录作为我们的项目目录mkdir project-test 使用你喜欢的编辑器打开，这里我使用pycharm。 编写脚本： 下面我们以一个登录模块的脚本为例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#python # Android environmentimport unittestfrom time import sleepfrom appium import webdriverclass LoginTests(unittest.TestCase): def setUp(self): # 配置appium需要哪些能力，以及设备信息等基础资料，详细字段可以参考 # http://appium.io/docs/en/writing-running-appium/caps/ desired_caps = &#123;&#125; desired_caps['platformName'] = 'Android' desired_caps['automationName'] = 'uiautomator2' desired_caps['deviceName'] = 'emulator-5556 (9)' desired_caps['appPackage'] = 'com.hd123.apos.ui.debug' desired_caps['appActivity'] = 'com.hd123.apos.ui.view.welcome.SplashActivity' desired_caps[\"autoGrantPermissions\"] = True desired_caps[\"noReset\"] = True self.driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) # def testIsLoginPageAndStoreIdCorrected(self): #执行一个测试，执行UI测试最重要的三点 # 1. 查找元素 # 2. 执行动作 # 3. 判断结果 sleep(2) # appium支持通过findbyid以及xpath等进行元素的定位 loginBtn = self.driver.find_element_by_id(\"login_tv\") self.assertIsNotNone(loginBtn) el = self.driver.find_element_by_xpath(\"//android.widget.TextView[contains(@text,'AP1001')]\") self.assertIsNotNone(el) def testStoreNumberCorrected(self): username = self.driver.find_element_by_id(\"code_et\") username.set_value(\"5551\") password = self.driver.find_element_by_id(\"pwd_et\") password.set_value(\"0\") loginBtn = self.driver.find_element_by_id(\"login_tv\") loginBtn.click() # def testif __name__ == '__main__': suite = unittest.TestLoader().loadTestsFromTestCase(LoginTests) unittest.TextTestRunner(verbosity=2).run(suite)","link":"/2019/03/29/使用Appium进行App自动化测试体验/"},{"title":"优化使用kotlin开发Android app的编译速度","text":"团队使用kotlin挺长时间了，一直以来都不太满意kotlin的编译速度，但是也能忍受。最近开了一个新项目，有不少同事从java过来的，他们就实在是受不了，优化编译速度就变得很重要了。 优化之前和之后的对比在优化之前我们的一次完整编译时间是2分21秒 具体的耗时任务在Run Tasks中： 可以看到具体的耗时任务如上，主要是kapt相关的编译和编译kotlin代码，以及最后的transformClassedWithXXX。 优化之后的完整编译时间31s 优化之后的增量编译时间15s 优化步骤：1.优化gradle配置：在项目根目录创建一个gradle.properties文件 12345678910111213141516171819202122//开启gradle并行编译，开启daemon，调整jvm内存大小org.gradle.daemon=trueorg.gradle.configureondemand=trueorg.gradle.parallel=trueorg.gradle.jvmargs=-Xmx4096m -XX:MaxPermSize=1024m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8//开启gradle缓存org.gradle.caching=trueandroid.enableBuildCache=true//开启kotlin的增量和并行编译kotlin.incremental=truekotlin.incremental.java=truekotlin.incremental.js=truekotlin.caching.enabled=truekotlin.parallel.tasks.in.project=true //开启kotlin并行编译//优化kaptkapt.use.worker.api=true //并行运行kapt1.2.60版本以上支持kapt.incremental.apt=true //增量编译 kapt1.3.30版本以上支持kapt.include.compile.classpath=false //kapt avoiding 如果用kapt依赖的内容没有变化，会完全重用编译内容，省掉最上图中的:app:kaptGenerateStubsDebugKotlin的时间 在上面的配置中，我们首先调整了gradle的配置，然后开启了缓存和kotlin和kapt的增量编译。 如果项目中使用了kapt请使用最新版本的kapt，当前写该文章时kapt的最新版本为1.3.31 2.优化app的build.gradle1.在项目的app目录中的build.gradle文件中修改： 123456789101112131415//如果有用到kapt添加如下配置kapt &#123; useBuildCache = true javacOptions &#123; option(\"-Xmaxerrs\", 500) &#125;&#125;//在Android代码块中添加如下配置：（可优化最上图中transformClassDexBuilderForDebug的时间）android &#123; dexOptions &#123; preDexLibraries true maxProcessCount 8 &#125;&#125; 2.其他不太重要的优化，好像对时间影响不算特别大 优化版本号的配置，如果是debug版本不要使用动态版本号 1234567891011121314151617181920212223242526//原配置defaultConfig &#123; ... minSdkVersion 19 targetSdkVersion 28 versionCode gitVersionCode() versionName currentName() ...&#125;//修改为defaultConfig &#123; ... minSdkVersion 19 targetSdkVersion 28 versionCode 1 versionName &quot;1.0.0&quot; ...&#125;applicationVariants.all &#123; variant -&gt; ... if (variant.buildType.name == &quot;release&quot;) &#123; versionName = currentName() versionCode = gitVersionCode() &#125; ...&#125; 以前我们的配置上versionCode是使用的git的提交次数作为版本号的，在本地debug状态的时候其实最好是写死版本号，如果版本号变化会导致需要重新生成Manifest文件以及完整的编译应用，导致InstantRun无法使用(PS其实我们一直没用InstantRun)。所以修改为写死版本号，然后在applicationVariants中判断如果是release才使用正常的版本号。然后还有一个就是使用依赖版本的时候，尽量不要使用+号的版本依赖，使用固定版本号速度会更快。 希望大家省下的编译时间，能够好好陪陪家人。 enjoy～ 参考资料： https://developer.android.com/studio/build/optimize-your-build https://www.kotlincn.net/docs/reference/kapt.html https://blog.jetbrains.com/kotlin/2019/01/kotlin-1-3-20-released/","link":"/2019/05/07/优化使用kotlin开发Android app的编译速度/"},{"title":"原生App项目集成flutter混合开发详细指南","text":"记得去年9月份的时候谷歌在上海有一次开发者大会，去参加的时候关注到了flutter，随后没过多久就发布了1.0版本。18年底的时候用flutter做了个小项目，发现flutter确实挺好用的。于是尝试在公司找个小项目上马，进行混合开发试试。 方案选择目前主流的混合开发方案有两种集成方式： 源码集成：也就是谷歌官方提供的方案[https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps] 产物集成：Flutter项目单独开发，开发完成后发布成aar包或者iOS的framework形式，原生项目依赖flutter输出的制品即可。具体可以参考闲鱼的文章 两种方式各有优劣，其实产物集成更好一些，不过即使是进行产物集成，也需要弄懂源码集成的方式，因为当有很多和原生交互的功能进行开发的时候，源码集成的方式可以直接调试会方便很多。 根据目前我们的情况： 1.参与人员都要进行flutter开发、 2.持续发布和构建我可以修改控制 我们现在这个项目选择了源码集成的方式。 为原生项目集成flutter整个的集成方案是参考谷歌方法：[https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps]，但是有一些不一样，我是创建了一个flutter项目后，在原生的项目中使用`git submodule`的形式进行管理的。 1.创建flutter module project我们假定已经有了原生的项目Native-iOS和Native-Android；现在我们需要创建我们的flutter项目。 把我们的flutter的channel切换到master(master分支下是flutter的preview版本) flutter channel master 创建flutter模块的项目 flutter create -t module {moduleName} 我这里创建一个flutter的模块项目叫flutter_module 1234567891011➜ flutter create -t module flutter_moduleCreating project flutter_module... flutter_module/test/widget_test.dart (created) ... ... flutter_module/.idea/workspace.xml (created)Running &quot;flutter packages get&quot; in flutter_module... 7.2sWrote 12 files.All done!Your module code is in flutter_module/lib/main.dart. 创建成功后我们可以看一下目录结构 123456789101112131415161718➜ flutter_module git:(master) ✗ tree -L 2 -a.├── .android│ ├── Flutter│ ├── app│ ├── ...├── .gitignore├── .ios│ ├── Config│ ├── Flutter│ ├── ...│ └── Runner.xcworkspace├── lib│ └── main.dart├── pubspec.lock├── pubspec.yaml└── test └── widget_test.dart 在flutter的模块项目中包含有一个隐藏的.android和.ios目录这个目录下是可运行的Android和iOS项目，我们的flutter代码还是在lib下编写，注意在.android和.ios目录下都有一个Flutter目录，这个是我们flutter的库项目了。也就是Android用来生成aar，iOS用来生产framework的库。如果我们用flutter create xxx 生成的纯flutter项目是没有这个Flutter目录的。 把该项目使用git管理起来，稍后我们要在native项目中以子模块的形式添加进去。 1234➜ cd flutter_module➜ git initInitialized empty Git repository in /Users/zhiqiangdeng/Documents/ProjectSource/FlutterProject/flutter_module/.git/➜ flutter_module git:(master) ✗ 初始化git仓库后我们先编辑一下项目下的.gitignore文件，当前这个文件是把项目下的.ios和.android忽略掉的。这个两个项目我们需要跟踪一下，大家可以去github上找一下iOS和Android的gitignore模版文件，然后添加到这个两个目录中，然后把顶层目录的文件作出如下修改，删除.android和.ios添加.ios/Flutter/Generated.xcconfig .gitignore文件： 123-.android/-.ios/+.ios/Flutter/Generated.xcconfig 提交你的flutter模块项目到你的git服务器(我提交到github上了[https://github.com/zakiso/flutter-module-demo.git]大家可以参考) 12git remote add origin &#123;你的flutter module的仓库地址&#125;git push origin master 2.给iOS项目集成flutter1.进入我们原生的iOS项目根目录中，为它添加一个git submodule，把我们的flutter项目拉取下来. 12git submodule add &#123;你的flutter module的仓库地址&#125;git submodule update 2.在项目的Podfile文件中添加下面的代码，在每次执行pod install会运行podhelper.rb 12345678910platform :ios, '8.0'use_frameworks!target 'MyApp' do pod 'AFNetworking', '~&gt; 2.6' xxxxend#添加如下两行代码，路径修改为我们的fluter module的路径flutter_application_path = './flutter-module-demo' eval(File.read(File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')), binding) 3.打开Xcode关闭bitcode配置Build Settings-&gt;Build Options-&gt;Enable Bitcode 4.添加编译脚本，打开Xcode在 Build Phases中添加New Run Script Phase在里面填入如下脚本 12\"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build\"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed 5.项目的配置完成现在需要生成一些配置文件 ​ a. 进入原生项目的flutter模块目录中执行flutter packages get命令 ​ b. 回到原生项目根目录执行pod install 12345678910111213141516➜ cd flutter-module-demo➜ flutter-module-demo git:(master) flutter packages getRunning \"flutter packages get\" in flutter-module-demo... 0.4s➜ flutter-module-demo git:(master) cd ..➜ FlutterNativeiOS git:(master) ✗ pod installAnalyzing dependenciesFetching podspec for `Flutter` from `./flutter-module-demo/.ios/Flutter/engine`Fetching podspec for `FlutterPluginRegistrant` from `./flutter-module-demo/.ios/Flutter/FlutterPluginRegistrant`Downloading dependenciesUsing AFNetworking (2.6.3)Installing Flutter (1.0.0)Installing FlutterPluginRegistrant (0.0.1)Generating Pods projectIntegrating client projectSending statsPod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed. 到此为止我们的原生项目就已经集成好了flutter项目了。 5.在原生项目中使用flutter，下面以swift项目为例 修改AppDelegate.swift:注意AppDelegate是集成自FlutterAppDelegate 12345678910111213141516import UIKitimport Flutterimport FlutterPluginRegistrant // Only if you have Flutter Plugins.@UIApplicationMainclass AppDelegate: FlutterAppDelegate &#123; var flutterEngine : FlutterEngine?; // Only if you have Flutter plugins. override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; self.flutterEngine = FlutterEngine(name: \"io.flutter\", project: nil); self.flutterEngine?.run(withEntrypoint: nil); GeneratedPluginRegistrant.register(with: self.flutterEngine); return super.application(application, didFinishLaunchingWithOptions: launchOptions); &#125;&#125; 修改Controller代码 123456789101112131415import UIKitimport Flutterclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let button = UIButton(type:UIButtonType.custom) ... self.view.addSubview(button) &#125; @objc func handleButtonAction() &#123; let flutterEngine = (UIApplication.shared.delegate as? AppDelegate)?.flutterEngine; let flutterViewController = FlutterViewController(engine: flutterEngine, nibName: nil, bundle: nil)!; self.present(flutterViewController, animated: true, completion: nil) &#125; RUN…. 3.iOS项目集成过程梳理整个的集成过程其实总得来说是如下三个步骤： 1.将flutter项目放入原生项目的文件夹下 2.在podfile中添加podhelper.rb配置 3.在Xcode的build phases添加&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot;iOS编译脚本。 其中podhelper.rb文件位于我们flutter模块项目的.ios/Flutter/podhelper.rb下，大家查看它的源码可以发现，它有下面几个作用： 1.把Flutter（flutterEngine）和FlutterPluginRegistrant两个库用pod给原生项目导入进入 2.如果flutter项目有用到flutter plugin插件，把插件用pod导入 3.导入Generated.xcconfig的相关配置信息，在podhelper.rb同级别的目录下还有一个Generated.xcconfig文件，这个文件在使用flutter create xx、flutter run xxx、flutter packages get命令的时候如果该文件不存在则会生成这个文件。这个文件内容如下： 12345678// This is a generated file; do not edit or check into version control.FLUTTER_ROOT=/Users/zhiqiangdeng/.flutter_wrapper/1.2.2-pre.43FLUTTER_APPLICATION_PATH=/Users/zhiqiangdeng/Documents/ProjectSource/XcodeProject/lianhua-order-iOS/order-check-module-flutterFLUTTER_TARGET=lib/main.dartFLUTTER_BUILD_DIR=buildSYMROOT=$&#123;SOURCE_ROOT&#125;/../build/iosFLUTTER_BUILD_NAME=1.0.0FLUTTER_BUILD_NUMBER=1 他记录了当前flutter sdk的目录位置，以及版本号，还有项目模块的目录位置。这个文件的内容在执行pod install的时候会被写入到xcode build setting中，在执行完pod install之后，可以在原生项目根目录使用xcodebuild -showBuildSettings|grep flutter 查看相关的信息。 最后一步就是运行程序，运行程序的时候在Build phase添加了xcode_backend.sh该脚本会使用到上面pod install给xcode build setting设置的那些环境变量，然后找到项目目录生成AppFramework。 4.给原生Android项目集成FlutterAndroid的文章很多，这里不再详细描述了 1.在原生Android项目中添加子模块，将上面创建的flutter module项目拉取到原生安卓项目中 12git submodule add &#123;你的flutter module的仓库地址&#125;git submodule update 2.在根目录的settings.gradle中添加如下配置 1234setBinding(new Binding([gradle: this])) evaluate(new File( &apos;&#123;xxxxx你的flutter module目录&#125;/.android/include_flutter.groovy&apos; )) 3.在原生项目的app目录下的build.gradle文件中添加Flutter库的依赖 123dependencies &#123; implementation project(&apos;:flutter&apos;)&#125; 4.在原生代码中集成flutter跳转到flutter页面 我使用了一个新的Activity进行跳转。具体可以参看源码 123456789Button open = findViewById(R.id.openBtn);open.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.setClass(MainActivity.this, MyFlutterActivity.class); startActivity(intent); &#125;&#125;); 12345678910111213141516171819202122public class MyFlutterActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_flutter); final FlutterView flutterView = Flutter.createView( this, getLifecycle(), \"route1\" ); final FrameLayout layout = findViewById(R.id.flutter_container); layout.addView(flutterView); final FlutterView.FirstFrameListener[] listeners = new FlutterView.FirstFrameListener[1]; listeners[0] = new FlutterView.FirstFrameListener() &#123; @Override public void onFirstFrame() &#123; layout.setVisibility(View.VISIBLE); &#125; &#125;; flutterView.addFirstFrameListener(listeners[0]); &#125;&#125; Android从原生跳到Flutter模块的黑屏问题，在网上看到很多说设置透明主题的但是没有用，后来看到一种先隐藏显示，等待渲染好第一帧后才显示flutter页面的方法。这里要注意一点要在布局中先把flutter的Container布局设置为InVisible状态，不要使用Gone，用gone的话是不显示也不渲染，用InVisible不显示但是会渲染界面占位置，等待渲染完成后再设置为Visible即可。 项目demo我已经传到github中：有遇到问题的可以参考项目源码 原生Android集成Flutter项目：https://github.com/zakiso/flutter-native-android.git 原生iOS集成Flutter项目：https://github.com/zakiso/flutter-native-ios.git Flutter模块项目：https://github.com/zakiso/flutter-module-demo.git 5.flutter的版本管理在我们的开发过程中遇到了一个问题，就是各个开发者使用的flutter sdk版本不一致，导致一些库无法运行，在网上也遇到有相同问题的人，提出了模仿gradle wrapper来做一个flutter_wrapper的思路。于是我根据自己的需要写了一个flutter_wrapper的小工具。它的主要作用是统一开发人员的本地flutter环境。 项目仓库地址：https://github.com/zakiso/flutterw.git 使用说明 在你的项目根目录中执行命令下载脚本curl -O https://raw.githubusercontent.com/zakiso/flutterw/master/flutterw &amp;&amp; chmod 755 flutterw 下载好脚本后在根目录中使用./flutterw init该命令会收集你当前系统中的flutter版本，并将相关信息写入flutter_wrapper.properties文件中，团队中所有成员都会以该版本号做为该项目的标准版本 将flutterw文件和flutter_wrapper.properties文件添加到git中提交到仓库里 其他成员拉取代码后在项目中使用flutter命令的地方使用./flutterw代替，如果使用ide请选择home目录下对应版本的sdk包 flutterw做了什么？ 使用flutterw的时候会获取当前目录下的flutter_wrapper.properties文件中的版本号 去用户的${HOME}/flutter_wrapper/{版本号}/ 目录下查找是否有该版本sdk 如果没有该版本sdk会下载下来，然后使用该目录下的sdk执行命令 注意事项 如果flutter版本是preview的版本是直接使用master的最新代码来管理的。大家可以查看源码很简单，根据自己的需要定制。 最后：我们整个项目都是使用git进行管理的，虽然每个开发者都需要安装flutter环境，但是对于小团队来说成本并不高，加上flutter_wrapper也保证了版本的一致性。iOS开发者可以在原来的iOS项目中开发flutter的项目，Android开发者可以在原android项目中开发flutter，flutter开发者也可以自己单独开发flutter项目，这种方式其实对于开发者来说也是很方便的。","link":"/2019/06/09/现有项目集成flutter混合开发和踩过的坑/"},{"title":"UML系列02之  UML类图(一)","text":"本章介绍类图中类的UML表示方法。内容包括： 目录第1部分 类图介绍第2部分 实体类的UML表示第3部分 抽象类和接口的UML表示 第1部分 类图介绍类图，是UML(统一建模语言)中用于描述”类”以及”类与类”之间的示意图。它形象的描述出了系统的结构，帮助人们理解系统。 类图是在”所有的UML图”中，实用频率非常之高；掌握它对于我们软件设计，以及交流都很有帮助。 对于类图而言，它的基本单位是类。类主要由三部分组成：类名、属性、操作(函数)。UML类的表示大致如下： 下面，分别介绍”实体类”, “抽象类”, “接口”的UML表示方法。 注：本章的图形都是通过”UML系列01之 UML和绘图工具Visio介绍“中介绍的Visio工具进行绘制的！ 第2部分 实体类的UML表示实体类的UML示例 对应的java代码 public class Student { private int id; protected int age; public String name; private void setId(int id); private int getId() ; protected void setAge(int age); protected int getAge() ; private void setName(String name); private String getName() ; }1. 类名类名是类的名称。 ##2. 属性UML类图中，属性的基本格式: 可见性 名称: 类型 [=缺省值] (01) 可见性 – 表示该属性对于类外的元素而言是否可见。 主要包括公有(public)、私有(private)和受保护(protected)三种，在类图中分别用符号+、-和#表示。 标志 可见性 + Public # Protected - Private (02) 名称 – 表示属性名。 (03) 类型 – 表示属性的数据类型。可以是基本数据类型，也可以是用户自定义类型。 (04) 缺省值 – 属性的初始值。它是一个可选项。 3. 操作UML类图中，属性的基本格式: 可见性 名称(参数类表) [:返回类型] (01) 可见性 – 表示该属性对于类外的元素而言是否可见。它的表示方法与”属性的可见性”相同。 标志 可见性 + Public # Protected - Private (02) 名称 – 表示方法名。 (03) 参数列表 – 表示方法的参数。参数个数是任意的，多个参数之间用逗号”,”隔开。 (04) 返回类型 – 表示方法的返回值类型。它是一个可选项；可以是具体的返回类型，可以是void，也可以无返回类型(构造方法)。 第3部分 抽象类和接口的UML表示1. 抽象类的UML表示抽象类和实体类的UML表示法类似。区别是: “抽象类的类名是斜体”，而”实体类的类名不是斜体”！ 抽象类的UML示例 将上面”实体类示例”中的实体类Student改为抽象类AbstractStudent，对应的UML图如下： 2. 接口的UML表示在UML中，通过在”类名”位置添加“interface”关键字来表示接口。示意图如下： 对应的代码： public interface Runnable { public void run(); }","link":"/2012/10/02/uml/2012-10-02-uml/"},{"title":"UML系列01之  UML和绘图工具Visio介绍","text":"UML，全称是Unified Modeling Language，中文是”统一建模语言”。通俗点说，UML是一种创建模型的语言。 UML是在开发阶段，说明，可视化，构建和书写一个面向对象软件密集系统的制品的开放方法。它使开发人员专注于建立产品的模型和结构，而不是选用什么程序语言和算法实现。当模型建立之后，模型可以被UML工具转化成指定的程序语言代码。 本章介绍通过UML绘图工具: visio。visio是Windows系统下创建图表的工具。visio 的下载地址: http://pan.baidu.com/s/1i39N8fb visio使用示例下面通过演示”visio中创建UML类图”的步骤，来说明visio的基本用法。 第1步 新建UML图打开”visio 2007”后，点击”文件” -&gt; “新建” -&gt; “软件和数据库” -&gt; “UML模型图”。如下图所示。 新建UML模型图之后，看到如下图所示画面。图的左侧，是几种常用的UML图的图形元素。 第2步 新建”类”将”静态结构”中的”类”，拖到绘图区域；然后，将字体大小设置为14。如下图所示。 第3步 打开”UML类属性”对话框双击绘图区域的”类1”，弹出”UML类属性”对话框；并将类名修改为”int”。如下图所示。 第4步 创建”int类”点击”确定”，创建”int类”。创建的”int类”在绘图区域的形状如下图所示。就这样，一个非常简单的类就创建成功了！ 下面创建一个稍微基本的类Student，Student声明如下： public class Student { private int id; public void setId(int id); public int getId() ; }第5步 打开”UML类属性”对话框。新建一个类，打开一个”UML类属性”对话框，并设置类名为Student。如下图所示。 第6步 创建”特性”。点击对话框的”特性”，并添加Student的属性”id”，设置id的类型是int类型。如下图所示。 第7步 创建”操作”。(01) 点击对话框的”操作”，并新建操作”setId”。如下图所示。 (02) 选中”setId”，点击”属性”，弹出”UML操作属性”对话框。如下图所示。 (03) 点击”UML操作属性”对话框，并新增参数”id”，设置id的int类型，种类是in(输入参数)。如下图所示。 (04) 点击”确定”。返回”UML类属性”对话框。如下图所示。 (05) 点击”新建”按钮，新建操作”getId”，并设置其返回类型是int。如下图所示。 第8步 点击”确定”，关闭”UML类属性”对话框。就这样，Student的类图就创建完成了。如下图所示。 第9步 保存类图为jpg图片。通过visio创建的文件，默认会被保存为.vsd格式。.vsd格式的文件包含了文件的完整信息，能方便下次修改！但是，有时候我们需要将完成的visio图单独的抠出来。例如，将上面完成的Student单独的保存成一张图片。可以通过以下操作完成： (01) 点击”文件” -&gt; “另存为”，弹出”另存为”对话框；然后将”保存类型”修改为”JPEG 文件交换格式”。如下图所示。 (02) 点击”确定”，文件就被保存为一张JPEG图片。如下图所示。","link":"/2012/10/01/uml/2012-10-01-uml/"},{"title":"UML系列04之  UML时序图","text":"本章对UML的时序图进行介绍。 时序图介绍时序图(Sequence Diagram)，亦称为序列图或循序图，是一种UML行为图。 时序图是用来描述系统内部是如何交互运作的，它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。 时序图组成时序图包含4类元素: 对象, 生命线, 消息, 激活。 在介绍这4类元素之前，先看一则简单的示例：系统(init.c)启动之后，会开启显示器(lcd.c)。这个流程的时序图如下： 1. 对象(Object)对象实际上就是类或者类对象。例如，在上面的示例中，init.c和lcd.c都是对象。 2. 生命线(Lifeline)生命线代表时序图中的对象在一段时期内的存在。它在时序图中用”一条垂直的虚线”表示。 3. 消息(Message)消息是不同对象之间的交流机制。它位于两个对象之间，消息包括许多种，如下图： 4. 激活(Activation)激活期代表时序图中的对象执行一项操作的时期。它在时序图中对应是”每条生命线上的窄的矩形”。","link":"/2012/10/04/uml/2012-10-04-uml/"},{"title":"UML系列03之  UML类图(二)","text":"在”UML系列02之 UML类图(一)“中介绍了类图的基本构成–类的UML表示方法。本文是接着前文，继续对”UML的类图”中几种关系进行介绍。 UML类图的几种关系在UML类图中，关系可以分为4种: 泛化, 实现, 关联 和 依赖。 关系名 说明 泛化 表示”类与类之间的继承关系” 实现 表示”类与接口之间的实现” 关联 表示”类与类之间的拥有关系”。即，一个类是另一个类的成员。关联又包括：自关联, 单向关联, 双向关联, 多重性关联, 组合, 聚合 依赖 表示”类与类之间的使用关系”。即，一个类是另一类的局部变量, 形式参数, 或者调用了静态方法/成员等 这几种关系表示的”类与类之间关系的强弱顺序”是：泛化 = 实现 &gt; 关联 &gt; 依赖 1. 泛化(Generalization)关系说明: 泛化是一种继承关系。它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种。 代码说明: 父类与子类。 UML图形: 带三角箭头的实线，箭头指向父类。 示例: Fruit是”水果”；Apple是”苹果”，它继承了Fruit，是水果中的一种。 UML示例图 对应的Java代码 public class Fruit { protected int price; public int getPrice() { return price; } public void setPrice() { return price; } } public class Apple extends Fruit { }2. 实现(Realization)关系说明: 实现是一种类与接口的关系，表示类是接口所有特征和行为的实现。 代码说明: 实现类与接口。 UML图形: 带三角箭头的虚线，箭头指向接口。 示例: Runnable接口表示”一个任务”，TimeTask是”计时任务”，它实现了Runnable接口。 UML示例图 对应的Java代码 public interface Runnable { abstract public void run(); } public class TimeTask implements Runnable{ @Override public void run() { } }3. 关联(Association)关联表示”类与类之间的拥有关系”。即，一个类是另一个类的成员。关联包括：自关联, 单向关联, 双向关联, 多重性关联, 聚合, 组合。 3.1 自关联关系说明: 一个类包含自己。例如，单向链表中的节点，包含下一个节点的信息。 代码说明: 成员变量 UML图形: 带普通箭头的实心线，指向被自己。 示例: Node是单向链表中的节点，它包含下一个节点的指针。 UML示例图 对应的Java代码 public class Node { private Node node; }3.2 单向关联关系说明: “类A”中有”类B”成员变量，”类B”中没有”类A”成员变量。 代码说明: 成员变量 UML图形: 带普通单向箭头的实心线，指向被拥有者。 示例: Person表示”人”，IdCard表示”身份证信息”，身份证包括id和”身份证编号snum”。一个人拥有唯一的身份证信息。 UML示例图 对应的Java代码 public class Person { private IdCard idcard; } public class IdCard { private int id; private String snum; }3.3 双向关联关系说明: “类A”中有”类B”成员变量，”类B”也有”类A”成员变量。 代码说明: 成员变量 UML图形: 带普通双向箭头的实心线 或者 不带箭头的实心线。 示例: Cusomer表示”客户”，Product表示”产品”。客户可以购买产品，产品也属于客户。 UML示例图 对应的Java代码 public class Customer { private Address address; } public class Address { private Customer customer; }3.4 多重性关联关系说明: 多重性关联是两个类之间在关联对象上的数量关系。有如下几种： 表示方法 多重性关联说明 1..1 表示另一个类的一个对象只与该类的一个对象有关系 0..* 表示另一个类的一个对象与该类的零个或多个对象有关系 1..* 表示另一个类的一个对象与该类的一个或多个对象有关系 0..1 表示另一个类的一个对象没有或只与该类的一个对象有关系 m..n 表示另一个类的一个对象与该类最少m，最多n个对象有关系(m≤n) 代码说明: 成员变量 UML图形: 实心线表示，单向关联则包括箭头，双向关联包括”两个箭头”或”不包含任何箭头”。 示例: Album是”相册”，Picture是”图片”，相册有N(N&gt;=0)张图片。 UML示例图 对应的Java代码 public class Album { private Picture[] pics; } public class Picture { }3.5 聚合关系说明: 聚合是整体与部分的关系。聚合关系是类与类之间关系比较密切的关联关系；要区分聚合和其它的关联关系，必须考察具体的逻辑关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。如车和轮胎是整体和部分的关系。 代码说明: 成员变量 UML图形: 带空心菱形的实心线，菱形指向整体 示例: Car表示”汽车”，Tire表示”轮胎”。”轮胎”本身是个独立个体。 UML示例图 对应的Java代码 public class Company { private Nose nose; private class Nose { } }3.6 组合关系说明: 组合是整体与部分的关系。组合关系是比聚合关系还要强的关联关系。但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。例如，身体和鼻子，身体包括鼻子，鼻子不能脱离身体而独立存在。 代码说明: 成员变量 UML图形: 带实心菱形的实线，菱形指向整体 示例: Body表示”身体”，Nose表示”鼻子”。身体包含鼻子，鼻子离不开身体。 UML示例图 对应的Java代码 public class Company { private Nose nose; private class Nose { } }4. 依赖(Dependency)关系说明: 依赖是一种使用的关系。在需要表示一个事物使用另一个事物时使用依赖关系，尽量不使用双向的互相依赖。 代码说明: 局部变量、方法的参数或者对静态方法的调用 UML图形: 带箭头的虚线，指向被使用者 示例: 人过河。人是”Person”类，它包括过河函数acrossRiver()，acrossRiver()的参数是过河工具，返回值是过河时间。此处的过河工具是船，船对应的类是Boat。 UML示例图 对应的Java代码 public class Person { public int acrossRiver(Boat boat); } public class Boat { }","link":"/2012/10/03/uml/2012-10-03-uml/"},{"title":"UML系列05之 基本流程图","text":"软件的基本流程图是我们在学习编程时的必修课，它很简单，却很实用。 需要说明的是：UML并不包括软件的基本流程图，但是为了方便我自己查阅，所以将基本软件流程图归纳到UML系列当中。读者切不要认为基本流程图是属于UML的。 流程图介绍流程图（FlowChart）是描述我们进行某一项活动所遵循顺序的一种图示方法。它能通过图形符号形象的表示解决问题的步骤和程序。好的流程图，不仅能对我们的程序设计起到作用；在帮助理解时，往往能起到”一张图胜过千言万语”的效果。 下面是美国国家标准学会(American National Standards Institute，ANSI)制定的一些常用流程图符号的表格： 流程图示例下面通过一个示例进行演示。 import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.IOException; public class MathDemo { public static void main(String[] args) { System.out.print(&quot;please insert a number:&quot;); // 计算&quot;0&quot;到&quot;iLen&quot;的合 int sum = 0; int iLen = getLen(); for (int i=0; i&lt;iLen; i++) { sum += i; } System.out.println(&quot;summary(0~&quot;+iLen+&quot;)=&quot;+sum); } // 读取一个长度，默认返回100 private static int getLen() { try { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); // 读取一行，字符串 String str = in.readLine(); // 将该字符串转换为int整型数 int len = Integer.parseInt(str); in.close(); return len; } catch(IOException e) { e.printStackTrace(); return 100; } } }运行结果： please insert a number:10 summary(0~10)=45结果说明： MathDemo的作用是，让用户输入一个整数。然后计算0到”这个整数”之间的和。在例子中，输入的值是10；运行结果是0+1+2+3+4+5+6+7+8+9=45。 示例对应的流程图","link":"/2012/10/05/uml/2012-10-05-uml/"},{"title":"Java 集合系列目录(Category)","text":"下面是最近总结的Java集合(JDK1.6.0_45)相关文章的目录。 01. Java 集合系列01之 总体框架 02. Java 集合系列02之 Collection架构 03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例 04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法) 05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例 06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例 07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例 08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析) 09. Java 集合系列09之 Map架构 10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例 11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例 12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例 13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例 14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景) 15. Java 集合系列15之 Set架构 16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例 17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例 18. Java 集合系列18之 Iterator和Enumeration比较 19. Java 集合系列扩展(一) Comparable和Comparator比较 20. Java 集合系列扩展(二) hashCode()和equals()的若干问题解答","link":"/2012/02/01/java/collection/2012-02-01-collection-00-index/"},{"title":"Java 集合系列01之 总体框架","text":"Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。Java集合工具包位置是java.util.*Java集合主要可以划分为4个部分：List列表、Set集合、Map映射、工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)。 Java集合工具包框架如下图。 说明：看上面的框架图，先抓住它的主干，即Collection和Map。 Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。 Collection包含了List和Set两大分支。 (01) List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。 List的实现类有LinkedList, ArrayList, Vector, Stack。(02) Set是一个不允许有重复元素的集合。 Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。 AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。 接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。 再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。 最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。 有了上面的整体框架之后，我们接下来对每个类分别进行分析。 更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/01/java/collection/2012-02-01-collection-01-summary/"},{"title":"Java 集合系列15之 Set架构","text":"前面，我们已经系统的对List和Map进行了学习。接下来，我们开始可以学习Set。相信经过Map的了解之后，学习Set会容易很多。毕竟，Set的实现类都是基于Map来实现的(HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的)。 首先，我们看看Set架构。 (01) Set 是继承于Collection的接口。它是一个不允许有重复元素的集合。(02) AbstractSet 是一个抽象类，它继承于AbstractCollection，AbstractCollection实现了Set中的绝大部分函数，为Set的实现类提供了便利。(03) HastSet 和 TreeSet 是Set的两个实现类。&nbsp;&nbsp;&nbsp;&nbsp;HashSet依赖于HashMap，它实际上是通过HashMap实现的。HashSet中的元素是无序的。&nbsp;&nbsp;&nbsp;&nbsp;TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。TreeSet中的元素是有序的。 更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/15/java/collection/2012-02-15-collection-15-set/"},{"title":"Java 集合系列18之 Iterator和Enumeration比较","text":"这一章，我们对Iterator和Enumeration进行比较学习。 目录第1部分 Iterator和Enumeration区别第2部分 Iterator和Enumeration实例 第1部分 Iterator和Enumeration区别在Java集合中，我们通常都通过 “Iterator(迭代器)” 或 “Enumeration(枚举类)” 去遍历集合。今天，我们就一起学习一下它们之间到底有什么区别。 我们先看看 Enumeration.java 和 Iterator.java的源码，再说它们的区别。 Enumeration是一个接口，它的源码如下： package java.util; public interface Enumeration&lt;E&gt; { boolean hasMoreElements(); E nextElement(); }Iterator也是一个接口，它的源码如下： package java.util; public interface Iterator&lt;E&gt; { boolean hasNext(); E next(); void remove(); }看完代码了，我们再来说说它们之间的区别。 (01) 函数接口不同&nbsp;&nbsp;&nbsp;&nbsp; Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。&nbsp;&nbsp;&nbsp;&nbsp;Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。 (02) Iterator支持fail-fast机制，而Enumeration不支持。&nbsp;&nbsp;&nbsp;&nbsp;Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。&nbsp;&nbsp;&nbsp;&nbsp;而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。 第2部分 Iterator和Enumeration实例下面，我们编写一个Hashtable，然后分别通过 Iterator 和 Enumeration 去遍历它，比较它们的效率。代码如下： import java.util.Enumeration; import java.util.Hashtable; import java.util.Iterator; import java.util.Map.Entry; import java.util.Random; /* * 测试分别通过 Iterator 和 Enumeration 去遍历Hashtable * @author skywang */ public class IteratorEnumeration { public static void main(String[] args) { int val; Random r = new Random(); Hashtable table = new Hashtable(); for (int i=0; i&lt;100000; i++) { // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); table.put(String.valueOf(i), val); } // 通过Iterator遍历Hashtable iterateHashtable(table) ; // 通过Enumeration遍历Hashtable enumHashtable(table); } /* * 通过Iterator遍历Hashtable */ private static void iterateHashtable(Hashtable table) { long startTime = System.currentTimeMillis(); Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) { //System.out.println(&quot;iter:&quot;+iter.next()); iter.next(); } long endTime = System.currentTimeMillis(); countTime(startTime, endTime); } /* * 通过Enumeration遍历Hashtable */ private static void enumHashtable(Hashtable table) { long startTime = System.currentTimeMillis(); Enumeration enu = table.elements(); while(enu.hasMoreElements()) { //System.out.println(&quot;enu:&quot;+enu.nextElement()); enu.nextElement(); } long endTime = System.currentTimeMillis(); countTime(startTime, endTime); } private static void countTime(long start, long end) { System.out.println(&quot;time: &quot;+(end-start)+&quot;ms&quot;); } }运行结果如下： time: 9ms time: 5ms从中，我们可以看出。Enumeration 比 Iterator 的遍历速度更快。为什么呢？这是因为，Hashtable中Iterator是通过Enumeration去实现的，而且Iterator添加了对fail-fast机制的支持；所以，执行的操作自然要多一些。 更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/18/java/collection/2012-02-18-collection-18-iterator_enumeration/"},{"title":"Java 随机数","text":"本章先讲解Java随机数的几种产生方式，然后通过示例对其进行演示。 广义上讲，Java中的随机数的有三种产生方式：(01). 通过System.currentTimeMillis()来获取一个当前时间毫秒数的long型数字。(02). 通过Math.random()返回一个0到1之间的double值。(03). 通过Random类来产生一个随机数，这个是专业的Random工具类，功能强大。 目录第1种 利用System.currentTimeMillis()获取随机数第2种 利用Math.random()获取随机数第3种 利用Random类来获取随机数获取随机数示例 第1种 利用System.currentTimeMillis()获取随机数通过System.currentTimeMillis()来获取随机数。实际上是获取当前时间毫秒数，它是long类型。使用方法如下： final long l = System.currentTimeMillis();若要获取int类型的整数，只需要将上面的结果转行成int类型即可。比如，获取[0, 100)之间的int整数。方法如下： final long l = System.currentTimeMillis(); final int i = (int)( l % 100 ); 第2种 利用Math.random()获取随机数通过Math.random()来获取随机数。实际上，它返回的是0(包含)到1(不包含)之间的double值。使用方法如下： final double d = Math.random();若要获取int类型的整数，只需要将上面的结果转行成int类型即可。比如，获取[0, 100)之间的int整数。方法如下： final double d = Math.random(); final int i = (int)(d*100); 第3种 利用Random类来获取随机数通过Random类来获取随机数。 使用方法如下：(01) 创建Random对象。有两种方法可以创建Random对象，如下： Random random = new Random();//默认构造方法 Random random = new Random(1000);//指定种子数字(02) 通过Random对象获取随机数。Random支持的随机值类型包括：boolean, byte, int, long, float, double。比如，获取[0, 100)之间的int整数。方法如下： int i2 = random.nextInt(100);Random 的函数接口 // 构造函数(一)： 创建一个新的随机数生成器。 Random() // 构造函数(二)： 使用单个 long 种子创建一个新随机数生成器： public Random(long seed) { setSeed(seed); } next 方法使用它来保存随机数生成器的状态。 Random(long seed) boolean nextBoolean() // 返回下一个“boolean类型”伪随机数。 void nextBytes(byte[] buf) // 生成随机字节并将其置于字节数组buf中。 double nextDouble() // 返回一个“[0.0, 1.0) 之间的double类型”的随机数。 float nextFloat() // 返回一个“[0.0, 1.0) 之间的float类型”的随机数。 int nextInt() // 返回下一个“int类型”随机数。 int nextInt(int n) // 返回一个“[0, n) 之间的int类型”的随机数。 long nextLong() // 返回下一个“long类型”随机数。 synchronized double nextGaussian() // 返回下一个“double类型”的随机数，它是呈高斯（“正常地”）分布的 double 值，其平均值是 0.0，标准偏差是 1.0。 synchronized void setSeed(long seed) // 使用单个 long 种子设置此随机数生成器的种子。 获取随机数示例下面通过示例演示上面3种获取随机数的使用方法。源码如下(RandomTest.java)： import java.util.Random; import java.lang.Math; /** * java 的随机数测试程序。共3种获取随机数的方法： * (01)、通过System.currentTimeMillis()来获取一个当前时间毫秒数的long型数字。 * (02)、通过Math.random()返回一个0到1之间的double值。 * (03)、通过Random类来产生一个随机数，这个是专业的Random工具类，功能强大。 * * @author skywang * @email kuiwu-wang@163.com */ public class RandomTest{ public static void main(String args[]){ // 通过System的currentTimeMillis()返回随机数 testSystemTimeMillis(); // 通过Math的random()返回随机数 testMathRandom(); // 新建“种子为1000”的Random对象，并通过该种子去测试Random的API testRandomAPIs(new Random(1000), &quot; 1st Random(1000)&quot;); testRandomAPIs(new Random(1000), &quot; 2nd Random(1000)&quot;); // 新建“默认种子”的Random对象，并通过该种子去测试Random的API testRandomAPIs(new Random(), &quot; 1st Random()&quot;); testRandomAPIs(new Random(), &quot; 2nd Random()&quot;); } /** * 返回随机数-01：测试System的currentTimeMillis() */ private static void testSystemTimeMillis() { // 通过 final long l = System.currentTimeMillis(); // 通过l获取一个[0, 100)之间的整数 final int i = (int)( l % 100 ); System.out.printf(&quot;\\n---- System.currentTimeMillis() ----\\n l=%s i=%s\\n&quot;, l, i); } /** * 返回随机数-02：测试Math的random() */ private static void testMathRandom() { // 通过Math的random()函数返回一个double类型随机数，范围[0.0, 1.0) final double d = Math.random(); // 通过d获取一个[0, 100)之间的整数 final int i = (int)(d*100); System.out.printf(&quot;\\n---- Math.random() ----\\n d=%s i=%s\\n&quot;, d, i); } /** * 返回随机数-03：测试Random的API */ private static void testRandomAPIs(Random random, String title) { final int BUFFER_LEN = 5; // 获取随机的boolean值 boolean b = random.nextBoolean(); // 获取随机的数组buf[] byte[] buf = new byte[BUFFER_LEN]; random.nextBytes(buf); // 获取随机的Double值，范围[0.0, 1.0) double d = random.nextDouble(); // 获取随机的float值，范围[0.0, 1.0) float f = random.nextFloat(); // 获取随机的int值 int i1 = random.nextInt(); // 获取随机的[0,100)之间的int值 int i2 = random.nextInt(100); // 获取随机的高斯分布的double值 double g = random.nextGaussian(); // 获取随机的long值 long l = random.nextLong(); System.out.printf(&quot;\\n---- %s ----\\nb=%s, d=%s, f=%s, i1=%s, i2=%s, g=%s, l=%s, buf=[&quot;, title, b, d, f, i1, i2, g, l); for (byte bt:buf) System.out.printf(&quot;%s, &quot;, bt); System.out.println(&quot;]&quot;); } }","link":"/2012/03/01/java/others/2012-03-01-random/"},{"title":"Java多线程系列--“基础篇”01之 基本概念","text":"多线程是Java中不可避免的一个重要主体。从本章开始，我们将展开对多线程的学习。接下来的内容，是对“JDK中新增JUC包”之前的Java多线程内容的讲解，涉及到的内容包括，Object类中的wait(), notify()等接口；Thread类中的接口；synchronized关键字。 注：JUC包是指，Java.util.concurrent包，它是由Java大师Doug Lea完成并在JDK1.5版本添加到Java中的。 在进入后面章节的学习之前，先对了解一些多线程的相关概念。 线程状态图 说明：线程共包括以下5种状态。 新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。 就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。 运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。 阻塞状态(Blocked) : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：&nbsp;&nbsp;&nbsp;&nbsp; (01) 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。&nbsp;&nbsp;&nbsp;&nbsp; (02) 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。&nbsp;&nbsp;&nbsp;&nbsp; (03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态(Dead) : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。在后面详细介绍wait(),notify()等方法时，我们会分析为什么“wait(), notify()等方法要定义在Object类，而不是Thread类中”。","link":"/2012/08/01/java/threads/2012-08-01-threads-basic/"},{"title":"Java多线程系列--目录","text":"Java多线程系列–“基础篇”01之 基本概念Java多线程系列–“基础篇”02之 常用的实现多线程的两种方式Java多线程系列–“基础篇”03之 Thread中start()和run()的区别Java多线程系列–“基础篇”04之 synchronized关键字Java多线程系列–“基础篇”05之 线程等待与唤醒Java多线程系列–“基础篇”06之 线程让步Java多线程系列–“基础篇”07之 线程休眠Java多线程系列–“基础篇”08之 join()Java多线程系列–“基础篇”09之 interrupt()和线程终止方式Java多线程系列–“基础篇”10之 线程优先级和守护线程Java多线程系列–“基础篇”11之 生产消费者问题 Java多线程系列–“JUC原子类”01之 框架Java多线程系列–“JUC原子类”02之 AtomicLong原子类Java多线程系列–“JUC原子类”03之 AtomicLongArray原子类Java多线程系列–“JUC原子类”04之 AtomicReference原子类Java多线程系列–“JUC原子类”05之 AtomicLongFieldUpdater原子类 Java多线程系列–“JUC锁”01之 框架Java多线程系列–“JUC锁”02之 互斥锁ReentrantLockJava多线程系列–“JUC锁”03之 公平锁(一)Java多线程系列–“JUC锁”04之 公平锁(二)Java多线程系列–“JUC锁”05之 非公平锁Java多线程系列–“JUC锁”06之 Condition条件Java多线程系列–“JUC锁”07之 LockSupportJava多线程系列–“JUC锁”08之 共享锁和ReentrantReadWriteLockJava多线程系列–“JUC锁”09之 CountDownLatch原理和示例Java多线程系列–“JUC锁”10之 CyclicBarrier原理和示例Java多线程系列–“JUC锁”11之 Semaphore信号量的原理和示例 Java多线程系列–“JUC集合”01之 框架Java多线程系列–“JUC集合”02之 CopyOnWriteArrayListJava多线程系列–“JUC集合”03之 CopyOnWriteArraySetJava多线程系列–“JUC集合”04之 ConcurrentHashMapJava多线程系列–“JUC集合”05之 ConcurrentSkipListMapJava多线程系列–“JUC集合”06之 ConcurrentSkipListSetJava多线程系列–“JUC集合”07之 ArrayBlockingQueueJava多线程系列–“JUC集合”08之 LinkedBlockingQueueJava多线程系列–“JUC集合”09之 LinkedBlockingDequeJava多线程系列–“JUC集合”10之 ConcurrentHashMap Java多线程系列–“JUC线程池”01之 线程池架构Java多线程系列–“JUC线程池”02之 线程池原理(一)Java多线程系列–“JUC线程池”03之 线程池原理(二)Java多线程系列–“JUC线程池”04之 线程池原理(三)Java多线程系列–“JUC线程池”05之 线程池原理(四)Java多线程系列–“JUC线程池”06之 Callable和Future","link":"/2012/08/01/java/threads/2012-08-01-threads-index/"},{"title":"Java多线程系列--“基础篇”02之 常用的实现多线程的两种方式","text":"本章，我们学习“常用的实现多线程的2种方式”：Thread 和 Runnable。之所以说是常用的，是因为通过还可以通过java.util.concurrent包中的线程池来实现多线程。关于线程池的内容，我们以后会详细介绍；现在，先对的Thread和Runnable进行了解。 目录1. Thread和Runnable简介2. Thread和Runnable的异同点3. Thread和Runnable的多线程示例 1. Thread和Runnable简介Runnable 是一个接口，该接口中只包含了一个run()方法。它的定义如下： public interface Runnable { public abstract void run(); }Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。 Thread 是一个类。Thread本身就实现了Runnable接口。它的声明如下： public class Thread implements Runnable {}Thread的作用，实现多线程。 2. Thread和Runnable的异同点Thread 和 Runnable 的相同点：都是“多线程的实现方式”。 Thread 和 Runnable 的不同点：Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 通常，建议通过“Runnable”实现多线程！ 3. Thread和Runnable的多线程示例3.1 Thread的多线程示例下面通过示例更好的理解Thread和Runnable，借鉴网上一个例子比较具有说服性的例子。 // ThreadTest.java 源码 class MyThread extends Thread{ private int ticket=10; public void run(){ for(int i=0;i&lt;20;i++){ if(this.ticket&gt;0){ System.out.println(this.getName()+&quot; 卖票：ticket&quot;+this.ticket--); } } } }; public class ThreadTest { public static void main(String[] args) { // 启动3个线程t1,t2,t3；每个线程各卖10张票！ MyThread t1=new MyThread(); MyThread t2=new MyThread(); MyThread t3=new MyThread(); t1.start(); t2.start(); t3.start(); } } 运行结果： Thread-0 卖票：ticket10 Thread-1 卖票：ticket10 Thread-2 卖票：ticket10 Thread-1 卖票：ticket9 Thread-0 卖票：ticket9 Thread-1 卖票：ticket8 Thread-2 卖票：ticket9 Thread-1 卖票：ticket7 Thread-0 卖票：ticket8 Thread-1 卖票：ticket6 Thread-2 卖票：ticket8 Thread-1 卖票：ticket5 Thread-0 卖票：ticket7 Thread-1 卖票：ticket4 Thread-2 卖票：ticket7 Thread-1 卖票：ticket3 Thread-0 卖票：ticket6 Thread-1 卖票：ticket2 Thread-2 卖票：ticket6 Thread-2 卖票：ticket5 Thread-2 卖票：ticket4 Thread-1 卖票：ticket1 Thread-0 卖票：ticket5 Thread-2 卖票：ticket3 Thread-0 卖票：ticket4 Thread-2 卖票：ticket2 Thread-0 卖票：ticket3 Thread-2 卖票：ticket1 Thread-0 卖票：ticket2 Thread-0 卖票：ticket1结果说明：(01) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出10张票。(02) 主线程main创建并启动3个MyThread子线程。每个子线程都各自卖出了10张票。 3.2 Runnable的多线程示例下面，我们对上面的程序进行修改。通过Runnable实现一个接口，从而实现多线程。 // RunnableTest.java 源码 class MyThread implements Runnable{ private int ticket=10; public void run(){ for(int i=0;i&lt;20;i++){ if(this.ticket&gt;0){ System.out.println(Thread.currentThread().getName()+&quot; 卖票：ticket&quot;+this.ticket--); } } } }; public class RunnableTest { public static void main(String[] args) { MyThread mt=new MyThread(); // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！ Thread t1=new Thread(mt); Thread t2=new Thread(mt); Thread t3=new Thread(mt); t1.start(); t2.start(); t3.start(); } }运行结果： Thread-0 卖票：ticket10 Thread-2 卖票：ticket8 Thread-1 卖票：ticket9 Thread-2 卖票：ticket6 Thread-0 卖票：ticket7 Thread-2 卖票：ticket4 Thread-1 卖票：ticket5 Thread-2 卖票：ticket2 Thread-0 卖票：ticket3 Thread-1 卖票：ticket1结果说明：(01) 和上面“MyThread继承于Thread”不同；这里的MyThread实现了Thread接口。(02) 主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。","link":"/2012/08/02/java/threads/2012-08-02-threads-basic/"},{"title":"Java多线程系列--“基础篇”03之  Thread中start()和run()的区别","text":"Thread类包含start()和run()方法，它们的区别是什么？本章将对此作出解答。 目录1. start() 和 run()的区别说明2. start() 和 run()的区别示例3. start() 和 run()相关源码(基于JDK1.7.0_40) 1. start() 和 run()的区别说明start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。run() : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！ 下面以代码来进行说明。 class MyThread extends Thread{ public void run(){ ... } }; MyThread mythread = new MyThread();mythread.start()会启动一个新线程，并在新线程中运行run()方法。而mythread.run()则会直接在当前线程中运行run()方法，并不会启动一个新线程来运行run()。 2. start() 和 run()的区别示例下面，通过一个简单示例演示它们之间的区别。源码如下： // Demo.java 的源码 class MyThread extends Thread{ public MyThread(String name) { super(name); } public void run(){ System.out.println(Thread.currentThread().getName()+&quot; is running&quot;); } }; public class Demo { public static void main(String[] args) { Thread mythread=new MyThread(&quot;mythread&quot;); System.out.println(Thread.currentThread().getName()+&quot; call mythread.run()&quot;); mythread.run(); System.out.println(Thread.currentThread().getName()+&quot; call mythread.start()&quot;); mythread.start(); } }运行结果： main call mythread.run() main is running main call mythread.start() mythread is running结果说明：(01) Thread.currentThread().getName()是用于获取“当前线程”的名字。当前线程是指正在cpu中调度执行的线程。(02) mythread.run()是在“主线程main”中调用的，该run()方法直接运行在“主线程main”上。(03) mythread.start()会启动“线程mythread”，“线程mythread”启动之后，会调用run()方法；此时的run()方法是运行在“线程mythread”上。 3. start() 和 run()相关源码(基于JDK1.7.0_40)Thread.java中start()方法的源码如下： public synchronized void start() { // 如果线程不是&quot;就绪状态&quot;，则抛出异常！ if (threadStatus != 0) throw new IllegalThreadStateException(); // 将线程添加到ThreadGroup中 group.add(this); boolean started = false; try { // 通过start0()启动线程 start0(); // 设置started标记 started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } }说明：start()实际上是通过本地方法start0()启动线程的。而start0()会新运行一个线程，新线程会调用run()方法。 private native void start0();Thread.java中run()的代码如下： public void run() { if (target != null) { target.run(); } }说明：target是一个Runnable对象。run()就是直接调用Thread线程的Runnable成员的run()方法，并不会新建一个线程。","link":"/2012/08/03/java/threads/2012-08-03-threads-basic/"},{"title":"Java多线程系列--“基础篇”06之 线程让步","text":"本章，会对Thread中的线程让步方法yield()进行介绍。 目录1. yield()介绍2. yield()示例3. yield() 与 wait()的比较 1. yield()介绍yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！ 2. yield()示例下面，通过示例查看它的用法。 // YieldTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public synchronized void run(){ for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i%4 == 0) Thread.yield(); } } } public class YieldTest{ public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); t1.start(); t2.start(); } } (某一次的)运行结果: t1 [5]:0 t2 [5]:0 t1 [5]:1 t1 [5]:2 t1 [5]:3 t1 [5]:4 t1 [5]:5 t1 [5]:6 t1 [5]:7 t1 [5]:8 t1 [5]:9 t2 [5]:1 t2 [5]:2 t2 [5]:3 t2 [5]:4 t2 [5]:5 t2 [5]:6 t2 [5]:7 t2 [5]:8 t2 [5]:9结果说明：“线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。 3. yield() 与 wait()的比较我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。 下面通过示例演示yield()是不会释放锁的。 // YieldLockTest.java 的源码 public class YieldLockTest{ private static Object obj = new Object(); public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); t1.start(); t2.start(); } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ // 获取obj对象的同步锁 synchronized (obj) { for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i%4 == 0) Thread.yield(); } } } } } (某一次)运行结果： t1 [5]:0 t1 [5]:1 t1 [5]:2 t1 [5]:3 t1 [5]:4 t1 [5]:5 t1 [5]:6 t1 [5]:7 t1 [5]:8 t1 [5]:9 t2 [5]:0 t2 [5]:1 t2 [5]:2 t2 [5]:3 t2 [5]:4 t2 [5]:5 t2 [5]:6 t2 [5]:7 t2 [5]:8 t2 [5]:9结果说明：主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！","link":"/2012/08/06/java/threads/2012-08-06-threads-basic/"},{"title":"Java多线程系列--“基础篇”07之 线程休眠","text":"本章，会对Thread中sleep()方法进行介绍。 目录1. sleep()介绍2. sleep()示例3. sleep() 与 wait()的比较 1. sleep()介绍sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。 2. sleep()示例下面通过一个简单示例演示sleep()的用法。 // SleepTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public synchronized void run() { try { for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); } } catch (InterruptedException e) { e.printStackTrace(); } } } public class SleepTest{ public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); t1.start(); } } 运行结果： t1: 0 t1: 1 t1: 2 t1: 3 t1: 4 t1: 5 t1: 6 t1: 7 t1: 8 t1: 9结果说明：程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。 3. sleep() 与 wait()的比较我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。 下面通过示例演示sleep()是不会释放锁的。 // SleepLockTest.java的源码 public class SleepLockTest{ private static Object obj = new Object(); public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); t1.start(); t2.start(); } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ // 获取obj对象的同步锁 synchronized (obj) { try { for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); } } catch (InterruptedException e) { e.printStackTrace(); } } } } } 运行结果： t1: 0 t1: 1 t1: 2 t1: 3 t1: 4 t1: 5 t1: 6 t1: 7 t1: 8 t1: 9 t2: 0 t2: 1 t2: 2 t2: 3 t2: 4 t2: 5 t2: 6 t2: 7 t2: 8 t2: 9结果说明：主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。下面是注释调synchronized(obj) 之后的源码： // SleepLockTest.java的源码(注释掉synchronized(obj)) public class SleepLockTest{ private static Object obj = new Object(); public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); t1.start(); t2.start(); } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ // 获取obj对象的同步锁 // synchronized (obj) { try { for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); } } catch (InterruptedException e) { e.printStackTrace(); } // } } } }","link":"/2012/08/07/java/threads/2012-08-07-threads-basic/"},{"title":"Java多线程系列--“基础篇”08之 join()","text":"本章，会对Thread中join()方法进行介绍。 目录1. join()介绍2. join()源码分析(基于JDK1.7.0_40)3. join()示例 1. join()介绍join() 定义在Thread.java中。 join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解： // 主线程 public class Father extends Thread { public void run() { Son s = new Son(); s.start(); s.join(); ... } } // 子线程 public class Son extends Thread { public void run() { ... } }说明：上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！ 2. join()源码分析(基于JDK1.7.0_40)public final void join() throws InterruptedException { join(0); } public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException(&quot;timeout value is negative&quot;); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } }说明：从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；即只要子线程是活的，主线程就不停的等待。我们根据上面解释join()作用时的代码来理解join()的用法！ 问题：虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让”子线程等待才对(因为调用子线程对象s的wait方法嘛)”？ 答案：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！ 3. join()示例在理解join()的作用之后，接下来通过示例查看join()的用法。 // JoinTest.java的源码 public class JoinTest{ public static void main(String[] args){ try { ThreadA t1 = new ThreadA(&quot;t1&quot;); // 新建“线程t1” t1.start(); // 启动“线程t1” t1.join(); // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成” System.out.printf(&quot;%s finish\\n&quot;, Thread.currentThread().getName()); } catch (InterruptedException e) { e.printStackTrace(); } } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ System.out.printf(&quot;%s start\\n&quot;, this.getName()); // 延时操作 for(int i=0; i &lt;1000000; i++) ; System.out.printf(&quot;%s finish\\n&quot;, this.getName()); } } }运行结果： t1 start t1 finish main finish结果说明：运行流程如图(01) 在“主线程main”中通过 new ThreadA(“t1”) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。","link":"/2012/08/08/java/threads/2012-08-08-threads-basic/"},{"title":"Java多线程系列--“基础篇”10之 线程优先级和守护线程","text":"本章，会对守护线程和线程优先级进行介绍。 目录1. 线程优先级的介绍2. 线程优先级的示例3. 守护线程的示例 1. 线程优先级的介绍java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。 java 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。 JDK 中关于线程优先级和守护线程的介绍如下： Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method.Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads. 大致意思是： 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。 当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：(01) 调用了exit()方法，并且exit()有权限被正常执行。(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。 2. 线程优先级的示例我们先看看优先级的示例 class MyThread extends Thread{ public MyThread(String name) { super(name); } public void run(){ for (int i=0; i&lt;5; i++) { System.out.println(Thread.currentThread().getName() +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot; +&quot;, loop &quot;+i); } } }; public class Demo { public static void main(String[] args) { System.out.println(Thread.currentThread().getName() +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;); Thread t1=new MyThread(&quot;t1&quot;); // 新建t1 Thread t2=new MyThread(&quot;t2&quot;); // 新建t2 t1.setPriority(1); // 设置t1的优先级为1 t2.setPriority(10); // 设置t2的优先级为10 t1.start(); // 启动t1 t2.start(); // 启动t2 } }运行结果： main(5) t1(1), loop 0 t2(10), loop 0 t1(1), loop 1 t2(10), loop 1 t1(1), loop 2 t2(10), loop 2 t1(1), loop 3 t2(10), loop 3 t1(1), loop 4 t2(10), loop 4结果说明：(01) 主线程main的优先级是5。(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。 3. 守护线程的示例下面是守护线程的示例。 // Demo.java class MyThread extends Thread{ public MyThread(String name) { super(name); } public void run(){ try { for (int i=0; i&lt;5; i++) { Thread.sleep(3); System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; +&quot;, loop &quot;+i); } } catch (InterruptedException e) { } } }; class MyDaemon extends Thread{ public MyDaemon(String name) { super(name); } public void run(){ try { for (int i=0; i&lt;10000; i++) { Thread.sleep(1); System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; +&quot;, loop &quot;+i); } } catch (InterruptedException e) { } } } public class Demo { public static void main(String[] args) { System.out.println(Thread.currentThread().getName() +&quot;(isDaemon=&quot;+Thread.currentThread().isDaemon()+ &quot;)&quot;); Thread t1=new MyThread(&quot;t1&quot;); // 新建t1 Thread t2=new MyDaemon(&quot;t2&quot;); // 新建t2 t2.setDaemon(true); // 设置t2为守护线程 t1.start(); // 启动t1 t2.start(); // 启动t2 } }运行结果： main(isDaemon=false) t2(isDaemon=true), loop 0 t2(isDaemon=true), loop 1 t1(isDaemon=false), loop 0 t2(isDaemon=true), loop 2 t2(isDaemon=true), loop 3 t1(isDaemon=false), loop 1 t2(isDaemon=true), loop 4 t2(isDaemon=true), loop 5 t2(isDaemon=true), loop 6 t1(isDaemon=false), loop 2 t2(isDaemon=true), loop 7 t2(isDaemon=true), loop 8 t2(isDaemon=true), loop 9 t1(isDaemon=false), loop 3 t2(isDaemon=true), loop 10 t2(isDaemon=true), loop 11 t1(isDaemon=false), loop 4 t2(isDaemon=true), loop 12结果说明：(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。","link":"/2012/08/10/java/threads/2012-08-10-threads-basic/"},{"title":"Java多线程系列--“基础篇”11之 生产消费者问题","text":"本章，会对“生产/消费者问题”进行讨论。 目录1. 生产/消费者模型2. 生产/消费者实现 1. 生产/消费者模型生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括“生产者”、“消费者”、“仓库”和“产品”。他们之间的关系如下：(01) 生产者仅仅在仓储未满时候生产，仓满则停止生产。(02) 消费者仅仅在仓储有产品时候才能消费，仓空则等待。(03) 当消费者发现仓储没产品可消费时候会通知生产者生产。(04) 生产者在生产出可消费产品时候，应该通知等待的消费者去消费。 2. 生产/消费者实现下面通过wait()/notify()方式实现该模型(后面在学习了线程池相关内容之后，再通过其它方式实现生产/消费者模型)。源码如下： // Demo1.java // 仓库 class Depot { private int capacity; // 仓库的容量 private int size; // 仓库的实际数量 public Depot(int capacity) { this.capacity = capacity; this.size = 0; } public synchronized void produce(int val) { try { // left 表示“想要生产的数量”(有可能生产量太多，需多此生产) int left = val; while (left &gt; 0) { // 库存已满时，等待“消费者”消费产品。 while (size &gt;= capacity) wait(); // 获取“实际生产的数量”(即库存中新增的数量) // 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库) // 否则“实际增量”=“想要生产的数量” int inc = (size+left)&gt;capacity ? (capacity-size) : left; size += inc; left -= inc; System.out.printf(&quot;%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\\n&quot;, Thread.currentThread().getName(), val, left, inc, size); // 通知“消费者”可以消费了。 notifyAll(); } } catch (InterruptedException e) { } } public synchronized void consume(int val) { try { // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费) int left = val; while (left &gt; 0) { // 库存为0时，等待“生产者”生产产品。 while (size &lt;= 0) wait(); // 获取“实际消费的数量”(即库存中实际减少的数量) // 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”； // 否则，“实际消费量”=“客户要消费的数量”。 int dec = (size&lt;left) ? size : left; size -= dec; left -= dec; System.out.printf(&quot;%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\\n&quot;, Thread.currentThread().getName(), val, left, dec, size); notifyAll(); } } catch (InterruptedException e) { } } public String toString() { return &quot;capacity:&quot;+capacity+&quot;, actual size:&quot;+size; } } // 生产者 class Producer { private Depot depot; public Producer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) { new Thread() { public void run() { depot.produce(val); } }.start(); } } // 消费者 class Customer { private Depot depot; public Customer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) { new Thread() { public void run() { depot.consume(val); } }.start(); } } public class Demo1 { public static void main(String[] args) { Depot mDepot = new Depot(100); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); } }说明：(01) Producer是“生产者”类，它与“仓库(depot)”关联。当调用“生产者”的produce()方法时，它会新建一个线程并向“仓库”中生产产品。(02) Customer是“消费者”类，它与“仓库(depot)”关联。当调用“消费者”的consume()方法时，它会新建一个线程并消费“仓库”中的产品。(03) Depot是“仓库”类，仓库中记录“仓库的容量(capacity)”以及“仓库中当前产品数目(size)”。&nbsp;&nbsp;&nbsp;&nbsp; “仓库”类的生产方法produce()和消费方法consume()方法都是synchronized方法，进入synchronized方法体，意味着这个线程获取到了该“仓库”对象的同步锁。这也就是说，同一时间，生产者和消费者线程只能有一个能运行。通过同步锁，实现了对“残酷”的互斥访问。&nbsp;&nbsp;&nbsp;&nbsp; 对于生产方法produce()而言：当仓库满时，生产者线程等待，需要等待消费者消费产品之后，生产线程才能生产；生产者线程生产完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“消费者线程”，即我们所说的“通知消费者进行消费”。&nbsp;&nbsp;&nbsp;&nbsp; 对于消费方法consume()而言：当仓库为空时，消费者线程等待，需要等待生产者生产产品之后，消费者线程才能消费；消费者线程消费完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“生产者线程”，即我们所说的“通知生产者进行生产”。 (某一次)运行结果： Thread-0 produce( 60) --&gt; left= 0, inc= 60, size= 60 Thread-4 produce(110) --&gt; left= 70, inc= 40, size=100 Thread-2 consume( 90) &lt;-- left= 0, dec= 90, size= 10 Thread-3 consume(150) &lt;-- left=140, dec= 10, size= 0 Thread-1 produce(120) --&gt; left= 20, inc=100, size=100 Thread-3 consume(150) &lt;-- left= 40, dec=100, size= 0 Thread-4 produce(110) --&gt; left= 0, inc= 70, size= 70 Thread-3 consume(150) &lt;-- left= 0, dec= 40, size= 30 Thread-1 produce(120) --&gt; left= 0, inc= 20, size= 50","link":"/2012/08/11/java/threads/2012-08-11-threads-basic/"},{"title":"Java 集合系列02之 Collection架构","text":"本文，我们将对Collection进行概括。下面先看看Collection的一些框架类的关系图： Collection是一个接口，它主要的两个分支是：List 和 Set。 List和Set都是接口，它们继承于Collection。List是有序的队列，List中可以有重复的元素；而Set是数学概念中的集合，Set中没有重复元素！List和Set都有它们各自的实现类。 为了方便实现，集合中定义了AbstractCollection抽象类，它实现了Collection中的绝大部分函数；这样，在Collection的实现类中，我们就可以通过继承AbstractCollection省去重复编码。AbstractList和AbstractSet都继承于AbstractCollection，具体的List实现类继承于AbstractList，而Set的实现类则继承于AbstractSet。 另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。 接下来，我们看看各个接口和抽象类的介绍；然后，再对实现类进行详细的了解。 目录1. Collection简介2. List简介3. Set简介4. AbstractCollection5. AbstractList6. AbstractSet7. Iterator8. ListIterator 1. Collection简介Collection的定义如下： public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {}它是一个接口，是高度抽象出来的集合，它包含了集合的基本操作：添加、删除、清空、遍历(读取)、是否为空、获取大小、是否保护某元素等等。 Collection接口的所有子类(直接子类和间接子类)都必须实现2种构造函数：不带参数的构造函数 和 参数为Collection的构造函数。带参数的构造函数，可以用来转换Collection的类型。 // Collection的API abstract boolean add(E object) abstract boolean addAll(Collection&lt;? extends E&gt; collection) abstract void clear() abstract boolean contains(Object object) abstract boolean containsAll(Collection&lt;?&gt; collection) abstract boolean equals(Object object) abstract int hashCode() abstract boolean isEmpty() abstract Iterator&lt;E&gt; iterator() abstract boolean remove(Object object) abstract boolean removeAll(Collection&lt;?&gt; collection) abstract boolean retainAll(Collection&lt;?&gt; collection) abstract int size() abstract &lt;T&gt; T[] toArray(T[] array) abstract Object[] toArray() 2. List简介List的定义如下： public interface List&lt;E&gt; extends Collection&lt;E&gt; {}List是一个继承于Collection的接口，即List是集合中的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。List的官方介绍如下： A List is a collection which maintains an ordering for its elements. Every element in the List has an index. Each element can thus be accessed by its index, with the first index being zero. Normally, Lists allow duplicate elements, as compared to Sets, where elements have to be unique. 关于API方面。既然List是继承于Collection接口，它自然就包含了Collection中的全部函数接口；由于List是有序队列，它也额外的有自己的API接口。主要有“添加、删除、获取、修改指定位置的元素”、“获取List中的子队列”等。 // Collection的API abstract boolean add(E object) abstract boolean addAll(Collection&lt;? extends E&gt; collection) abstract void clear() abstract boolean contains(Object object) abstract boolean containsAll(Collection&lt;?&gt; collection) abstract boolean equals(Object object) abstract int hashCode() abstract boolean isEmpty() abstract Iterator&lt;E&gt; iterator() abstract boolean remove(Object object) abstract boolean removeAll(Collection&lt;?&gt; collection) abstract boolean retainAll(Collection&lt;?&gt; collection) abstract int size() abstract &lt;T&gt; T[] toArray(T[] array) abstract Object[] toArray() // 相比与Collection，List新增的API： abstract void add(int location, E object) abstract boolean addAll(int location, Collection&lt;? extends E&gt; collection) abstract E get(int location) abstract int indexOf(Object object) abstract int lastIndexOf(Object object) abstract ListIterator&lt;E&gt; listIterator(int location) abstract ListIterator&lt;E&gt; listIterator() abstract E remove(int location) abstract E set(int location, E object) abstract List&lt;E&gt; subList(int start, int end) 3. Set简介Set的定义如下： public interface Set&lt;E&gt; extends Collection&lt;E&gt; {}Set是一个继承于Collection的接口，即Set也是集合中的一种。Set是没有重复元素的集合。 关于API方面。Set的API和Collection完全一样。 // Set的API abstract boolean add(E object) abstract boolean addAll(Collection&lt;? extends E&gt; collection) abstract void clear() abstract boolean contains(Object object) abstract boolean containsAll(Collection&lt;?&gt; collection) abstract boolean equals(Object object) abstract int hashCode() abstract boolean isEmpty() abstract Iterator&lt;E&gt; iterator() abstract boolean remove(Object object) abstract boolean removeAll(Collection&lt;?&gt; collection) abstract boolean retainAll(Collection&lt;?&gt; collection) abstract int size() abstract &lt;T&gt; T[] toArray(T[] array) abstract Object[] toArray() 4. AbstractCollectionAbstractCollection的定义如下： public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {}AbstractCollection是一个抽象类，它实现了Collection中除iterator()和size()之外的函数。AbstractCollection的主要作用：它实现了Collection接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。 5. AbstractListAbstractList的定义如下： public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {}AbstractList是一个继承于AbstractCollection，并且实现List接口的抽象类。它实现了List中除size()、get(int location)之外的函数。AbstractList的主要作用：它实现了List接口中的大部分函数。从而方便其它类继承List。另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()接口。 6. AbstractSetAbstractSet的定义如下： public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {}AbstractSet是一个继承于AbstractCollection，并且实现Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。AbstractSet的主要作用：它实现了Set接口中的大部分函数。从而方便其它类实现Set接口。 7. IteratorIterator的定义如下： public interface Iterator&lt;E&gt; {}Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。注意：Iterator遍历Collection时，是fail-fast机制的。即，当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。关于fail-fast的详细内容，我们会在fail-fast总结后面专门进行说明。 // Iterator的API abstract boolean hasNext() abstract E next() abstract void remove() 8. ListIteratorListIterator的定义如下： public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {}ListIterator是一个继承于Iterator的接口，它是队列迭代器。专门用于便利List，能提供向前/向后遍历。相比于Iterator，它新增了添加、是否存在上一个元素、获取上一个元素等等API接口。 // ListIterator的API // 继承于Iterator的接口 abstract boolean hasNext() abstract E next() abstract void remove() // 新增API接口 abstract void add(E object) abstract boolean hasPrevious() abstract int nextIndex() abstract E previous() abstract int previousIndex() abstract void set(E object)更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/02/java/collection/2012-02-02-collection-02-framework/"},{"title":"Java 集合系列07之 Stack详细介绍(源码解析)和使用示例","text":"学完Vector了之后，接下来我们开始学习Stack。Stack很简单，它继承于Vector。学习方式还是和之前一样，先对Stack有个整体认识，然后再学习它的源码；最后再通过实例来学会使用它。内容包括： 目录第1部分 Stack介绍第2部分 Stack源码解析(基于JDK1.6.0_45)第3部分 Vector示例 第1部分 Stack介绍Stack简介Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。 java工具包中的Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。当然，我们也可以将LinkedList当作栈来使用！在“Java 集合系列06之 Vector详细介绍(源码解析)和使用示例”中，已经详细介绍过Vector的数据结构，这里就不再对Stack的数据结构进行说明了。 Stack的继承关系 java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.Vector&lt;E&gt; ↳ java.util.Stack&lt;E&gt;Stack的声明 public class Stack&lt;E&gt; extends Vector&lt;E&gt; {}Stack和Collection的关系如下图： Stack的构造函数 Stack()Stack的API boolean empty() synchronized E peek() synchronized E pop() E push(E object) synchronized int search(Object o)由于Stack和继承于Vector，因此它也包含Vector中的全部API。 第2部分 Stack源码解析(基于JDK1.6.0_45)Stack的源码非常简单，下面我们对它进行学习。 package java.util; public class Stack&lt;E&gt; extends Vector&lt;E&gt; { // 版本ID。这个用于版本升级控制，这里不须理会！ private static final long serialVersionUID = 1224463164541339165L; // 构造函数 public Stack() { } // push函数：将元素存入栈顶 public E push(E item) { // 将元素存入栈顶。 // addElement()的实现在Vector.java中 addElement(item); return item; } // pop函数：返回栈顶元素，并将其从栈中删除 public synchronized E pop() { E obj; int len = size(); obj = peek(); // 删除栈顶元素，removeElementAt()的实现在Vector.java中 removeElementAt(len - 1); return obj; } // peek函数：返回栈顶元素，不执行删除操作 public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); // 返回栈顶元素，elementAt()具体实现在Vector.java中 return elementAt(len - 1); } // 栈是否为空 public boolean empty() { return size() == 0; } // 查找“元素o”在栈中的位置：由栈底向栈顶方向数 public synchronized int search(Object o) { // 获取元素索引，elementAt()具体实现在Vector.java中 int i = lastIndexOf(o); if (i &gt;= 0) { return size() - i; } return -1; } }总结： (01) Stack实际上也是通过数组去实现的。 执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。执行pull时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。(02) Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。 第3部分 Vector示例下面我们通过实例学习如何使用Stack import java.util.Stack; import java.util.Iterator; import java.util.List; /** * @desc Stack的测试程序。测试常用API的用法 * * @author skywang */ public class StackTest { public static void main(String[] args) { Stack stack = new Stack(); // 将1,2,3,4,5添加到栈中 for(int i=1; i&lt;6; i++) { stack.push(String.valueOf(i)); } // 遍历并打印出该栈 iteratorThroughRandomAccess(stack) ; // 查找“2”在栈中的位置，并输出 int pos = stack.search(&quot;2&quot;); System.out.println(&quot;the postion of 2 is:&quot;+pos); // pup栈顶元素之后，遍历栈 stack.pop(); iteratorThroughRandomAccess(stack) ; // peek栈顶元素之后，遍历栈 String val = (String)stack.peek(); System.out.println(&quot;peek:&quot;+val); iteratorThroughRandomAccess(stack) ; // 通过Iterator去遍历Stack iteratorThroughIterator(stack) ; } /** * 通过快速访问遍历Stack */ public static void iteratorThroughRandomAccess(List list) { String val = null; for (int i=0; i&lt;list.size(); i++) { val = (String)list.get(i); System.out.print(val+&quot; &quot;); } System.out.println(); } /** * 通过迭代器遍历Stack */ public static void iteratorThroughIterator(List list) { String val = null; for(Iterator iter = list.iterator(); iter.hasNext(); ) { val = (String)iter.next(); System.out.print(val+&quot; &quot;); } System.out.println(); } }运行结果： 1 2 3 4 5 the postion of 2 is:4 1 2 3 4 peek:4 1 2 3 4 1 2 3 4 更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/07/java/collection/2012-02-07-collection-07-stack/"},{"title":"Java 集合系列09之 Map架构","text":"前面，我们已经系统的对List进行了学习。接下来，我们先学习Map，然后再学习Set；因为Set的实现类都是基于Map来实现的(如，HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的)。 首先，我们看看Map架构。 如上图： (01) Map 是映射接口，Map中存储的内容是键值对(key-value)。(02) AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。(03) SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。(04) NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。(05) TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”！(06) HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“键值对，但不保证次序”！(07) Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“键值对，也不保证次序”。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。(08) WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”。 在对各个实现类进行详细之前，先来看看各个接口和抽象类的大致介绍。内容包括： 1 Map2 Map.Entry3 AbstractMap4 SortedMap5 NavigableMap6 Dictionary 1. MapMap的定义如下： public interface Map&lt;K,V&gt; { }Map 是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值。Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。Map 映射顺序。有些实现类，可以明确保证其顺序，如 TreeMap；另一些映射实现则不保证顺序，如 HashMap 类。Map 的实现类应该提供2个“标准的”构造方法：第一个，void（无参数）构造方法，用于创建空映射；第二个，带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新映射。实际上，后一个构造方法允许用户复制任意映射，生成所需类的一个等价映射。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的映射实现都遵从它。 Map的API abstract void clear() abstract boolean containsKey(Object key) abstract boolean containsValue(Object value) abstract Set&lt;Entry&lt;K, V&gt;&gt; entrySet() abstract boolean equals(Object object) abstract V get(Object key) abstract int hashCode() abstract boolean isEmpty() abstract Set&lt;K&gt; keySet() abstract V put(K key, V value) abstract void putAll(Map&lt;? extends K, ? extends V&gt; map) abstract V remove(Object key) abstract int size() abstract Collection&lt;V&gt; values()说明：(01) Map提供接口分别用于返回 键集、值集或键-值映射关系集。 entrySet()用于返回键-值集的Set集合keySet()用于返回键集的Set集合values()用户返回值集的Collection集合因为Map中不能包含重复的键；每个键最多只能映射到一个值。所以，键-值集、键集都是Set，值集时Collection。 (02) Map提供了“键-值对”、“根据键获取值”、“删除键”、“获取容量大小”等方法。 2. Map.EntryMap.Entry的定义如下： interface Entry&lt;K,V&gt; { }Map.Entry是Map中内部的一个接口，Map.Entry是键值对，Map通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。 Map.Entry的API abstract boolean equals(Object object) abstract K getKey() abstract V getValue() abstract int hashCode() abstract V setValue(V object) 3. AbstractMapAbstractMap的定义如下： public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; {}AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。要实现不可修改的映射，编程人员只需扩展此类并提供 entrySet 方法的实现即可，该方法将返回映射的映射关系 set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 set 不支持 add() 或 remove() 方法，其迭代器也不支持 remove() 方法。 要实现可修改的映射，编程人员必须另外重写此类的 put 方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其 remove 方法。 AbstractMap的API abstract Set&lt;Entry&lt;K, V&gt;&gt; entrySet() void clear() boolean containsKey(Object key) boolean containsValue(Object value) boolean equals(Object object) V get(Object key) int hashCode() boolean isEmpty() Set&lt;K&gt; keySet() V put(K key, V value) void putAll(Map&lt;? extends K, ? extends V&gt; map) V remove(Object key) int size() String toString() Collection&lt;V&gt; values() Object clone() 4. SortedMapSortedMap的定义如下： public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; { }SortedMap是一个继承于Map接口的接口。它是一个有序的SortedMap键值映射。SortedMap的排序方式有两种：自然排序 或者 用户指定比较器。 插入有序 SortedMap 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。 另外，所有SortedMap 实现类都应该提供 4 个“标准”构造方法：(01) void（无参数）构造方法，它创建一个空的有序映射，按照键的自然顺序进行排序。(02) 带有一个 Comparator 类型参数的构造方法，它创建一个空的有序映射，根据指定的比较器进行排序。(03) 带有一个 Map 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系与参数相同，按照键的自然顺序进行排序。(04) 带有一个 SortedMap 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系和排序方法与输入的有序映射相同。无法保证强制实施此建议，因为接口不能包含构造方法。 SortedMap的API // 继承于Map的API abstract void clear() abstract boolean containsKey(Object key) abstract boolean containsValue(Object value) abstract Set&lt;Entry&lt;K, V&gt;&gt; entrySet() abstract boolean equals(Object object) abstract V get(Object key) abstract int hashCode() abstract boolean isEmpty() abstract Set&lt;K&gt; keySet() abstract V put(K key, V value) abstract void putAll(Map&lt;? extends K, ? extends V&gt; map) abstract V remove(Object key) abstract int size() abstract Collection&lt;V&gt; values() // SortedMap新增的API abstract Comparator&lt;? super K&gt; comparator() abstract K firstKey() abstract SortedMap&lt;K, V&gt; headMap(K endKey) abstract K lastKey() abstract SortedMap&lt;K, V&gt; subMap(K startKey, K endKey) abstract SortedMap&lt;K, V&gt; tailMap(K startKey) 5 NavigableMapNavigableMap的定义如下： public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; { }NavigableMap是继承于SortedMap的接口。它是一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。NavigableMap分别提供了获取“键”、“键-值对”、“键集”、“键-值对集”的相关方法。 NavigableMap的API abstract Entry&lt;K, V&gt; ceilingEntry(K key) abstract Entry&lt;K, V&gt; firstEntry() abstract Entry&lt;K, V&gt; floorEntry(K key) abstract Entry&lt;K, V&gt; higherEntry(K key) abstract Entry&lt;K, V&gt; lastEntry() abstract Entry&lt;K, V&gt; lowerEntry(K key) abstract Entry&lt;K, V&gt; pollFirstEntry() abstract Entry&lt;K, V&gt; pollLastEntry() abstract K ceilingKey(K key) abstract K floorKey(K key) abstract K higherKey(K key) abstract K lowerKey(K key) abstract NavigableSet&lt;K&gt; descendingKeySet() abstract NavigableSet&lt;K&gt; navigableKeySet() abstract NavigableMap&lt;K, V&gt; descendingMap() abstract NavigableMap&lt;K, V&gt; headMap(K toKey, boolean inclusive) abstract SortedMap&lt;K, V&gt; headMap(K toKey) abstract SortedMap&lt;K, V&gt; subMap(K fromKey, K toKey) abstract NavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) abstract SortedMap&lt;K, V&gt; tailMap(K fromKey) abstract NavigableMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive)说明：NavigableMap除了继承SortedMap的特性外，它的提供的功能可以分为4类：第1类，提供操作键-值对的方法。&nbsp;&nbsp;lowerEntry、floorEntry、ceilingEntry 和 higherEntry 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象。&nbsp;&nbsp;firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。第2类，提供操作键的方法。这个和第1类比较类似&nbsp;&nbsp;lowerKey、floorKey、ceilingKey 和 higherKey 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键。第3类，获取键集。&nbsp;&nbsp;navigableKeySet、descendingKeySet分别获取正序/反序的键集。第4类，获取键-值对的子集。 6. DictionaryDictionary的定义如下： public abstract class Dictionary&lt;K,V&gt; {}NavigableMap是JDK 1.0定义的键值对的接口，它也包括了操作键值对的基本函数。 Dictionary的API abstract Enumeration&lt;V&gt; elements() abstract V get(Object key) abstract boolean isEmpty() abstract Enumeration&lt;K&gt; keys() abstract V put(K key, V value) abstract V remove(Object key) abstract int size()更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/09/java/collection/2012-02-09-collection-09-map/"},{"title":"Java 集合系列扩展(一) Comparable和Comparator比较","text":"本文，先介绍Comparable 和Comparator两个接口，以及它们的差异；接着，通过示例，对它们的使用方法进行说明。 目录1. Comparable 介绍2. Comparator 介绍3. Comparator 和 Comparable 比较 1. Comparable 介绍1.1 Comparable 介绍Comparable 是排序接口。 若一个类实现了Comparable接口，就意味着“该类支持排序”。 即然实现Comparable接口的类支持排序，假设现在存在“实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。 此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。 1.2 Comparable 定义Comparable 接口仅仅只包括一个函数，它的定义如下： package java.lang; import java.util.*; public interface Comparable&lt;T&gt; { public int compareTo(T o); }说明： 假设我们通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。 2. Comparator 介绍2.1 Comparator 简介Comparator 是比较器接口。 我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。 也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。 2.2 Comparator 定义Comparator 接口仅仅只包括两个个函数，它的定义如下： package java.util; public interface Comparator&lt;T&gt; { int compare(T o1, T o2); boolean equals(Object obj); }说明：(01) 若一个类要实现Comparator接口：它一定要实现compareTo(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。&nbsp;&nbsp;&nbsp;&nbsp; 为什么可以不实现 equals(Object obj) 函数呢？ 因为任何类，默认都是已经实现了equals(Object obj)的。 Java中的一切类都是继承于java.lang.Object，在Object.java中实现了equals(Object obj)函数；所以，其它所有的类也相当于都实现了该函数。(02) int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。 3. Comparator 和 Comparable 比较Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 我们不难发现：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 我们通过一个测试程序来对这两个接口进行说明。源码如下： import java.util.*; import java.lang.Comparable; /** * @desc &quot;Comparator&quot;和“Comparable”的比较程序。 * (01) &quot;Comparable&quot; * 它是一个排序接口，只包含一个函数compareTo()。 * 一个类实现了Comparable接口，就意味着“该类本身支持排序”，它可以直接通过Arrays.sort() 或 Collections.sort()进行排序。 * (02) &quot;Comparator&quot; * 它是一个比较器接口，包括两个函数：compare() 和 equals()。 * 一个类实现了Comparator接口，那么它就是一个“比较器”。其它的类，可以根据该比较器去排序。 * * 综上所述：Comparable是内部比较器，而Comparator是外部比较器。 * 一个类本身实现了Comparable比较器，就意味着它本身支持排序；若它本身没实现Comparable，也可以通过外部比较器Comparator进行排序。 */ public class CompareComparatorAndComparableTest{ public static void main(String[] args) { // 新建ArrayList(动态数组) ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); // 添加对象到ArrayList中 list.add(new Person(&quot;ccc&quot;, 20)); list.add(new Person(&quot;AAA&quot;, 30)); list.add(new Person(&quot;bbb&quot;, 10)); list.add(new Person(&quot;ddd&quot;, 40)); // 打印list的原始序列 System.out.printf(&quot;Original sort, list:%s\\n&quot;, list); // 对list进行排序 // 这里会根据“Person实现的Comparable&lt;String&gt;接口”进行排序，即会根据“name”进行排序 Collections.sort(list); System.out.printf(&quot;Name sort, list:%s\\n&quot;, list); // 通过“比较器(AscAgeComparator)”，对list进行排序 // AscAgeComparator的排序方式是：根据“age”的升序排序 Collections.sort(list, new AscAgeComparator()); System.out.printf(&quot;Asc(age) sort, list:%s\\n&quot;, list); // 通过“比较器(DescAgeComparator)”，对list进行排序 // DescAgeComparator的排序方式是：根据“age”的降序排序 Collections.sort(list, new DescAgeComparator()); System.out.printf(&quot;Desc(age) sort, list:%s\\n&quot;, list); // 判断两个person是否相等 testEquals(); } /** * @desc 测试两个Person比较是否相等。 * 由于Person实现了equals()函数：若两person的age、name都相等，则认为这两个person相等。 * 所以，这里的p1和p2相等。 * * TODO：若去掉Person中的equals()函数，则p1不等于p2 */ private static void testEquals() { Person p1 = new Person(&quot;eee&quot;, 100); Person p2 = new Person(&quot;eee&quot;, 100); if (p1.equals(p2)) { System.out.printf(&quot;%s EQUAL %s\\n&quot;, p1, p2); } else { System.out.printf(&quot;%s NOT EQUAL %s\\n&quot;, p1, p2); } } /** * @desc Person类。 * Person实现了Comparable接口，这意味着Person本身支持排序 */ private static class Person implements Comparable&lt;Person&gt;{ int age; String name; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } public String toString() { return name + &quot; - &quot; +age; } /** * 比较两个Person是否相等：若它们的name和age都相等，则认为它们相等 */ boolean equals(Person person) { if (this.age == person.age &amp;&amp; this.name == person.name) return true; return false; } /** * @desc 实现 “Comparable&lt;String&gt;” 的接口，即重写compareTo&lt;T t&gt;函数。 * 这里是通过“person的名字”进行比较的 */ @Override public int compareTo(Person person) { return name.compareTo(person.name); //return this.name - person.name; } } /** * @desc AscAgeComparator比较器 * 它是“Person的age的升序比较器” */ private static class AscAgeComparator implements Comparator&lt;Person&gt; { @Override public int compare(Person p1, Person p2) { return p1.getAge() - p2.getAge(); } } /** * @desc DescAgeComparator比较器 * 它是“Person的age的升序比较器” */ private static class DescAgeComparator implements Comparator&lt;Person&gt; { @Override public int compare(Person p1, Person p2) { return p2.getAge() - p1.getAge(); } } }下面对这个程序进行说明。 a) Person类定义。如下： private static class Person implements Comparable&lt;Person&gt;{ int age; String name; ... /** * @desc 实现 “Comparable&lt;String&gt;” 的接口，即重写compareTo&lt;T t&gt;函数。 * 这里是通过“person的名字”进行比较的 */ @Override public int compareTo(Person person) { return name.compareTo(person.name); //return this.name - person.name; } } 说明：(01) Person类代表一个人，Persong类中有两个属性：age(年纪) 和 name“人名”。(02) Person类实现了Comparable接口，因此它能被排序。 b) 在main()中，我们创建了Person的List数组(list)。如下： // 新建ArrayList(动态数组) ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); // 添加对象到ArrayList中 list.add(new Person(&quot;ccc&quot;, 20)); list.add(new Person(&quot;AAA&quot;, 30)); list.add(new Person(&quot;bbb&quot;, 10)); list.add(new Person(&quot;ddd&quot;, 40));c) 接着，我们打印出list的全部元素。如下： // 打印list的原始序列 System.out.printf(&quot;Original sort, list:%s\\n&quot;, list);d) 然后，我们通过Collections的sort()函数，对list进行排序。 由于Person实现了Comparable接口，因此通过sort()排序时，会根据Person支持的排序方式，即 compareTo(Person person) 所定义的规则进行排序。如下： // 对list进行排序 // 这里会根据“Person实现的Comparable&lt;String&gt;接口”进行排序，即会根据“name”进行排序 Collections.sort(list); System.out.printf(&quot;Name sort, list:%s\\n&quot;, list);e) 对比Comparable和Comparator 我们定义了两个比较器 AscAgeComparator 和 DescAgeComparator，来分别对Person进行 升序 和 降低 排序。 e.1) AscAgeComparator比较器 它是将Person按照age进行升序排序。代码如下： /** * @desc AscAgeComparator比较器 * 它是“Person的age的升序比较器” */ private static class AscAgeComparator implements Comparator&lt;Person&gt; { @Override public int compare(Person p1, Person p2) { return p1.getAge() - p2.getAge(); } }e.2) DescAgeComparator比较器 它是将Person按照age进行降序排序。代码如下： /** * @desc DescAgeComparator比较器 * 它是“Person的age的升序比较器” */ private static class DescAgeComparator implements Comparator&lt;Person&gt; { @Override public int compare(Person p1, Person p2) { return p2.getAge() - p1.getAge(); } }f) 运行结果运行程序，输出如下： Original sort, list:[ccc - 20, AAA - 30, bbb - 10, ddd - 40] Name sort, list:[AAA - 30, bbb - 10, ccc - 20, ddd - 40] Asc(age) sort, list:[bbb - 10, ccc - 20, AAA - 30, ddd - 40] Desc(age) sort, list:[ddd - 40, AAA - 30, ccc - 20, bbb - 10] eee - 100 EQUAL eee - 100","link":"/2012/02/19/java/collection/2012-02-19-comparable-comparator/"},{"title":"《深入理解Java内存模型》读书总结","text":"文章是《深入理解Java内容模型》读书笔记，该书总共包括了3部分的知识。 第1部分，基本概念&nbsp;&nbsp;&nbsp;&nbsp; 包括“并发、同步、主内存、本地内存、重排序、内存屏障、happens before规则、as-if-serial规则、数据依赖性、顺序一致性模型、JMM的含义和意义”。第2部分，同步机制&nbsp;&nbsp;&nbsp;&nbsp; 该部分中就介绍了“同步”的3种方式：volatile、锁、final。对于每一种方式，从该方式的“特性”、“建立的happens before关系”、“对应的内存语义”、“实现方式”等几个方面进行了分析说明。实际上，JMM保证“如果程序正确同步，则执行结果与顺序一致性内存模型的结果相同”的机制；而这部分这是确保程序正确同步的机制。第3部分，JMM总结 目录 第1部分 基本概念1. 并发定义：即，并发(同时)发生。在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。 并发需要处理两个关键问题：线程之间如何通信及线程之间如何同步。(01) 通信 —— 是指线程之间如何交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。(02) 同步—— 是指程序用于控制不同线程之间操作发生相对顺序的机制。在Java中，可以通过volatile，synchronized, 锁等方式实现同步。 2.主内存和本地内存主内存 —— 即main memory。在java中，实例域、静态域和数组元素是线程之间共享的数据，它们存储在主内存中。本地内存 —— 即local memory。 局部变量，方法定义参数 和 异常处理器参数是不会在线程之间共享的，它们存储在线程的本地内存中。 3.重排序定义：重排序是指“编译器和处理器”为了提高性能，而在程序执行时会对程序进行的重排序。说明：重排序分为——“编译器”和“处理器”两个方面，而“处理器”重排序又包括“指令级重排序”和“内存的重排序”。 关于重排序，我们需要理解它的思想：为了提高程序的并发度，从而提高性能！但是对于多线程程序，重排序可能会导致程序执行的结果不是我们需要的结果！因此，就需要我们通过“volatile，synchronize，锁等方式”作出正确的实现同步。 4.内存屏障定义：包括LoadLoad, LoadStore, StoreLoad, StoreStore共4种内存屏障。内存屏障是与相应的内存重排序相对应的。 屏障类型 指令示例 说明 LoadLoad Barriers Load1; LoadLoad; Load2 确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。 StoreStore Barriers Store1; StoreStore; Store2 确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。 LoadStore Barriers Load1; LoadStore; Store2 确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。 StoreLoad Barriers Store1; StoreLoad; Load2 确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。 作用：通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。 5. happens-before定义：JDK5(JSR-133)提供的概念，用于描述多线程操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。 作用：描述多线程操作之间的内存可见性。 [程序顺序规则]：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。[监视器锁规则]：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。[volatile变量规则]：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。[传递性]：如果A happens- before B，且B happens- before C，那么A happens- before C。 6. 数据依赖性定义：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。作用：编译器和处理器不会对“存在数据依赖关系的两个操作”执行重排序。 7.as-if-serial定义：不管怎么重排序，程序的执行结果不能被改变。 8. 顺序一致性内存模型定义：它是理想化的内存模型。有以下规则：(01) 一个线程中的所有操作必须按照程序的顺序来执行。(02) 所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。 9. JMM定义：Java Memory Mode，即Java内存模型。它是Java线程之间通信的控制机制。说明：JMM对Java程序作出保证——如果程序是正确同步的，程序的执行将具有顺序一致性。即，程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。 10. 可见性可见性一般用于指不同线程之间的数据是否可见。 在java中， 实例域、静态域和数组元素这些数据是线程之间共享的数据，它们存储在主内存中；主内存中的所有数据对该内存中的线程都是可见的。而局部变量，方法定义参数 和 异常处理器参数这些数据是不会在线程之间共享的，它们存储在线程的本地内存中；它们对其它线程是不可见的。 此外，对于主内存中的数据，在本地内存中会对应的创建该数据的副本(相当于缓冲)；这些副本对于其它线程也是不可见的。 11. 原子性是指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。 第2部分 同步机制1.volatile1.1 作用如果一个变量是volatile类型，则对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。volatile变量自身具有下列特性： [可见性]：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。 [原子性]：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。 1.2 volatile的内存语义volatile写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。 volatile读：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 1.3 JMM中的实现方式JMM针对编译器制定的volatile重排序规则表： 是否能重排序 第二个操作 第一个操作 普通读/写 volatile读 volatile写 普通读/写 NO volatile读 NO NO NO volatile写 NO NO 下面是基于保守策略的JMM内存屏障插入策略： 在每个volatile写操作的前面插入一个StoreStore屏障。在每个volatile写操作的后面插入一个StoreLoad屏障。在每个volatile读操作的后面插入一个LoadLoad屏障。在每个volatile读操作的后面插入一个LoadStore屏障。 1.4 volatile和 synchronize对比在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。 volatile仅仅保证对单个volatile变量的读/写具有原子性；而synchronize锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。 2.锁2.1 作用锁是java并发编程中最重要的同步机制。 2.2 锁的内存语义(01) 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。 (02) 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。 (03) 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。 2.3 JMM如何实现锁公平锁公平锁是通过“volatile”实现同步的。公平锁在释放锁的最后写volatile变量state；在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变的对获取锁的线程可见。 非公平锁通过CAS实现的，CAS就是compare and swap。CAS实际上调用的JNI函数，也就是CAS依赖于本地实现。以Intel来说，对于CAS的JNI实现函数，它保证：(01)禁止该CAS之前和之后的读和写指令重排序。(02)把写缓冲区中的所有数据刷新到内存中。 3.final3.1 特性对于基本类型的final域，编译器和处理器要遵守两个重排序规则： (01) final写：“构造函数内对一个final域的写入”，与“随后把这个被构造对象的引用赋值给一个引用变量”，这两个操作之间不能重排序。 (02) final读：“初次读一个包含final域的对象的引用”，与“随后初次读对象的final域”，这两个操作之间不能重排序。 对于引用类型的final域，除上面两条之外，还有一条规则： (03) final写：在“构造函数内对一个final引用的对象的成员域的写入”，与“随后在构造函数外把这个被构造对象的引用赋值给一个引用变量”，这两个操作之间不能重排序。 注意：&nbsp;&nbsp;&nbsp;&nbsp; 写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。 3.2 JMM如何实现final通过“内存屏障”实现。 在final域的写之后，构造函数return之前，插入一个StoreStore障屏。在读final域的操作前面插入一个LoadLoad屏障。 第3部分JMM总结JMM保证：如果程序是正确同步的，程序的执行将具有顺序一致性 。 JMM设计 从JMM设计者的角度来说，在设计JMM时，需要考虑两个关键因素：&nbsp;&nbsp;&nbsp;&nbsp; (01) 程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型(程序尽可能的顺序执行)来编写代码。&nbsp;&nbsp;&nbsp;&nbsp; (02) 编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化(对程序重排序，做尽可能多的并发)来提高性能。编译器和处理器希望实现一个弱内存模型。 JMM设计就需要在这两者之间作出协调。JMM对程序采取了不同的策略：&nbsp;&nbsp;&nbsp;&nbsp; (01) 对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。&nbsp;&nbsp;&nbsp;&nbsp; (02) 对于不会改变程序执行结果的重排序，JMM对编译器和处理器不作要求（JMM允许这种重排序）。 参考文献1. 程晓明的“深入理解Java内存模型”的博客 2. The JSR-133 Cookbook for Compiler Writers","link":"/2012/07/01/java/ebook/2012-07-01-ebook-JavaMemoryMode/"},{"title":"Java异常(一) Java异常简介及其架构","text":"本章对Java中的异常进行介绍。 目录第1部分 Java异常简介第2部分 Java异常框架 第1部分 Java异常简介Java异常是Java提供的一种识别及响应错误的一致性机制。 Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出。 Java异常机制用到的几个关键字：try、catch、finally、throw、throws。 关键字 说明 try 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。 catch 用于捕获异常。catch用来捕获try语句块中发生的异常。 finally finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。 throw 用于抛出异常。 throws 用在方法签名中，用于声明该方法可能抛出的异常。 下面通过几个示例对这几个关键字进行简单了解。 示例一: 了解try和catch基本用法public class Demo1 { public static void main(String[] args) { try { int i = 10/0; System.out.println(&quot;i=&quot;+i); } catch (ArithmeticException e) { System.out.println(&quot;Caught Exception&quot;); System.out.println(&quot;e.getMessage(): &quot; + e.getMessage()); System.out.println(&quot;e.toString(): &quot; + e.toString()); System.out.println(&quot;e.printStackTrace():&quot;); e.printStackTrace(); } } }运行结果： Caught Exception e.getMessage(): / by zero e.toString(): java.lang.ArithmeticException: / by zero e.printStackTrace(): java.lang.ArithmeticException: / by zero at Demo1.main(Demo1.java:6)结果说明：在try语句块中有除数为0的操作，该操作会抛出java.lang.ArithmeticException异常。通过catch，对该异常进行捕获。观察结果我们发现，并没有执行System.out.println(“i=”+i)。这说明try语句块发生异常之后，try语句块中的剩余内容就不会再被执行了。 示例二: 了解finally的基本用法在”示例一”的基础上，我们添加finally语句。 public class Demo2 { public static void main(String[] args) { try { int i = 10/0; System.out.println(&quot;i=&quot;+i); } catch (ArithmeticException e) { System.out.println(&quot;Caught Exception&quot;); System.out.println(&quot;e.getMessage(): &quot; + e.getMessage()); System.out.println(&quot;e.toString(): &quot; + e.toString()); System.out.println(&quot;e.printStackTrace():&quot;); e.printStackTrace(); } finally { System.out.println(&quot;run finally&quot;); } } }运行结果： Caught Exception e.getMessage(): / by zero e.toString(): java.lang.ArithmeticException: / by zero e.printStackTrace(): java.lang.ArithmeticException: / by zero at Demo2.main(Demo2.java:6) run finally结果说明：最终执行了finally语句块。 示例三: 了解throws和throw的基本用法throws是用于声明抛出的异常，而throw是用于抛出异常。 class MyException extends Exception { public MyException() {} public MyException(String msg) { super(msg); } } public class Demo3 { public static void main(String[] args) { try { test(); } catch (MyException e) { System.out.println(&quot;Catch My Exception&quot;); e.printStackTrace(); } } public static void test() throws MyException{ try { int i = 10/0; System.out.println(&quot;i=&quot;+i); } catch (ArithmeticException e) { throw new MyException(&quot;This is MyException&quot;); } } }运行结果： Catch My Exception MyException: This is MyException at Demo3.test(Demo3.java:24) at Demo3.main(Demo3.java:13)结果说明：MyException是继承于Exception的子类。test()的try语句块中产生ArithmeticException异常(除数为0)，并在catch中捕获该异常；接着抛出MyException异常。main()方法对test()中抛出的MyException进行捕获处理。 第2部分 Java异常框架Java异常架构图 1. ThrowableThrowable是 Java 语言中所有错误或异常的超类。Throwable包含两个子类: Error 和 Exception。它们通常用于指示发生了异常情况。Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。 2. ExceptionException及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。 3. RuntimeExceptionRuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 编译器不会检查RuntimeException异常。例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ 4. Error和Exception一样，Error也是Throwable的子类。它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。和RuntimeException一样，编译器也不会检查Error。 Java将可抛出(Throwable)的结构分为三种类型：被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。 **(01) 运行时异常** 定义: RuntimeException及其子类都被称为运行时异常。特点: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。&nbsp;&nbsp;&nbsp;&nbsp; 虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。&nbsp;&nbsp;&nbsp;&nbsp; 如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ **(02) 被检查的异常** 定义: Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。特点: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。&nbsp;&nbsp;&nbsp;&nbsp; 被检查异常通常都是可以恢复的。 **(03) 错误** 定义: Error类及其子类。特点: 和运行时异常一样，编译器也不会对错误进行检查。&nbsp;&nbsp;&nbsp;&nbsp; 当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。&nbsp;&nbsp;&nbsp;&nbsp; 按照Java惯例，我们是不应该是实现任何新的Error子类的！ 对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是：对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。","link":"/2012/04/14/java/exception/2012-04-14-exception/"},{"title":"Java异常(二) 《Effective Java》中关于异常处理的几条建议","text":"本章是从《Effective Java》摘录整理出来的关于异常处理的几条建议。 目录第1条: 只针对不正常的情况才使用异常第2条: 对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常第3条: 避免不必要的使用被检查的异常第4条: 尽量使用标准的异常第5条: 抛出的异常要适合于相应的抽象第6条: 每个方法抛出的异常都要有文档第7条: 在细节消息中包含失败 – 捕获消息第8条: 努力使失败保持原子性第9条: 不要忽略异常 它们对应原书中”第8章 异常”部分的第39-47条。 第1条: 只针对不正常的情况才使用异常建议：异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。 通过比较下面的两份代码进行说明。 代码1 try { int i=0; while (true) { arr[i]=0; i++; } } catch (IndexOutOfBoundsException e) { }代码2 for (int i=0; i&lt;arr.length; i++) { arr[i]=0; }两份代码的作用都是遍历arr数组，并设置数组中每一个元素的值为0。代码1的是通过异常来终止，看起来非常难懂，代码2是通过数组边界来终止。我们应该避免使用代码1这种方式，主要原因有三点： 异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。 把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。 对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。 实际上，基于异常的模式比标准模式要慢得多。测试代码如下： public class Advice1 { private static int[] arr = new int[]{1,2,3,4,5}; private static int SIZE = 10000; public static void main(String[] args) { long s1 = System.currentTimeMillis(); for (int i=0; i&lt;SIZE; i++) endByRange(arr); long e1 = System.currentTimeMillis(); System.out.println(&quot;endByRange time:&quot;+(e1-s1)+&quot;ms&quot; ); long s2 = System.currentTimeMillis(); for (int i=0; i&lt;SIZE; i++) endByException(arr); long e2 = System.currentTimeMillis(); System.out.println(&quot;endByException time:&quot;+(e2-s2)+&quot;ms&quot; ); } // 遍历arr数组: 通过异常的方式 private static void endByException(int[] arr) { try { int i=0; while (true) { arr[i]=0; i++; //System.out.println(&quot;endByRange: arr[&quot;+i+&quot;]=&quot;+arr[i]); } } catch (IndexOutOfBoundsException e) { } } // 遍历arr数组: 通过边界的方式 private static void endByRange(int[] arr) { for (int i=0; i&lt;arr.length; i++) { arr[i]=0; //System.out.println(&quot;endByException: arr[&quot;+i+&quot;]=&quot;+arr[i]); } } }运行结果： endByRange time:8ms endByException time:16ms结果说明：通过异常遍历的速度比普通方式遍历数组慢很多！ 第2条: 对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常 异常 说明 运行时异常 RuntimeException类及其子类都被称为运行时异常。 被检查的异常 Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常 它们的区别是：Java编译器会对”被检查的异常”进行检查，而对”运行时异常”不会检查。 也就是说，对于被检查的异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。而对于运行时异常，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。当然，虽说Java编译器不会检查运行时异常，但是，我们同样可以通过throws对该异常进行说明，或通过try-catch进行捕获。 rithmeticException(例如，除数为0)，IndexOutOfBoundsException(例如，数组越界)等都属于运行时异常。对于这种异常，我们应该通过修改代码进行避免它的产生。而对于被检查的异常，则可以通过处理让程序恢复运行。例如，假设因为一个用户没有存储足够数量的前，所以他在企图在一个收费电话上进行呼叫就会失败；于是就将一个被检查异常抛出。 第3条: 避免不必要的使用被检查的异常“被检查的异常”是Java语言的一个很好的特性。与返回代码不同，”被检查的异常”会强迫程序员处理例外的条件，大大提高了程序的可靠性。 但是，过分使用被检查异常会使API用起来非常不方便。如果一个方法抛出一个或多个被检查的异常，那么调用该方法的代码则必须在一个或多个catch语句块中处理这些异常，或者必须通过throws声明抛出这些异常。 无论是通过catch处理，还是通过throws声明抛出，都给程序员添加了不可忽略的负担。 适用于”被检查的异常”必须同时满足两个条件：第一，即使正确使用API并不能阻止异常条件的发生。第二，一旦产生了异常，使用API的程序员可以采取有用的动作对程序进行处理。 第4条: 尽量使用标准的异常代码重用是值得提倡的，这是一条通用规则，异常也不例外。重用现有的异常有几个好处：第一，它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。第二，对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。第三，异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。 Java标准异常中有几个是经常被使用的异常。如下表格： 异常 使用场合 IllegalArgumentException 参数的值不合适 IllegalStateException 参数的状态不合适 NullPointerException 在null被禁止的情况下参数值为null IndexOutOfBoundsException 下标越界 ConcurrentModificationException 在禁止并发修改的情况下，对象检测到并发修改 UnsupportedOperationException 对象不支持客户请求的方法 虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上！ 最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。 第5条: 抛出的异常要适合于相应的抽象如果一个方法抛出的异常与它执行的任务没有明显的关联关系，这种情形会让人不知所措。当一个方法传递一个由低层抽象抛出的异常时，往往会发生这种情况。这种情况发生时，不仅让人困惑，而且也”污染”了高层API。 为了避免这个问题，高层实现应该捕获低层的异常，同时抛出一个可以按照高层抽象进行介绍的异常。这种做法被称为”异常转译(exception translation)”。 例如，在Java的集合框架AbstractSequentialList的get()方法如下(基于JDK1.7.0_40)： public E get(int index) { try { return listIterator(index).next(); } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); } }listIterator(index)会返回ListIterator对象，调用该对象的next()方法可能会抛出NoSuchElementException异常。而在get()方法中，抛出NoSuchElementException异常会让人感到困惑。所以，get()对NoSuchElementException进行了捕获，并抛出了IndexOutOfBoundsException异常。即，相当于将NoSuchElementException转译成了IndexOutOfBoundsException异常。 第6条: 每个方法抛出的异常都要有文档要单独的声明被检查的异常，并且利用Javadoc的@throws标记，准确地记录下每个异常被抛出的条件。 如果一个类中的许多方法处于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的。 第7条: 在细节消息中包含失败 – 捕获消息简而言之，当我们自定义异常或者抛出异常时，应该包含失败相关的信息。 当一个程序由于一个未被捕获的异常而失败的时候，系统会自动打印出该异常的栈轨迹。在栈轨迹中包含该异常的字符串表示。典型情况下它包含该异常类的类名，以及紧随其后的细节消息。 第8条: 努力使失败保持原子性当一个对象抛出一个异常之后，我们总期望这个对象仍然保持在一种定义良好的可用状态之中。对于被检查的异常而言，这尤为重要，因为调用者通常期望从被检查的异常中恢复过来。 一般而言，一个失败的方法调用应该保持使对象保持在”它在被调用之前的状态”。具有这种属性的方法被称为具有”失败原子性(failure atomic)”。可以理解为，失败了还保持着原子性。对象保持”失败原子性”的方式有几种： (01) 设计一个非可变对象。 (02) 对于在可变对象上执行操作的方法，获得”失败原子性”的最常见方法是，在执行操作之前检查参数的有效性。如下(Stack.java中的pop方法)： public Object pop() { if (size==0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; return result; }(03) 与上一种方法类似，可以对计算处理过程调整顺序，使得任何可能会失败的计算部分都发生在对象状态被修改之前。 (04) 编写一段恢复代码，由它来解释操作过程中发生的失败，以及使对象回滚到操作开始之前的状态上。 (05) 在对象的一份临时拷贝上执行操作，当操作完成之后再把临时拷贝中的结果复制给原来的对象。 虽然”保持对象的失败原子性”是期望目标，但它并不总是可以做得到。例如，如果多个线程企图在没有适当的同步机制的情况下，并发的访问一个对象，那么该对象就有可能被留在不一致的状态中。 即使在可以实现”失败原子性”的场合，它也不是总被期望的。对于某些操作，它会显著的增加开销或者复杂性。总的规则是：作为方法规范的一部分，任何一个异常都不应该改变对象调用该方法之前的状态，如果这条规则被违反，则API文档中应该清楚的指明对象将会处于什么样的状态。 第9条: 不要忽略异常当一个API的设计者声明一个方法会抛出某个异常的时候，他们正在试图说明某些事情。所以，请不要忽略它！忽略异常的代码如下： try { ... } catch (SomeException e) { }空的catch块会使异常达不到应有的目的，异常的目的是强迫你处理不正常的条件。忽略一个异常，就如同忽略一个火警信号一样 – 若把火警信号器关闭了，那么当真正的火灾发生时，就没有人看到火警信号了。所以，至少catch块应该包含一条说明，用来解释为什么忽略这个异常是合适的。","link":"/2012/04/15/java/exception/2012-04-15-exception/"},{"title":"Java引用总结--StrongReference、SoftReference、WeakReference、PhantomReference","text":"目录1. Java引用介绍2. 内存回收3. Java对引用的分类 1. Java引用介绍Java从1.2版本开始引入了4种引用，这4种引用的级别由高到低依次为： 强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用 (01) 强引用（StrongReference）&nbsp;&nbsp;&nbsp;&nbsp; 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 (02) 软引用（SoftReference）&nbsp;&nbsp;&nbsp;&nbsp; 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。&nbsp;&nbsp;&nbsp;&nbsp; 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 (03) 弱引用（WeakReference）&nbsp;&nbsp;&nbsp;&nbsp; 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。&nbsp;&nbsp;&nbsp;&nbsp; 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 (04) 虚引用（PhantomReference）&nbsp;&nbsp;&nbsp;&nbsp; “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。&nbsp;&nbsp;&nbsp;&nbsp; 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 由于引用和内存回收关系紧密。下面，先通过实例对内存回收有个认识；然后，进一步通过引用实例加深对引用的了解。 2. 内存回收创建公共类MyDate，它的作用是覆盖finalize()函数：在finalize()中输出打印信息，方便追踪。 说明：finalize()函数是在JVM回收内存时执行的，但JVM并不保证在回收内存时一定会调用finalize()。 MyDate代码如下： package com.skywang.java; import java.util.Date; public class MyDate extends Date { /** Creates a new instance of MyDate */ public MyDate() { } // 覆盖finalize()方法 protected void finalize() throws Throwable { super.finalize(); System.out.println(&quot;obj [Date: &quot; + this.getTime() + &quot;] is gc&quot;); } public String toString() { return &quot;Date: &quot; + this.getTime(); } }在这个类中，对java.util.Date类进行了扩展，并重写了finalize()和toString()方法。 创建公共类ReferenceTest，它的作用是定义一个方法drainMemory()：消耗大量内存，以此来引发JVM回收内存。 ReferenceTest代码如下： package com.skywang.java; public class ReferenceTest { /** Creates a new instance of ReferenceTest */ public ReferenceTest() { } // 消耗大量内存 public static void drainMemory() { String[] array = new String[1024 * 10]; for(int i = 0; i &lt; 1024 * 10; i++) { for(int j = &apos;a&apos;; j &lt;= &apos;z&apos;; j++) { array[i] += (char)j; } } } } 在这个类中定义了一个静态方法drainMemory()，此方法旨在消耗大量的内存，促使JVM运行垃圾回收。 有了上面两个公共类之后，我们即可测试JVM什么时候进行垃圾回收。下面分3种情况进行测试： 情况1：清除对象 实现代码： package com.skywang.java; public class NoGarbageRetrieve { public static void main(String[] args) { MyDate date = new MyDate(); date = null; } }运行结果： &lt;无任何输出&gt;结果分析：date虽然设为null，但由于JVM没有执行垃圾回收操作，MyDate的finalize()方法没有被运行。 情况2：显式调用垃圾回收 实现代码： package com.skywang.java; public class ExplicitGarbageRetrieve { /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub MyDate date = new MyDate(); date = null; System.gc(); } }运行结果： obj [Date: 1372137067328] is gc结果分析：调用了System.gc()，使JVM运行垃圾回收，MyDate的finalize()方法被运行。 情况3：隐式调用垃圾回收 实现代码： package com.skywang.java; public class ImplicitGarbageRetrieve { /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub MyDate date = new MyDate(); date = null; ReferenceTest.drainMemory(); } } 运行结果： obj [Date: 1372137171965] is gc结果分析：虽然没有显式调用垃圾回收方法System.gc()，但是由于运行了耗费大量内存的方法，触发JVM进行垃圾回收。 总结：JVM的垃圾回收机制，在内存充足的情况下，除非你显式调用System.gc()，否则它不会进行垃圾回收；在内存不足的情况下，垃圾回收将自动运行 3. Java对引用的分类3.1 强引用实例代码： package com.skywang.java; public class StrongReferenceTest { public static void main(String[] args) { MyDate date = new MyDate(); System.gc(); } }运行结果： &lt;无任何输出&gt;结果说明：即使显式调用了垃圾回收，但是用于date是强引用，date没有被回收。 3.2 软引用实例代码： package com.skywang.java; import java.lang.ref.SoftReference; public class SoftReferenceTest { public static void main(String[] args) { SoftReference ref = new SoftReference(new MyDate()); ReferenceTest.drainMemory(); } }运行结果： &lt;无任何输出&gt;结果说明：在内存不足时，软引用被终止。软引用被禁止时， SoftReference ref = new SoftReference(new MyDate()); ReferenceTest.drainMemory();等价于 MyDate date = new MyDate(); // 由JVM决定运行 if(JVM.内存不足()) { date = null; System.gc(); }3.3 弱引用示例代码： package com.skywang.java; import java.lang.ref.WeakReference; public class WeakReferenceTest { public static void main(String[] args) { WeakReference ref = new WeakReference(new MyDate()); System.gc(); } }运行结果： obj [Date: 1372142034360] is gc结果说明：在JVM垃圾回收运行时，弱引用被终止. WeakReference ref = new WeakReference(new MyDate()); System.gc();等同于： MyDate date = new MyDate(); // 垃圾回收 if(JVM.内存不足()) { date = null; System.gc(); }3.4 假象引用示例代码： package com.skywang.java; import java.lang.ref.ReferenceQueue; import java.lang.ref.PhantomReference; public class PhantomReferenceTest { public static void main(String[] args) { ReferenceQueue queue = new ReferenceQueue(); PhantomReference ref = new PhantomReference(new MyDate(), queue); System.gc(); } }运行结果： obj [Date: 1372142282558] is gc结果说明：假象引用，在实例化后，就被终止了。 ReferenceQueue queue = new ReferenceQueue(); PhantomReference ref = new PhantomReference(new MyDate(), queue); System.gc();等同于： MyDate date = new MyDate(); date = null;可以用以下表格总结上面的内容： 级别 什么时候被垃圾回收 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 在内存不足时 对象简单？缓存 内存不足时终止 弱引用 在垃圾回收时 对象缓存 gc运行后终止 虚引用 Unknown Unknown Unknown","link":"/2012/03/02/java/others/2012-03-02-reference/"},{"title":"Java多线程系列--“基础篇”05之 线程等待与唤醒","text":"本章，会对线程等待/唤醒方法进行介绍。 目录1. wait(), notify(), notifyAll()等方法介绍2. wait()和notify()示例3. wait(long timeout)和notify()4. wait() 和 notifyAll()5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中 1. wait(), notify(), notifyAll()等方法介绍在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。 Object类中关于等待/唤醒的API详细信息如下： API接口 API说明 notify() 唤醒在此对象监视器上等待的单个线程。 notifyAll() 唤醒在此对象监视器上等待的所有线程。 wait() 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。 wait(long timeout) 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 wait(long timeout, int nanos) 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。 2. wait()和notify()示例下面通过示例演示”wait()和notify()配合使用的情形”。 // WaitTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { synchronized (this) { System.out.println(Thread.currentThread().getName()+&quot; call notify()&quot;); // 唤醒当前的wait线程 notify(); } } } public class WaitTest { public static void main(String[] args) { ThreadA t1 = new ThreadA(&quot;t1&quot;); synchronized(t1) { try { // 启动“线程t1” System.out.println(Thread.currentThread().getName()+&quot; start t1&quot;); t1.start(); // 主线程等待t1通过notify()唤醒。 System.out.println(Thread.currentThread().getName()+&quot; wait()&quot;); t1.wait(); System.out.println(Thread.currentThread().getName()+&quot; continue&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } }运行结果: main start t1 main wait() t1 call notify() main continue结果说明：如下图，说明了“主线程”和“线程t1”的流程。(01) 注意，图中”主线程” 代表“主线程main”。”线程t1” 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。(02) “主线程”通过 new ThreadA(“t1”) 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。 对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？在解答该问题前，我们先看看jdk文档中关于wait的一段介绍： Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.In other words, this method behaves exactly as if it simply performs the call wait(0).The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution. 中文意思大概是： 引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。 注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！ 3. wait(long timeout)和notify()wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。 // WaitTimeoutTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { System.out.println(Thread.currentThread().getName() + &quot; run &quot;); // 死循环，不断运行。 while(true) ; } } public class WaitTimeoutTest { public static void main(String[] args) { ThreadA t1 = new ThreadA(&quot;t1&quot;); synchronized(t1) { try { // 启动“线程t1” System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;); t1.start(); // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。 System.out.println(Thread.currentThread().getName() + &quot; call wait &quot;); t1.wait(3000); System.out.println(Thread.currentThread().getName() + &quot; continue&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } }运行结果： main start t1 main call wait t1 run // 大约3秒之后...输出“main continue” main continue结果说明：如下图，说明了“主线程”和“线程t1”的流程。(01) 注意，图中”主线程” 代表WaitTimeoutTest主线程(即，线程main)。”线程t1” 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。(02) 主线程main执行t1.start()启动“线程t1”。(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。(04) “线程t1”运行之后，进入了死循环，一直不断的运行。(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。 4. wait() 和 notifyAll()通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。 下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。 public class NotifyAllTest { private static Object obj = new Object(); public static void main(String[] args) { ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); ThreadA t3 = new ThreadA(&quot;t3&quot;); t1.start(); t2.start(); t3.start(); try { System.out.println(Thread.currentThread().getName()+&quot; sleep(3000)&quot;); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized(obj) { // 主线程等待唤醒。 System.out.println(Thread.currentThread().getName()+&quot; notifyAll()&quot;); obj.notifyAll(); } } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run() { synchronized (obj) { try { // 打印输出结果 System.out.println(Thread.currentThread().getName() + &quot; wait&quot;); // 唤醒当前的wait线程 obj.wait(); // 打印输出结果 System.out.println(Thread.currentThread().getName() + &quot; continue&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } } }运行结果： t1 wait main sleep(3000) t3 wait t2 wait main notifyAll() t2 continue t3 continue t1 continue结果说明：参考下面的流程图。(01) 主线程中新建并且启动了3个线程”t1”, “t2”和”t3”。(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设”t1”, “t2”和”t3”这3个线程都运行了。以”t1”为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，”t2”和”t3”也会等待其它线程通过nofity()或nofityAll()来唤醒它们。(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒”t1”, “t2”和”t3”这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，”t1”, “t2”和”t3”就可以获取“obj锁”而继续运行了！ 5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。 wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。 负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。 总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。","link":"/2012/08/05/java/threads/2012-08-05-threads-basic/"},{"title":"Java多线程系列--“基础篇”09之 interrupt()和线程终止方式","text":"本章，会对线程的interrupt()中断和终止方式进行介绍。 目录1. interrupt()说明2. 终止线程的方式&nbsp;&nbsp;&nbsp;&nbsp; 2.1 终止处于“阻塞状态”的线程&nbsp;&nbsp;&nbsp;&nbsp; 2.2 终止处于“运行状态”的线程3. 终止线程的示例4. interrupted() 和 isInterrupted()的区别 1. interrupt()说明在介绍终止线程的方式之前，有必要先对interrupt()进行了解。关于interrupt()，java的djk文档描述如下：http://docs.oracle.com/javase/7/docs/api/ Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown. If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException. If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException. If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked. If none of the previous conditions hold then this thread’s interrupt status will be set. Interrupting a thread that is not alive need not have any effect. 大致意思是： interrupt()的作用是中断本线程。本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。 如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。 2. 终止线程的方式Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。 2.1 终止处于“阻塞状态”的线程通常，我们通过“中断”方式终止处于“阻塞状态”的线程。当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下： @Override public void run() { try { while (true) { // 执行任务... } } catch (InterruptedException ie) { // 由于产生InterruptedException异常，退出while(true)循环，线程终止！ } }说明：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下： @Override public void run() { while (true) { try { // 执行任务... } catch (InterruptedException ie) { // InterruptedException在while(true)循环体内。 // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出 break; } } }说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。 2.2 终止处于“运行状态”的线程通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。 (01) 通过“中断标记”终止线程。形式如下： @Override public void run() { while (!isInterrupted()) { // 执行任务... } }说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。 (02) 通过“额外添加标记”。形式如下： private volatile boolean flag= true; protected void stopTask() { flag = false; } @Override public void run() { while (flag) { // 执行任务... } }说明：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。 综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下： @Override public void run() { try { // 1. isInterrupted()保证，只要中断标记为true就终止线程。 while (!isInterrupted()) { // 执行任务... } } catch (InterruptedException ie) { // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。 } } 3. 终止线程的示例interrupt()常常被用来终止“阻塞状态”线程。参考下面示例： // Demo1.java的源码 class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { try { int i=0; while (!isInterrupted()) { Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i); } } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;); } } } public class Demo1 { public static void main(String[] args) { try { Thread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } }运行结果： t1 (NEW) is new. t1 (RUNNABLE) is started. t1 (RUNNABLE) loop 1 t1 (RUNNABLE) loop 2 t1 (TIMED_WAITING) is interrupted. t1 (RUNNABLE) catch InterruptedException. t1 (TERMINATED) is interrupted now.结果说明：(01) 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。 我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。 // Demo2.java的源码 class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { int i=0; while (!isInterrupted()) { try { Thread.sleep(100); // 休眠100ms } catch (InterruptedException ie) { System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;); } i++; System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i); } } } public class Demo2 { public static void main(String[] args) { try { Thread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } }运行结果： t1 (NEW) is new. t1 (RUNNABLE) is started. t1 (RUNNABLE) loop 1 t1 (RUNNABLE) loop 2 t1 (TIMED_WAITING) is interrupted. t1 (RUNNABLE) catch InterruptedException. t1 (RUNNABLE) loop 3 t1 (RUNNABLE) loop 4 t1 (RUNNABLE) loop 5 t1 (TIMED_WAITING) is interrupted now. t1 (RUNNABLE) loop 6 t1 (RUNNABLE) loop 7 t1 (RUNNABLE) loop 8 t1 (RUNNABLE) loop 9 ...结果说明：程序进入了死循环！为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。 下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例： // Demo3.java的源码 class MyThread extends Thread { private volatile boolean flag= true; public void stopTask() { flag = false; } public MyThread(String name) { super(name); } @Override public void run() { synchronized(this) { try { int i=0; while (flag) { Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i); } } catch (InterruptedException ie) { System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;); } } } } public class Demo3 { public static void main(String[] args) { try { MyThread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.stopTask(); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } }运行结果： t1 (NEW) is new. t1 (RUNNABLE) is started. t1 (RUNNABLE) loop 1 t1 (RUNNABLE) loop 2 t1 (TIMED_WAITING) is interrupted. t1 (RUNNABLE) loop 3 t1 (TERMINATED) is interrupted now. 4. interrupted() 和 isInterrupted()的区别最后谈谈 interrupted() 和 isInterrupted()。interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。","link":"/2012/08/09/java/threads/2012-08-09-threads-basic/"},{"title":"Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)","text":"前面，我们已经学习了ArrayList。接下来，我们以ArrayList为例，对Iterator的fail-fast机制进行了解。内容包括：： 目录1 fail-fast简介2 fail-fast示例3 fail-fast解决办法4 fail-fast原理5 解决fail-fast的原理 1. fail-fast简介fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 在详细介绍fail-fast机制的原理之前，先通过一个示例来认识fail-fast。 2 fail-fast示例示例代码：(FastFailTest.java) import java.util.*; import java.util.concurrent.*; /* * @desc java集合中Fast-Fail的测试程序。 * * fast-fail事件产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过iterator去遍历集合时，该集合的内容被其他线程所改变；则会抛出ConcurrentModificationException异常。 * fast-fail解决办法：通过util.concurrent集合包下的相应类去处理，则不会产生fast-fail事件。 * * 本例中，分别测试ArrayList和CopyOnWriteArrayList这两种情况。ArrayList会产生fast-fail事件，而CopyOnWriteArrayList不会产生fast-fail事件。 * (01) 使用ArrayList时，会产生fast-fail事件，抛出ConcurrentModificationException异常；定义如下： * private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); * (02) 使用时CopyOnWriteArrayList，不会产生fast-fail事件；定义如下： * private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); * * @author skywang */ public class FastFailTest { private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); public static void main(String[] args) { // 同时启动两个线程对list进行操作！ new ThreadOne().start(); new ThreadTwo().start(); } private static void printAll() { System.out.println(&quot;&quot;); String value = null; Iterator iter = list.iterator(); while(iter.hasNext()) { value = (String)iter.next(); System.out.print(value+&quot;, &quot;); } } /** * 向list中依次添加0,1,2,3,4,5，每添加一个数之后，就通过printAll()遍历整个list */ private static class ThreadOne extends Thread { public void run() { int i = 0; while (i&lt;6) { list.add(String.valueOf(i)); printAll(); i++; } } } /** * 向list中依次添加10,11,12,13,14,15，每添加一个数之后，就通过printAll()遍历整个list */ private static class ThreadTwo extends Thread { public void run() { int i = 10; while (i&lt;16) { list.add(String.valueOf(i)); printAll(); i++; } } } }运行结果 运行该代码，抛出异常java.util.ConcurrentModificationException！即，产生fail-fast事件！ 结果说明 (01) FastFailTest中通过 new ThreadOne().start() 和 new ThreadTwo().start() 同时启动两个线程去操作list。 ThreadOne线程：向list中依次添加0,1,2,3,4,5。每添加一个数之后，就通过printAll()遍历整个list。 ThreadTwo线程：向list中依次添加10,11,12,13,14,15。每添加一个数之后，就通过printAll()遍历整个list。 (02) 当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出ConcurrentModificationException异常，产生fail-fast事件。 3. fail-fast解决办法fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。所以，本例中只需要将ArrayList替换成java.util.concurrent包下对应的类即可。即，将代码 private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();替换为 private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();则可以解决该办法。 4. fail-fast原理产生fail-fast事件，是通过抛出ConcurrentModificationException异常来触发的。那么，ArrayList是如何抛出ConcurrentModificationException异常的呢? 我们知道，ConcurrentModificationException是在操作Iterator时抛出的异常。我们先看看Iterator的源码。ArrayList的Iterator是在父类AbstractList.java中实现的。代码如下： package java.util; public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; { ... // AbstractList中唯一的属性 // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1 protected transient int modCount = 0; // 返回List对应迭代器。实际上，是返回Itr对象。 public Iterator&lt;E&gt; iterator() { return new Itr(); } // Itr是Iterator(迭代器)的实现类 private class Itr implements Iterator&lt;E&gt; { int cursor = 0; int lastRet = -1; // 修改数的记录值。 // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount； // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 checkForComodification(); try { E next = get(cursor); lastRet = cursor++; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } ... }从中，我们可以发现在调用 next() 和 remove()时，都会执行 checkForComodification()。若 “modCount 不等于 expectedModCount”，则抛出ConcurrentModificationException异常，产生fail-fast事件。 要搞明白 fail-fast机制，我们就要需要理解什么时候“modCount 不等于 expectedModCount”！从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改为不等于 modCount。所以，需要考证的就是modCount何时会被修改。 接下来，我们查看ArrayList的源码，来看看modCount是如何被修改的。 package java.util; public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable { ... // list中容量变化时，对应的同步函数 public void ensureCapacity(int minCapacity) { modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) { Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } } // 添加元素到队列最后 public boolean add(E e) { // 修改modCount ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; } // 添加元素到指定的位置 public void add(int index, E element) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot;+size); // 修改modCount ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } // 添加集合 public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray(); int numNew = a.length; // 修改modCount ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } // 删除指定位置的元素 public E remove(int index) { RangeCheck(index); // 修改modCount modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; } // 快速删除指定位置的元素 private void fastRemove(int index) { // 修改modCount modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work } // 清空集合 public void clear() { // 修改modCount modCount++; // Let gc do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; } ... }从中，我们发现：无论是add()、remove()，还是clear()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。 接下来，我们再系统的梳理一下fail-fast是怎么产生的。步骤如下：(01) 新建了一个ArrayList，名称为arrayList。(02) 向arrayList中添加内容。(03) 新建一个“线程a”，并在“线程a”中通过Iterator反复的读取arrayList的值。(04) 新建一个“线程b”，在“线程b”中删除arrayList中的一个“节点A”。(05) 这时，就会产生有趣的事件了。 在某一时刻，“线程a”创建了arrayList的Iterator。此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！“线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。 至此，我们就完全了解了fail-fast是如何产生的！即，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 5. 解决fail-fast的原理上面，说明了“解决fail-fast机制的办法”，也知道了“fail-fast产生的根本原因”。接下来，我们再进一步谈谈java.util.concurrent包中是如何解决fail-fast事件的。还是以和ArrayList对应的CopyOnWriteArrayList进行说明。我们先看看CopyOnWriteArrayList的源码： package java.util.concurrent; import java.util.*; import java.util.concurrent.locks.*; import sun.misc.Unsafe; public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable { ... // 返回集合对应的迭代器 public Iterator&lt;E&gt; iterator() { return new COWIterator&lt;E&gt;(getArray(), 0); } ... private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; { private final Object[] snapshot; private int cursor; private COWIterator(Object[] elements, int initialCursor) { cursor = initialCursor; // 新建COWIterator时，将集合中的元素保存到一个新的拷贝数组中。 // 这样，当原始集合的数据改变，拷贝数据中的值也不会变化。 snapshot = elements; } public boolean hasNext() { return cursor &lt; snapshot.length; } public boolean hasPrevious() { return cursor &gt; 0; } public E next() { if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; } public E previous() { if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; } public int nextIndex() { return cursor; } public int previousIndex() { return cursor-1; } public void remove() { throw new UnsupportedOperationException(); } public void set(E e) { throw new UnsupportedOperationException(); } public void add(E e) { throw new UnsupportedOperationException(); } } ... }从中，我们可以看出: (01) 和ArrayList继承于AbstractList不同，CopyOnWriteArrayList没有继承于AbstractList，它仅仅只是实现了List接口。(02) ArrayList的iterator()函数返回的Iterator是在AbstractList中实现的；而CopyOnWriteArrayList是自己实现Iterator。(03) ArrayList的Iterator实现类中调用next()时，会“调用checkForComodification()比较‘expectedModCount’和‘modCount’的大小”；但是，CopyOnWriteArrayList的Iterator实现类中，没有所谓的checkForComodification()，更不会抛出ConcurrentModificationException异常！ 更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/04/java/collection/2012-02-04-collection-04-fail-fast/"},{"title":"Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)","text":"前面，我们学完了List的全部内容(ArrayList, LinkedList, Vector, Stack)。现在，我们再回头看看总结一下List。内容包括： 目录第1部分 List概括第2部分 List使用场景第3部分 LinkedList和ArrayList性能差异分析第4部分 Vector和ArrayList比较 第1部分 List概括先回顾一下List的框架图 (01) List 是一个接口，它继承于Collection的接口。它代表着有序的队列。(02) AbstractList 是一个抽象类，它继承于AbstractCollection。AbstractList实现List接口中除size()、get(int location)之外的函数。(03) AbstractSequentialList 是一个抽象类，它继承于AbstractList。AbstractSequentialList 实现了“链表中，根据index索引值操作链表的全部函数”。(04) ArrayList, LinkedList, Vector, Stack是List的4个实现类。 ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率低。Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。 第2部分 List使用场景学东西的最终目的是为了能够理解、使用它。下面先概括的说明一下各个List的使用场景，后面再分析原因。 如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍。(01) 对于需要快速插入，删除元素，应该使用LinkedList。(02) 对于需要快速随机访问元素，应该使用ArrayList。(03) 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。 对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。 通过下面的测试程序，我们来验证上面的(01)和(02)结论。参考代码如下： import java.util.*; import java.lang.Class; /* * @desc 对比ArrayList和LinkedList的插入、随机读取效率、删除的效率 * * @author skywang */ public class ListCompareTest { private static final int COUNT = 100000; private static LinkedList linkedList = new LinkedList(); private static ArrayList arrayList = new ArrayList(); private static Vector vector = new Vector(); private static Stack stack = new Stack(); public static void main(String[] args) { // 换行符 System.out.println(); // 插入 insertByPosition(stack) ; insertByPosition(vector) ; insertByPosition(linkedList) ; insertByPosition(arrayList) ; // 换行符 System.out.println(); // 随机读取 readByPosition(stack); readByPosition(vector); readByPosition(linkedList); readByPosition(arrayList); // 换行符 System.out.println(); // 删除 deleteByPosition(stack); deleteByPosition(vector); deleteByPosition(linkedList); deleteByPosition(arrayList); } // 获取list的名称 private static String getListName(List list) { if (list instanceof LinkedList) { return &quot;LinkedList&quot;; } else if (list instanceof ArrayList) { return &quot;ArrayList&quot;; } else if (list instanceof Stack) { return &quot;Stack&quot;; } else if (list instanceof Vector) { return &quot;Vector&quot;; } else { return &quot;List&quot;; } } // 向list的指定位置插入COUNT个元素，并统计时间 private static void insertByPosition(List list) { long startTime = System.currentTimeMillis(); // 向list的位置0插入COUNT个数 for (int i=0; i&lt;COUNT; i++) list.add(0, i); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot; : insert &quot;+COUNT+&quot; elements into the 1st position use time：&quot; + interval+&quot; ms&quot;); } // 从list的指定位置删除COUNT个元素，并统计时间 private static void deleteByPosition(List list) { long startTime = System.currentTimeMillis(); // 删除list第一个位置元素 for (int i=0; i&lt;COUNT; i++) list.remove(0); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot; : delete &quot;+COUNT+&quot; elements from the 1st position use time：&quot; + interval+&quot; ms&quot;); } // 根据position，不断从list中读取元素，并统计时间 private static void readByPosition(List list) { long startTime = System.currentTimeMillis(); // 读取list元素 for (int i=0; i&lt;COUNT; i++) list.get(i); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + &quot; : read &quot;+COUNT+&quot; elements by position use time：&quot; + interval+&quot; ms&quot;); } }运行结果如下： Stack : insert 100000 elements into the 1st position use time：1640 ms Vector : insert 100000 elements into the 1st position use time：1607 ms LinkedList : insert 100000 elements into the 1st position use time：29 ms ArrayList : insert 100000 elements into the 1st position use time：1617 ms Stack : read 100000 elements by position use time：9 ms Vector : read 100000 elements by position use time：6 ms LinkedList : read 100000 elements by position use time：10809 ms ArrayList : read 100000 elements by position use time：5 ms Stack : delete 100000 elements from the 1st position use time：1916 ms Vector : delete 100000 elements from the 1st position use time：1910 ms LinkedList : delete 100000 elements from the 1st position use time：15 ms ArrayList : delete 100000 elements from the 1st position use time：1909 ms从中，我们可以发现：插入10万个元素，LinkedList所花时间最短：29ms。删除10万个元素，LinkedList所花时间最短：15ms。遍历10万个元素，LinkedList所花时间最长：10809 ms；而ArrayList、Stack和Vector则相差不多，都只用了几秒。 考虑到Vector是支持同步的，而Stack又是继承于Vector的；因此，得出结论：(01) 对于需要快速插入，删除元素，应该使用LinkedList。(02) 对于需要快速随机访问元素，应该使用ArrayList。(03) 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类。 第3部分 LinkedList和ArrayList性能差异分析下面我们看看为什么LinkedList中插入元素很快，而ArrayList中插入元素很慢！ LinkedList.java中向指定位置插入元素的代码如下： // 在index前添加节点，且节点的值为element public void add(int index, E element) { addBefore(element, (index==size ? header : entry(index))); } // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) { if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前向后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) { for (int i = 0; i &lt;= index; i++) e = e.next; } else { for (int i = size; i &gt; index; i--) e = e.previous; } return e; } // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) { // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); // 插入newEntry到链表中 newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; size++; modCount++; return newEntry; }从中，我们可以看出：通过add(int index, E element)向LinkedList插入元素时。先是在双向链表中找到要插入节点的位置index；找到之后，再插入一个新节点。双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。 接着，我们看看ArrayList.java中向指定位置插入元素的代码。如下： // 将e添加到ArrayList的指定位置 public void add(int index, E element) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot;+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; }ensureCapacity(size+1) 的作用是“确认ArrayList的容量，若容量不够，则增加容量。”真正耗时的操作是 System.arraycopy(elementData, index, elementData, index + 1, size - index); Sun JDK包的java/lang/System.java中的arraycopy()声明如下： public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);arraycopy()是个JNI函数，它是在JVM中实现的。sunJDK中看不到源码，不过可以在OpenJDK包中看到的源码。网上有对arraycopy()的分析说明，请参考：System.arraycopy源码分析实际上，我们只需要了解： System.arraycopy(elementData, index, elementData, index + 1, size - index); 会移动index之后所有元素即可。这就意味着，ArrayList的add(int index, E element)函数，会引起index之后所有元素的改变！ 通过上面的分析，我们就能理解为什么LinkedList中插入元素很快，而ArrayList中插入元素很慢。“删除元素”与“插入元素”的原理类似，这里就不再过多说明。 接下来，我们看看 “为什么LinkedList中随机访问很慢，而ArrayList中随机访问很快”。 先看看LinkedList随机访问的代码 // 返回LinkedList指定位置的元素 public E get(int index) { return entry(index).element; } // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) { if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) { for (int i = 0; i &lt;= index; i++) e = e.next; } else { for (int i = size; i &gt; index; i--) e = e.previous; } return e; }从中，我们可以看出：通过get(int index)获取LinkedList第index个元素时。先是在双向链表中找到要index位置的元素；找到之后再返回。双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。 下面看看ArrayList随机访问的代码 // 获取index位置的元素值 public E get(int index) { RangeCheck(index); return (E) elementData[index]; } private void RangeCheck(int index) { if (index &gt;= size) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot;+size); }从中，我们可以看出：通过get(int index)获取ArrayList第index个元素时。直接返回数组中index位置的元素，而不需要像LinkedList一样进行查找。 第4部分 Vector和ArrayList比较相同之处1 它们都是List 它们都继承于AbstractList，并且实现List接口。ArrayList和Vector的类定义如下： // ArrayList的定义 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable // Vector的定义 public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}2 它们都实现了RandomAccess和Cloneable接口 实现RandomAccess接口，意味着它们都支持快速随机访问；实现Cloneable接口，意味着它们能克隆自己。 3 它们都是通过数组实现的，本质上都是动态数组 ArrayList.java中定义数组elementData用于保存元素 // 保存ArrayList中数据的数组 private transient Object[] elementData; Vector.java中也定义了数组elementData用于保存元素 // 保存Vector中数据的数组 protected Object[] elementData;4 它们的默认数组容量是10 若创建ArrayList或Vector时，没指定容量大小；则使用默认容量大小10。 ArrayList的默认构造函数如下： // ArrayList构造函数。默认容量是10。 public ArrayList() { this(10); }Vector的默认构造函数如下： // Vector构造函数。默认容量是10。 public Vector() { this(10); } 5 它们都支持Iterator和listIterator遍历 它们都继承于AbstractList，而AbstractList中分别实现了 “iterator()接口返回Iterator迭代器” 和 “listIterator()返回ListIterator迭代器”。 不同之处1 线程安全性不一样 ArrayList是非线程安全；而Vector是线程安全的，它的函数都是synchronized的，即都是支持同步的。ArrayList适用于单线程，Vector适用于多线程。 2 对序列化支持不同 ArrayList支持序列化，而Vector不支持；即ArrayList有实现java.io.Serializable接口，而Vector没有实现该接口。 3 构造函数个数不同 ArrayList有3个构造函数，而Vector有4个构造函数。Vector除了包括和ArrayList类似的3个构造函数之外，另外的一个构造函数可以指定容量增加系数。 ArrayList的构造函数如下： // 默认构造函数 ArrayList() // capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。 ArrayList(int capacity) // 创建一个包含collection的ArrayList ArrayList(Collection&lt;? extends E&gt; collection) Vector的构造函数如下： // 默认构造函数 Vector() // capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。 Vector(int capacity) // 创建一个包含collection的Vector Vector(Collection&lt;? extends E&gt; collection) // capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。 Vector(int capacity, int capacityIncrement)4 容量增加方式不同 逐个添加元素时，若ArrayList容量不足时，“新的容量”=“(原始容量x3)/2 + 1”。而Vector的容量增长与“增长系数有关”，若指定了“增长系数”，且“增长系数有效(即，大于0)”；那么，每次容量不足时，“新的容量”=“原始容量+增长系数”。若增长系数无效(即，小于/等于0)，则“新的容量”=“原始容量 x 2”。 ArrayList中容量增长的主要函数如下： public void ensureCapacity(int minCapacity) { // 将“修改统计数”+1 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity &gt; oldCapacity) { Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); } }Vector中容量增长的主要函数如下： private void ensureCapacityHelper(int minCapacity) { int oldCapacity = elementData.length; // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。 // 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement // 否则，将容量增大一倍。 if (minCapacity &gt; oldCapacity) { Object[] oldData = elementData; int newCapacity = (capacityIncrement &gt; 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2); if (newCapacity &lt; minCapacity) { newCapacity = minCapacity; } elementData = Arrays.copyOf(elementData, newCapacity); } }5 对Enumeration的支持不同。Vector支持通过Enumeration去遍历，而List不支持 Vector中实现Enumeration的代码如下： public Enumeration&lt;E&gt; elements() { // 通过匿名类实现Enumeration return new Enumeration&lt;E&gt;() { int count = 0; // 是否存在下一个元素 public boolean hasMoreElements() { return count &lt; elementCount; } // 获取下一个元素 public E nextElement() { synchronized (Vector.this) { if (count &lt; elementCount) { return (E)elementData[count++]; } } throw new NoSuchElementException(&quot;Vector Enumeration&quot;); } }; }更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/08/java/collection/2012-02-08-collection-08-List/"},{"title":"Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例","text":"这一章，我们对HashSet进行学习。我们先对HashSet有个整体认识，然后再学习它的源码，最后再通过实例来学会使用HashSet。 目录第1部分 HashSet介绍第2部分 HashSet数据结构第3部分 HashSet源码解析(基于JDK1.6.0_45)第4部分 HashSet遍历方式第5部分 HashSet示例 第1部分 HashSet介绍HashSet 简介HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null 元素。HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问： Set s = Collections.synchronizedSet(new HashSet(...));HashSet通过iterator()返回的迭代器是fail-fast的。 HashSet的构造函数// 默认构造函数 public HashSet() // 带集合的构造函数 public HashSet(Collection&lt;? extends E&gt; c) // 指定HashSet初始容量和加载因子的构造函数 public HashSet(int initialCapacity, float loadFactor) // 指定HashSet初始容量的构造函数 public HashSet(int initialCapacity) // 指定HashSet初始容量和加载因子的构造函数,dummy没有任何作用 HashSet(int initialCapacity, float loadFactor, boolean dummy) HashSet的主要APIboolean add(E object) void clear() Object clone() boolean contains(Object object) boolean isEmpty() Iterator&lt;E&gt; iterator() boolean remove(Object object) int size() 第2部分 HashSet数据结构HashSet的继承关系如下： java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractSet&lt;E&gt; ↳ java.util.HashSet&lt;E&gt;public class HashSet extends AbstractSet implements Set, Cloneable, java.io.Serializable { } HashSet与Map关系如下图： 从图中可以看出：(01) HashSet继承于AbstractSet，并且实现了Set接口。(02) HashSet的本质是一个”没有重复元素”的集合，它是通过HashMap实现的。HashSet中含有一个”HashMap类型的成员变量”map，HashSet的操作函数，实际上都是通过map实现的。 第3部分 HashSet源码解析(基于JDK1.6.0_45)为了更了解HashSet的原理，下面对HashSet源码代码作出分析。 package java.util; public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable { static final long serialVersionUID = -5024744406713321676L; // HashSet是通过map(HashMap对象)保存内容的 private transient HashMap&lt;E,Object&gt; map; // PRESENT是向map中插入key-value对应的value // 因为HashSet中只需要用到key，而HashMap是key-value键值对； // 所以，向map中添加键值对时，键值对的值固定是PRESENT private static final Object PRESENT = new Object(); // 默认构造函数 public HashSet() { // 调用HashMap的默认构造函数，创建map map = new HashMap&lt;E,Object&gt;(); } // 带集合的构造函数 public HashSet(Collection&lt;? extends E&gt; c) { // 创建map。 // 为什么要调用Math.max((int) (c.size()/.75f) + 1, 16)，从 (c.size()/.75f) + 1 和 16 中选择一个比较大的树呢？ // 首先，说明(c.size()/.75f) + 1 // 因为从HashMap的效率(时间成本和空间成本)考虑，HashMap的加载因子是0.75。 // 当HashMap的“阈值”(阈值=HashMap总的大小*加载因子) &lt; “HashMap实际大小”时， // 就需要将HashMap的容量翻倍。 // 所以，(c.size()/.75f) + 1 计算出来的正好是总的空间大小。 // 接下来，说明为什么是 16 。 // HashMap的总的大小，必须是2的指数倍。若创建HashMap时，指定的大小不是2的指数倍； // HashMap的构造函数中也会重新计算，找出比“指定大小”大的最小的2的指数倍的数。 // 所以，这里指定为16是从性能考虑。避免重复计算。 map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); // 将集合(c)中的全部元素添加到HashSet中 addAll(c); } // 指定HashSet初始容量和加载因子的构造函数 public HashSet(int initialCapacity, float loadFactor) { map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); } // 指定HashSet初始容量的构造函数 public HashSet(int initialCapacity) { map = new HashMap&lt;E,Object&gt;(initialCapacity); } HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); } // 返回HashSet的迭代器 public Iterator&lt;E&gt; iterator() { // 实际上返回的是HashMap的“key集合的迭代器” return map.keySet().iterator(); } public int size() { return map.size(); } public boolean isEmpty() { return map.isEmpty(); } public boolean contains(Object o) { return map.containsKey(o); } // 将元素(e)添加到HashSet中 public boolean add(E e) { return map.put(e, PRESENT)==null; } // 删除HashSet中的元素(o) public boolean remove(Object o) { return map.remove(o)==PRESENT; } public void clear() { map.clear(); } // 克隆一个HashSet，并返回Object对象 public Object clone() { try { HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; } catch (CloneNotSupportedException e) { throw new InternalError(); } } // java.io.Serializable的写入函数 // 将HashSet的“总的容量，加载因子，实际容量，所有的元素”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out any hidden serialization magic s.defaultWriteObject(); // Write out HashMap capacity and load factor s.writeInt(map.capacity()); s.writeFloat(map.loadFactor()); // Write out size s.writeInt(map.size()); // Write out all elements in the proper order. for (Iterator i=map.keySet().iterator(); i.hasNext(); ) s.writeObject(i.next()); } // java.io.Serializable的读取函数 // 将HashSet的“总的容量，加载因子，实际容量，所有的元素”依次读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // Read in HashMap capacity and load factor and create backing HashMap int capacity = s.readInt(); float loadFactor = s.readFloat(); map = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) : new HashMap&lt;E,Object&gt;(capacity, loadFactor)); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) { E e = (E) s.readObject(); map.put(e, PRESENT); } } }说明： HashSet的代码实际上非常简单，通过上面的注释应该很能够看懂。它是通过HashMap实现的，若对HashSet的理解有困难，建议先学习以下HashMap；学完HashMap之后，在学习HashSet就非常容易了。 第4部分 HashSet遍历方式4.1 通过Iterator遍历HashSet第一步：根据iterator()获取HashSet的迭代器。 第二步：遍历迭代器获取各个元素。 // 假设set是HashSet对象 for(Iterator iterator = set.iterator(); iterator.hasNext(); ) { iterator.next(); } 4.2 通过for-each遍历HashSet第一步：根据toArray()获取HashSet的元素集合对应的数组。 第二步：遍历数组，获取各个元素。 // 假设set是HashSet对象，并且set中元素是String类型 String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(&quot;for each : %s\\n&quot;, str);HashSet的遍历测试程序如下： import java.util.Random; import java.util.Iterator; import java.util.HashSet; /* * @desc 介绍HashSet遍历方法 * * @author skywang */ public class HashSetIteratorTest { public static void main(String[] args) { // 新建HashSet HashSet set = new HashSet(); // 添加元素 到HashSet中 for (int i=0; i&lt;5; i++) set.add(&quot;&quot;+i); // 通过Iterator遍历HashSet iteratorHashSet(set) ; // 通过for-each遍历HashSet foreachHashSet(set); } /* * 通过Iterator遍历HashSet。推荐方式 */ private static void iteratorHashSet(HashSet set) { for(Iterator iterator = set.iterator(); iterator.hasNext(); ) { System.out.printf(&quot;iterator : %s\\n&quot;, iterator.next()); } } /* * 通过for-each遍历HashSet。不推荐！此方法需要先将Set转换为数组 */ private static void foreachHashSet(HashSet set) { String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(&quot;for each : %s\\n&quot;, str); } }运行结果： iterator : 3iterator : 2iterator : 1iterator : 0iterator : 4for each : 3for each : 2for each : 1for each : 0for each : 4 第5部分 HashSet示例下面我们通过实例学习如何使用HashSet import java.util.Iterator;import java.util.HashSet; /* @desc HashSet常用API的使用。 @author skywang /public class HashSetTest { public static void main(String[] args) { // HashSet常用API testHashSetAPIs() ; } /* HashSet除了iterator()和add()之外的其它常用API /private static void testHashSetAPIs() { // 新建HashSet HashSet set = new HashSet(); // 将元素添加到Set中 set.add(“a”); set.add(“b”); set.add(“c”); set.add(“d”); set.add(“e”); // 打印HashSet的实际大小 System.out.printf(“size : %d\\n”, set.size()); // 判断HashSet是否包含某个值 System.out.printf(“HashSet contains a :%s\\n”, set.contains(“a”)); System.out.printf(“HashSet contains g :%s\\n”, set.contains(“g”)); // 删除HashSet中的“e” set.remove(“e”); // 将Set转换为数组 String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(&quot;for each : %s\\n&quot;, str); // 新建一个包含b、c、f的HashSet HashSet otherset = new HashSet(); otherset.add(“b”); otherset.add(“c”); otherset.add(“f”); // 克隆一个removeset，内容和set一模一样 HashSet removeset = (HashSet)set.clone(); // 删除“removeset中，属于otherSet的元素” removeset.removeAll(otherset); // 打印removeset System.out.printf(“removeset : %s\\n”, removeset); // 克隆一个retainset，内容和set一模一样 HashSet retainset = (HashSet)set.clone(); // 保留“retainset中，属于otherSet的元素” retainset.retainAll(otherset); // 打印retainset System.out.printf(“retainset : %s\\n”, retainset); // 遍历HashSet for(Iterator iterator = set.iterator(); iterator.hasNext(); ) System.out.printf(&quot;iterator : %s\\n&quot;, iterator.next()); // 清空HashSet set.clear(); // 输出HashSet是否为空 System.out.printf(&quot;%s\\n&quot;, set.isEmpty()?&quot;set is empty&quot;:&quot;set is not empty&quot;); }} 运行结果： size : 5 HashSet contains a :true HashSet contains g :false for each : d for each : b for each : c for each : a removeset : [d, a] retainset : [b, c] iterator : d iterator : b iterator : c iterator : a set is empty更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/16/java/collection/2012-02-16-collection-16-hashset/"},{"title":"Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例","text":"这一章，我们对TreeSet进行学习。我们先对TreeSet有个整体认识，然后再学习它的源码，最后再通过实例来学会使用TreeSet。 目录第1部分 TreeSet介绍第2部分 TreeSet数据结构第3部分 TreeSet源码解析(基于JDK1.6.0_45)第4部分 TreeSet遍历方式第5部分 TreeSet示例 转载请注明出处：http://www.cnblogs.com/skywang12345/admin/EditPosts.aspx?postid=3311268 第1部分 TreeSet介绍TreeSet简介TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet, Cloneable, java.io.Serializable接口。TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。TreeSet 实现了Cloneable接口，意味着它能被克隆。TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。 TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。 TreeSet的构造函数// 默认构造函数。使用该构造函数，TreeSet中的元素按照自然排序进行排列。 TreeSet() // 创建的TreeSet包含collection TreeSet(Collection&lt;? extends E&gt; collection) // 指定TreeSet的比较器 TreeSet(Comparator&lt;? super E&gt; comparator) // 创建的TreeSet包含set TreeSet(SortedSet&lt;E&gt; set)TreeSet的API boolean add(E object) boolean addAll(Collection&lt;? extends E&gt; collection) void clear() Object clone() boolean contains(Object object) E first() boolean isEmpty() E last() E pollFirst() E pollLast() E lower(E e) E floor(E e) E ceiling(E e) E higher(E e) boolean remove(Object object) int size() Comparator&lt;? super E&gt; comparator() Iterator&lt;E&gt; iterator() Iterator&lt;E&gt; descendingIterator() SortedSet&lt;E&gt; headSet(E end) NavigableSet&lt;E&gt; descendingSet() NavigableSet&lt;E&gt; headSet(E end, boolean endInclusive) SortedSet&lt;E&gt; subSet(E start, E end) NavigableSet&lt;E&gt; subSet(E start, boolean startInclusive, E end, boolean endInclusive) NavigableSet&lt;E&gt; tailSet(E start, boolean startInclusive) SortedSet&lt;E&gt; tailSet(E start)说明： (01) TreeSet是有序的Set集合，因此支持add、remove、get等方法。(02) 和NavigableSet一样，TreeSet的导航方法大致可以区分为两类，一类时提供元素项的导航方法，返回某个元素；另一类时提供集合的导航方法，返回某个集合。lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。 第2部分 TreeSet数据结构TreeSet的继承关系 java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractSet&lt;E&gt; ↳ java.util.TreeSet&lt;E&gt;TreeSet的声明 public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable{}TreeSet与Collection关系如下图： 从图中可以看出：(01) TreeSet继承于AbstractSet，并且实现了NavigableSet接口。(02) TreeSet的本质是一个”有序的，并且没有重复元素”的集合，它是通过TreeMap实现的。TreeSet中含有一个”NavigableMap类型的成员变量”m，而m实际上是”TreeMap的实例”。 第3部分 TreeSet源码解析(基于JDK1.6.0_45)为了更了解TreeSet的原理，下面对TreeSet源码代码作出分析。 package java.util; public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable { // NavigableMap对象 private transient NavigableMap&lt;E,Object&gt; m; // TreeSet是通过TreeMap实现的， // PRESENT是键-值对中的值。 private static final Object PRESENT = new Object(); // 不带参数的构造函数。创建一个空的TreeMap public TreeSet() { this(new TreeMap&lt;E,Object&gt;()); } // 将TreeMap赋值给 &quot;NavigableMap对象m&quot; TreeSet(NavigableMap&lt;E,Object&gt; m) { this.m = m; } // 带比较器的构造函数。 public TreeSet(Comparator&lt;? super E&gt; comparator) { this(new TreeMap&lt;E,Object&gt;(comparator)); } // 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中 public TreeSet(Collection&lt;? extends E&gt; c) { this(); // 将集合c中的元素全部添加到TreeSet中 addAll(c); } // 创建TreeSet，并将s中的全部元素都添加到TreeSet中 public TreeSet(SortedSet&lt;E&gt; s) { this(s.comparator()); addAll(s); } // 返回TreeSet的顺序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; iterator() { return m.navigableKeySet().iterator(); } // 返回TreeSet的逆序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; descendingIterator() { return m.descendingKeySet().iterator(); } // 返回TreeSet的大小 public int size() { return m.size(); } // 返回TreeSet是否为空 public boolean isEmpty() { return m.isEmpty(); } // 返回TreeSet是否包含对象(o) public boolean contains(Object o) { return m.containsKey(o); } // 添加e到TreeSet中 public boolean add(E e) { return m.put(e, PRESENT)==null; } // 删除TreeSet中的对象o public boolean remove(Object o) { return m.remove(o)==PRESENT; } // 清空TreeSet public void clear() { m.clear(); } // 将集合c中的全部元素添加到TreeSet中 public boolean addAll(Collection&lt;? extends E&gt; c) { // Use linear-time version if applicable if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp; c instanceof SortedSet &amp;&amp; m instanceof TreeMap) { SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c; TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m; Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator(); Comparator&lt;? super E&gt; mc = map.comparator(); if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) { map.addAllForTreeSet(set, PRESENT); return true; } } return super.addAll(c); } // 返回子Set，实际上是通过TreeMap的subMap()实现的。 public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) { return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); } // 返回Set的头部，范围是：从头部到toElement。 // inclusive是是否包含toElement的标志 public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) { return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); } // 返回Set的尾部，范围是：从fromElement到结尾。 // inclusive是是否包含fromElement的标志 public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) { return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); } // 返回子Set。范围是：从fromElement(包括)到toElement(不包括)。 public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) { return subSet(fromElement, true, toElement, false); } // 返回Set的头部，范围是：从头部到toElement(不包括)。 public SortedSet&lt;E&gt; headSet(E toElement) { return headSet(toElement, false); } // 返回Set的尾部，范围是：从fromElement到结尾(不包括)。 public SortedSet&lt;E&gt; tailSet(E fromElement) { return tailSet(fromElement, true); } // 返回Set的比较器 public Comparator&lt;? super E&gt; comparator() { return m.comparator(); } // 返回Set的第一个元素 public E first() { return m.firstKey(); } // 返回Set的最后一个元素 public E first() { public E last() { return m.lastKey(); } // 返回Set中小于e的最大元素 public E lower(E e) { return m.lowerKey(e); } // 返回Set中小于/等于e的最大元素 public E floor(E e) { return m.floorKey(e); } // 返回Set中大于/等于e的最小元素 public E ceiling(E e) { return m.ceilingKey(e); } // 返回Set中大于e的最小元素 public E higher(E e) { return m.higherKey(e); } // 获取第一个元素，并将该元素从TreeMap中删除。 public E pollFirst() { Map.Entry&lt;E,?&gt; e = m.pollFirstEntry(); return (e == null)? null : e.getKey(); } // 获取最后一个元素，并将该元素从TreeMap中删除。 public E pollLast() { Map.Entry&lt;E,?&gt; e = m.pollLastEntry(); return (e == null)? null : e.getKey(); } // 克隆一个TreeSet，并返回Object对象 public Object clone() { TreeSet&lt;E&gt; clone = null; try { clone = (TreeSet&lt;E&gt;) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(); } clone.m = new TreeMap&lt;E,Object&gt;(m); return clone; } // java.io.Serializable的写入函数 // 将TreeSet的“比较器、容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { s.defaultWriteObject(); // 写入比较器 s.writeObject(m.comparator()); // 写入容量 s.writeInt(m.size()); // 写入“TreeSet中的每一个元素” for (Iterator i=m.keySet().iterator(); i.hasNext(); ) s.writeObject(i.next()); } // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeSet的“比较器、容量、所有的元素值”依次读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden stuff s.defaultReadObject(); // 从输入流中读取TreeSet的“比较器” Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject(); TreeMap&lt;E,Object&gt; tm; if (c==null) tm = new TreeMap&lt;E,Object&gt;(); else tm = new TreeMap&lt;E,Object&gt;(c); m = tm; // 从输入流中读取TreeSet的“容量” int size = s.readInt(); // 从输入流中读取TreeSet的“全部元素” tm.readTreeSet(size, s, PRESENT); } // TreeSet的序列版本号 private static final long serialVersionUID = -2479143000061671589L; }总结： (01) TreeSet实际上是TreeMap实现的。当我们构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。(02) TreeSet是非线程安全的。(03) TreeSet实现java.io.Serializable的方式。当写入到输出流时，依次写入“比较器、容量、全部元素”；当读出输入流时，再依次读取。 第4部分 TreeSet遍历方式4.1 Iterator顺序遍历for(Iterator iter = set.iterator(); iter.hasNext(); ) { iter.next(); } 4.2 Iterator顺序遍历// 假设set是TreeSet对象 for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) { iter.next(); }4.3 for-each遍历HashSet// 假设set是TreeSet对象，并且set中元素是String类型 String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(&quot;for each : %s\\n&quot;, str);TreeSet不支持快速随机遍历，只能通过迭代器进行遍历！ TreeSet遍历测试程序如下： import java.util.*; /** * @desc TreeSet的遍历程序 * * @author skywang * @email kuiwu-wang@163.com */ public class TreeSetIteratorTest { public static void main(String[] args) { TreeSet set = new TreeSet(); set.add(&quot;aaa&quot;); set.add(&quot;aaa&quot;); set.add(&quot;bbb&quot;); set.add(&quot;eee&quot;); set.add(&quot;ddd&quot;); set.add(&quot;ccc&quot;); // 顺序遍历TreeSet ascIteratorThroughIterator(set) ; // 逆序遍历TreeSet descIteratorThroughIterator(set); // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组 foreachTreeSet(set); } // 顺序遍历TreeSet public static void ascIteratorThroughIterator(TreeSet set) { System.out.print(&quot;\\n ---- Ascend Iterator ----\\n&quot;); for(Iterator iter = set.iterator(); iter.hasNext(); ) { System.out.printf(&quot;asc : %s\\n&quot;, iter.next()); } } // 逆序遍历TreeSet public static void descIteratorThroughIterator(TreeSet set) { System.out.printf(&quot;\\n ---- Descend Iterator ----\\n&quot;); for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) System.out.printf(&quot;desc : %s\\n&quot;, (String)iter.next()); } // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组 private static void foreachTreeSet(TreeSet set) { System.out.printf(&quot;\\n ---- For-each ----\\n&quot;); String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(&quot;for each : %s\\n&quot;, str); } }运行结果： ---- Ascend Iterator ---- asc : aaa asc : bbb asc : ccc asc : ddd asc : eee ---- Descend Iterator ---- desc : eee desc : ddd desc : ccc desc : bbb desc : aaa ---- For-each ---- for each : aaa for each : bbb for each : ccc for each : ddd for each : eee 第5部分 TreeSet示例下面通过实例学习如何使用TreeSet import java.util.*; /** * @desc TreeSet的API测试 * * @author skywang * @email kuiwu-wang@163.com */ public class TreeSetTest { public static void main(String[] args) { testTreeSetAPIs(); } // 测试TreeSet的api public static void testTreeSetAPIs() { String val; // 新建TreeSet TreeSet tSet = new TreeSet(); // 将元素添加到TreeSet中 tSet.add(&quot;aaa&quot;); // Set中不允许重复元素，所以只会保存一个“aaa” tSet.add(&quot;aaa&quot;); tSet.add(&quot;bbb&quot;); tSet.add(&quot;eee&quot;); tSet.add(&quot;ddd&quot;); tSet.add(&quot;ccc&quot;); System.out.println(&quot;TreeSet:&quot;+tSet); // 打印TreeSet的实际大小 System.out.printf(&quot;size : %d\\n&quot;, tSet.size()); // 导航方法 // floor(小于、等于) System.out.printf(&quot;floor bbb: %s\\n&quot;, tSet.floor(&quot;bbb&quot;)); // lower(小于) System.out.printf(&quot;lower bbb: %s\\n&quot;, tSet.lower(&quot;bbb&quot;)); // ceiling(大于、等于) System.out.printf(&quot;ceiling bbb: %s\\n&quot;, tSet.ceiling(&quot;bbb&quot;)); System.out.printf(&quot;ceiling eee: %s\\n&quot;, tSet.ceiling(&quot;eee&quot;)); // ceiling(大于) System.out.printf(&quot;higher bbb: %s\\n&quot;, tSet.higher(&quot;bbb&quot;)); // subSet() System.out.printf(&quot;subSet(aaa, true, ccc, true): %s\\n&quot;, tSet.subSet(&quot;aaa&quot;, true, &quot;ccc&quot;, true)); System.out.printf(&quot;subSet(aaa, true, ccc, false): %s\\n&quot;, tSet.subSet(&quot;aaa&quot;, true, &quot;ccc&quot;, false)); System.out.printf(&quot;subSet(aaa, false, ccc, true): %s\\n&quot;, tSet.subSet(&quot;aaa&quot;, false, &quot;ccc&quot;, true)); System.out.printf(&quot;subSet(aaa, false, ccc, false): %s\\n&quot;, tSet.subSet(&quot;aaa&quot;, false, &quot;ccc&quot;, false)); // headSet() System.out.printf(&quot;headSet(ccc, true): %s\\n&quot;, tSet.headSet(&quot;ccc&quot;, true)); System.out.printf(&quot;headSet(ccc, false): %s\\n&quot;, tSet.headSet(&quot;ccc&quot;, false)); // tailSet() System.out.printf(&quot;tailSet(ccc, true): %s\\n&quot;, tSet.tailSet(&quot;ccc&quot;, true)); System.out.printf(&quot;tailSet(ccc, false): %s\\n&quot;, tSet.tailSet(&quot;ccc&quot;, false)); // 删除“ccc” tSet.remove(&quot;ccc&quot;); // 将Set转换为数组 String[] arr = (String[])tSet.toArray(new String[0]); for (String str:arr) System.out.printf(&quot;for each : %s\\n&quot;, str); // 打印TreeSet System.out.printf(&quot;TreeSet:%s\\n&quot;, tSet); // 遍历TreeSet for(Iterator iter = tSet.iterator(); iter.hasNext(); ) { System.out.printf(&quot;iter : %s\\n&quot;, iter.next()); } // 删除并返回第一个元素 val = (String)tSet.pollFirst(); System.out.printf(&quot;pollFirst=%s, set=%s\\n&quot;, val, tSet); // 删除并返回最后一个元素 val = (String)tSet.pollLast(); System.out.printf(&quot;pollLast=%s, set=%s\\n&quot;, val, tSet); // 清空HashSet tSet.clear(); // 输出HashSet是否为空 System.out.printf(&quot;%s\\n&quot;, tSet.isEmpty()?&quot;set is empty&quot;:&quot;set is not empty&quot;); } }运行结果： TreeSet:[aaa, bbb, ccc, ddd, eee] size : 5 floor bbb: bbb lower bbb: aaa ceiling bbb: bbb ceiling eee: eee higher bbb: ccc subSet(aaa, true, ccc, true): [aaa, bbb, ccc] subSet(aaa, true, ccc, false): [aaa, bbb] subSet(aaa, false, ccc, true): [bbb, ccc] subSet(aaa, false, ccc, false): [bbb] headSet(ccc, true): [aaa, bbb, ccc] headSet(ccc, false): [aaa, bbb] tailSet(ccc, true): [ccc, ddd, eee] tailSet(ccc, false): [ddd, eee] for each : aaa for each : bbb for each : ddd for each : eee TreeSet:[aaa, bbb, ddd, eee] iter : aaa iter : bbb iter : ddd iter : eee pollFirst=aaa, set=[bbb, ddd, eee] pollLast=eee, set=[bbb, ddd] set is empty更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/17/java/collection/2012-02-17-collection-17-treeset/"},{"title":"Java 集合系列扩展(二) hashCode()和equals()的若干问题解答","text":"本章的内容主要解决下面几个问题：(01) equals() 的作用是什么？(02) equals() 与 == 的区别是什么？(03) hashCode() 的作用是什么？(04) hashCode() 和 equals() 之间有什么联系？ 目录第1部分 equals() 的作用第2部分 equals() 与 == 的区别是什么？第3部分 hashCode() 的作用第4部分 hashCode() 和 equals() 的关系 第1部分 equals() 的作用equals() 的作用是 用来判断两个对象是否相等。 equals() 定义在JDK的Object.java中。通过判断两个对象的地址是否相等(即，是否是同一个对象)来区分它们是否相等。源码如下： public boolean equals(Object obj) { return (this == obj); }既然Object.java中定义了equals()方法，这就意味着所有的Java类都实现了equals()方法，所有的类都可以通过equals()去比较两个对象是否相等。 但是，我们已经说过，使用默认的“equals()”方法，等价于“==”方法。因此，我们通常会重写equals()方法：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。 下面根据“类是否覆盖equals()方法”，将它分为2类。 (01) 若某个类没有覆盖equals()方法，当它的通过equals()比较两个对象时，实际上是比较两个对象是不是同一个对象。这时，等价于通过“==”去比较这两个对象。 (02) 我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象是否相等。通常的做法是：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。 下面，举例对上面的2种情况进行说明。 1. “没有覆盖equals()方法”的情况代码如下 (EqualsTest1.java)： import java.util.*; import java.lang.Comparable; /** * @desc equals()的测试程序。 * * @author skywang * @emai kuiwu-wang@163.com */ public class EqualsTest1{ public static void main(String[] args) { // 新建2个相同内容的Person对象， // 再用equals比较它们是否相等 Person p1 = new Person(&quot;eee&quot;, 100); Person p2 = new Person(&quot;eee&quot;, 100); System.out.printf(&quot;%s\\n&quot;, p1.equals(p2)); } /** * @desc Person类。 */ private static class Person { int age; String name; public Person(String name, int age) { this.name = name; this.age = age; } public String toString() { return name + &quot; - &quot; +age; } } }运行结果： false结果分析 我们通过 p1.equals(p2) 来“比较p1和p2是否相等时”。实际上，调用的Object.java的equals()方法，即调用的 (p1==p2) 。它是比较“p1和p2是否是同一个对象”。而由 p1 和 p2 的定义可知，它们虽然内容相同；但它们是两个不同的对象！因此，返回结果是false。 2. “覆盖equals()方法”的情况我们修改上面的EqualsTest1.java：覆盖equals()方法。 代码如下 (EqualsTest2.java)： import java.util.*; import java.lang.Comparable; /** * @desc equals()的测试程序。 * * @author skywang * @emai kuiwu-wang@163.com */ public class EqualsTest2{ public static void main(String[] args) { // 新建2个相同内容的Person对象， // 再用equals比较它们是否相等 Person p1 = new Person(&quot;eee&quot;, 100); Person p2 = new Person(&quot;eee&quot;, 100); System.out.printf(&quot;%s\\n&quot;, p1.equals(p2)); } /** * @desc Person类。 */ private static class Person { int age; String name; public Person(String name, int age) { this.name = name; this.age = age; } public String toString() { return name + &quot; - &quot; +age; } /** * @desc 覆盖equals方法 */ @Override public boolean equals(Object obj){ if(obj == null){ return false; } //如果是同一个对象返回true，反之返回false if(this == obj){ return true; } //判断是否类型相同 if(this.getClass() != obj.getClass()){ return false; } Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; } } }运行结果： true结果分析： 我们在EqualsTest2.java 中重写了Person的equals()函数：当两个Person对象的 name 和 age 都相等，则返回true。因此，运行结果返回true。 讲到这里，顺便说一下java对equals()的要求。有以下几点： 对称性：如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”。 反射性：x.equals(x)必须返回是”true”。 类推性：如果x.equals(y)返回是”true”，而且y.equals(z)返回是”true”，那么z.equals(x)也应该返回是”true”。 一致性：如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true”。 非空性，x.equals(null)，永远返回是”false”；x.equals(和x不同类型的对象)永远返回是”false”。 现在，再回顾一下equals()的作用：判断两个对象是否相等。当我们重写equals()的时候，可千万不好将它的作用给改变了！ 第2部分 equals() 与 == 的区别是什么？== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。 equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第1部分已详细介绍过)：&nbsp;&nbsp;&nbsp;&nbsp; 情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。&nbsp;&nbsp;&nbsp;&nbsp; 情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。 下面，通过示例比较它们的区别。 代码如下： import java.util.*; import java.lang.Comparable; /** * @desc equals()的测试程序。 * * @author skywang * @emai kuiwu-wang@163.com */ public class EqualsTest3{ public static void main(String[] args) { // 新建2个相同内容的Person对象， // 再用equals比较它们是否相等 Person p1 = new Person(&quot;eee&quot;, 100); Person p2 = new Person(&quot;eee&quot;, 100); System.out.printf(&quot;p1.equals(p2) : %s\\n&quot;, p1.equals(p2)); System.out.printf(&quot;p1==p2 : %s\\n&quot;, p1==p2); } /** * @desc Person类。 */ private static class Person { int age; String name; public Person(String name, int age) { this.name = name; this.age = age; } public String toString() { return name + &quot; - &quot; +age; } /** * @desc 覆盖equals方法 */ @Override public boolean equals(Object obj){ if(obj == null){ return false; } //如果是同一个对象返回true，反之返回false if(this == obj){ return true; } //判断是否类型相同 if(this.getClass() != obj.getClass()){ return false; } Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; } } }运行结果： p1.equals(p2) : true p1==p2 : false结果分析： 在EqualsTest3.java 中：(01) p1.equals(p2)&nbsp;&nbsp;&nbsp;&nbsp; 这是判断p1和p2的内容是否相等。因为Person覆盖equals()方法，而这个equals()是用来判断p1和p2的内容是否相等，恰恰p1和p2的内容又相等；因此，返回true。(02) p1==p2&nbsp;&nbsp;&nbsp;&nbsp; 这是判断p1和p2是否是同一个对象。由于它们是各自新建的两个Person对象；因此，返回false。 第3部分 hashCode() 的作用hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。&nbsp;&nbsp;&nbsp;&nbsp; 虽然，每个Java类都包含hashCode() 函数。但是，仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，该类的hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置；其它情况下(例如，创建类的单个对象，或者创建类的对象数组等等)，类的hashCode() 没有作用。&nbsp;&nbsp;&nbsp;&nbsp; 上面的散列表，指的是：Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。 也就是说：hashCode() 在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 OK！至此，我们搞清楚了：hashCode()的作用是获取散列码。但是，散列码是用来干什么的呢？为什么散列表需要散列码呢？要解决这些问题，就需要理解散列表！关于散列表的内容，非三言两语道的明白；大家可以通过下面几篇文章来学习：转载: 散列表(Hash Table)从理论到实用(上)转载: 散列表(Hash Table)从理论到实用(中)转载: 散列表(Hash Table)从理论到实用(下) 为了能理解后面的内容，这里简单的介绍一下散列码的作用。 我们都知道，散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！散列表的本质是通过数组实现的。当我们要获取散列表中的某个“值”时，实际上是要获取数组中的某个位置的元素。而数组的位置，就是通过“键”来获取的；更进一步说，数组的位置，是通过“键”对应的散列码计算得到的。 下面，我们以HashSet为例，来深入说明hashCode()的作用。 假设，HashSet中已经有1000个元素。当插入第1001个元素时，需要怎么处理？因为HashSet是Set集合，它允许有重复元素。“将第1001个元素逐个的和前面1000个元素进行比较”？显然，这个效率是相等低下的。散列表很好的解决了这个问题，它根据元素的散列码计算出元素在散列表中的位置，然后将元素插入该位置即可。对于相同的元素，自然是只保存了一个。由此可知，若两个元素相等，它们的散列码一定相等；但反过来确不一定。在散列表中，&nbsp;&nbsp;&nbsp;&nbsp; 1、如果两个对象相等，那么它们的hashCode()值一定要相同；&nbsp;&nbsp;&nbsp;&nbsp; 2、如果两个对象hashCode()相等，它们并不一定相等。注意：这是在散列表中的情况。在非散列表中一定如此！ 对“hashCode()的作用”就谈这么多。 第4部分 hashCode() 和 equals() 的关系接下面，我们讨论另外一个话题。网上很多文章将 hashCode() 和 equals 关联起来，有的讲的不透彻，有误导读者的嫌疑。在这里，我自己梳理了一下 “hashCode() 和 equals()的关系”。 我们以“类的用途”来将“hashCode() 和 equals()的关系”分2种情况来说明。 1. 第一种 不会创建“类对应的散列表” 这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。 在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。 下面，我们通过示例查看类的两个对象相等 以及 不等时hashCode()的取值。 源码如下 (NormalHashCodeTest.java)： import java.util.*; import java.lang.Comparable; /** * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。 * * @author skywang * @emai kuiwu-wang@163.com */ public class NormalHashCodeTest{ public static void main(String[] args) { // 新建2个相同内容的Person对象， // 再用equals比较它们是否相等 Person p1 = new Person(&quot;eee&quot;, 100); Person p2 = new Person(&quot;eee&quot;, 100); Person p3 = new Person(&quot;aaa&quot;, 200); System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode()); System.out.printf(&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\\n&quot;, p1.equals(p3), p1.hashCode(), p3.hashCode()); } /** * @desc Person类。 */ private static class Person { int age; String name; public Person(String name, int age) { this.name = name; this.age = age; } public String toString() { return name + &quot; - &quot; +age; } /** * @desc 覆盖equals方法 */ public boolean equals(Object obj){ if(obj == null){ return false; } //如果是同一个对象返回true，反之返回false if(this == obj){ return true; } //判断是否类型相同 if(this.getClass() != obj.getClass()){ return false; } Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; } } }运行结果： p1.equals(p2) : true; p1(1169863946) p2(1901116749) p1.equals(p3) : false; p1(1169863946) p3(2131949076)从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。 2. 第二种 会创建“类对应的散列表”这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。 在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：1)、如果两个对象相等，那么它们的hashCode()值一定相同。&nbsp;&nbsp;&nbsp;&nbsp; 这里的相等是指，通过equals()比较两个对象时返回true。2)、如果两个对象hashCode()相等，它们并不一定相等。&nbsp;&nbsp;&nbsp;&nbsp; 因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。 此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。例如，创建Person类的HashSet集合，必须同时覆盖Person类的equals() 和 hashCode()方法。&nbsp;&nbsp;&nbsp;&nbsp; 如果单单只是覆盖equals()方法。我们会发现，equals()方法没有达到我们想要的效果。 参考代码 (ConflictHashCodeTest1.java)： import java.util.*; import java.lang.Comparable; /** * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。 * * @author skywang * @emai kuiwu-wang@163.com */ public class ConflictHashCodeTest1{ public static void main(String[] args) { // 新建Person对象， Person p1 = new Person(&quot;eee&quot;, 100); Person p2 = new Person(&quot;eee&quot;, 100); Person p3 = new Person(&quot;aaa&quot;, 200); // 新建HashSet对象 HashSet set = new HashSet(); set.add(p1); set.add(p2); set.add(p3); // 比较p1 和 p2， 并打印它们的hashCode() System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode()); // 打印set System.out.printf(&quot;set:%s\\n&quot;, set); } /** * @desc Person类。 */ private static class Person { int age; String name; public Person(String name, int age) { this.name = name; this.age = age; } public String toString() { return &quot;(&quot;+name + &quot;, &quot; +age+&quot;)&quot;; } /** * @desc 覆盖equals方法 */ @Override public boolean equals(Object obj){ if(obj == null){ return false; } //如果是同一个对象返回true，反之返回false if(this == obj){ return true; } //判断是否类型相同 if(this.getClass() != obj.getClass()){ return false; } Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; } } }运行结果： p1.equals(p2) : true; p1(1169863946) p2(1690552137) set:[(eee, 100), (eee, 100), (aaa, 200)]结果分析： 我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。 下面，我们同时覆盖equals() 和 hashCode()方法。 参考代码 (ConflictHashCodeTest2.java)： import java.util.*; import java.lang.Comparable; /** * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。 * * @author skywang * @emai kuiwu-wang@163.com */ public class ConflictHashCodeTest2{ public static void main(String[] args) { // 新建Person对象， Person p1 = new Person(&quot;eee&quot;, 100); Person p2 = new Person(&quot;eee&quot;, 100); Person p3 = new Person(&quot;aaa&quot;, 200); Person p4 = new Person(&quot;EEE&quot;, 100); // 新建HashSet对象 HashSet set = new HashSet(); set.add(p1); set.add(p2); set.add(p3); // 比较p1 和 p2， 并打印它们的hashCode() System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode()); // 比较p1 和 p4， 并打印它们的hashCode() System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode()); // 打印set System.out.printf(&quot;set:%s\\n&quot;, set); } /** * @desc Person类。 */ private static class Person { int age; String name; public Person(String name, int age) { this.name = name; this.age = age; } public String toString() { return name + &quot; - &quot; +age; } /** * @desc重写hashCode */ @Override public int hashCode(){ int nameHash = name.toUpperCase().hashCode(); return nameHash ^ age; } /** * @desc 覆盖equals方法 */ @Override public boolean equals(Object obj){ if(obj == null){ return false; } //如果是同一个对象返回true，反之返回false if(this == obj){ return true; } //判断是否类型相同 if(this.getClass() != obj.getClass()){ return false; } Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; } } }运行结果： p1.equals(p2) : true; p1(68545) p2(68545) p1.equals(p4) : false; p1(68545) p4(68545) set:[aaa - 200, eee - 100]结果分析： 这下，equals()生效了，HashSet中没有重复元素。比较p1和p2，我们发现：它们的hashCode()相等，通过equals()比较它们也返回true。所以，p1和p2被视为相等。比较p1和p4，我们发现：虽然它们的hashCode()相等；但是，通过equals()比较它们返回false。所以，p1和p4被视为不相等。","link":"/2012/02/20/java/collection/2012-02-20-hashcode-and-equals/"},{"title":"Java异常(三) 《Java Puzzles》中关于异常的几个谜题","text":"本章介绍《Java Puzzles》中关于异常的几个谜题。这一章都是以代码为例，相比上一章看起来更有意思。 目录谜题1: 优柔寡断谜题2: 极端不可思议谜题3: 不受欢迎的宾客谜题4: 您好,再见!谜题5: 不情愿的构造器谜题6: 域和流谜题7: 异常为循环而抛 谜题1: 优柔寡断看看下面的程序，它到底打印什么？ public class Indecisive { public static void main(String[] args) { System.out.println(decision()); } private static boolean decision() { try { return true; } finally { return false; } } }运行结果： false结果说明： 在一个 try-finally 语句中,finally 语句块总是在控制权离开 try 语句块时执行的。无论 try 语句块是正常结束的,还是意外结束的, 情况都是如此。 一条语句或一个语句块在它抛出了一个异常,或者对某个封闭型语句执行了一个 break 或 continue,或是象这个程序一样在方法中执行了一个return 时,将发生意外结束。它们之所以被称为意外结束,是因为它们阻止程序去按顺序执行下面的语句。当 try 语句块和 finally 语句块都意外结束时, try 语句块中引发意外结束的原因将被丢弃, 而整个 try-finally 语句意外结束的原因将于 finally 语句块意外结束的原因相同。在这个程序中,在 try 语句块中的 return 语句所引发的意外结束将被丢弃, try-finally 语句意外结束是由 finally 语句块中的 return 而造成的。 简单地讲, 程序尝试着 (try) (return) 返回 true, 但是它最终 (finally) 返回(return)的是 false。丢弃意外结束的原因几乎永远都不是你想要的行为, 因为意外结束的最初原因可能对程序的行为来说会显得更重要。对于那些在 try 语句块中执行 break、continue 或 return 语句,只是为了使其行为被 finally 语句块所否决掉的程序,要理解其行为是特别困难的。总之,每一个 finally 语句块都应该正常结束,除非抛出的是不受检查的异常。 千万不要用一个 return、break、continue 或 throw 来退出一个 finally 语句块,并且千万不要允许将一个受检查的异常传播到一个 finally 语句块之外去。对于语言设计者, 也许应该要求 finally 语句块在未出现不受检查的异常时必须正常结束。朝着这个目标,try-finally 结构将要求 finally 语句块可以正常结束。return、break 或 continue 语句把控制权传递到 finally 语句块之外应该是被禁止的, 任何可以引发将被检查异常传播到 finally 语句块之外的语句也同样应该是被禁止的。 谜题2: 极端不可思议下面的三个程序每一个都会打印些什么? 不要假设它们都可以通过编译。 第一个程序 import java.io.IOException; public class Arcane1 { public static void main(String[] args) { try { System.out.println(&quot;Hello world&quot;); } catch(IOException e) { System.out.println(&quot;I&apos;ve never seen println fail!&quot;); } } }第二个程序 public class Arcane2 { public static void main(String[] args) { try { // If you have nothing nice to say, say nothing } catch(Exception e) { System.out.println(&quot;This can&apos;t happen&quot;); } } }第三个程序 interface Type1 { void f() throws CloneNotSupportedException; } interface Type2 { void f() throws InterruptedException; } interface Type3 extends Type1, Type2 { } public class Arcane3 implements Type3 { public void f() { System.out.println(&quot;Hello world&quot;); } public static void main(String[] args) { Type3 t3 = new Arcane3(); t3.f(); } }运行结果： (01) 第一个程序编译出错！ Arcane1.java:9: exception java.io.IOException is never thrown in body of corresponding try statement } catch(IOException e) { ^ 1 error(02) 第二个程序能正常编译和运行。 (03) 第三个程序能正常编译和运行。输出结果是: Hello world 结果说明： (01) Arcane1展示了被检查异常的一个基本原则。它看起来应该是可以编译的:try 子句执行 I/O,并且 catch 子句捕获 IOException 异常。但是这个程序不能编译,因为 println 方法没有声明会抛出任何被检查异常,而IOException 却正是一个被检查异常。语言规范中描述道:如果一个 catch 子句要捕获一个类型为 E 的被检查异常, 而其相对应的 try 子句不能抛出 E 的某种子类型的异常,那么这就是一个编译期错误。 (02) 基于同样的理由,第二个程序,Arcane2,看起来应该是不可以编译的,但是它却可以。它之所以可以编译,是因为它唯一的 catch 子句检查了 Exception。尽管在这一点上十分含混不清,但是捕获 Exception 或 Throwble 的 catch 子句是合法的,不管与其相对应的 try 子句的内容为何。尽管 Arcane2 是一个合法的程序,但是 catch 子句的内容永远的不会被执行,这个程序什么都不会打印。 (03) 第三个程序,Arcane3,看起来它也不能编译。方法 f 在 Type1 接口中声明要抛出被检查异常 CloneNotSupportedException,并且在 Type2 接口中声明要抛出被检查异常 InterruptedException。Type3 接口继承了 Type1 和 Type2,因此, 看起来在静态类型为 Type3 的对象上调用方法 f 时, 有潜在可能会抛出这些异常。一个方法必须要么捕获其方法体可以抛出的所有被检查异常, 要么声明它将抛出这些异常。Arcane3 的 main 方法在静态类型为 Type3 的对象上调用了方法 f,但它对 CloneNotSupportedException 和 InterruptedExceptioin 并没有作这些处理。那么,为什么这个程序可以编译呢? 上述分析的缺陷在于对“Type3.f 可以抛出在 Type1.f 上声明的异常和在 Type2.f 上声明的异常”所做的假设。这并不正确,因为每一个接口都限制了方法 f 可以抛出的被检查异常集合。一个方法可以抛出的被检查异常集合是它所适用的所有类型声明要抛出的被检查异常集合的交集,而不是合集。因此,静态类型为 Type3 的对象上的 f 方法根本就不能抛出任何被检查异常。因此,Arcane3可以毫无错误地通过编译,并且打印 Hello world。 谜题3: 不受欢迎的宾客下面的程序会打印出什么呢? public class UnwelcomeGuest { public static final long GUEST_USER_ID = -1; private static final long USER_ID; static { try { USER_ID = getUserIdFromEnvironment(); } catch (IdUnavailableException e) { USER_ID = GUEST_USER_ID; System.out.println(&quot;Logging in as guest&quot;); } } private static long getUserIdFromEnvironment() throws IdUnavailableException { throw new IdUnavailableException(); } public static void main(String[] args) { System.out.println(&quot;User ID: &quot; + USER_ID); } } class IdUnavailableException extends Exception { }运行结果： UnwelcomeGuest.java:10: variable USER_ID might already have been assigned USER_ID = GUEST_USER_ID; ^ 1 error结果说明： 该程序看起来很直观。对 getUserIdFromEnvironment 的调用将抛出一个异常, 从而使程序将 GUEST_USER_ID(-1L)赋值给 USER_ID, 并打印 Loggin in as guest。 然后 main 方法执行,使程序打印 User ID: -1。表象再次欺骗了我们,该程序并不能编译。如果你尝试着去编译它, 你将看到和一条错误信息。 问题出在哪里了?USER_ID 域是一个空 final(blank final),它是一个在声明中没有进行初始化操作的 final 域。很明显,只有在对 USER_ID 赋值失败时,才会在 try 语句块中抛出异常,因此,在 catch 语句块中赋值是相 当安全的。不管怎样执行静态初始化操作语句块,只会对 USER_ID 赋值一次,这正是空 final 所要求的。为什么编译器不知道这些呢? 要确定一个程序是否可以不止一次地对一个空 final 进行赋值是一个很困难的问题。事实上,这是不可能的。这等价于经典的停机问题,它通常被认为是不可能解决的。为了能够编写出一个编译器,语言规范在这一点上采用了保守的方式。在程序中,一个空 final 域只有在它是明确未赋过值的地方才可以被赋值。规范长篇大论,对此术语提供了一个准确的但保守的定义。 因为它是保守的,所以编译器必须拒绝某些可以证明是安全的程序。这个谜题就展示了这样的一个程序。幸运的是, 你不必为了编写 Java 程序而去学习那些骇人的用于明确赋值的细节。通常明确赋值规则不会有任何妨碍。如果碰巧你编写了一个真的可能会对一个空final 赋值超过一次的程序,编译器会帮你指出的。只有在极少的情况下,就像本谜题一样, 你才会编写出一个安全的程序, 但是它并不满足规范的形式化要求。编译器的抱怨就好像是你编写了一个不安全的程序一样,而且你必须修改你的程序以满足它。 解决这类问题的最好方式就是将这个烦人的域从空 final 类型改变为普通的final 类型,用一个静态域的初始化操作替换掉静态的初始化语句块。实现这一点的最佳方式是重构静态语句块中的代码为一个助手方法: public class UnwelcomeGuest { public static final long GUEST_USER_ID = -1; private static final long USER_ID = getUserIdOrGuest(); private static long getUserIdOrGuest() { try { return getUserIdFromEnvironment(); } catch (IdUnavailableException e) { System.out.println(&quot;Logging in as guest&quot;); return GUEST_USER_ID; } } private static long getUserIdFromEnvironment() throws IdUnavailableException { throw new IdUnavailableException(); } public static void main(String[] args) { System.out.println(&quot;User ID: &quot; + USER_ID); } } class IdUnavailableException extends Exception { }程序的这个版本很显然是正确的,而且比最初的版本根据可读性,因为它为了域值的计算而增加了一个描述性的名字, 而最初的版本只有一个匿名的静态初始化操作语句块。将这样的修改作用于程序,它就可以如我们的期望来运行了。总之,大多数程序员都不需要学习明确赋值规则的细节。该规则的作为通常都是正确的。如果你必须重构一个程序,以消除由明确赋值规则所引发的错误,那么你应该考虑添加一个新方法。这样做除了可以解决明确赋值问题,还可以使程序的可读性提高。 谜题4: 您好,再见!下面的程序将会打印出什么呢? public class HelloGoodbye { public static void main(String[] args) { try { System.out.println(&quot;Hello world&quot;); System.exit(0); } finally { System.out.println(&quot;Goodbye world&quot;); } } }运行结果: Hello world结果说明： 这个程序包含两个 println 语句: 一个在 try 语句块中, 另一个在相应的 finally语句块中。try 语句块执行它的 println 语句,并且通过调用 System.exit 来提前结束执行。在此时,你可能希望控制权会转交给 finally 语句块。然而,如果你运行该程序,就会发现它永远不会说再见:它只打印了 Hello world。这是否违背了”Indecisive示例” 中所解释的原则呢? 不论 try 语句块的执行是正常地还是意外地结束, finally 语句块确实都会执行。然而在这个程序中,try 语句块根本就没有结束其执行过程。System.exit 方法将停止当前线程和所有其他当场死亡的线程。finally 子句的出现并不能给予线程继续去执行的特殊权限。 当 System.exit 被调用时,虚拟机在关闭前要执行两项清理工作。首先,它执行所有的关闭挂钩操作,这些挂钩已经注册到了 Runtime.addShutdownHook 上。这对于释放 VM 之外的资源将很有帮助。务必要为那些必须在 VM 退出之前发生的行为关闭挂钩。下面的程序版本示范了这种技术,它可以如我们所期望地打印出 Hello world 和 Goodbye world: public class HelloGoodbye1 { public static void main(String[] args) { System.out.println(&quot;Hello world&quot;); Runtime.getRuntime().addShutdownHook( new Thread() { public void run() { System.out.println(&quot;Goodbye world&quot;); } }); System.exit(0); } }VM 执行在 System.exit 被调用时执行的第二个清理任务与终结器有关。如果System.runFinalizerOnExit 或它的魔鬼双胞胎 Runtime.runFinalizersOnExit被调用了,那么 VM 将在所有还未终结的对象上面调用终结器。这些方法很久以前就已经过时了,而且其原因也很合理。无论什么原因,永远不要调用System.runFinalizersOnExit 和 Runtime.runFinalizersOnExit: 它们属于 Java类库中最危险的方法之一[ThreadStop]。调用这些方法导致的结果是,终结器会在那些其他线程正在并发操作的对象上面运行, 从而导致不确定的行为或导致死锁。 总之,System.exit 将立即停止所有的程序线程,它并不会使 finally 语句块得到调用,但是它在停止 VM 之前会执行关闭挂钩操作。当 VM 被关闭时,请使用关闭挂钩来终止外部资源。通过调用 System.halt 可以在不执行关闭挂钩的情况下停止 VM,但是这个方法很少使用。 谜题5: 不情愿的构造器下面的程序将打印出什么呢? public class Reluctant { private Reluctant internalInstance = new Reluctant(); public Reluctant() throws Exception { throw new Exception(&quot;I&apos;m not coming out&quot;); } public static void main(String[] args) { try { Reluctant b = new Reluctant(); System.out.println(&quot;Surprise!&quot;); } catch (Exception ex) { System.out.println(&quot;I told you so&quot;); } } }运行结果： Exception in thread &quot;main&quot; java.lang.StackOverflowError at Reluctant.&lt;init&gt;(Reluctant.java:3) ...结果说明： main 方法调用了 Reluctant 构造器,它将抛出一个异常。你可能期望 catch 子句能够捕获这个异常,并且打印 I told you so。凑近仔细看看这个程序就会发现,Reluctant 实例还包含第二个内部实例,它的构造器也会抛出一个异常。无论抛出哪一个异常,看起来 main 中的 catch 子句都应该捕获它,因此预测该程序将打印 I told you 应该是一个安全的赌注。但是当你尝试着去运行它时,就会发现它压根没有去做这类的事情:它抛出了 StackOverflowError 异常,为什么呢? 与大多数抛出 StackOverflowError 异常的程序一样,本程序也包含了一个无限递归。当你调用一个构造器时,实例变量的初始化操作将先于构造器的程序体而运行[JLS 12.5]。在本谜题中, internalInstance 变量的初始化操作递归调用了构造器,而该构造器通过再次调用 Reluctant 构造器而初始化该变量自己的 internalInstance 域,如此无限递归下去。这些递归调用在构造器程序体获得执行机会之前就会抛出 StackOverflowError 异常,因为 StackOverflowError 是 Error 的子类型而不是 Exception 的子类型,所以 catch 子句无法捕获它。对于一个对象包含与它自己类型相同的实例的情况,并不少见。例如,链接列表节点、树节点和图节点都属于这种情况。你必须非常小心地初始化这样的包含实例,以避免 StackOverflowError 异常。 至于本谜题名义上的题目:声明将抛出异常的构造器,你需要注意,构造器必须声明其实例初始化操作会抛出的所有被检查异常。 谜题6: 域和流下面的方法将一个文件拷贝到另一个文件,并且被设计为要关闭它所创建的每一个流,即使它碰到 I/O 错误也要如此。遗憾的是,它并非总是能够做到这一点。为什么不能呢,你如何才能订正它呢? static void copy(String src, String dest) throws IOException { InputStream in = null; OutputStream out = null; try { in = new FileInputStream(src); out = new FileOutputStream(dest); byte[] buf = new byte[1024]; int n; while ((n = in.read(buf)) &gt; 0) out.write(buf, 0, n); } finally { if (in != null) in.close(); if (out != null) out.close(); } }谜题分析： 这个程序看起来已经面面俱到了。其流域(in 和 out)被初始化为 null,并且新的流一旦被创建,它们马上就被设置为这些流域的新值。对于这些域所引用的流,如果不为空,则 finally 语句块会将其关闭。即便在拷贝操作引发了一个 IOException 的情况下,finally 语句块也会在方法返回之前执行。出什么错了呢? 问题在 finally 语句块自身中。close 方法也可能会抛出 IOException 异常。如果这正好发生在 in.close 被调用之时,那么这个异常就会阻止 out.close 被调用,从而使输出流仍保持在开放状态。请注意,该程序违反了”优柔寡断” 的建议:对 close 的调用可能会导致 finally 语句块意外结束。遗憾的是,编译器并不能帮助你发现此问题,因为 close 方法抛出的异常与 read 和 write 抛出的异常类型相同,而其外围方法(copy)声明将传播该异常。解决方式是将每一个 close 都包装在一个嵌套的 try 语句块中。 下面的 finally 语句块的版本可以保证在两个流上都会调用 close: try { // 和之前一样 } finally { if (in != null) { try { in.close(); } catch (IOException ex) { // There is nothing we can do if close fails } } if (out != null) { try { out.close(); } catch (IOException ex) { // There is nothing we can do if close fails } } }总之,当你在 finally 语句块中调用 close 方法时,要用一个嵌套的 try-catch 语句来保护它,以防止 IOException 的传播。更一般地讲,对于任何在 finally 语句块中可能会抛出的被检查异常都要进行处理,而不是任其传播。 谜题7: 异常为循环而抛下面的程序会打印出什么呢? public class Loop { public static void main(String[] args) { int[][] tests = { { 6, 5, 4, 3, 2, 1 }, { 1, 2 }, { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1 } }; int successCount = 0; try { int i = 0; while (true) { if (thirdElementIsThree(tests[i++])) successCount ++; } } catch(ArrayIndexOutOfBoundsException e) { // No more tests to process } System.out.println(successCount); } private static boolean thirdElementIsThree(int[] a) { return a.length &gt;= 3 &amp; a[2] == 3; } }运行结果： 0结果说明： 该程序主要说明了两个问题。 第1个问题：不应该使用异常作为终止循环的手段！ 该程序用 thirdElementIsThree 方法测试了 tests 数组中的每一个元素。遍历这个数组的循环显然是非传统的循环:它不是在循环变量等于数组长度的时候终止,而是在它试图访问一个并不在数组中的元素时终止。尽管它是非传统的,但是这个循环应该可以工作。 如果传递给 thirdElementIsThree 的参数具有 3 个或更多的元素,并且其第三个元素等于 3,那么该方法将返回 true。对于 tests中的 5 个元素来说,有 2 个将返回 true,因此看起来该程序应该打印 2。如果你运行它,就会发现它打印的时 0。肯定是哪里出了问题,你能确定吗? 事实上,这个程序犯了两个错误。第一个错误是该程序使用了一种可怕的循环惯用法,该惯用法依赖的是对数组的访问会抛出异常。这种惯用法不仅难以阅读, 而且运行速度还非常地慢。不要使用异常来进行循环控制;应该只为异常条件而使用异常。为了纠正这个错误,可以将整个 try-finally 语句块替换为循环遍历数组的标准惯用法: for (int i = 0; i &lt; test.length; i++) if (thirdElementIsThree(tests[i])) successCount++;如果你使用的是 5.0 或者是更新的版本,那么你可以用 for 循环结构来代替: for (int[] test : tests) if(thirdElementIsThree(test)) successCount++;第2个问题: 主要比较”&amp;操作符” 和 “&amp;&amp;操作符”的区别。注意示例中的操作符是&amp;，这是按位进行”与”操作。","link":"/2012/04/16/java/exception/2012-04-16-exception/"},{"title":"Android 之Animation动画(一)之 Animation介绍","text":"Android动画都支持通过”代码”和”属性”两种方式进行控制。Google官网文档建议，通过”属性”的方式来控制动画。 Android动画包括三种：View Animation，Drawable Animation和Property Animation。 下面分别对这3种动画进行介绍。","link":"/2014/07/24/android/api_guide/animation/2014-07-24-Animation/"},{"title":"Android 触摸事件机制(一) 简介","text":"本系列文章将介绍Android中触摸事件，即Touch Event的传递机制。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. 触摸事件概述2. Activity, ViewGroup, View中的触摸事件API3. OnTouchListener接口 1. 触摸事件概述本文介绍的触摸事件API和接口主要是：dispatchTouchEvent(), onTouchEvent(), onInterceptTouchEvent()和OnTouchListener接口。这些内容中，最复杂的莫过于dispatchTouchEvent(), onTouchEvent()和onInterceptTouchEvent()这三者之间的关系。如果你能认真读完本系列文章，相信对它们之间的关系，它们的原理和用法，很有很清晰的认识。 本文先对这些接口做个大致介绍，建立一个整体概念。后续再通过阅读Activity, View和ViewGroup中触摸事件API的源码，来对认识这些API；最后，再通过几个示例来进一步了解它们，同时也了解它们的用法。 2. Activity, ViewGroup, View中的触摸事件API1. Activity中的触摸事件APIpublic boolean dispatchTouchEvent(MotionEvent ev)；public boolean onTouchEvent(MotionEvent ev); 2. ViewGroup中的触摸事件APIpublic boolean dispatchTouchEvent(MotionEvent ev)；public boolean onTouchEvent(MotionEvent ev);public boolean onInterceptTouchEvent(MotionEvent ev); 3. View中的触摸事件APIpublic boolean dispatchTouchEvent(MotionEvent ev)；public boolean onTouchEvent(MotionEvent ev); 下面简单的说明一下涉及到的三个API的作用。 dispatchTouchEvent：它是传递触摸事件的接口。(01) Activity将触摸事件传递给ViewGroup，ViewGroup将触摸事件传递给另一个ViewGroup，以及ViewGroup将触摸事件传递给View；这些都是通过dispatchTouchEvent()来传递的。(02) dispatchTouchEvent(), onInterceptTouchEvent(), onTouchEvent()以及onTouch()它们之间的联系，都是通过dispatchTouchEvent()体现的。它们都是在dispatchTouchEvent()中调度的！因此，理解dispatchTouchEvent()是理解Android事件机制的关机；而其中，最关机的就是ViewGroup中的dispatchTouchEvent()(03) 返回值：true，表示触摸事件被消费了；false，则表示触摸事件没有被消费。onTouchEvent：它是处理触摸事件的接口。(01) 无论是Activity, ViewGroup还是View，对触摸事件的处理，基本上都是在onTouchEvent()中进行的。因此，我们说它是处理触摸事件的接口。(02) 返回值：返回true，表示触摸事件被它处理过了；或者，换句话说，表示它消费了触摸事件。否则，表示它没有消费该触摸事件。onInterceptTouchEvent：它是拦截触摸事件的接口。(01) 只有ViewGroup中才有该接口。如果ViewGroup不想将触摸事件传递给它的子View，则可以在onInterceptTouchEvent中进行拦截。(02) 返回值：true，表示ViewGroup拦截了该触摸事件；那么，该事件就不会分发给它的子View或者子ViewGroup。否则，表示ViewGroup没有拦截该事件，该事件就会分发给它的子View和子ViewGroup。 3. OnTouchListener接口OnTouchListener一个interface接口，它是在View中声明的。OnTouchListener中只包含了onTouch()函数。那么，onTouch()和onTouchEvent()有什么相同和不同点呢？ 相同点onTouch()与onTouchEvent()都是用户处理触摸事件的API。 不同点(01)，onTouch()是View专门提供给用户的接口，目的是为了方便用户自己处理触摸事件。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。 dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。 如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。 关于它们之间的内容，在讲解View的dispatchTouchEvent()时，会详细说明。","link":"/2015/01/01/android/os/event/2015-01-01-TouchEvent-Introduce/"},{"title":"Android 触摸事件机制(五) 触摸事件示例2--View接受触摸事件","text":"本文将通过示例演示触摸事件的传递流程。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. 示例概述1.1. 示例简介1.2. 示例结论2. 示例源码3. 运行结果 1. 示例概述 1.1 示例简介本文的示例是在触摸事件示例(一)的基础上修改的。即本文的示例仍然是：自定义一个Activity，该Activity中的显示内容是包含一个自定义的ViewGroup，该ViewGroup中包含一个自定义的View。 相比触摸事件示例(一)，本示例对MyView中的onTouchEvent()进行了修改。修改后的onTouchEvent()代码如下： @Override public boolean onTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName); // boolean ret = super.onTouchEvent(event); boolean ret = true; Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } 这里的onTouchEvent()直接返回true，表示MyView消费了触摸事件。 1.2 示例结论(01) 如果MyView接受了ACTION_DOWN，那么就不会再再执行其他对象的onTouchEvent()函数的。即，不会执行MyViewGroup的onTouchEvent()和MyActivity的onTouchEvent()。因为MyView接受了ACTION_DOWN，意味着这个事件已经被消费了；就无须其他对象再来消费ACTION_DOWN了。(02) 如果MyView接受了ACTION_DOWN，那么MyView能继续收到ACTION_MOVE和ACTION_UP这两种触摸触事件。并且ACTION_MOVE和ACTION_UP的处理流程和ACTION_DOWN的流程基本一样。 Activity中ACTION_DOWN的流程图如下： 2. 示例源码点击查看：触摸事件示例2的源码 3. 运行结果3.1 ACTION_DOWN事件点击MyView所在的区域，ACTION_DOWN相关的log如下： D/##skywang-MyActivity( 2273): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2273): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2273): onInterceptTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2273): onInterceptTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyView( 2273): dispatchTouchEvent(start) :DOWND/##skywang-MyView( 2273): onTouchEvent(start) :DOWND/##skywang-MyView( 2273): onTouchEvent( end ) :DOWN, ret=trueD/##skywang-MyView( 2273): dispatchTouchEvent( end ) :DOWN, ret=trueD/##skywang-MyViewGroup( 2273): dispatchTouchEvent( end ) :DOWN, ret=trueD/##skywang-MyActivity( 2273): dispatchTouchEvent( end ) :DOWN, ret=true 说明：很显然，ACTION_DOWN的流程如下：(01) MyActivity收到ACTION_DOWN，进入MyActivity.dispatchTouchEvent()。(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，进入MyViewGroup.dispatchTouchEvent()。(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先进入MyViewGroup.onInterceptTouchEvent()。(04) 紧接着，MyViewGroup会退出MyViewGroup.onInterceptTouchEvent()。因为MyViewGroup没有对触摸事件进行拦截，MyViewGroup会继续分发事件。(05) MyViewGroup将触摸事件分发给MyView，即进入MyView.dispatchTouchEvent()。(06) MyView会调用onTouchEvent()对触摸事件进行处理，即进入MyView.onTouchEvent() 。(07) 紧接着，MyView会退出MyView.onTouchEvent()。此时的，MyView.onTouchEvent()返回的是true；表示MyView消费了此次触摸事件。(08) MyView.dispatchTouchEvent()得知MyView.onTouchEvent()消费此次触摸事件之后；也就返回true，表示MyView接受该此次触摸事件。(09) MyViewGroup则得知MyView接受了该触摸事件之后，就退出MyViewGroup.dispatchTouchEvent()，并返回true。(10) MyActivity得知MyViewGroup接受了该触摸事件之后，就会调用退出MyActivity.dispatchTouchEvent()，并返回true。 对比，触摸事件示例(一)中的ACTION_DOWN路径。在本示例中，MyView消费了ACTION_DOWN事件之后；触摸事件就没有再发送给MyViewGroup.onTouchEvent()以及MyActivity.onTouchEvent()。 3.2 ACTION_MOVE事件点击MyView所在的区域，ACTION_MOVE相关的log如下： D/##skywang-MyActivity( 2273): dispatchTouchEvent(start) :MOVED/##skywang-MyViewGroup( 2273): dispatchTouchEvent(start) :MOVED/##skywang-MyViewGroup( 2273): onInterceptTouchEvent(start) :MOVED/##skywang-MyViewGroup( 2273): onInterceptTouchEvent( end ) :MOVE, ret=falseD/##skywang-MyView( 2273): dispatchTouchEvent(start) :MOVED/##skywang-MyView( 2273): onTouchEvent(start) :MOVED/##skywang-MyView( 2273): onTouchEvent( end ) :MOVE, ret=trueD/##skywang-MyView( 2273): dispatchTouchEvent( end ) :MOVE, ret=trueD/##skywang-MyViewGroup( 2273): dispatchTouchEvent( end ) :MOVE, ret=trueD/##skywang-MyActivity( 2273): dispatchTouchEvent( end ) :MOVE, ret=true 说明：由于MyView接受了ACTION_DOWN；因此，ACTION_MOVE事件会继续分发给MyView。ACTION_MOVE的分发路径和ACTION_DOWN的路径基本上一样！ 3.3 ACTION_UP事件点击MyView所在的区域，ACTION_UP相关的log如下： D/##skywang-MyActivity( 2273): dispatchTouchEvent(start) :UPD/##skywang-MyViewGroup( 2273): dispatchTouchEvent(start) :UPD/##skywang-MyViewGroup( 2273): onInterceptTouchEvent(start) :UPD/##skywang-MyViewGroup( 2273): onInterceptTouchEvent( end ) :UP, ret=falseD/##skywang-MyView( 2273): dispatchTouchEvent(start) :UPD/##skywang-MyView( 2273): onTouchEvent(start) :UPD/##skywang-MyView( 2273): onTouchEvent( end ) :UP, ret=trueD/##skywang-MyView( 2273): dispatchTouchEvent( end ) :UP, ret=trueD/##skywang-MyViewGroup( 2273): dispatchTouchEvent( end ) :UP, ret=trueD/##skywang-MyActivity( 2273): dispatchTouchEvent( end ) :UP, ret=true 说明：由于MyView接受了ACTION_DOWN；因此，ACTION_UP事件会继续分发给MyView。ACTION_UP的分发路径和ACTION_DOWN的路径基本上一样！","link":"/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-02-View/"},{"title":"Android 触摸事件机制(五) 触摸事件示例4--ViewGroup拦截并消费触摸事件","text":"本文将通过示例演示触摸事件的传递流程。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. 示例概述1.1. 示例简介1.2. 示例结论2. 示例源码3. 运行结果 1. 示例概述 1.1 示例简介在触摸事件示例(三)中，MyViewGroup只是拦截了触摸事件，但是并没有消费触摸事件。而在本文的示例中，MyViewGroup将在拦截触摸事件的基础上，同时消费触摸事件。 本文的示例仍然是在触摸事件示例(三)的基础上修改的。与触摸事件示例(三)相比，本文的示例对MyViewGroup中的onTouchEvent()进行了修改。修改后的onTouchEvent()代码如下： @Override public boolean onTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName); // boolean ret = super.onTouchEvent(event); boolean ret = true; Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } 1.2 示例结论(01) MyViewGroup拦截并消费了ACTION_DOWN。那么，该事件就不会分发给MyViewGroup的子类，也不会调用MyActivity的onTouchEvent()。(02) MyViewGroup拦截并消费了ACTION_DOWN。那么，MyViewGroup就会接受到ACTION_MOVE和ACTION_UP这两种触摸触事件。而且对于ACTION_MOVE和ACTION_UP事件，不会再执行拦截操作，即不会调用MyViewGroup.onInterceptTouchEvent()；而是直接调用MyViewGroup.onTouchEvent()对事件进行处理。 为什么在ACTION_MOVE和ACTION_UP中，没有执行MyViewGroup.onInterceptTouchEvent()呢？查看[ViewGroup中的dispatchTouchEvent()源码]即可得到答案，MyViewGroup在分发ACTION_MOVE时，没有执行”第3步”和”第5步”，而是直接执行”第6步”；进而调用View.dispatchTouchEvent()进行的处理。 Activity中ACTION_DOWN的流程图如下： 2. 示例源码点击查看：触摸事件示例4的源码 3. 运行结果3.1 ACTION_DOWN事件点击MyView所在的区域，ACTION_DOWN相关的log如下： D/##skywang-MyActivity( 2465): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2465): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2465): onInterceptTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2465): onInterceptTouchEvent( end ) :DOWN, ret=trueD/##skywang-MyViewGroup( 2465): onTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2465): onTouchEvent( end ) :DOWN, ret=trueD/##skywang-MyViewGroup( 2465): dispatchTouchEvent( end ) :DOWN, ret=trueD/##skywang-MyActivity( 2465): dispatchTouchEvent( end ) :DOWN, ret=true 说明：很显然，ACTION_DOWN的流程如下：(01) MyActivity收到ACTION_DOWN，进入MyActivity.dispatchTouchEvent()。(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，进入MyViewGroup.dispatchTouchEvent()。(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先进入MyViewGroup.onInterceptTouchEvent()。(04) 紧接着，MyViewGroup会退出MyViewGroup.onInterceptTouchEvent()。此时，MyViewGroup.onInterceptTouchEvent()返回true。表示MyViewGroup拦截了该触摸事件。(05) MyViewGroup在得知自己拦截了触摸事件之后，将触摸事件交给自己的onTouchEvent()进行处理，即进入MyViewGroup.onTouchEvent()。(06) 紧接着，MyViewGroup会退出MyViewGroup.onTouchEvent()，并返回true。表示MyViewGroup消费了该事件。(07) 随后，MyViewGroup会退出MyViewGroup.dispatchTouchEvent()，并返回true。表示MyViewGroup接受了该触摸事件。(08) MyActivity得知MyViewGroup接受了该触摸事件之后，就会退出MyActivity.dispatchTouchEvent()，并返回true。表示此次触摸事件被消费了。 3.2 ACTION_MOVE事件点击MyView所在的区域，ACTION_MOVE相关的log如下： D/##skywang-MyActivity( 2465): dispatchTouchEvent(start) :MOVED/##skywang-MyViewGroup( 2465): dispatchTouchEvent(start) :MOVED/##skywang-MyViewGroup( 2465): onTouchEvent(start) :MOVED/##skywang-MyViewGroup( 2465): onTouchEvent( end ) :MOVE, ret=trueD/##skywang-MyViewGroup( 2465): dispatchTouchEvent( end ) :MOVE, ret=trueD/##skywang-MyActivity( 2465): dispatchTouchEvent( end ) :MOVE, ret=true 说明：由于MyViewGroup接受了ACTION_DOWN；因此，ACTION_MOVE事件会继续分发给MyViewGroup。不过此时，是直接调用onTouchEvent()进行消息处理，而不再需要执行onInterceptTouchEvent()来拦截消息。为什么没有执行MyViewGroup.onInterceptTouchEvent()呢？查看[ViewGroup中的dispatchTouchEvent()源码]即可得到答案，MyViewGroup在分发ACTION_MOVE时，没有执行”第3步”和”第5步”，而是直接执行”第6步”；进而调用View.dispatchTouchEvent()进行的处理。 3.3 ACTION_UP事件点击MyView所在的区域，ACTION_UP相关的log如下： D/##skywang-MyActivity( 2595): dispatchTouchEvent(start) :UPD/##skywang-MyViewGroup( 2595): dispatchTouchEvent(start) :UPD/##skywang-MyViewGroup( 2595): onTouchEvent(start) :UPD/##skywang-MyViewGroup( 2595): onTouchEvent( end ) :UP, ret=trueD/##skywang-MyViewGroup( 2595): dispatchTouchEvent( end ) :UP, ret=trueD/##skywang-MyActivity( 2595): dispatchTouchEvent( end ) :UP, ret=true 说明：ACTION_UP的路径和ACTION_MOVE的路径一样！","link":"/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-04-ViewGroup/"},{"title":"Android 触摸事件机制(五) 触摸事件示例3--ViewGroup拦截但不消费触摸事件","text":"本文将通过示例演示触摸事件的传递流程。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. 示例概述1.1. 示例简介1.2. 示例结论2. 示例源码3. 运行结果 1. 示例概述 1.1 示例简介在触摸事件示例(二)中，MyView接受了触摸事件。可是，在有的时候，我们希望MyViewGroup对触摸事件进行拦截；而不希望这个事件发送给MyView进行处理。此时，就需要重载GroupView的onInterceptTouchEvent()来拦截触摸事件。这就是本文要讲到的示例。 本文的示例仍然是在触摸事件示例(一)的基础上修改的。与触摸事件示例(二)不同，本文的示例仅仅只对MyViewGroup中的onInterceptTouchEvent()进行了修改。修改后的onInterceptTouchEvent()代码如下： @Override public boolean onInterceptTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;onInterceptTouchEvent(start) :&quot;+actionName); // boolean ret = super.onInterceptTouchEvent(event); boolean ret = true; Log.d(TAG, &quot;onInterceptTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } 这里的onTouchEvent()直接返回true，表示MyView消费了触摸事件。 1.2 示例结论(01) MyViewGroup拦截了ACTION_DOWN，并没有消费该ACTION_DOWN。既然MyViewGroup拦截了ACTION_DOWN，那就意味着该事件就不会分发给MyViewGroup的子类。但是由于MyViewGroup没有消费该事件，即它并没有接受该事件；那么，ACTION_DOWN会继续查找其他对象来消费它自己，这也意味着该触摸事件仍然会发送MyActivity的onTouchEvent()。 如果MyActivity中有和MyViewGroup同级别的GroupView的话，在得知MyViewGroup拦截了ACTION_DOWN，却没有消费该ACTION_DOWN之后；MyActivity仍然能够向这个同级的GroupView分发消息。(02) MyViewGroup并没有消费ACTION_DOWN，那么，MyViewGroup就不能接受到ACTION_MOVE和ACTION_UP这两种触摸触事件。至于MyViewGroup的子类MyView，就更加不可能接受到ACTION_MOVE和ACTION_UP了。 Activity中ACTION_DOWN的流程图如下： 2. 示例源码点击查看：触摸事件示例3的源码 3. 运行结果3.1 ACTION_DOWN事件点击MyView所在的区域，ACTION_DOWN相关的log如下： D/##skywang-MyActivity( 2371): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2371): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2371): onInterceptTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2371): onInterceptTouchEvent( end ) :DOWN, ret=trueD/##skywang-MyViewGroup( 2371): onTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2371): onTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyViewGroup( 2371): dispatchTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyActivity( 2371): onTouchEvent(start) :DOWND/##skywang-MyActivity( 2371): onTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyActivity( 2371): dispatchTouchEvent( end ) :DOWN, ret=false 说明：很显然，ACTION_DOWN的流程如下：(01) MyActivity收到ACTION_DOWN，进入MyActivity.dispatchTouchEvent()。(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，进入MyViewGroup.dispatchTouchEvent()。(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先进入MyViewGroup.onInterceptTouchEvent()。(04) 紧接着，MyViewGroup会退出MyViewGroup.onInterceptTouchEvent()。此时，MyViewGroup.onInterceptTouchEvent()返回true。表示MyViewGroup拦截了该触摸事件。(05) MyViewGroup在得知自己拦截了触摸事件之后，将触摸事件交给自己的onTouchEvent()进行处理，即进入MyViewGroup.onTouchEvent()。(06) 紧接着，MyViewGroup会退出MyViewGroup.onTouchEvent()。而MyViewGroup自身并没有消费该事件，因此MyViewGroup.onTouchEvent()返回false。(07) 随后，退出MyViewGroup.dispatchTouchEvent()，并返回false。表示MyViewGroup没有接受该触摸事件。(08) MyActivity得知MyViewGroup没有接受该触摸事件之后，就会调用进入MyActivity.onTouchEvent()。(09) 紧接着，MyActivity会退出MyActivity.onTouchEvent()，并返回false。表示MyActivity也没有消费触摸事件。(10) 最后，MyActivity会退出MyActivity.dispatchTouchEvent()，并返回false。表示此次触摸事件没有被消费。 对比，触摸事件示例(一)中的ACTION_DOWN路径。在本示例中，MyViewGroup拦截了ACTION_DOWN，但是没有消费ACTION_DOWN事件。 (01) MyViewGroup拦截了ACTION_DOWN事件，意味着该事件不会继续往下分发。 (02) MyViewGroup没有消费该事件，意味着该事件就继续往上分发。 3.2 ACTION_MOVE事件点击MyView所在的区域，ACTION_MOVE相关的log如下： D/##skywang-MyActivity( 2371): dispatchTouchEvent(start) :MOVED/##skywang-MyActivity( 2371): onTouchEvent(start) :MOVED/##skywang-MyActivity( 2371): onTouchEvent( end ) :MOVE, ret=falseD/##skywang-MyActivity( 2371): dispatchTouchEvent( end ) :MOVE, ret=false 说明：由于MyViewGroup拦截了ACTION_DOWN，却没有消费给ACTION_DOWN；导致ACTION_MOVE不会分发给MyViewGroup。既然没有分发给MyViewGroup，就更加谈不上分发给MyView了。 3.3 ACTION_UP事件点击MyView所在的区域，ACTION_UP相关的log如下： D/##skywang-MyActivity( 2371): dispatchTouchEvent(start) :UPD/##skywang-MyActivity( 2371): onTouchEvent(start) :UPD/##skywang-MyActivity( 2371): onTouchEvent( end ) :UP, ret=falseD/##skywang-MyActivity( 2371): dispatchTouchEvent( end ) :UP, ret=false 说明：ACTION_UP的路径和ACTION_MOVE的路径一样！","link":"/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-03-ViewGroup/"},{"title":"Android 触摸事件机制(五) 触摸事件示例5--ViewGroup没拦截但是却消费了触摸事件","text":"本文将通过示例演示触摸事件的传递流程。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. 示例概述1.1. 示例简介1.2. 示例结论2. 示例源码3. 运行结果 1. 示例概述 1.1 示例简介本文的示例是在触摸事件示例(一)的基础上修改的。与触摸事件示例(一)相比，本文的示例对MyViewGroup中的onTouchEvent()进行了修改。修改后的onTouchEvent()代码如下： @Override public boolean onTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName); // boolean ret = super.onTouchEvent(event); boolean ret = true; Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } 说明：修改后的MyViewGroup没有拦截触摸事件，但是消费了触摸事件。 1.2 示例结论(01) MyViewGroup没有拦截却消费了ACTION_DOWN。由于MyViewGroup没有拦截ACTION_DOWN，因此，该事件会继续分发给MyViewGroup的子类MyView。由于MyViewGroup消费了ACTION_DOWN，因此该事件不会分发给MyActivity的onTouchEvent()。(02) MyViewGroup没有拦截却消费了ACTION_DOWN。那么，MyViewGroup仍然可以接受到ACTION_MOVE和ACTION_UP这两种触摸触事件。但是对于MyView而言，由于MyView没有接受该事件；因此，MyView不会收到ACTION_MOVE和ACTION_UP。 试想想，如果MyView接受了ACTION_DOWN事件的话；它是否会收到ACTION_MOVE和ACTION_UP事件呢？答案是：会。感兴趣的读者可以自行验证。 Activity中ACTION_DOWN的流程图如下： 2. 示例源码点击查看：触摸事件示例5的源码 3. 运行结果3.1 ACTION_DOWN事件点击MyView所在的区域，ACTION_DOWN相关的log如下： D/##skywang-MyActivity( 2950): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2950): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2950): onInterceptTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2950): onInterceptTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyView( 2950): dispatchTouchEvent(start) :DOWND/##skywang-MyView( 2950): onTouchEvent(start) :DOWND/##skywang-MyView( 2950): onTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyView( 2950): dispatchTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyViewGroup( 2950): onTouchEvent(start) :DOWND/##skywang-MyViewGroup( 2950): onTouchEvent( end ) :DOWN, ret=trueD/##skywang-MyViewGroup( 2950): dispatchTouchEvent( end ) :DOWN, ret=trueD/##skywang-MyActivity( 2950): dispatchTouchEvent( end ) :DOWN, ret=true 3.2 ACTION_MOVE事件点击MyView所在的区域，ACTION_MOVE相关的log如下： D/##skywang-MyActivity( 2950): dispatchTouchEvent(start) :MOVED/##skywang-MyViewGroup( 2950): dispatchTouchEvent(start) :MOVED/##skywang-MyViewGroup( 2950): onTouchEvent(start) :MOVED/##skywang-MyViewGroup( 2950): onTouchEvent( end ) :MOVE, ret=trueD/##skywang-MyViewGroup( 2950): dispatchTouchEvent( end ) :MOVE, ret=trueD/##skywang-MyActivity( 2950): dispatchTouchEvent( end ) :MOVE, ret=true 3.3 ACTION_UP事件点击MyView所在的区域，ACTION_UP相关的log如下： D/##skywang-MyActivity( 2950): dispatchTouchEvent(start) :UPD/##skywang-MyViewGroup( 2950): dispatchTouchEvent(start) :UPD/##skywang-MyViewGroup( 2950): onTouchEvent(start) :UPD/##skywang-MyViewGroup( 2950): onTouchEvent( end ) :UP, ret=trueD/##skywang-MyViewGroup( 2950): dispatchTouchEvent( end ) :UP, ret=trueD/##skywang-MyActivity( 2950): dispatchTouchEvent( end ) :UP, ret=true","link":"/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-05-ViewGroup/"},{"title":"Android反编译","text":"本文介绍ubuntu下APK反编译的相关内容。包括：反编译工具下载和环境搭建，反编译的详细步骤。 资源下载和环境搭建1 点击下载android_decompile_tools_ForUbuntu_201309.zip 2 通过以下命令解压资源包 $ unzip android_decompile_tools_ForUbuntu_201309.zip若zip解压工具没有安装，可以通过以下命令安装： $ sudo apt-get install unzip 解压后得到4个文件: apktool1.5.2.tar.bz2dex2jar-0.0.9.15.zipjad158e.linux.intel.ziplibstdc++2.10-glibc2.2_2.95.4-27_i386.deb 3 解压apktool1.5.2.tar.bz2 apktool1.5.2.tar.bz2 是“反编译apk资源”工具，即反编译apk的manifest和res目录。通过以下命令将文件解压到当前目录： $ tar -xvf apktool1.5.2.tar.bz2解压后得到文件 “apktool1.5.2/apktool.jar”。 补充：这里使用的是1.5.2版本的apktool工具。若要下载最新版本的apktool工具，点击链接：http://code.google.com/p/android-apktool/ 4 解压dex2jar-0.0.9.15.zip dex2jar-0.0.9.15.zip 是“将dex转换为jar”工具。 通过以下命令将文件解压到当前目录： $ unzip dex2jar-0.0.9.15.zip解压后得到目录 “dex2jar-0.0.9.15”。 补充：这里使用的是0.0.9.15版本的dex2jar工具。若要下载最新版本的dex2jar工具，点击链接： http://code.google.com/p/dex2jar/ 5 解压 jad158e.linux.intel.zip jad158e.linux.intel.zip 是“将jar还原成java源文件”的工具。通过以下命令将文件解压到当前目录： $ unzip jad158e.linux.intel.zip解压后，得到文件 “jad”。 补充：这里使用的是jad158e版本工具。若要下载最新版本的jad工具，点击链接： http://www.varaneckas.com/jad 6 安装 libstdc++2.10-glibc2.2_2.95.4-27_i386.deb 到 http://archive.debian.net/etch/i386/libstdc++2.10-glibc2.2/download 中下载一个文件，然后通过以下命令安装deb文件： $ dpkg -i libstdc++2.10-glibc2.2_2.95.4-27_i386.deb补充：若不执行这一步。在运行命令”$ ./jad “时，会报“libstdc++-libc6.2-2.so.3 not found”错误！ 7 将反编译工具添加到ubuntu环境变量中 a) 假设第3步中得到的“apktool.jar”目录的路径为： /home/skywang/android/decompile/apktool1.5.2/apktool.jarb) 假设第4步中得到的“dex2jar-0.0.9.15”目录的路径为： /home/skywang/android/decompile/dex2jar-0.0.9.15c) 假设第5步中得到的“jad”文件的路径为： /home/skywang/android/decompile/jad 编辑 ~/.bashrc ，添加以下内容： Android Decompile toolsexport APKTOOL_PATH=/home/skywang/android/decompile/apktool1.5.2/apktool.jarexport JAD_PATH=/home/skywang/android/decompileexport DEX2JAR_PATH=/home/skywang/android/decompile/dex2jar-0.0.9.15export PATH=$PATH:$JAD_PATH:$DEX2JAR_PATH 其中，APKTOOL_PATH是“apktool.jar文件”的路径，JAD_PATH是“jad文件”所在目录，DEX2JAR_PATH是“dex2jar-0.0.9.15目录”的路径，PATH是ubuntu自带的环境变量。 设置完毕之后，重新导入环境变量： $ source ~/.bashrc若重新打开“终端”窗口，则不需要执行“$ source ~/.bashrc”。 补充：可以通过以下命令检查环境变量是否设置成功。 $ echo $APKTOOL_PATH $ echo $PATH显示的内容包括你所添加的路径，则说明环境变量设置成功！ 工具和环境都设置ok之后，接下来讲解反编译步骤。反编译包括2部分：反编译资源 和 反编译源码。 反编译步骤1. 反编译“apk资源”反编译“apk资源”，会得到“manifest文件”和“res目录”。 1.1 准备apk资源 可以通过eclipse新建一个简单的Android工程；然后编译运行。此时，在工程的bin目录下会自动生成一个apk文件。 1.2 反编译资源执行以下命令： $java -jar $APKTOOL_PATH d [apk_path.apk]说明：(01) APKTOOL_PATH 是“apktool.jar路径”对应的环境变量。前面我们已经在~/.bashrc中进行了设置。(02) apk_path.apk 是“apk文件所在的路径”。上诉命令的作用就是：将apk反编译，得到的“manfiest”和“res目录”都是原始资源文件。而“smali”并不是我们需要的代码，我们需要按照下面的步骤来反编译代码。 2. 反编译“apk源码”2.1 解压apk文件通过以下命令解压apk文件到当前目录： $ unzip [apk_path.apk]说明：(01) apk_path.apk 是“apk文件所在的路径”。(02) apk本质上是一个zip格式的压缩文件，所以可以用unzip命令解压缩。 此外，我们可以通过”$ file [apk_path.apk]”来查看apk的文件格式。上诉命令的作用是：解压apk，得到“classes.dex”文件。除了“classes.dex”之外的其它文件，都可以删除。 2.2 将dex转换为jar文件执行以下命令： $ d2j-dex2jar.sh classes.dex说明：上诉命令的作用是：在当前目录，生成一个“classes_dex2jar.jar”文件。 2.3 解压classes_dex2jar.jar文件新建目录”folder”，并将classes_dex2jar.jar解压到该目录下。执行以下命令： $ mkdir folder $ unzip classes_dex2jar.jar -d folder说明：(01) mkdir 的作用是，新建目录folder。(02) unzip 的作用是，将classes_dex2jar.jar解压到folder目录下。 2.4 将class转为java文件执行以下命令： $ jad -o -r -sjava -dsrc folder/**/*.class说明：执行上诉命令，会在当前目录生成“src”目录，并且“src”中的全部文件都是java源文件。 至此，就完成了“反编译得到java源文件”的工作！","link":"/2014/07/21/android/tools/compile/2014-07-21-Decompile/"},{"title":"Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例","text":"上一章，我们学习了Collection的架构。这一章开始，我们对Collection的具体实现类进行讲解；首先，讲解List，而List中ArrayList又最为常用。因此，本章我们讲解ArrayList。先对ArrayList有个整体认识，再学习它的源码，最后再通过例子来学习如何使用它。内容包括： 目录第1部分 ArrayList简介第2部分 ArrayList数据结构第3部分 ArrayList源码解析(基于JDK1.6.0_45)第4部分 ArrayList遍历方式第5部分 toArray()异常第6部分 ArrayList示例 第1部分 ArrayList介绍ArrayList简介ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 ArrayList构造函数// 默认构造函数 ArrayList() // capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。 ArrayList(int capacity) // 创建一个包含collection的ArrayList ArrayList(Collection&lt;? extends E&gt; collection)ArrayList的API// Collection中定义的API boolean add(E object) boolean addAll(Collection&lt;? extends E&gt; collection) void clear() boolean contains(Object object) boolean containsAll(Collection&lt;?&gt; collection) boolean equals(Object object) int hashCode() boolean isEmpty() Iterator&lt;E&gt; iterator() boolean remove(Object object) boolean removeAll(Collection&lt;?&gt; collection) boolean retainAll(Collection&lt;?&gt; collection) int size() &lt;T&gt; T[] toArray(T[] array) Object[] toArray() // AbstractCollection中定义的API void add(int location, E object) boolean addAll(int location, Collection&lt;? extends E&gt; collection) E get(int location) int indexOf(Object object) int lastIndexOf(Object object) ListIterator&lt;E&gt; listIterator(int location) ListIterator&lt;E&gt; listIterator() E remove(int location) E set(int location, E object) List&lt;E&gt; subList(int start, int end) // ArrayList新增的API Object clone() void ensureCapacity(int minimumCapacity) void trimToSize() void removeRange(int fromIndex, int toIndex) 第2部分 ArrayList数据结构ArrayList的继承关系 java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.ArrayList&lt;E&gt;ArrayList类声明 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}ArrayList与Collection关系如下图： ArrayList包含了两个重要的对象：elementData 和 size。 (01) elementData 是”Object[]类型的数组”，它保存了添加到ArrayList中的元素。实际上，elementData是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity)来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数ArrayList()来创建ArrayList，则elementData的容量默认是10。elementData数组的大小会根据ArrayList容量的增长而动态的增长，具体的增长方式，请参考源码分析中的ensureCapacity()函数。 (02) size 则是动态数组的实际大小。 第3部分 ArrayList源码解析(基于JDK1.6.0_45)为了更了解ArrayList的原理，下面对ArrayList源码代码作出分析。ArrayList是通过数组实现的，源码比较容易理解。 package java.util; public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable { // 序列版本号 private static final long serialVersionUID = 8683452581122892189L; // 保存ArrayList中数据的数组 private transient Object[] elementData; // ArrayList中实际数据的数量 private int size; // ArrayList带容量大小的构造函数。 public ArrayList(int initialCapacity) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); // 新建一个数组 this.elementData = new Object[initialCapacity]; } // ArrayList构造函数。默认容量是10。 public ArrayList() { this(10); } // 创建一个包含collection的ArrayList public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } // 将当前容量值设为 =实际元素个数 public void trimToSize() { modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) { elementData = Arrays.copyOf(elementData, size); } } // 确定ArrarList的容量。 // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1” public void ensureCapacity(int minCapacity) { // 将“修改统计数”+1 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity &gt; oldCapacity) { Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); } } // 添加元素e public boolean add(E e) { // 确定ArrayList的容量大小 ensureCapacity(size + 1); // Increments modCount!! // 添加e到ArrayList中 elementData[size++] = e; return true; } // 返回ArrayList的实际大小 public int size() { return size; } // 返回ArrayList是否包含Object(o) public boolean contains(Object o) { return indexOf(o) &gt;= 0; } // 返回ArrayList是否为空 public boolean isEmpty() { return size == 0; } // 正向查找，返回元素的索引值 public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1; } // 反向查找，返回元素的索引值 public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值 public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } // 返回ArrayList的Object数组 public Object[] toArray() { return Arrays.copyOf(elementData, size); } // 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) { // 若数组a的大小 &lt; ArrayList的元素个数； // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中 if (a.length &lt; size) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // 若数组a的大小 &gt;= ArrayList的元素个数； // 则将ArrayList的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; } // 获取index位置的元素值 public E get(int index) { RangeCheck(index); return (E) elementData[index]; } // 设置index位置的值为element public E set(int index, E element) { RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; } // 将e添加到ArrayList中 public boolean add(E e) { ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; } // 将e添加到ArrayList的指定位置 public void add(int index, E element) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot;+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } // 删除ArrayList指定位置的元素 public E remove(int index) { RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; } // 删除ArrayList的指定元素 public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // 快速删除第index个元素 private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; // 从&quot;index+1&quot;开始，用后面的元素替换前面的元素。 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设为null elementData[--size] = null; // Let gc do its work } // 删除元素 public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { // 便利ArrayList，找到“元素o”，则删除，并返回true。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // 清空ArrayList，将全部的元素设为null public void clear() { modCount++; for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; } // 将集合c追加到ArrayList中 public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } // 从index位置开始，将集合c添加到ArrayList public boolean addAll(int index, Collection&lt;? extends E&gt; c) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( &quot;Index: &quot; + index + &quot;, Size: &quot; + size); Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } // 删除fromIndex到toIndex之间的全部元素。 protected void removeRange(int fromIndex, int toIndex) { modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newSize = size - (toIndex-fromIndex); while (size != newSize) elementData[--size] = null; } private void RangeCheck(int index) { if (index &gt;= size) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot;+size); } // 克隆函数 public Object clone() { try { ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); // 将当前ArrayList的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); } } // java.io.Serializable的写入函数 // 将ArrayList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // 写入“数组的容量” s.writeInt(elementData.length); // 写入“数组的每一个元素” for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } // java.io.Serializable的读取函数：根据写入方式读出 // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // 从输入流中读取ArrayList的“容量” int arrayLength = s.readInt(); Object[] a = elementData = new Object[arrayLength]; // 从输入流中将“所有的元素值”读出 for (int i=0; i&lt;size; i++) a[i] = s.readObject(); } }总结：(01) ArrayList 实际上是通过一个数组去保存数据的。当我们构造ArrayList时；若使用默认构造函数，则ArrayList的默认容量大小是10。(02) 当ArrayList容量不足以容纳全部元素时，ArrayList会重新设置容量：新的容量=“(原始容量x3)/2 + 1”。(03) ArrayList的克隆函数，即是将全部元素克隆到一个数组中。(04) ArrayList实现java.io.Serializable的方式。当写入到输出流时，先写入“容量”，再依次写入“每一个元素”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 第4部分 ArrayList遍历方式ArrayList支持3种遍历方式 (01) 第一种，通过迭代器遍历。即通过Iterator去遍历。 Integer value = null; Iterator iter = list.iterator(); while (iter.hasNext()) { value = (Integer)iter.next(); }(02) 第二种，随机访问，通过索引值去遍历。由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。 Integer value = null; int size = list.size(); for (int i=0; i&lt;size; i++) { value = (Integer)list.get(i); }(03) 第三种，for循环遍历。如下： Integer value = null; for (Integer integ:list) { value = integ; }下面通过一个实例，比较这3种方式的效率，实例代码(ArrayListRandomAccessTest.java)如下： import java.util.*; import java.util.concurrent.*; /* * @desc ArrayList遍历方式和效率的测试程序。 * * @author skywang */ public class ArrayListRandomAccessTest { public static void main(String[] args) { List list = new ArrayList(); for (int i=0; i&lt;100000; i++) list.add(i); //isRandomAccessSupported(list); iteratorThroughRandomAccess(list) ; iteratorThroughIterator(list) ; iteratorThroughFor2(list) ; } private static void isRandomAccessSupported(List list) { if (list instanceof RandomAccess) { System.out.println(&quot;RandomAccess implemented!&quot;); } else { System.out.println(&quot;RandomAccess not implemented!&quot;); } } public static void iteratorThroughRandomAccess(List list) { long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i=0; i&lt;list.size(); i++) { list.get(i); } endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughRandomAccess：&quot; + interval+&quot; ms&quot;); } public static void iteratorThroughIterator(List list) { long startTime; long endTime; startTime = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext(); ) { iter.next(); } endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughIterator：&quot; + interval+&quot; ms&quot;); } public static void iteratorThroughFor2(List list) { long startTime; long endTime; startTime = System.currentTimeMillis(); for(Object obj:list) ; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;); } }运行结果： iteratorThroughRandomAccess：3 ms iteratorThroughIterator：8 ms iteratorThroughFor2：5 ms由此可见，遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低！ 第5部分 toArray()异常当我们调用ArrayList中的 toArray()，可能遇到过抛出“java.lang.ClassCastException”异常的情况。下面我们说说这是怎么回事。 ArrayList提供了2个toArray()函数： Object[] toArray() &lt;T&gt; T[] toArray(T[] contents)调用 toArray() 函数会抛出“java.lang.ClassCastException”异常，但是调用 toArray(T[] contents) 能正常返回 T[]。 toArray() 会抛出异常是因为 toArray() 返回的是 Object[] 数组，将 Object[] 转换为其它类型(如如，将Object[]转换为的Integer[])则会抛出“java.lang.ClassCastException”异常，因为Java不支持向下转型。具体的可以参考前面ArrayList.java的源码介绍部分的toArray()。解决该问题的办法是调用 T[] toArray(T[] contents) ， 而不是 Object[] toArray()。 调用 toArray(T[] contents) 返回T[]的可以通过以下几种方式实现。 // toArray(T[] contents)调用方式一 public static Integer[] vectorToArray1(ArrayList&lt;Integer&gt; v) { Integer[] newText = new Integer[v.size()]; v.toArray(newText); return newText; }// toArray(T[] contents)调用方式二。最常用！ public static Integer[] vectorToArray2(ArrayList&lt;Integer&gt; v) { Integer[] newText = (Integer[])v.toArray(new Integer[0]); return newText; }// toArray(T[] contents)调用方式三 public static Integer[] vectorToArray3(ArrayList&lt;Integer&gt; v) { Integer[] newText = new Integer[v.size()]; Integer[] newStrings = (Integer[])v.toArray(newText); return newStrings; } 第6部分 ArrayList示例本文通过一个实例(ArrayListTest.java)，介绍 ArrayList 中常用API的用法。 import java.util.*; /* * @desc ArrayList常用API的测试程序 * @author skywang * @email kuiwu-wang@163.com */ public class ArrayListTest { public static void main(String[] args) { // 创建ArrayList ArrayList list = new ArrayList(); // 将“” list.add(&quot;1&quot;); list.add(&quot;2&quot;); list.add(&quot;3&quot;); list.add(&quot;4&quot;); // 将下面的元素添加到第1个位置 list.add(0, &quot;5&quot;); // 获取第1个元素 System.out.println(&quot;the first element is: &quot;+ list.get(0)); // 删除“3” list.remove(&quot;3&quot;); // 获取ArrayList的大小 System.out.println(&quot;Arraylist size=: &quot;+ list.size()); // 判断list中是否包含&quot;3&quot; System.out.println(&quot;ArrayList contains 3 is: &quot;+ list.contains(3)); // 设置第2个元素为10 list.set(1, &quot;10&quot;); // 通过Iterator遍历ArrayList for(Iterator iter = list.iterator(); iter.hasNext(); ) { System.out.println(&quot;next is: &quot;+ iter.next()); } // 将ArrayList转换为数组 String[] arr = (String[])list.toArray(new String[0]); for (String str:arr) System.out.println(&quot;str: &quot;+ str); // 清空ArrayList list.clear(); // 判断ArrayList是否为空 System.out.println(&quot;ArrayList is empty: &quot;+ list.isEmpty()); } }运行结果： the first element is: 5 Arraylist size=: 4 ArrayList contains 3 is: false next is: 5 next is: 10 next is: 2 next is: 4 str: 5 str: 10 str: 2 str: 4 ArrayList is empty: true更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/03/java/collection/2012-02-03-collection-03-arraylist/"},{"title":"Java Annotation认知(包括框架图、详细介绍、示例说明)","text":"Java Annotation是JDK5.0引入的一种注释机制。 网上很多关于Java Annotation的文章，看得人眼花缭乱。Java Annotation本来很简单的，结果说的人没说清楚；弄的看的人更加迷糊。 我按照自己的思路，对Annotation进行了整理。理解 Annotation 的关键，是理解Annotation的语法和用法，对这些内容，我都进行了详细说明；理解Annotation的语法和用法之后，再看Annotation的框架图，可能有更深刻体会。废话就说这么多，下面开始对Annotation进行说明。若您发现文章中存在错误或不足的地方，希望您能指出！ 目录第1部分 Annotation架构第2部分 Annotation组成部分第3部分 java自带的Annotation第4部分 Annotation 的作用 第1部分 Annotation架构先看看Annotation的架构图： 从中，我们可以看出：(01) 1个Annotation 和 1个RetentionPolicy关联。&nbsp;&nbsp;&nbsp;&nbsp; 可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。 (02) 1个Annotation 和 1~n个ElementType关联。&nbsp;&nbsp;&nbsp;&nbsp; 可以理解为：对于每1个Annotation对象，可以有若干个ElementType属性。 (03) Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override等等。&nbsp;&nbsp;&nbsp;&nbsp; Annotation 的每一个实现类，都“和1个RetentionPolicy关联”并且“和1~n个ElementType关联”。 下面，我先介绍框架图的左半边(如下图)，即Annotation, RetentionPolicy, ElementType；然后在就Annotation的实现类进行举例说明。 第2部分 Annotation组成部分1. annotation组成成分java annotation 的组成中，有3个非常重要的主干类。它们分别是： (01) Annotation.java package java.lang.annotation; public interface Annotation { boolean equals(Object obj); int hashCode(); String toString(); Class&lt;? extends Annotation&gt; annotationType(); }(02) ElementType.java package java.lang.annotation; public enum ElementType { TYPE, /* 类、接口（包括注释类型）或枚举声明 */ FIELD, /* 字段声明（包括枚举常量） */ METHOD, /* 方法声明 */ PARAMETER, /* 参数声明 */ CONSTRUCTOR, /* 构造方法声明 */ LOCAL_VARIABLE, /* 局部变量声明 */ ANNOTATION_TYPE, /* 注释类型声明 */ PACKAGE /* 包声明 */ }(03) RetentionPolicy.java package java.lang.annotation; public enum RetentionPolicy { SOURCE, /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了 */ CLASS, /* 编译器将Annotation存储于类对应的.class文件中。默认行为 */ RUNTIME /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */ }说明：(01) Annotation 就是个接口。&nbsp;&nbsp;&nbsp;&nbsp; “每1个Annotation” 都与 “1个RetentionPolicy”关联，并且与 “1～n个ElementType”关联。可以通俗的理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性；至于ElementType属性，则有1~n个。 (02) ElementType 是Enum枚举类型，它用来指定Annotation的类型。&nbsp;&nbsp;&nbsp;&nbsp; “每1个Annotation” 都与 “1～n个ElementType”关联。当Annotation与某个ElementType关联时，就意味着：Annotation有了某种用途。&nbsp;&nbsp;&nbsp;&nbsp; 例如，若一个Annotation对象是METHOD类型，则该Annotation只能用来修饰方法。 (03) RetentionPolicy 是Enum枚举类型，它用来指定Annotation的策略。通俗点说，就是不同RetentionPolicy类型的Annotation的作用域不同。&nbsp;&nbsp;&nbsp;&nbsp; “每1个Annotation” 都与 “1个RetentionPolicy”关联。&nbsp;&nbsp;&nbsp;&nbsp; a) 若Annotation的类型为 SOURCE，则意味着：Annotation仅存在于编译器处理期间，编译器处理完之后，该Annotation就没用了。&nbsp;&nbsp;&nbsp;&nbsp; 例如，“ @Override ”标志就是一个Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，“@Override”就没有任何作用了。&nbsp;&nbsp;&nbsp;&nbsp; b) 若Annotation的类型为 CLASS，则意味着：编译器将Annotation存储于类对应的.class文件中，它是Annotation的默认行为。&nbsp;&nbsp;&nbsp;&nbsp; c) 若Annotation的类型为 RUNTIME，则意味着：编译器将Annotation存储于class文件中，并且可由JVM读入。 这时，只需要记住“每1个Annotation” 都与 “1个RetentionPolicy”关联，并且与 “1～n个ElementType”关联。学完后面的内容之后，再回头看这些内容，会更容易理解。 第3部分 java自带的Annotation理解了上面的3个类的作用之后，我们接下来可以讲解Annotation实现类的语法定义了。 1 Annotation通用定义@Documented @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation1 { }说明：上面的作用是定义一个Annotation，它的名字是MyAnnotation1。定义了MyAnnotation1之后，我们可以在代码中通过“@MyAnnotation1”来使用它。 其它的，@Documented, @Target, @Retention, @interface都是来修饰MyAnnotation1的。下面分别说说它们的含义：(01) @interface&nbsp;&nbsp;&nbsp;&nbsp; 使用@interface定义注解时，意味着它实现了java.lang.annotation.Annotation接口，即该注解就是一个Annotation。&nbsp;&nbsp;&nbsp;&nbsp; 定义Annotation时，@interface是必须的。&nbsp;&nbsp;&nbsp;&nbsp; 注意：它和我们通常的implemented实现接口的方法不同。Annotation接口的实现细节都由编译器完成。通过@interface定义注解后，该注解不能继承其他的注解或接口。 (02) @Documented&nbsp;&nbsp;&nbsp;&nbsp; 类和方法的Annotation在缺省情况下是不出现在javadoc中的。如果使用@Documented修饰该Annotation，则表示它可以出现在javadoc中。&nbsp;&nbsp;&nbsp;&nbsp; 定义Annotation时，@Documented可有可无；若没有定义，则Annotation不会出现在javadoc中。 (03) @Target(ElementType.TYPE)&nbsp;&nbsp;&nbsp;&nbsp; 前面我们说过，ElementType 是Annotation的类型属性。而@Target的作用，就是来指定Annotation的类型属性。&nbsp;&nbsp;&nbsp;&nbsp; @Target(ElementType.TYPE) 的意思就是指定该Annotation的类型是ElementType.TYPE。这就意味着，MyAnnotation1是来修饰“类、接口（包括注释类型）或枚举声明”的注解。&nbsp;&nbsp;&nbsp;&nbsp; 定义Annotation时，@Target可有可无。若有@Target，则该Annotation只能用于它所指定的地方；若没有@Target，则该Annotation可以用于任何地方。 (04) @Retention(RetentionPolicy.RUNTIME)&nbsp;&nbsp;&nbsp;&nbsp; 前面我们说过，RetentionPolicy 是Annotation的策略属性，而@Retention的作用，就是指定Annotation的策略属性。&nbsp;&nbsp;&nbsp;&nbsp; @Retention(RetentionPolicy.RUNTIME) 的意思就是指定该Annotation的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将该Annotation信息保留在.class文件中，并且能被虚拟机读取。&nbsp;&nbsp;&nbsp;&nbsp; 定义Annotation时，@Retention可有可无。若没有@Retention，则默认是RetentionPolicy.CLASS。 2 java自带的Annotation通过上面的示例，我们能理解：@interface用来声明Annotation，@Documented用来表示该Annotation是否会出现在javadoc中， @Target用来指定Annotation的类型，@Retention用来指定Annotation的策略。 理解这一点之后，我们就很容易理解java中自带的Annotation的实现类，即Annotation架构图的右半边。如下图： java 常用的Annotation： 标注 说明 @Deprecated @Deprecated 所标注内容，不再被建议使用。 @Override @Override 只能标注方法，表示该方法覆盖父类中的方法。 @Documented @Documented 所标注内容，可以出现在javadoc中。 @Inherited @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。 @Retention @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。 @Target @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。 @SuppressWarnings @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。 由于“@Deprecated和@Override”类似，“@Documented, @Inherited, @Retention, @Target”类似；下面，我们只对@Deprecated, @Inherited, @SuppressWarnings 这3个Annotation进行说明。 2.1 @Deprecated@Deprecated 的定义如下： @Documented @Retention(RetentionPolicy.RUNTIME) public @interface Deprecated { }说明：(01) @interface – 它的用来修饰Deprecated，意味着Deprecated实现了java.lang.annotation.Annotation接口；即Deprecated就是一个注解。 (02) @Documented – 它的作用是说明该注解能出现在javadoc中。 (03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Deprecated的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated的信息保留在.class文件中，并且能被虚拟机读取。 (04) @Deprecated 所标注内容，不再被建议使用。&nbsp;&nbsp;&nbsp;&nbsp; 例如，若某个方法被 @Deprecated 标注，则该方法不再被建议使用。如果有开发人员试图使用或重写被@Deprecated标示的方法，编译器会给相应的提示信息。示例如下: 源码如下(DeprecatedTest.java)： package com.skywang.annotation; import java.util.Date; import java.util.Calendar; public class DeprecatedTest { // @Deprecated 修饰 getString1(),表示 它是建议不被使用的函数 @Deprecated private static void getString1(){ System.out.println(&quot;Deprecated Method&quot;); } private static void getString2(){ System.out.println(&quot;Normal Method&quot;); } // Date是日期/时间类。java已经不建议使用该类了 private static void testDate() { Date date = new Date(113, 8, 25); System.out.println(date.getYear()); } // Calendar是日期/时间类。java建议使用Calendar取代Date表示“日期/时间” private static void testCalendar() { Calendar cal = Calendar.getInstance(); System.out.println(cal.get(Calendar.YEAR)); } public static void main(String[] args) { getString1(); getString2(); testDate(); testCalendar(); } }说明：上面是eclipse中的截图，比较类中 “getString1() 和 getString2()” 以及 “testDate() 和 testCalendar()” 。 (01) getString1() 被@Deprecated标注，意味着建议不再使用getString1()；所以getString1()的定义和调用时，都会一横线。这一横线是eclipse()对@Deprecated方法的处理。getString2() 没有被@Deprecated标注，它的显示正常。 (02) testDate() 调用了Date的相关方法，而java已经建议不再使用Date操作日期/时间。因此，在调用Date的API时，会产生警告信息，途中的warnings。testCalendar() 调用了Calendar的API来操作日期/时间，java建议用Calendar取代Date。因此，操作Calendar不回产生warning。 2.2 @Inherited@Inherited 的定义如下： @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Inherited { }说明：(01) @interface – 它的用来修饰Inherited，意味着Inherited实现了java.lang.annotation.Annotation接口；即Inherited就是一个注解。 (02) @Documented – 它的作用是说明该注解能出现在javadoc中。 (03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Inherited的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Inherited的信息保留在.class文件中，并且能被虚拟机读取。 (04) @Target(ElementType.ANNOTATION_TYPE) – 它的作用是指定Inherited的类型是ANNOTATION_TYPE。这就意味着，@Inherited只能被用来标注“Annotation类型”。 (05) @Inherited 的含义是，它所标注的Annotation将具有继承性。&nbsp;&nbsp;&nbsp;&nbsp; 假设，我们定义了某个Annotaion，它的名称是MyAnnotation，并且MyAnnotation被标注为@Inherited。现在，某个类Base使用了MyAnnotation，则Base具有了“具有了注解MyAnnotation”；现在，Sub继承了Base，由于MyAnnotation是@Inherited的(具有继承性)，所以，Sub也“具有了注解MyAnnotation”。 @Inherited的使用示例源码如下(InheritableSon.java)： /** * @Inherited 演示示例 * * @author skywang * @email kuiwu-wang@163.com */ package com.skywang.annotation; import java.lang.annotation.Target; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Inherited; /** * 自定义的Annotation。 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Inherited @interface Inheritable { } @Inheritable class InheritableFather { public InheritableFather() { // InheritableBase是否具有 Inheritable Annotation System.out.println(&quot;InheritableFather:&quot;+InheritableFather.class.isAnnotationPresent(Inheritable.class)); } } /** * InheritableSon 类只是继承于 InheritableFather， */ public class InheritableSon extends InheritableFather { public InheritableSon() { super(); // 调用父类的构造函数 // InheritableSon类是否具有 Inheritable Annotation System.out.println(&quot;InheritableSon:&quot;+InheritableSon.class.isAnnotationPresent(Inheritable.class)); } public static void main(String[] args) { InheritableSon is = new InheritableSon(); } }运行结果： InheritableFather:true InheritableSon:true现在，我们对InheritableSon.java进行修改：注释掉“Inheritable的@Inherited注解”。源码如下(InheritableSon.java)： /** * @Inherited 演示示例 * * @author skywang * @email kuiwu-wang@163.com */ package com.skywang.annotation; import java.lang.annotation.Target; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Inherited; /** * 自定义的Annotation。 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) //@Inherited @interface Inheritable { } @Inheritable class InheritableFather { public InheritableFather() { // InheritableBase是否具有 Inheritable Annotation System.out.println(&quot;InheritableFather:&quot;+InheritableFather.class.isAnnotationPresent(Inheritable.class)); } } /** * InheritableSon 类只是继承于 InheritableFather， */ public class InheritableSon extends InheritableFather { public InheritableSon() { super(); // 调用父类的构造函数 // InheritableSon类是否具有 Inheritable Annotation System.out.println(&quot;InheritableSon:&quot;+InheritableSon.class.isAnnotationPresent(Inheritable.class)); } public static void main(String[] args) { InheritableSon is = new InheritableSon(); } }运行结果： InheritableFather:true InheritableSon:false对比上面的两个结果，我们发现：当注解Inheritable被@Inherited标注时，它具有继承性。否则，没有继承性。 2.3 @SuppressWarnings@SuppressWarnings 的定义如下： @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) @Retention(RetentionPolicy.SOURCE) public @interface SuppressWarnings { String[] value(); }说明：(01) @interface – 它的用来修饰SuppressWarnings，意味着SuppressWarnings实现了java.lang.annotation.Annotation接口；即SuppressWarnings就是一个注解。 (02) @Retention(RetentionPolicy.SOURCE) – 它的作用是指定SuppressWarnings的策略是RetentionPolicy.SOURCE。这就意味着，SuppressWarnings信息仅存在于编译器处理期间，编译器处理完之后SuppressWarnings就没有作用了。 (03) @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) – 它的作用是指定SuppressWarnings的类型同时包括TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE。 TYPE意味着，它能标注“类、接口（包括注释类型）或枚举声明”。FIELD意味着，它能标注“字段声明”。METHOD意味着，它能标注“方法”。PARAMETER意味着，它能标注“参数”。CONSTRUCTOR意味着，它能标注“构造方法”。LOCAL_VARIABLE意味着，它能标注“局部变量”。 (04) String[] value(); 意味着，SuppressWarnings能指定参数 (05) SuppressWarnings 的作用是，让编译器对“它所标注的内容”的某些警告保持静默。例如，”@SuppressWarnings(value={“deprecation”, “unchecked”})” 表示对“它所标注的内容”中的 “SuppressWarnings不再建议使用警告”和“未检查的转换时的警告”保持沉默。示例如下： 源码如下(SuppressWarningTest.java)： package com.skywang.annotation; import java.util.Date; public class SuppressWarningTest { //@SuppressWarnings(value={&quot;deprecation&quot;}) public static void doSomething(){ Date date = new Date(113, 8, 26); System.out.println(date); } public static void main(String[] args) { doSomething(); } }说明：(01) 左边的图中，没有使用 @SuppressWarnings(value={“deprecation”}) , 而Date属于java不再建议使用的类。因此，调用Date的API时，会产生警告。而右边的图中，使用了 @SuppressWarnings(value={“deprecation”})。因此，编译器对“调用Date的API产生的警告”保持沉默。 补充：SuppressWarnings 常用的关键字的表格 关键字 说明 deprecation 使用了不赞成使用的类或方法时的警告 unchecked 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。 fallthrough 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。 path 在类路径、源文件路径等中有不存在的路径时的警告。 serial 当在可序列化的类上缺少 serialVersionUID 定义时的警告。 finally 任何 finally 子句不能正常完成时的警告。 all 关于以上所有情况的警告。 第4部分 Annotation 的作用Annotation 是一个辅助类，它在Junit、Struts、Spring等工具框架中被广泛使用。 我们在编程中经常会使用到的Annotation作用有： 1 编译检查Annotation具有“让编译器进行编译检查的作用”。 例如，@SuppressWarnings, @Deprecated和@Override都具有编译检查作用。 (01) 关于@SuppressWarnings和@Deprecated，已经在“第3部分”中详细介绍过了。这里就不再举例说明了。 (02) 若某个方法被 @Override的 标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被@Override标示，但父类中却没有“被@Override标注”的同名方法，则编译器会报错。示例如下： 源码(OverrideTest.java): package com.skywang.annotation; /** * @Override测试程序 * * @author skywang * @email kuiwu-wang@163.com */ public class OverrideTest { /** * toString() 在java.lang.Object中定义； * 因此，这里用 @Override 标注是对的。 */ @Override public String toString(){ return &quot;Override toString&quot;; } /** * getString() 没有在OverrideTest的任何父类中定义； * 但是，这里却用 @Override 标注，因此会产生编译错误！ */ @Override public String getString(){ return &quot;get toString&quot;; } public static void main(String[] args) { } }上面是该程序在eclipse中的截图。从中，我们可以发现“getString()”函数会报错。这是因为“getString() 被@Override所标注，但在OverrideTest的任何父类中都没有定义getString1()函数”。“将getString() 上面的@Override注释掉”，即可解决该错误。 2 在反射中使用Annotation在反射的Class, Method, Field等函数中，有许多于Annotation相关的接口。这也意味着，我们可以在反射中解析并使用Annotation。源码如下(AnnotationTest.java)： package com.skywang.annotation; import java.lang.annotation.Annotation; import java.lang.annotation.Target; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Inherited; import java.lang.reflect.Method; /** * Annotation在反射函数中的使用示例 * * @author skywang * @email kuiwu-wang@163.com */ @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation { String[] value() default &quot;unknown&quot;; } /** * Person类。它会使用MyAnnotation注解。 */ class Person { /** * empty()方法同时被 &quot;@Deprecated&quot; 和 “@MyAnnotation(value={&quot;a&quot;,&quot;b&quot;})”所标注 * (01) @Deprecated，意味着empty()方法，不再被建议使用 * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot; */ @MyAnnotation @Deprecated public void empty(){ System.out.println(&quot;\\nempty&quot;); } /** * sombody() 被 @MyAnnotation(value={&quot;girl&quot;,&quot;boy&quot;}) 所标注， * @MyAnnotation(value={&quot;girl&quot;,&quot;boy&quot;}), 意味着MyAnnotation的value值是{&quot;girl&quot;,&quot;boy&quot;} */ @MyAnnotation(value={&quot;girl&quot;,&quot;boy&quot;}) public void somebody(String name, int age){ System.out.println(&quot;\\nsomebody: &quot;+name+&quot;, &quot;+age); } } public class AnnotationTest { public static void main(String[] args) throws Exception { // 新建Person Person person = new Person(); // 获取Person的Class实例 Class&lt;Person&gt; c = Person.class; // 获取 somebody() 方法的Method实例 Method mSomebody = c.getMethod(&quot;somebody&quot;, new Class[]{String.class, int.class}); // 执行该方法 mSomebody.invoke(person, new Object[]{&quot;lily&quot;, 18}); iteratorAnnotations(mSomebody); // 获取 somebody() 方法的Method实例 Method mEmpty = c.getMethod(&quot;empty&quot;, new Class[]{}); // 执行该方法 mEmpty.invoke(person, new Object[]{}); iteratorAnnotations(mEmpty); } public static void iteratorAnnotations(Method method) { // 判断 somebody() 方法是否包含MyAnnotation注解 if(method.isAnnotationPresent(MyAnnotation.class)){ // 获取该方法的MyAnnotation注解实例 MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class); // 获取 myAnnotation的值，并打印出来 String[] values = myAnnotation.value(); for (String str:values) System.out.printf(str+&quot;, &quot;); System.out.println(); } // 获取方法上的所有注解，并打印出来 Annotation[] annotations = method.getAnnotations(); for(Annotation annotation : annotations){ System.out.println(annotation); } } }运行结果： somebody: lily, 18 girl, boy, @com.skywang.annotation.MyAnnotation(value=[girl, boy]) empty unknown, @com.skywang.annotation.MyAnnotation(value=[unknown]) @java.lang.Deprecated()3 根据Annotation生成帮助文档通过给Annotation注解加上@Documented标签，能使该Annotation标签出现在javadoc中。 4 能够帮忙查看查看代码通过@Override, @Deprecated等，我们能很方便的了解程序的大致结构。另外，我们也可以通过自定义Annotation来实现一些功能。","link":"/2012/03/03/java/others/2012-03-03-annotation/"},{"title":"Java多线程系列--“基础篇”04之 synchronized关键字","text":"本章，会对synchronized关键字进行介绍。 目录1. synchronized原理2. synchronized基本规则3. synchronized方法 和 synchronized代码块4. 实例锁 和 全局锁 1. synchronized原理在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。 当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。 不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。 2. synchronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。 第一条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 第一条当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。下面是“synchronized代码块”对应的演示程序。 class MyRunable implements Runnable { @Override public void run() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + &quot; loop &quot; + i); } } catch (InterruptedException ie) { } } } } public class Demo1_1 { public static void main(String[] args) { Runnable demo = new MyRunable(); // 新建“Runnable对象” Thread t1 = new Thread(demo, &quot;t1&quot;); // 新建“线程t1”, t1是基于demo这个Runnable对象 Thread t2 = new Thread(demo, &quot;t2&quot;); // 新建“线程t2”, t2是基于demo这个Runnable对象 t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” } }运行结果： t1 loop 0 t1 loop 1 t1 loop 2 t1 loop 3 t1 loop 4 t2 loop 0 t2 loop 1 t2 loop 2 t2 loop 3 t2 loop 4结果说明：run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于”demo这个Runnable对象”创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。 如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下： class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + &quot; loop &quot; + i); } } catch (InterruptedException ie) { } } } } public class Demo1_2 { public static void main(String[] args) { Thread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” Thread t2 = new MyThread(&quot;t2&quot;); // 新建“线程t2” t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” } }代码说明：比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？运行结果： t1 loop 0 t2 loop 0 t1 loop 1 t2 loop 1 t1 loop 2 t2 loop 2 t1 loop 3 t2 loop 3 t1 loop 4 t2 loop 4结果说明：如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。 第二条当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。下面是“synchronized代码块”对应的演示程序。 class Count { // 含有synchronized同步块的方法 public void synMethod() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i); } } catch (InterruptedException ie) { } } } // 非同步的方法 public void nonSynMethod() { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i); } } catch (InterruptedException ie) { } } } public class Demo2 { public static void main(String[] args) { final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() { @Override public void run() { count.synMethod(); } }, &quot;t1&quot;); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() { @Override public void run() { count.nonSynMethod(); } }, &quot;t2&quot;); t1.start(); // 启动t1 t2.start(); // 启动t2 } }运行结果： t1 synMethod loop 0 t2 nonSynMethod loop 0 t1 synMethod loop 1 t2 nonSynMethod loop 1 t1 synMethod loop 2 t2 nonSynMethod loop 2 t1 synMethod loop 3 t2 nonSynMethod loop 3 t1 synMethod loop 4 t2 nonSynMethod loop 4结果说明：主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。 第三条当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下： class Count { // 含有synchronized同步块的方法 public void synMethod() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i); } } catch (InterruptedException ie) { } } } // 也包含synchronized同步块的方法 public void nonSynMethod() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i); } } catch (InterruptedException ie) { } } } } public class Demo3 { public static void main(String[] args) { final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() { @Override public void run() { count.synMethod(); } }, &quot;t1&quot;); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() { @Override public void run() { count.nonSynMethod(); } }, &quot;t2&quot;); t1.start(); // 启动t1 t2.start(); // 启动t2 } }运行结果： t1 synMethod loop 0 t1 synMethod loop 1 t1 synMethod loop 2 t1 synMethod loop 3 t1 synMethod loop 4 t2 nonSynMethod loop 0 t2 nonSynMethod loop 1 t2 nonSynMethod loop 2 t2 nonSynMethod loop 3 t2 nonSynMethod loop 4结果说明：主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。 3. synchronized方法 和 synchronized代码块“synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。 synchronized方法示例 public synchronized void foo1() { System.out.println(&quot;synchronized methoed&quot;); }synchronized代码块 public void foo2() { synchronized (this) { System.out.println(&quot;synchronized methoed&quot;); } }synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。 synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。下面通过一个示例来演示： // Demo4.java的源码 public class Demo4 { public synchronized void synMethod() { for(int i=0; i&lt;1000000; i++) ; } public void synBlock() { synchronized( this ) { for(int i=0; i&lt;1000000; i++) ; } } public static void main(String[] args) { Demo4 demo = new Demo4(); long start, diff; start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synMethod(); // 调用“synchronized方法” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println(&quot;synMethod() : &quot;+ diff); start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synBlock(); // 调用“synchronized方法块” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println(&quot;synBlock() : &quot;+ diff); } }(某一次)执行结果： synMethod() : 11 synBlock() : 3 4. 实例锁 和 全局锁实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。 &nbsp;&nbsp;&nbsp;&nbsp; 实例锁对应的就是synchronized关键字。全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 &nbsp;&nbsp;&nbsp;&nbsp; 全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。 关于“实例锁”和“全局锁”有一个很形象的例子： pulbic class Something { public synchronized void isSyncA(){} public synchronized void isSyncB(){} public static synchronized void cSyncA(){} public static synchronized void cSyncB(){} }假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。(01) x.isSyncA()与x.isSyncB()(02) x.isSyncA()与y.isSyncA()(03) x.cSyncA()与y.cSyncB()(04) x.isSyncA()与Something.cSyncA() (01) 不能被同时访问。因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！ // LockTest1.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;); } }catch (InterruptedException ie) { } } public synchronized void isSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;); } }catch (InterruptedException ie) { } } } public class LockTest1 { Something x = new Something(); Something y = new Something(); // 比较(01) x.isSyncA()与x.isSyncB() private void test1() { // 新建t11, t11会调用 x.isSyncA() Thread t11 = new Thread( new Runnable() { @Override public void run() { x.isSyncA(); } }, &quot;t11&quot;); // 新建t12, t12会调用 x.isSyncB() Thread t12 = new Thread( new Runnable() { @Override public void run() { x.isSyncB(); } }, &quot;t12&quot;); t11.start(); // 启动t11 t12.start(); // 启动t12 } public static void main(String[] args) { LockTest1 demo = new LockTest1(); demo.test1(); } }运行结果： t11 : isSyncA t11 : isSyncA t11 : isSyncA t11 : isSyncA t11 : isSyncA t12 : isSyncB t12 : isSyncB t12 : isSyncB t12 : isSyncB t12 : isSyncB(02) 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。 // LockTest2.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;); } }catch (InterruptedException ie) { } } public synchronized void isSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;); } }catch (InterruptedException ie) { } } } public class LockTest2 { Something x = new Something(); Something y = new Something(); // 比较(02) x.isSyncA()与y.isSyncA() private void test2() { // 新建t21, t21会调用 x.isSyncA() Thread t21 = new Thread( new Runnable() { @Override public void run() { x.isSyncA(); } }, &quot;t21&quot;); // 新建t22, t22会调用 x.isSyncB() Thread t22 = new Thread( new Runnable() { @Override public void run() { y.isSyncA(); } }, &quot;t22&quot;); t21.start(); // 启动t21 t22.start(); // 启动t22 } public static void main(String[] args) { LockTest2 demo = new LockTest2(); demo.test2(); } }运行结果： t21 : isSyncA t22 : isSyncA t21 : isSyncA t22 : isSyncA t21 : isSyncA t22 : isSyncA t21 : isSyncA t22 : isSyncA t21 : isSyncA t22 : isSyncA(03) 不能被同时访问。因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。 // LockTest3.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;); } }catch (InterruptedException ie) { } } public synchronized void isSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;); } }catch (InterruptedException ie) { } } } public class LockTest3 { Something x = new Something(); Something y = new Something(); // 比较(03) x.cSyncA()与y.cSyncB() private void test3() { // 新建t31, t31会调用 x.isSyncA() Thread t31 = new Thread( new Runnable() { @Override public void run() { x.cSyncA(); } }, &quot;t31&quot;); // 新建t32, t32会调用 x.isSyncB() Thread t32 = new Thread( new Runnable() { @Override public void run() { y.cSyncB(); } }, &quot;t32&quot;); t31.start(); // 启动t31 t32.start(); // 启动t32 } public static void main(String[] args) { LockTest3 demo = new LockTest3(); demo.test3(); } }运行结果： t31 : cSyncA t31 : cSyncA t31 : cSyncA t31 : cSyncA t31 : cSyncA t32 : cSyncB t32 : cSyncB t32 : cSyncB t32 : cSyncB t32 : cSyncB(04) 可以被同时访问。因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。 // LockTest4.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;); } }catch (InterruptedException ie) { } } public synchronized void isSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;); } }catch (InterruptedException ie) { } } } public class LockTest4 { Something x = new Something(); Something y = new Something(); // 比较(04) x.isSyncA()与Something.cSyncA() private void test4() { // 新建t41, t41会调用 x.isSyncA() Thread t41 = new Thread( new Runnable() { @Override public void run() { x.isSyncA(); } }, &quot;t41&quot;); // 新建t42, t42会调用 x.isSyncB() Thread t42 = new Thread( new Runnable() { @Override public void run() { Something.cSyncA(); } }, &quot;t42&quot;); t41.start(); // 启动t41 t42.start(); // 启动t42 } public static void main(String[] args) { LockTest4 demo = new LockTest4(); demo.test4(); } }运行结果： t41 : isSyncA t42 : cSyncA t41 : isSyncA t42 : cSyncA t41 : isSyncA t42 : cSyncA t41 : isSyncA t42 : cSyncA t41 : isSyncA t42 : cSyncA","link":"/2012/08/04/java/threads/2012-08-04-threads-basic/"},{"title":"Android之AsyncTask介绍","text":"本文介绍AsyncTask，它通常用于执行异步任务。 目录1. AsyncTask介绍2. AsyncTask使用和示例3. AsyncTask原理 AsyncTask介绍AsyncTask比Handler更轻量级一些，适用于简单的异步处理。 使用AsyncTask时，注意重写以下几个方法： 1. doInBackground()作用：执行后台任务。要求：必须重写！注意：在doInBackground()中不能进行UI操作！ 2. onPreExecute()作用：通常用于执行后台任务开始前的准备动作。在用户调用execute()后，并且在AsyncTask主动执行doInBackground()之前被调用。要求：选择性重写。如果不重写该函数，默认不执行任何动作 3. onPostExecute()作用：通常用于处理后台动作的返回结果。在AsyncTask主动执行doInBackground()之前被调用。要求：选择性重写。如果不重写该函数，默认不执行任何动作 4. onProgressUpdate()作用：通常用于执行后台任务执行期间的进度更新。因为doInBackground()中不能操作UI，假如我们想在后台任务处理时显示进度，可以在doInBackground()中调用publishProgress()，而publicProgress()会调用onProgressUpdate()；在onProgressUpdate()中进行UI操作即可。要求：选择性重写。如果不重写该函数，默认不执行任何动作 5. onCancelled()作用：通常用于执行取消AsyncTask任务时的相关动作。如果客户主动调用cancel()，则会执行onCancelled()；否则(AsyncTask执行完之后正常停止)，则不会调用onCancelled()。要求：选择性重写。如果不重写该函数，默认不执行任何动作 AsyncTask使用和示例下面是一个自定义的AsyncTask。 private class MyTask extends AsyncTask&lt;String, Integer, String&gt; { //onPreExecute方法用于在执行后台任务前做一些UI操作 @Override protected void onPreExecute() { Log.i(TAG, &quot;onPreExecute&quot;); textView.setText(&quot;loading...&quot;); } //doInBackground方法内部执行后台任务,不可在此方法内修改UI @Override protected String doInBackground(String... params) { Log.i(TAG, &quot;doInBackground&quot;); try { for (int i=0; i&lt;6; i++) { Log.d(TAG, &quot;doInBackground: publishProgress=&quot;+i); publishProgress(20*i); Thread.sleep(500); } Log.d(TAG, &quot;doInBackground: return OK!&quot;); return &quot;OK&quot;; } catch (InterruptedException e) { e.printStackTrace(); } Log.d(TAG, &quot;doInBackground: return FAIL!&quot;); return &quot;FAIL&quot;; } //onProgressUpdate方法用于更新进度信息 @Override protected void onProgressUpdate(Integer... progresses) { Log.i(TAG, &quot;onProgressUpdate&quot;); progressBar.setProgress(progresses[0]); textView.setText(&quot;loading...&quot; + progresses[0] + &quot;%&quot;); } //onPostExecute方法用于在执行完后台任务后更新UI,显示结果 @Override protected void onPostExecute(String result) { Log.i(TAG, &quot;onPostExecute&quot;); textView.setText(result); execute.setEnabled(true); cancel.setEnabled(false); } //onCancelled方法用于在取消执行中的任务时更改UI @Override protected void onCancelled() { Log.i(TAG, &quot;onCancelled&quot;); textView.setText(&quot;cancelled&quot;); progressBar.setProgress(0); execute.setEnabled(true); cancel.setEnabled(false); } }说明：(01) textView是一个TextView对象，cancel和execute分别是两个Button按钮，而progressBar则是进度条。(02) 在任务开始时会通过onPreExecute()更新TextView的显示内容。(03) 在任务结束时通过onPreExecute()更新TextView的显示内容。(04) 任务执行过程中会通过publishProgress()更新进度条。(05) 如果任务被强制取消的话，会将进度条重置为0。 创建并执行AsyncTask的接口如下： mTask = new MyTask(); mTask.execute(&quot;http://www.baidu.com&quot;);取消AsyncTask的接口如下： mTask.cancel();点击查看：AsyncTask示例完整原理 AsyncTask原理下面通过Android4.4.2的AsyncTask源码来对AsyncTask原理进行介绍。 1. AsyncTask构造函数public AsyncTask() { mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; }说明： (01) mWorker是个WorkerRunnable对象，而WorkerRunnable是Callable的实现类。而在”线程池中关于Callable的介绍“时，我们说过，Callable类似于Runnable接口，不同之处主要在于Callable能和Future配合使用获取任务的结果，而Runnable不能获取结果！(02) mFuture是FutureTask对象，而FutureTask洽洽是Future的实现类。 mWorker和mFuture配合使用，能获取后台任务的结果！ 2. executeexecute()的源码如下： public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); }说明：sDefaultExecutor是线程池对象，而executeOnExecutor()是真正执行后台动作的地方。 下面是线程池相关的代码： private static final int CORE_POOL_SIZE = CPU_COUNT + 1; private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE = 1; public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); ... public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } }说明：该线程池是”通过双向队列实现的串行线程池”。scheduleNext()每次只会执行一个任务。 下面看看executeOnExecutor()的代码： public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; }说明：(01) executeOnExecutor()首先会对任务的状态进行处理。任务共三种姿态： PENDING: 挂起状态。当AsyncTask被创建时，就进入了PENDING状态。RUNNING: 运行状态。当AsyncTask被执行时，就进入了RUNNING状态。FINISHED: 完成状态。当AsyncTask完成(被客户cancel()或正常运行完毕)时，就进入了FINISHED状态。 当任务是RUNNING或PENDING状态时，会抛出异常。这就决定了，一个AsyncTask只能被执行一次，即只能对一个AsyncTask调用一次execute()；如果要重新执行任务，则需要新建AsyncTask后再调用execute()。(02) 接着，调用onPreExecute()。这也就是任务执行前的准备动作！(03) 然后，调用exec.execute(mFuture)。作用是将任务提交到线程池中进行执行。线程池的代码前面已经给出，SerialExecutor中的execute()会执行r.run()任务。r.run()实际上是调用FutureTask中run()方法，而FutureTask的run()方法，则会执行Callable的call()函数，即会执行到mWorker的call()方法。而观察前面mWorker的run()方法，我们会发现它会调用doInBackground()接口，并通过postResult()返回任务执行结果。而postResult()的内容如下： private static final InternalHandler sHandler = new InternalHandler(); private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } private static class InternalHandler extends Handler { @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } }说明：postResult()会发送MESSAGE_POST_RESULT给sHandler，而sHandler中会将任务执行结果传递给finish()。以下是finish()的代码： private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; }说明：如果是正常执行结束，则调用onPostExecute()方法；否则(异常结束)，则调用onCancelled()方法。 至此，AsyncTask的原理结果完毕！总的来说，就是通过线程池来实现的，AsyncTask的任务会提交到线程池中，执行完后，线程池再返回结果。","link":"/2014/06/25/android/api_guide/tasks/2014-06-25-AsyncTask/"},{"title":"Android Binder机制(七) addService详解03之 请求的反馈","text":"前面两篇文章分别介绍了addService中”请求的发送”和”请求的处理”这两部分，本文将介绍addService请求的最后一部分–请求的反馈。ServiceManager在处理完addService请求之后，添加了一个待处理事务到MediaPlayerService的事务列表中，并将MediaPlayerService唤醒。我们从上次MediaPlayerService休眠的地方开始，看看它被唤醒之后干了些什么。 注意：本文是基于Android 4.4.2版本进行介绍的！ 1. Binder驱动中binder_thread_read()的源码static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) { ... if (wait_for_proc_work) { ... if (non_block) { ... } else // 阻塞式的读取，则阻塞等待事务的发生。 ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); } else { ... } ... while (1) { struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... else { ... } ... switch (w-&gt;type) { case BINDER_WORK_TRANSACTION: { t = container_of(w, struct binder_transaction, work); } break; ... } if (!t) continue; // t-&gt;buffer-&gt;target_node是NULL if (t-&gt;buffer-&gt;target_node) { ... } else { tr.target.ptr = NULL; tr.cookie = NULL; cmd = BR_REPLY; } // 交易码 tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) { struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); } else { tr.sender_pid = 0; } // 数据大小 tr.data_size = t-&gt;buffer-&gt;data_size; // 数据中对象的偏移数组的大小(即对象的个数) tr.offsets_size = t-&gt;buffer-&gt;offsets_size; // 数据 tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; // 数据中对象的偏移数组 tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); // 将cmd指令写入到ptr，即传递到用户空间 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; // 将tr数据拷贝到用户空间 ptr += sizeof(uint32_t); if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); ... // 删除已处理的事务 list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; // 设置回复信息 if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) { ... } else { t-&gt;buffer-&gt;transaction = NULL; kfree(t); } break; } done: // 更新bwr.read_consumed的值 *consumed = ptr - buffer; ... return 0; }说明：MediaPlayerService进程被Service Manager唤醒，同时它的待处理事务队列中有ServiceManager添加的事务；此时，binder_has_thread_work()为true。因此，MediaPlayerService会继续往下执行。(01) 进入while循环后，首先取出待处理事务。(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让MediaPlayerService读取后进行处理。此时的指令是BR_REPLY。 binder_thread_read()执行完毕之后，共反馈了两个指令到用户空间：BR_NOOP和BR_REPLY 现在回到MediaPlayerService位于用户空间的进程。它会逐个解析Binder驱动反馈的指令。对于BR_NOOP，MediaPlayerService不会做任何实质性的动作。对于BR_REPLY，看看MediaPlayerService的处理流程。 2. IPCThreadState::waitForResponsestatus_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult) { int32_t cmd; int32_t err; while (1) { if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... cmd = mIn.readInt32(); switch (cmd) { ... case BR_REPLY: { binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ... if (reply) { if ((tr.flags &amp; TF_STATUS_CODE) == 0) { reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(size_t), freeBuffer, this); } else { ... } } else { ... } } goto finish; ... } } finish: ... return err; }说明：在BR_REPLY分支中，先读取出数据，并保存到tr中。由于reply不为null，并且tr.flags &amp; TF_STATUS_CODE为0；因此，会执行reply-&gt;ipcSetDataReference()。 3. Parcel::ipcSetDataReferencevoid Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize, const size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie) { freeDataNoInit(); mError = NO_ERROR; mData = const_cast&lt;uint8_t*&gt;(data); mDataSize = mDataCapacity = dataSize; mDataPos = 0; mObjects = const_cast&lt;size_t*&gt;(objects); mObjectsSize = mObjectsCapacity = objectsCount; mNextObjectHint = 0; mOwner = relFunc; mOwnerCookie = relCookie; scanForFds(); }说明：ipcSetDataReference()是根据参数的值重新初始化Parcel的数据和对象。(01) freeDataNoInit()的目的是释放原有的内存。为接下来保存Binder驱动反馈的数据做准备。(02) 在Android Binder机制(六) addService详解02之 请求的处理中，ServiceManager反馈数据时，我们知道它对应的BR_REPLY的数据实际上是空的！因此，这里的mDataSize和mObjectsSize都是0。 实际上，Binder驱动反馈给MediaPlayerService的指令就是告诉它addService已经成功处理完毕！ 在MediaPlayerService解析完Binder驱动反馈的数据之后，它会层层向上返回。这样，MediaPlayerService::instantiate()也就正式执行完了！MediaPlayerService::instantiate()执行完毕，但是MediaPlayerService进程似乎还没有进入消息循环中等到Client的请求！那么，它是何时进入消息循环的呢？回到MediaPlayerService进程的main()函数入口中，它后面是通过startThreadPool()进入消息循环的。这部分的内容，我们下一章再来介绍。 int main(int argc, char** argv) { ... if (doLog &amp;&amp; (childPid = fork()) != 0) { ... } else { ... MediaPlayerService::instantiate(); ... ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); } }","link":"/2014/09/05/android/os/binder/2014-09-05-BinderCommunication-AddService03/"},{"title":"Android Binder机制(八) MediaPlayerService服务的消息循环","text":"在前面的3篇文章中，我们以MediaPlayerService为例，介绍了C-S中的Server服务是如何通过addService请求添加到ServiceManager中的。但是，在Android Binder机制(七) addService详解03之 请求的反馈的结尾，我们提到过：MediaPlayerService仅仅只是将自己注册到了ServiceManager中，它还没有进入消息循环等待Client的请求。本文，就接着介绍MediaPlayerService是如何进入消息循环的。 注意：本文是基于Android 4.4.2版本进行介绍的！ 1. MediaPlayerService的main()函数int main(int argc, char** argv) { ... if (doLog &amp;&amp; (childPid = fork()) != 0) { ... } else { ... MediaPlayerService::instantiate(); ... ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); } }说明：该代码在frameworks/av/media/mediaserver/main_mediaserver.cpp中。对于MediaPlayerService::instantiate()，已经详细介绍过了；它的作用是将MediaPlayerService已经注册到ServiceManager中。下面看看startThreadPool()的流程。 2. ProcessState::startThreadPool();void ProcessState::startThreadPool() { AutoMutex _l(mLock); if (!mThreadPoolStarted) { mThreadPoolStarted = true; spawnPooledThread(true); } }说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中。mThreadPoolStarted的初始值为false，因此这里设置mThreadPoolStarted=true之后，就调用spawnPooledThread()。 2. ProcessState::spawnPooledThread()void ProcessState::spawnPooledThread(bool isMain) { if (mThreadPoolStarted) { String8 name = makeBinderThreadName(); ALOGV(&quot;Spawning new pooled thread, name=%s\\n&quot;, name.string()); sp&lt;Thread&gt; t = new PoolThread(isMain); t-&gt;run(name.string()); } }说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中。 此时mThreadPoolStarted=true，因此会先调用makeBinderThreadName()为线程取一个名称；然后新建PoolThread线程，并运行。makeBinderThreadName()的代码比较简单，这里就不列出了。线程的名称是”Binder_X”(其实X是16进制数)，每新建一个线程X的值都会+1。下面看看PoolThread。 3. ProcessState::spawnPooledThread()class PoolThread : public Thread { public: PoolThread(bool isMain) : mIsMain(isMain) { } protected: virtual bool threadLoop() { IPCThreadState::self()-&gt;joinThreadPool(mIsMain); return false; } const bool mIsMain; };说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中。PoolThread继承于Thread，在线程启动之后，会调用threadLoop()进入消息循环中。 下面简单说说，当PoolThread启动之后，是如何调用到threadLoop()的。PoolThread继承于Thread，先看看Thread的构造函数，然后再看看run()的代码。 4. Thread::ThreadThread::Thread(bool canCallJava) : mCanCallJava(canCallJava), mThread(thread_id_t(-1)), mLock(&quot;Thread::mLock&quot;), mStatus(NO_ERROR), mExitPending(false), mRunning(false) , mTid(-1) { } 说明：该代码定义在system/core/libutils/Threads.cpp中。新建Thread对象时，会进行一些列初始化。这里设置mCanCallJava=true。 5. Thread::runstatus_t Thread::run(const char* name, int32_t priority, size_t stack) { Mutex::Autolock _l(mLock); ... // 初始化 mStatus = NO_ERROR; mExitPending = false; mThread = thread_id_t(-1); mHoldSelf = this; mRunning = true; bool res; if (mCanCallJava) { res = createThreadEtc(_threadLoop, this, name, priority, stack, &amp;mThread); } else { ... } ... return NO_ERROR; }说明：该代码定义在system/core/libutils/Threads.cpp中。(01) 先看看函数参数。name是spawnPooledThread()中创建的Binder线程名称，形式是”Binder_X”。priority是优先级(默认值为PRIORITY_DEFAULT)，stack是线程栈数量(默认是0)；它们都是使用默认值，在system/core/include/utils/Thread.h中定义。(02) 先进行初始化；mCanCallJava的值在构造函数中被初始化为true。因此，会调用createThreadEtc()。 6. createThreadEtc// Create thread with lots of parameters inline bool createThreadEtc(thread_func_t entryFunction, void *userData, const char* threadName = &quot;android:unnamed_thread&quot;, int32_t threadPriority = PRIORITY_DEFAULT, size_t threadStackSize = 0, thread_id_t *threadId = 0) { return androidCreateThreadEtc(entryFunction, userData, threadName, threadPriority, threadStackSize, threadId) ? true : false; }说明：该代码定义在system/core/include/utils/AndroidThreads.h中。它会调用androidCreateThreadEtc()。 7. androidCreateThreadEtcstatic android_create_thread_fn gCreateThreadFn = androidCreateRawThreadEtc; int androidCreateThreadEtc(android_thread_func_t entryFunction, void *userData, const char* threadName, int32_t threadPriority, size_t threadStackSize, android_thread_id_t *threadId) { return gCreateThreadFn(entryFunction, userData, threadName, threadPriority, threadStackSize, threadId); } void androidSetCreateThreadFunc(android_create_thread_fn func) { gCreateThreadFn = func; }说明：该代码定义在system/core/libutils/Threads.cpp中。 androidCreateThreadEtc()会调用gCreateThreadFn()。gCreateThreadFn()是个函数指针，它的值是androidCreateRawThreadEtc。 8. androidCreateRawThreadEtcint androidCreateRawThreadEtc(android_thread_func_t entryFunction, void *userData, const char* threadName, int32_t threadPriority, size_t threadStackSize, android_thread_id_t *threadId) { ... int result = pthread_create(&amp;thread, &amp;attr, (android_pthread_entry)entryFunction, userData); ... return 1; }说明：该代码定义在system/core/libutils/Threads.cpp中。 该函数会调用pthread_create()，而pthread_create()则是我们非常熟悉的Linux的标准接口，它的作用就是创建线程。线程创建成功之后运行时，会以执行entryFunction对应的函数。而entryFunction这个函数指针的值是_threadLoop。因此，当线程启动之后，会执行_threadLoop。 9. _threadLoopint Thread::_threadLoop(void* user) { ... bool first = true; do { bool result; if (first) { first = false; self-&gt;mStatus = self-&gt;readyToRun(); result = (self-&gt;mStatus == NO_ERROR); if (result &amp;&amp; !self-&gt;exitPending()) { result = self-&gt;threadLoop(); } } else { ... } ... } while(strong != 0); return 0; }说明：该代码定义在system/core/libutils/Threads.cpp中。first的初始值为true，因此进入到if(first)中。 readyToRun()的实现在Threads.cpp中，返回NO_ERROR。因此result为true，而mExitPending的默认值为false，即self0&gt;exitPending()返回false。因此会执行self-&gt;threadLoop()。由于PoolThread重载了threadLoop()，因此，这里的self-&gt;threadLoop()会调用PoolThread中的threadLoop()。 10. PoolThread::threadLoop()virtual bool threadLoop() { IPCThreadState::self()-&gt;joinThreadPool(mIsMain); return false; }说明：这是PoolThread中实现的threadLoop()函数。它会先通过IPCThreadState::self()获取IPCThreadState对象，然后调用IPCThreadState::joinThreadPool(mIsMain)，其中mIsMain为true。 11. IPCThreadState::joinThreadPool()void IPCThreadState::joinThreadPool(bool isMain) { ... mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER); ... do { ... result = getAndExecuteCommand(); if (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) { ... abort(); } if(result == TIMED_OUT &amp;&amp; !isMain) { break; } } while (result != -ECONNREFUSED &amp;&amp; result != -EBADF); ... mOut.writeInt32(BC_EXIT_LOOPER); talkWithDriver(false); }说明：该代码定义在frameworks/native/libs/binder/IPCThreadState.cpp中。在该函数中，便进入了消息循环！(01) isMain=true，因此会先将BC_ENTER_LOOPER指令写入到mOut中。(02) 接着调用getAndExecuteCommand()。 12. IPCThreadState::getAndExecuteCommand()status_t IPCThreadState::getAndExecuteCommand() { status_t result; int32_t cmd; // 和Binder驱动交互 result = talkWithDriver(); if (result &gt;= NO_ERROR) { ... // 读取mIn中的数据 cmd = mIn.readInt32(); ... // 调用executeCommand()对数据进行处理。 result = executeCommand(cmd); ... } return result; }说明：该函数会调用talkWithDriver()和Binder驱动进行交互。对于talkWithDriver()，前面已经多次提到。在此，talkWithDriver()会将BC_ENTER_LOOPER指令发送给Binder驱动，告诉Binder驱动，MediaPlayerService进入了消息循环状态。BC_ENTER_LOOPER的流程在Android Binder机制(三) ServiceManager守护进程中已经介绍过了。当BC_ENTER_LOOPER处理完毕，MediaPlayerService再次调用ioctl()和Binder驱动通信时，由于MediaPlayerService对应的待处理事务列表为空，因此MediaPlayerService线程会进入中断等待状态。当有Client向MediaPlayerService发送请求时，MediaPlayerService就会被唤醒。","link":"/2014/09/06/android/os/binder/2014-09-06-BinderCommunication-ThreadPool/"},{"title":"Android Binder机制(十一) getService详解03之 请求的反馈","text":"前面两篇文章分别介绍了getService中”请求的发送”和”请求的处理”这两部分，本文将介绍getService请求的最后一部分–请求的反馈。下面就说说MediaPlayer收到请求反馈之后的处理流程。 注意：本文是基于Android 4.4.2版本进行介绍的！ 1. Binder驱动中binder_thread_read()的源码从MediaPlayer开始唤醒开始说起。 static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) { ... if (wait_for_proc_work) { ... if (non_block) { ... } else ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); } else { ... } ... while (1) { struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... else { ... } ... switch (w-&gt;type) { case BINDER_WORK_TRANSACTION: { t = container_of(w, struct binder_transaction, work); } break; ... } if (!t) continue; // t-&gt;buffer-&gt;target_node是目标节点。 // 这里，MediaPlayer的getService请求的目标是Service Manager，因此target_node是Service Manager对应的节点； if (t-&gt;buffer-&gt;target_node) { ... } else { tr.target.ptr = NULL; tr.cookie = NULL; cmd = BR_REPLY; } // 交易码 tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) { struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); } else { ... } // 数据大小 tr.data_size = t-&gt;buffer-&gt;data_size; // 数据中对象的偏移数组的大小(即对象的个数) tr.offsets_size = t-&gt;buffer-&gt;offsets_size; // 数据 tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; // 数据中对象的偏移数组 tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); // 将cmd指令写入到ptr，即传递到用户空间 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; // 将tr数据拷贝到用户空间 ptr += sizeof(uint32_t); if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); ... // 删除已处理的事务 list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) { ... } else { t-&gt;buffer-&gt;transaction = NULL; kfree(t); } break; } done: // 更新bwr.read_consumed的值 *consumed = ptr - buffer; ... return 0; }说明：MediaPlayer进程被唤醒之后，binder_has_thread_work()为true，因为MediaPlayer进程中有个BINDER_WORK_TRANSACTION类型的待处理事务。(01) 进入while循环后，首先取出待处理事务。(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让MediaPlayer读取后进行处理。此时的指令为BR_REPLY！(03) 最后，更新consumed的值，即更新bwr.read_consumed的值。 binder_thread_read()执行完毕之后，共反馈了两个指令到用户空间：BR_NOOP和BR_REPLY。 之后的流程应该都比较熟悉了，首先返回到binder_ioctl()中，接着将ServiceManager反馈的数据拷贝到用户空间。接下来的工作就交给MediaPlayer进程进行处理了。从Binder驱动返回后，首先回到talkWithDriver()中，接着便返回到waitForResponse()中。在waitForResponse()会反馈数据进行解析。 2. IPCThreadState::waitForResponsestatus_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult) { int32_t cmd; int32_t err; while (1) { if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... cmd = mIn.readInt32(); switch (cmd) { ... case BR_REPLY: { binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ... if (reply) { if ((tr.flags &amp; TF_STATUS_CODE) == 0) { reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(size_t), freeBuffer, this); } else { ... } } else { ... } } goto finish; ... } } finish: ... return err; }说明：在BR_REPLY分支中，先读取出数据，并保存到tr中。由于reply不为null，并且tr.flags &amp; TF_STATUS_CODE为0；因此，会执行reply-&gt;ipcSetDataReference()。 3. Parcel::ipcSetDataReferencevoid Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize, const size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie) { freeDataNoInit(); mError = NO_ERROR; mData = const_cast&lt;uint8_t*&gt;(data); mDataSize = mDataCapacity = dataSize; mDataPos = 0; mObjects = const_cast&lt;size_t*&gt;(objects); mObjectsSize = mObjectsCapacity = objectsCount; mNextObjectHint = 0; mOwner = relFunc; mOwnerCookie = relCookie; scanForFds(); }说明： data就是ServiceManager返回来的数据。数据中包含一个flat_binder_object对象(对应ServiceManager中的binder_object)，因此objectsCount则为1。先通过freeDataNoInit()将原始的数据清空，然后再给mData和mObjects赋值，这样就将数据保存到了Parcel中。为什么objectsCount的值是1呢？请返回查看一下Service Manager在执行binder_send_reply()即可知，这里就不再多说。 waitForResponse()执行完BR_REPLY之后，便返回到IPCThreadState::transact()中；然后层层返回，直到退回到checkService()。 4. BpServiceManager::checkService()virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const { Parcel data, reply; data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply); return reply.readStrongBinder(); } 说明：到目前为止，通过transact()来获取MediaPlayerService的事务已经执行完毕！MediaPlayerService的接入点已经保存在replay中。接下来的工作就是调用reply.readStrongBinder()来从replay中解析出所需要的数据，即MediaPlayerService在Biner驱动中的Binder引用描述，也就是C++层的句柄。 5. Parcel::readStrongBindersp&lt;IBinder&gt; Parcel::readStrongBinder() const { sp&lt;IBinder&gt; val; unflatten_binder(ProcessState::self(), *this, &amp;val); return val; }说明：readStrongBinder()会调用unflatten_binder()来解析Parcel中的数据。 6. Parcel::unflatten_binderstatus_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc, const Parcel&amp; in, sp&lt;IBinder&gt;* out) { const flat_binder_object* flat = in.readObject(false); if (flat) { switch (flat-&gt;type) { case BINDER_TYPE_BINDER: ... case BINDER_TYPE_HANDLE: *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle); return finish_unflatten_binder( static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in); } } return BAD_TYPE; }说明：readObject()的作用是从Parcel中读取出它所保存的flat_binder_object类型的对象。该对象的类型是BINDER_TYPE_HANDLE，因此会指向BINDER_TYPE_HANDLE对应的switch分支。(01) 这里的proc是ProcessState对象，执行proc-&gt;getStrongProxyForHandle()会将句柄(MediaPlayerService的Binder引用描述)保存到ProcessState的链表中，然后再创建并返回该句柄的BpBinder对象(即Binder的代理)。在Android Binder机制(四) defaultServiceManager()的实现中有getStrongProxyForHandle()的详细说明，下面只给出getStrongProxyForHandle()代码。(02) finish_unflatten_binder()中只有return NO_ERROR。 sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle) { sp&lt;IBinder&gt; result; AutoMutex _l(mLock); // 在矢量数组中查找&quot;句柄值为handle的handle_entry对象&quot;； // 找到的话，则直接返回；找不到的话，则新建handle对应的handle_entry。 handle_entry* e = lookupHandleLocked(handle); if (e != NULL) { IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) { // 当handle==0(即是Service Manager的句柄)时，尝试去ping Binder驱动。 if (handle == 0) { Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, NULL, 0); if (status == DEAD_OBJECT) return NULL; } // 新建BpBinder代理 b = new BpBinder(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; } else { ... } } return result; }这样，getService()的内容就全部执行完毕。getService()的返回结果IBinder=BpBinder对象，该对象包含了”MediaPlayerService(在Binder驱动)中的Binder引用的描述”，该描述在C++层而言就是个整型句柄。之后，若MediaPlayer要向MediaPlayerService发送请求，就根据该IBinder对象和”MediaPlayerService”进行通信。 上面只是执行完了getService()，它返回了IBinder对象。但是，getMediaPlayerService()并没有执行完毕。下面继续回到getMediaPlayerService()中。 7. IMediaDeathNotifier::getMediaPlayerService()const sp&lt;IMediaPlayerService&gt;&amp; IMediaDeathNotifier::getMediaPlayerService() { ... if (sMediaPlayerService == 0) { sp&lt;IServiceManager&gt; sm = defaultServiceManager(); sp&lt;IBinder&gt; binder; do { binder = sm-&gt;getService(String16(&quot;media.player&quot;)); ... usleep(500000); // 0.5 s } while (true); ... sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder); } ... return sMediaPlayerService; }说明：在成功获取MediaPlayerService对应的IBinder对象(binder)之后，可以通过interface_cast(binder)获取它的代理。是不是对interface_cast()很熟悉！不错，在Android Binder机制(四) defaultServiceManager()的实现中就是通过该宏获取IServiceManager的代理的。 8. IMediaDeathNotifier::getMediaPlayerService()template&lt;typename INTERFACE&gt; inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj) { return INTERFACE::asInterface(obj); } 下面直接给出IMediaPlayerService::asInterface()的代码。 android::sp&lt;IMediaPlayerService&gt; IMediaPlayerService::asInterface( const android::sp&lt;android::IBinder&gt;&amp; obj) { android::sp&lt;IMediaPlayerService&gt; intr; if (obj != NULL) { intr = static_cast&lt;IMediaPlayerService*&gt;( obj-&gt;queryLocalInterface( IMediaPlayerService::descriptor).get()); if (intr == NULL) { intr = new BpServiceManager(obj); } } return intr; }说明：asInterface()会调用new BpMediaPlayerService()新建BpServiceManager对象，并返回给对象。 这样，MediaPlayer进程的getService请求就全部介绍完毕了。","link":"/2014/09/07/android/os/binder/2014-09-07-BinderCommunication-GetService03/"},{"title":"Android 触摸事件机制(二) Activity中触摸事件详解","text":"本文将对Activity中触摸事件相关的内容进行介绍，重点介绍的是Activity中与触摸事件相关的两个API：dispatchTouchEvent()和onTouchEvent()。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. Activity中触摸事件的概述2. Activity中触摸事件的源码解析2.1. Activity中的dispatchTouchEvent2.2. Activity中的onTouchEvent 1. Activity中触摸事件的概述 Activity中与触摸事件相关API主要是dispatchTouchEvent()和onTouchEvent()。dispatchTouchEvent()是传递触摸事件的API，而onTouchEvent()则是Activity处理触摸事件的API。 Activity就是dispatchTouchEvent()将触摸事件传递给它所包含的根视图，从而实现将触摸事件传递给View或ViewGroup进行处理。 而在onTouchEvent()在是Activity自己对触摸事件的处理。例如，如果Activity是一个Dialog主题，即Activity相当于一个对话框；那么当onTouchEvent()收到点击事件，并且该点击事件的坐标在Activity之外的时候，onTouchEvent()就会结束Activity。 2. Activity中触摸事件的源码解析 2.1 Activity中的dispatchTouchEventpublic boolean dispatchTouchEvent(MotionEvent ev) { // onUserInteraction默认不执行任何动作。 // 它是提供给客户的接口。 if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } // 这里会调用到ViewGroup的dispatchTouchEvent()， // 即会调用Activity包含的根视图的dispatchTouchEvent()。 if (getWindow().superDispatchTouchEvent(ev)) { return true; } // 如果superDispatchTouchEvent()返回false， // 即Activity的根视图以及根视图的子视图都没有拦截该事件的话，则调用Activity的onTouchEvent() return onTouchEvent(ev); }说明：该代码定义在frameworks/base/core/java/android/app/Activity.java中。Activity通过调用dispatchTouchEvent()将触摸事件分发给Activity所包含的视图；如果Activity中的视图都没有对触摸事件进行拦截的话，则调用Activity的onTouchEvent()对触摸事件进行处理。下面，先看看Activity是如何通过superDispatchTouchEvent()将事件分发给它所包含的View的。 2.1.1 Activity中的getWindow()private Window mWindow; public Window getWindow() { return mWindow; } final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config) { ... mWindow = PolicyManager.makeNewWindow(this); ... }说明：getWindow()返回的是mWindow对象，而mWindow是在attach()中初始化的。attach()是Activity被加载时调用的，具体是如何attact()的，不是我们关心的重点；这里只需要了解，Activity被加载时，attach()会被执行即可。接着，我们就看看PolicyManager.makeNewWindow()是如何实现的。 2.1.2 PolicyManager中的makeNewWindow()public static Window makeNewWindow(Context context) { return sPolicy.makeNewWindow(context); } private static final String POLICY_IMPL_CLASS_NAME = &quot;com.android.internal.policy.impl.Policy&quot;; private static final IPolicy sPolicy; static { // Pull in the actual implementation of the policy at run-time try { Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME); sPolicy = (IPolicy)policyClass.newInstance(); } catch (ClassNotFoundException ex) { throw new RuntimeException( POLICY_IMPL_CLASS_NAME + &quot; could not be loaded&quot;, ex); } catch (InstantiationException ex) { throw new RuntimeException( POLICY_IMPL_CLASS_NAME + &quot; could not be instantiated&quot;, ex); } catch (IllegalAccessException ex) { throw new RuntimeException( POLICY_IMPL_CLASS_NAME + &quot; could not be instantiated&quot;, ex); } } 说明：该代码定义在frameworks/base/core/java/com/android/internal/policy/PolicyManager.java中。makeNewWindow()是调用的sPolicy.makeNewWindow()，而sPolicy是个静态变量，它的实现也是在静态代码块中。因此，在PolicyManager.java加载的时候，sPolicy就会被初始化为policyClass.newInstance()。而policyClass是通过Class得到的Policy对象。也就是说，PolicyManager中的makeNewWindow()会调用Policy中的makeNewWindow()。 2.1.3 Policy中的makeNewWindowpublic Window makeNewWindow(Context context) { return new PhoneWindow(context); } 说明：该代码定义在frameworks/base/policy/src/com/android/internal/policy/impl/Policy.java中。makeNewWindow()会返回PhoneWindow对象。回到Activity的dispatchTouchEvent()中，也就是说getWindow()返回的是PhoneWindow对象。接着，就看看superDispatchTouchEvent()的实现。 2.1.4 PhoneWindow中的superDispatchTouchEvent@Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } private DecorView mDecor; private void installDecor() { if (mDecor == null) { mDecor = generateDecor(); ... } ... } protected DecorView generateDecor() { return new DecorView(getContext(), -1); } 说明：该代码定义在frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java中。superDispatchTouchEvent()会调用mDecor.superDispatchTouchEvent()；而mDecor是DecorView对象。mDecor是在installDecor()中被创建的。总之，PhoneWindow中的superDispatchTouchEvent()会调用DecorView中的superDispatchTouchEvent()。DecorView是PhoneWindow中的内部类，下面看看它的实现。 2.1.5 DecorView中的superDispatchTouchEventprivate final class DecorView extends FrameLayout implements RootViewSurfaceTaker { ... public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } ... }说明：DecorView中的superDispatchTouchEvent()会调用父类的dispatchTouchEvent()。而DecorView的父类是FrameLayout，FrameLayout的父类又是GroupView；因此superDispatchTouchEvent()最终会调用到GroupView的dispatchTouchEvent()。 关于GroupView中的dispatchTouchEvent()的流程，在后面的文章中再来详细介绍！这里重点需要了解：Activity在通过dispatchTouchEvent()传递触摸事件的时候，会调用到ViewGroup的dispatchTouchEvent()。从而实现，将Activity中的触摸事件传递给它所包含的View或ViewGroup。 2.2 Activity中的onTouchEvent回顾一下Activity中dispatchTouchEvent()的内容。 public boolean dispatchTouchEvent(MotionEvent ev) { // onUserInteraction默认不执行任何动作。 // 它是提供给客户的接口。 if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } // 这里会调用到ViewGroup的dispatchTouchEvent()， // 即会调用Activity包含的根视图的dispatchTouchEvent()。 if (getWindow().superDispatchTouchEvent(ev)) { return true; } // 如果superDispatchTouchEvent()返回false， // 即Activity的根视图以及根视图的子视图都没有拦截该事件的话，则调用Activity的onTouchEvent() return onTouchEvent(ev); }(01) 如果superDispatchTouchEvent()返回true的话，dispatchTouchEvent()就直接返回true了，不会执行onTouchEvent()。也就是说，如果Activity将触摸事件分发给它所包含的视图的时候，如果有视图拦截或消费了该事件，就不会轮到Activity来处理该事件了；即，不会执行Activity的onTouchEvent()了。(02) 如果superDispatchTouchEvent()返回false的话，意味着，Activity所包含的视图都没有拦截或消费该触摸事件；那么，就会调用Activity的onTouchEvent()来处理触摸事件。 下面就看看onTouchEvent()的代码。 public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; } 说明：代码很简单。它会先调用mWindow.shouldCloseOnTouch()，如果shouldCloseOnTouch()返回true，则意味着该触摸事件会触发”结束Activity”的动作。那么接下来，就调用finish()来结束Activity，并返回true，表示Activity消费了这个触摸事件。否则的话，就返回false。 2.2.1 Window的shouldCloseOnTouch()前面分析过，mWindow是PhoneWindow对象，而PhoneWindow继承于Window。则mWindow.shouldCloseOnTouch()实际上会调用Window中的shouldCloseOnTouch()。 public boolean shouldCloseOnTouch(Context context, MotionEvent event) { if (mCloseOnTouchOutside &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event) &amp;&amp; peekDecorView() != null) { return true; } return false; } 说明：该代码定义在frameworks/base/core/java/android/view/Window.java中。(01) mCloseOnTouchOutside是一个boolean变量，它是由Window的android:windowCloseOnTouchOutside属性值决定。(02) isOutOfBounds(context, event)是判断该event的坐标是否在context(对于本文来说就是当前的Activity)之外。是的话，返回true；否则，返回false。(03) peekDecorView()则是返回PhoneWindow的mDecor。也就是说，如果设置了android:windowCloseOnTouchOutside属性为true，并且当前事件是ACTION_DOWN，而且点击发生在Activity之外，同时Activity还包含视图的话，则返回true；表示该点击事件会导致Activity的结束。 至此，Activity中关于触摸事件的代码就分析完毕了。总结来说：(01) Activity中的dispatchTouchEvent会将触摸事件传递给Activity所包含的视图。具体的实现方式在通过调用到Activity所属Window的superDispatchTouchEvent，进而调用到Window的DecorView的superDispatchTouchEvent，进一步的又调用到ViewGroup的dispatchTouchEvent()。 如果Activity所包含的视图拦截或者消费了该触摸事件的话，就不会再执行Activity的onTouchEvent()； 如果Activity所包含的视图没有拦截或者消费该触摸事件的话，则会执行Activity的onTouchEvent()。(02) Activity中的onTouchEvent是Activity自身对触摸事件的处理。如果该Activity的android:windowCloseOnTouchOutside属性为true，并且当前触摸事件是ACTION_DOWN，而且该触摸事件的坐标在Activity之外，同时Activity还包含了视图的话；就会导致Activity被结束。","link":"/2015/01/02/android/os/event/2015-01-02-TouchEvent-Activity/"},{"title":"Android 触摸事件机制(五) 触摸事件示例1--默认处理方式","text":"本文将通过示例演示触摸事件的传递流程。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. 示例概述1.1. 示例简介1.2. 示例结论2. 示例源码2.1. MyActivity的源码2.2. MyViewGroup的源码2.3. MyView的源码3. 运行结果 1. 示例概述 1.1 示例简介本文的示例：自定义一个Activity，该Activity中的显示内容是包含一个自定义的ViewGroup，该ViewGroup中包含一个自定义的View。 (01) 自定义的Activity是MyActivitypublic boolean dispatchTouchEvent(MotionEvent ev): 调用系统默认的dispatchTouchEvent()public boolean onTouchEvent(MotionEvent ev): 调用系统默认的onTouchEvent() (02) 自定义ViewGroup是MyViewGrouppublic boolean dispatchTouchEvent(MotionEvent ev): 调用系统默认的dispatchTouchEvent()public boolean onTouchEvent(MotionEvent ev): 调用系统默认的onTouchEvent()public boolean onInterceptTouchEvent(MotionEvent ev):: 调用系统默认的onInterceptTouchEvent() (03) 自定义View是MyViewpublic boolean dispatchTouchEvent(MotionEvent ev): 调用系统默认的dispatchTouchEvent()public boolean onTouchEvent(MotionEvent ev): 调用系统默认的onTouchEvent() 1.2 示例结论(01) MyActivity, ViewGroup和View的触摸事件相关API默认都返回false。即，上面列出的API的默认返回值都是false。(02) 触摸事件的分发顺序是经过MyActivity –&gt; MyViewGroup –&gt; MyView。 它们的触摸事件的入口都是dispatchTouchEvent()，即MyActivity将事件分发给MyViewGroup时，是通过MyActivity.dispatchTouchEvent()去调用MyViewGroup.dispatchTouchEvent()；同样的，MyViewGroup将事件分发给MyView时，也是通过MyViewGroup.dispatchTouchEvent()去调用MyView.dispatchTouchEvent()。 它们的对触摸事件的处理都是在onTouchEvent()中完成的。也就是说，会在它们的dispatchTouchEvent()中，皆会调用(它们各自的)onTouchEvent()来对事件进行处理。onTouchEvent()返回true，就表示消费了个事件，或者说接受了个事件。 前面说过消息的分发顺序是MyActivity –&gt; MyViewGroup –&gt; MyView。如果想在MyActivity中进行消息拦截(即，MyActivity不想将消息分发给它包含的视图)，则需要重载dispatchTouchEvent()。如果想在MyViewGroup中进行消息拦截(即，MyViewGroup收到触摸事件之后，不想分发给它的子视图)，则一般都会通过覆盖onInterceptTouchEvent()，并在onInterceptTouchEvent()返回true来拦截消息。(03) MyViewGroup和MyView都没有接受ACTION_DOWN事件的话；那么，ACTION_MOVE和ACTION_UP等触摸事件也就不会发送给它们。 Activity中ACTION_DOWN的流程图如下： 2. 示例源码点击查看：触摸事件示例1的源码 2.1 MyActivity的源码public class MyActivity extends Activity { private static final String TAG = &quot;##skywang-MyActivity&quot;; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } @Override public boolean dispatchTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;dispatchTouchEvent(start) :&quot;+actionName); boolean ret = super.dispatchTouchEvent(event); Log.d(TAG, &quot;dispatchTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } @Override public boolean onTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName); boolean ret = super.onTouchEvent(event); Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } }说明：MyActivity的layout是main.xml。虽然它覆盖了dispatchTouchEvent()和onTouchEvent()方法；但它们都是在调用父类的对应的方法的基础之上，添加了打印信息而已。 2.1.1 getActionName的源码public static String getActionName(MotionEvent event) { final int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) { return &quot;DOWN&quot;; } else if (action == MotionEvent.ACTION_MOVE) { return &quot;MOVE&quot;; } else if (action == MotionEvent.ACTION_UP) { return &quot;UP&quot;; } else if (action == MotionEvent.ACTION_CANCEL) { return &quot;CANCEL&quot;; } else { return &quot;NULL&quot;; } }2.1.2 main.xml的源码&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; &gt; &lt;TextView android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World, EventTest-Default&quot; /&gt; &lt;com.skw.eventtest.MyViewGroup android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;400dp&quot; android:background=&quot;#cccccc&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; &gt; &lt;com.skw.eventtest.MyView android:layout_width=&quot;200dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#451c0a&quot; /&gt; &lt;/com.skw.eventtest.MyViewGroup&gt; &lt;/LinearLayout&gt;说明：main.xml中包含了MyViewGroup，而MyViewGroup中又包含了MyView。 2.2 MyViewGroup的源码public class MyViewGroup extends LinearLayout { private static final String TAG = &quot;##skywang-MyViewGroup&quot;; public MyViewGroup(Context context){ super(context); } public MyViewGroup(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean dispatchTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;dispatchTouchEvent(start) :&quot;+actionName); boolean ret = super.dispatchTouchEvent(event); Log.d(TAG, &quot;dispatchTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } @Override public boolean onTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName); boolean ret = super.onTouchEvent(event); Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } @Override public boolean onInterceptTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;onInterceptTouchEvent(start) :&quot;+actionName); boolean ret = super.onInterceptTouchEvent(event); Log.d(TAG, &quot;onInterceptTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } }说明：MyViewGroup继承于ViewGroup。虽然它覆盖了dispatchTouchEvent(), onTouchEvent()和onInterceptTouchEvent()方法；但它们都是在调用父类的对应的方法的基础之上，添加了打印信息而已。 2.3 MyView的源码public class MyView extends View { private static final String TAG = &quot;##skywang-MyView&quot;; public MyView(Context context) { super(context); } public MyView(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean dispatchTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;dispatchTouchEvent(start) :&quot;+actionName); boolean ret = super.dispatchTouchEvent(event); Log.d(TAG, &quot;dispatchTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } @Override public boolean onTouchEvent(MotionEvent event) { String actionName = Utils.getActionName(event); Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName); boolean ret = super.onTouchEvent(event); Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret); return ret; } } 3. 运行结果3.1 ACTION_DOWN事件点击MyView所在的区域，ACTION_DOWN相关的log如下： D/##skywang-MyActivity( 1935): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 1935): dispatchTouchEvent(start) :DOWND/##skywang-MyViewGroup( 1935): onInterceptTouchEvent(start) :DOWND/##skywang-MyViewGroup( 1935): onInterceptTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyView( 1935): dispatchTouchEvent(start) :DOWND/##skywang-MyView( 1935): onTouchEvent(start) :DOWND/##skywang-MyView( 1935): onTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyView( 1935): dispatchTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyViewGroup( 1935): onTouchEvent(start) :DOWND/##skywang-MyViewGroup( 1935): onTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyViewGroup( 1935): dispatchTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyActivity( 1935): onTouchEvent(start) :DOWND/##skywang-MyActivity( 1935): onTouchEvent( end ) :DOWN, ret=falseD/##skywang-MyActivity( 1935): dispatchTouchEvent( end ) :DOWN, ret=false 说明：很显然，ACTION_DOWN的流程如下：(01) MyActivity收到ACTION_DOWN，进入MyActivity.dispatchTouchEvent()。(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，进入MyViewGroup.dispatchTouchEvent()。(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先进入MyViewGroup.onInterceptTouchEvent()。(04) 紧接着，MyViewGroup会退出MyViewGroup.onInterceptTouchEvent()。因为MyViewGroup没有对触摸事件进行拦截，MyViewGroup会继续分发事件。(05) MyViewGroup将触摸事件分发给MyView，即进入MyView.dispatchTouchEvent()。(06) MyView会调用onTouchEvent()对触摸事件进行处理，即进入MyView.onTouchEvent() 。(07) 紧接着，MyView会退出MyView.onTouchEvent()。返回false给MyView.dispatchTouchEvent()。(08) MyView收到MyView.onTouchEvent()的返回值之后，退出MyView.dispatchTouchEvent()。返回false给MyViewGroup的MyViewGroup.dispatchTouchEvent()，表示MyView没有接受该触摸事件。(09) MyViewGroup则得知MyView没有接受该触摸事件之后，将自己当作一个View，调用View.dispatchTouchEvent()；View.dispatchTouchEvent()接着就会进入MyViewGroup.onTouchEvent()。(10) 紧接着，就会退出MyViewGroup.onTouchEvent()。MyViewGroup.onTouchEvent()没有消费该触摸事件，因此返回false。(11) 然后，View.dispatchTouchEvent()就会结束，并返回false。接着，MyViewGroup就会退出MyViewGroup.dispatchTouchEvent()。并返回false。(12) MyActivity在得知MyViewGroup没有接受该触摸事件之后，就会调用进入MyActivity.onTouchEvent。(13) 紧接着，就会退出MyActivity.onTouchEvent，并返回false。(14) 至此，MyActivity.dispatchTouchEvent()才结束。因此，会退出MyActivity.dispatchTouchEvent()，并返回false。 说明：触摸事件的分发顺序是经过MyActivity –&gt; MyViewGroup –&gt; MyView。 3.2 ACTION_MOVE事件点击MyView所在的区域，ACTION_MOVE相关的log如下： D/##skywang-MyActivity( 1935): dispatchTouchEvent(start) :MOVED/##skywang-MyActivity( 1935): onTouchEvent(start) :MOVED/##skywang-MyActivity( 1935): onTouchEvent( end ) :MOVE, ret=falseD/##skywang-MyActivity( 1935): dispatchTouchEvent( end ) :MOVE, ret=false 说明：由于MyViewGroup和MyView都没有接受ACTION_DOWN事件，因此ACTION_MOVE事件就不会再分发给它们。 3.3 ACTION_UP事件点击MyView所在的区域，ACTION_UP相关的log如下： D/##skywang-MyActivity( 1935): dispatchTouchEvent(start) :UPD/##skywang-MyActivity( 1935): onTouchEvent(start) :UPD/##skywang-MyActivity( 1935): onTouchEvent( end ) :UP, ret=falseD/##skywang-MyActivity( 1935): dispatchTouchEvent( end ) :UP, ret=false 说明：由于MyViewGroup和MyView都没有接受ACTION_DOWN事件，因此ACTION_UP事件就不会再分发给它们。","link":"/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-01-default/"},{"title":"Android 触摸事件机制(三) View中触摸事件详解","text":"本文将对View中触摸事件相关的内容进行介绍。重点介绍的是dispatchTouchEvent(), onTouchEvent()这两个API以及OnTouchListener接口。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. View中触摸事件的概述2. View中触摸事件的源码解析2.1. View中的dispatchTouchEvent2.2. View中的onTouchEvent 1. View中触摸事件的概述 View中与触摸事件相关的内容可以分为两部分。 第一部分 dispatchTouchEvent()和onTouchEvent()这两个API dispatchTouchEvent()是传递触摸事件的API，而onTouchEvent()则是View处理触摸事件的API。View中dispatchTouchEvent()将事件传递给”自己的onTouch()”, “自己的onTouchEvent()”进行处理。 onTouch()是OnTouchListener接口中API，属于View提供的，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统提供的，用于处理触摸事件的接口；在onTouchEvent()中会进行一系列的动作，例如获取焦点、设置按下状态，调用onClick()等。 第二部分 OnTouchListener, OnClickListener, OnLongClickListener等接口 这部分主要是接口。但本文主要介绍的是OnTouchListener接口中的onTouch()。为什么呢？这是因为，onTouch()与onTouchEvent()都是用户处理触摸事件的API。但不同的是：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。 如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。 public interface OnTouchListener { boolean onTouch(View v, MotionEvent event); } 2. View中触摸事件的源码解析 2.1 View中的dispatchTouchEventpublic boolean dispatchTouchEvent(MotionEvent event) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } // 如果该View被遮蔽，并且该View在被遮蔽时不响应点击事件； // 此时，返回false；不会执行onTouch()或onTouchEvent()，即过滤调用该点击事件。 // 否则，返回true。 // 被遮蔽的意思是：该View不是位于顶部，有其他的View在它之上。 if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { return true; } if (onTouchEvent(event)) { return true; } } if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } return false; }说明：该代码定义在frameworks/base/core/java/android/view/View.java中。(01) mInputEventConsistencyVerifier是调试用的，这里不用理会。重点看onFilterTouchEventForSecurity()部分。(02) onFilterTouchEventForSecurity()表示是否要分发该触摸事件；如果该View不是位于顶部，并且有设置属性使该View不在顶部时不响应触摸事件，则不分发该触摸事件，即不会执行onTouch()与onTouchEvent()。 否则的话，则将事件分发给onTouch(), onTouchEvent()进行处理。(03) 如果将事件进行分发的话，会先尝试分发给onTouch()；然后才分发给onTouchEvent()。 2.1.1 View中的onFilterTouchEventForSecurity()public boolean onFilterTouchEventForSecurity(MotionEvent event) { //noinspection RedundantIfStatement if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0 &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) { // Window is obscured, drop this touch. return false; } return true; }说明：onFilterTouchEventForSecurity()返回true，表示可以分发该触摸事件；否则，不能分发该触摸事件。不能分发事件的情况，只有mViewFlags&amp;FILTER_TOUCHES_WHEN_OBSCURED!=0，并且event.getFlags()&amp;MotionEvent.FLAG_WINDOW_IS_OBSCURED!=0同时成立。(01) FILTER_TOUCHES_WHEN_OBSCURED是android:filterTouchesWhenObscured属性所对应的位。android:filterTouchesWhenObscured是true的话，则表示其他视图在该视图之上，导致该视图被隐藏时，该视图就不再响应触摸事件。(02) MotionEvent.FLAG_WINDOW_IS_OBSCURED为true的话，则表示该视图的窗口是被隐藏的。 2.2 View中的onTouchEventpublic boolean onTouchEvent(MotionEvent event) { final int viewFlags = mViewFlags; // 如果View被禁用的话，则返回它是否可以点击。 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); } // 如果该View的mTouchDelegate不为null的话，将触摸消息分发给mTouchDelegate。 // mTouchDelegate的默认值是null。 if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } // 如果View可以被点击的话，则执行if里面的内容。 // 这其中涉及到的主要是获取焦点，设置按下状态，触发onClick(), onLongClick()事件等等。 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) { switch (event.getAction()) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don&apos;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true); } if (!mHasPerformedLongPress) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we&apos;re inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away setPressed(true); checkForLongClick(0); } break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); break; case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); } } break; } return true; } return false; }说明：onTouchEvent()是Android系统实现的View对触摸事件的处理。(01) 如果View被禁用的话，则返回它是否可以点击。当我们调用了setEnabled(false)时，View就被禁用了；默认情况下，View是可用的。当调用setClickable(true)或者android:clickable为true时，View就是可点击状态；默认情况下，View是不可点击的。(02) 如果该View的mTouchDelegate不为null的话，将触摸消息分发给mTouchDelegate。例如，假设有两个视图v1和v2，它们的布局相互之间不重叠；如果设置了v1.setTouchDelegate(v2)的话，v1的触摸事件就会分发给v2。 注意：mTouchDelegate的默认值是null。(03) 如果View可以被点击的话，则执行if里面的内容。if里面涉及的内容很多，这里与本文的主题关联不大，暂且不表；如果要细将的话，估计得好几篇文章。例如，setPressed()是设置View的按下状态，如果用户有设置View在不同状态的图片时，setPressed()时会导致View的图片的更新。 View中关于触摸事件的代码就分析至此。总的来说：(01) View中的dispatchTouchEvent()会将事件传递给”自己的onTouch()”, “自己的onTouchEvent()”进行处理。而且onTouch()的优先级比onTouchEvent()的优先级要高。(02) onTouch()与onTouchEvent()都是View中用户处理触摸事件的API。onTouch是OnTouchListener接口中的函数，OnTouchListener接口需要用户自己实现。onTouchEvent()是View自带的接口，Android系统提供了默认的实现；当然，用户可以重载该API。(03) onTouch()与onTouchEvent()有两个不同之处：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。 如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。","link":"/2015/01/03/android/os/event/2015-01-03-TouchEvent-View/"},{"title":"Java 集合系列06之 Vector详细介绍(源码解析)和使用示例","text":"学完ArrayList和LinkedList之后，我们接着学习Vector。学习方式还是和之前一样，先对Vector有个整体认识，然后再学习它的源码；最后再通过实例来学会使用它。 目录第1部分 Vector介绍第2部分 Vector数据结构第3部分 Vector源码解析(基于JDK1.6.0_45)第4部分 Vector遍历方式第5部分 Vector示例 第1部分 Vector介绍Vector简介Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。 和ArrayList不同，Vector中的操作是线程安全的。 Vector的构造函数Vector共有4个构造函数 // 默认构造函数 Vector() // capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。 Vector(int capacity) // capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。 Vector(int capacity, int capacityIncrement) // 创建一个包含collection的Vector Vector(Collection&lt;? extends E&gt; collection)Vector的APIsynchronized boolean add(E object) void add(int location, E object) synchronized boolean addAll(Collection&lt;? extends E&gt; collection) synchronized boolean addAll(int location, Collection&lt;? extends E&gt; collection) synchronized void addElement(E object) synchronized int capacity() void clear() synchronized Object clone() boolean contains(Object object) synchronized boolean containsAll(Collection&lt;?&gt; collection) synchronized void copyInto(Object[] elements) synchronized E elementAt(int location) Enumeration&lt;E&gt; elements() synchronized void ensureCapacity(int minimumCapacity) synchronized boolean equals(Object object) synchronized E firstElement() E get(int location) synchronized int hashCode() synchronized int indexOf(Object object, int location) int indexOf(Object object) synchronized void insertElementAt(E object, int location) synchronized boolean isEmpty() synchronized E lastElement() synchronized int lastIndexOf(Object object, int location) synchronized int lastIndexOf(Object object) synchronized E remove(int location) boolean remove(Object object) synchronized boolean removeAll(Collection&lt;?&gt; collection) synchronized void removeAllElements() synchronized boolean removeElement(Object object) synchronized void removeElementAt(int location) synchronized boolean retainAll(Collection&lt;?&gt; collection) synchronized E set(int location, E object) synchronized void setElementAt(E object, int location) synchronized void setSize(int length) synchronized int size() synchronized List&lt;E&gt; subList(int start, int end) synchronized &lt;T&gt; T[] toArray(T[] contents) synchronized Object[] toArray() synchronized String toString() synchronized void trimToSize() 第2部分 Vector数据结构Vector的继承关系 java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.Vector&lt;E&gt;Vector的声明 public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}Vector与Collection关系如下图： Vector的数据结构和ArrayList差不多，它包含了3个成员变量：elementData , elementCount， capacityIncrement。 (01) elementData 是”Object[]类型的数组”，它保存了添加到Vector中的元素。elementData是个动态数组，如果初始化Vector时，没指定动态数组的&gt;大小，则使用默认大小10。随着Vector中元素的增加，Vector的容量也会动态增长，capacityIncrement是与容量增长相关的增长系数，具体的增长方式，请参考源码分析中的ensureCapacity()函数。 (02) elementCount 是动态数组的实际大小。 (03) capacityIncrement 是动态数组的增长系数。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。 第3部分 Vector源码解析(基于JDK1.6.0_45)为了更了解Vector的原理，下面对Vector源码代码作出分析。 package java.util; public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable { // 保存Vector中数据的数组 protected Object[] elementData; // 实际数据的数量 protected int elementCount; // 容量增长系数 protected int capacityIncrement; // Vector的序列版本号 private static final long serialVersionUID = -2767605614048989439L; // Vector构造函数。默认容量是10。 public Vector() { this(10); } // 指定Vector容量大小的构造函数 public Vector(int initialCapacity) { this(initialCapacity, 0); } // 指定Vector&quot;容量大小&quot;和&quot;增长系数&quot;的构造函数 public Vector(int initialCapacity, int capacityIncrement) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); // 新建一个数组，数组容量是initialCapacity this.elementData = new Object[initialCapacity]; // 设置容量增长系数 this.capacityIncrement = capacityIncrement; } // 指定集合的Vector构造函数。 public Vector(Collection&lt;? extends E&gt; c) { // 获取“集合(c)”的数组，并将其赋值给elementData elementData = c.toArray(); // 设置数组长度 elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); } // 将数组Vector的全部元素都拷贝到数组anArray中 public synchronized void copyInto(Object[] anArray) { System.arraycopy(elementData, 0, anArray, 0, elementCount); } // 将当前容量值设为 =实际元素个数 public synchronized void trimToSize() { modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) { elementData = Arrays.copyOf(elementData, elementCount); } } // 确认“Vector容量”的帮助函数 private void ensureCapacityHelper(int minCapacity) { int oldCapacity = elementData.length; // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。 // 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement // 否则，将容量增大一倍。 if (minCapacity &gt; oldCapacity) { Object[] oldData = elementData; int newCapacity = (capacityIncrement &gt; 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2); if (newCapacity &lt; minCapacity) { newCapacity = minCapacity; } elementData = Arrays.copyOf(elementData, newCapacity); } } // 确定Vector的容量。 public synchronized void ensureCapacity(int minCapacity) { // 将Vector的改变统计数+1 modCount++; ensureCapacityHelper(minCapacity); } // 设置容量值为 newSize public synchronized void setSize(int newSize) { modCount++; if (newSize &gt; elementCount) { // 若 &quot;newSize 大于 Vector容量&quot;，则调整Vector的大小。 ensureCapacityHelper(newSize); } else { // 若 &quot;newSize 小于/等于 Vector容量&quot;，则将newSize位置开始的元素都设置为null for (int i = newSize ; i &lt; elementCount ; i++) { elementData[i] = null; } } elementCount = newSize; } // 返回“Vector的总的容量” public synchronized int capacity() { return elementData.length; } // 返回“Vector的实际大小”，即Vector中元素个数 public synchronized int size() { return elementCount; } // 判断Vector是否为空 public synchronized boolean isEmpty() { return elementCount == 0; } // 返回“Vector中全部元素对应的Enumeration” public Enumeration&lt;E&gt; elements() { // 通过匿名类实现Enumeration return new Enumeration&lt;E&gt;() { int count = 0; // 是否存在下一个元素 public boolean hasMoreElements() { return count &lt; elementCount; } // 获取下一个元素 public E nextElement() { synchronized (Vector.this) { if (count &lt; elementCount) { return (E)elementData[count++]; } } throw new NoSuchElementException(&quot;Vector Enumeration&quot;); } }; } // 返回Vector中是否包含对象(o) public boolean contains(Object o) { return indexOf(o, 0) &gt;= 0; } // 从index位置开始向后查找元素(o)。 // 若找到，则返回元素的索引值；否则，返回-1 public synchronized int indexOf(Object o, int index) { if (o == null) { // 若查找元素为null，则正向找出null元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; } else { // 若查找元素不为null，则正向找出该元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; } return -1; } // 查找并返回元素(o)在Vector中的索引值 public int indexOf(Object o) { return indexOf(o, 0); } // 从后向前查找元素(o)。并返回元素的索引 public synchronized int lastIndexOf(Object o) { return lastIndexOf(o, elementCount-1); } // 从后向前查找元素(o)。开始位置是从前向后的第index个数； // 若找到，则返回元素的“索引值”；否则，返回-1。 public synchronized int lastIndexOf(Object o, int index) { if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot;+ elementCount); if (o == null) { // 若查找元素为null，则反向找出null元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; } else { // 若查找元素不为null，则反向找出该元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } // 返回Vector中index位置的元素。 // 若index月结，则抛出异常 public synchronized E elementAt(int index) { if (index &gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); } return (E)elementData[index]; } // 获取Vector中的第一个元素。 // 若失败，则抛出异常！ public synchronized E firstElement() { if (elementCount == 0) { throw new NoSuchElementException(); } return (E)elementData[0]; } // 获取Vector中的最后一个元素。 // 若失败，则抛出异常！ public synchronized E lastElement() { if (elementCount == 0) { throw new NoSuchElementException(); } return (E)elementData[elementCount - 1]; } // 设置index位置的元素值为obj public synchronized void setElementAt(E obj, int index) { if (index &gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); } elementData[index] = obj; } // 删除index位置的元素 public synchronized void removeElementAt(int index) { modCount++; if (index &gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); } else if (index &lt; 0) { throw new ArrayIndexOutOfBoundsException(index); } int j = elementCount - index - 1; if (j &gt; 0) { System.arraycopy(elementData, index + 1, elementData, index, j); } elementCount--; elementData[elementCount] = null; /* to let gc do its work */ } // 在index位置处插入元素(obj) public synchronized void insertElementAt(E obj, int index) { modCount++; if (index &gt; elementCount) { throw new ArrayIndexOutOfBoundsException(index + &quot; &gt; &quot; + elementCount); } ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++; } // 将“元素obj”添加到Vector末尾 public synchronized void addElement(E obj) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; } // 在Vector中查找并删除元素obj。 // 成功的话，返回true；否则，返回false。 public synchronized boolean removeElement(Object obj) { modCount++; int i = indexOf(obj); if (i &gt;= 0) { removeElementAt(i); return true; } return false; } // 删除Vector中的全部元素 public synchronized void removeAllElements() { modCount++; // 将Vector中的全部元素设为null for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0; } // 克隆函数 public synchronized Object clone() { try { Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone(); // 将当前Vector的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, elementCount); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); } } // 返回Object数组 public synchronized Object[] toArray() { return Arrays.copyOf(elementData, elementCount); } // 返回Vector的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public synchronized &lt;T&gt; T[] toArray(T[] a) { // 若数组a的大小 &lt; Vector的元素个数； // 则新建一个T[]数组，数组大小是“Vector的元素个数”，并将“Vector”全部拷贝到新数组中 if (a.length &lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); // 若数组a的大小 &gt;= Vector的元素个数； // 则将Vector的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, elementCount); if (a.length &gt; elementCount) a[elementCount] = null; return a; } // 获取index位置的元素 public synchronized E get(int index) { if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return (E)elementData[index]; } // 设置index位置的值为element。并返回index位置的原始值 public synchronized E set(int index, E element) { if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); Object oldValue = elementData[index]; elementData[index] = element; return (E)oldValue; } // 将“元素e”添加到Vector最后。 public synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } // 删除Vector中的元素o public boolean remove(Object o) { return removeElement(o); } // 在index位置添加元素element public void add(int index, E element) { insertElementAt(element, index); } // 删除index位置的元素，并返回index位置的原始值 public synchronized E remove(int index) { modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); Object oldValue = elementData[index]; int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return (E)oldValue; } // 清空Vector public void clear() { removeAllElements(); } // 返回Vector是否包含集合c public synchronized boolean containsAll(Collection&lt;?&gt; c) { return super.containsAll(c); } // 将集合c添加到Vector中 public synchronized boolean addAll(Collection&lt;? extends E&gt; c) { modCount++; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); // 将集合c的全部元素拷贝到数组elementData中 System.arraycopy(a, 0, elementData, elementCount, numNew); elementCount += numNew; return numNew != 0; } // 删除集合c的全部元素 public synchronized boolean removeAll(Collection&lt;?&gt; c) { return super.removeAll(c); } // 删除“非集合c中的元素” public synchronized boolean retainAll(Collection&lt;?&gt; c) { return super.retainAll(c); } // 从index位置开始，将集合c添加到Vector中 public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) { modCount++; if (index &lt; 0 || index &gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); int numMoved = elementCount - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); elementCount += numNew; return numNew != 0; } // 返回两个对象是否相等 public synchronized boolean equals(Object o) { return super.equals(o); } // 计算哈希值 public synchronized int hashCode() { return super.hashCode(); } // 调用父类的toString() public synchronized String toString() { return super.toString(); } // 获取Vector中fromIndex(包括)到toIndex(不包括)的子集 public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) { return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); } // 删除Vector中fromIndex到toIndex的元素 protected synchronized void removeRange(int fromIndex, int toIndex) { modCount++; int numMoved = elementCount - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; } // java.io.Serializable的写入函数 private synchronized void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { s.defaultWriteObject(); } }总结：(01) Vector实际上是通过一个数组去保存数据的。当我们构造Vecotr时；若使用默认构造函数，则Vector的默认容量大小是10。(02) 当Vector容量不足以容纳全部元素时，Vector的容量会增加。若容量增加系数 &gt;0，则将容量的值增加“容量增加系数”；否则，将容量大小增加一倍。(03) Vector的克隆函数，即是将全部元素克隆到一个数组中。 第4部分 Vector遍历方式Vector支持4种遍历方式。建议使用下面的第二种去遍历Vector，因为效率问题。 (01) 第一种，通过迭代器遍历。即通过Iterator去遍历。 Integer value = null; int size = vec.size(); for (int i=0; i&lt;size; i++) { value = (Integer)vec.get(i); }(02) 第二种，随机访问，通过索引值去遍历。 由于Vector实现了RandomAccess接口，它支持通过索引值去随机访问元素。 Integer value = null; int size = vec.size(); for (int i=0; i&lt;size; i++) { value = (Integer)vec.get(i); }(03) 第三种，另一种for循环。 Integer value = null; for (Integer integ:vec) { value = integ; }(04) 第四种，Enumeration遍历。 Integer value = null; Enumeration enu = vec.elements(); while (enu.hasMoreElements()) { value = (Integer)enu.nextElement(); }测试这些遍历方式效率的代码如下： import java.util.*; /* * @desc Vector遍历方式和效率的测试程序。 * * @author skywang */ public class VectorRandomAccessTest { public static void main(String[] args) { Vector vec= new Vector(); for (int i=0; i&lt;100000; i++) vec.add(i); iteratorThroughRandomAccess(vec) ; iteratorThroughIterator(vec) ; iteratorThroughFor2(vec) ; iteratorThroughEnumeration(vec) ; } private static void isRandomAccessSupported(List list) { if (list instanceof RandomAccess) { System.out.println(&quot;RandomAccess implemented!&quot;); } else { System.out.println(&quot;RandomAccess not implemented!&quot;); } } public static void iteratorThroughRandomAccess(List list) { long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i=0; i&lt;list.size(); i++) { list.get(i); } endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughRandomAccess：&quot; + interval+&quot; ms&quot;); } public static void iteratorThroughIterator(List list) { long startTime; long endTime; startTime = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext(); ) { iter.next(); } endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughIterator：&quot; + interval+&quot; ms&quot;); } public static void iteratorThroughFor2(List list) { long startTime; long endTime; startTime = System.currentTimeMillis(); for(Object obj:list) ; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;); } public static void iteratorThroughEnumeration(Vector vec) { long startTime; long endTime; startTime = System.currentTimeMillis(); for(Enumeration enu = vec.elements(); enu.hasMoreElements(); ) { enu.nextElement(); } endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;iteratorThroughEnumeration：&quot; + interval+&quot; ms&quot;); } }运行结果： iteratorThroughRandomAccess：6 ms iteratorThroughIterator：9 ms iteratorThroughFor2：8 ms iteratorThroughEnumeration：7 ms总结：遍历Vector，使用索引的随机访问方式最快，使用迭代器最慢。 第5部分 Vector示例下面通过示例学习如何使用Vector import java.util.Vector; import java.util.List; import java.util.Iterator; import java.util.Enumeration; /** * @desc Vector测试函数：遍历Vector和常用API * * @author skywang */ public class VectorTest { public static void main(String[] args) { // 新建Vector Vector vec = new Vector(); // 添加元素 vec.add(&quot;1&quot;); vec.add(&quot;2&quot;); vec.add(&quot;3&quot;); vec.add(&quot;4&quot;); vec.add(&quot;5&quot;); // 设置第一个元素为100 vec.set(0, &quot;100&quot;); // 将“500”插入到第3个位置 vec.add(2, &quot;300&quot;); System.out.println(&quot;vec:&quot;+vec); // (顺序查找)获取100的索引 System.out.println(&quot;vec.indexOf(100):&quot;+vec.indexOf(&quot;100&quot;)); // (倒序查找)获取100的索引 System.out.println(&quot;vec.lastIndexOf(100):&quot;+vec.lastIndexOf(&quot;100&quot;)); // 获取第一个元素 System.out.println(&quot;vec.firstElement():&quot;+vec.firstElement()); // 获取第3个元素 System.out.println(&quot;vec.elementAt(2):&quot;+vec.elementAt(2)); // 获取最后一个元素 System.out.println(&quot;vec.lastElement():&quot;+vec.lastElement()); // 获取Vector的大小 System.out.println(&quot;size:&quot;+vec.size()); // 获取Vector的总的容量 System.out.println(&quot;capacity:&quot;+vec.capacity()); // 获取vector的“第2”到“第4”个元素 System.out.println(&quot;vec 2 to 4:&quot;+vec.subList(1, 4)); // 通过Enumeration遍历Vector Enumeration enu = vec.elements(); while(enu.hasMoreElements()) System.out.println(&quot;nextElement():&quot;+enu.nextElement()); Vector retainVec = new Vector(); retainVec.add(&quot;100&quot;); retainVec.add(&quot;300&quot;); // 获取“vec”中包含在“retainVec中的元素”的集合 System.out.println(&quot;vec.retain():&quot;+vec.retainAll(retainVec)); System.out.println(&quot;vec:&quot;+vec); // 获取vec对应的String数组 String[] arr = (String[]) vec.toArray(new String[0]); for (String str:arr) System.out.println(&quot;str:&quot;+str); // 清空Vector。clear()和removeAllElements()一样！ vec.clear(); // vec.removeAllElements(); // 判断Vector是否为空 System.out.println(&quot;vec.isEmpty():&quot;+vec.isEmpty()); } }运行结果： vec:[100, 2, 300, 3, 4, 5] vec.indexOf(100):0 vec.lastIndexOf(100):0 vec.firstElement():100 vec.elementAt(2):300 vec.lastElement():5 size:6 capacity:10 vec 2 to 4:[2, 300, 3] nextElement():100 nextElement():2 nextElement():300 nextElement():3 nextElement():4 nextElement():5 vec.retain():true vec:[100, 300] str:100 str:300 vec.isEmpty():true更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/06/java/collection/2012-02-06-collection-06-vector/"},{"title":"Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)","text":"目录第1部分 Map概括第2部分 HashMap和Hashtable异同第3部分 HashMap和WeakHashMap异同 第1部分 Map概括(01) Map 是“键值对”映射的抽象接口。(02) AbstractMap 实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。(03) SortedMap 有序的“键值对”映射接口。(04) NavigableMap 是继承于SortedMap的，支持导航函数的接口。(05) HashMap, Hashtable, TreeMap, WeakHashMap这4个类是“键值对”映射的实现类。它们各有区别！&nbsp;&nbsp;&nbsp;&nbsp;HashMap 是基于“拉链法”实现的散列表。一般用于单线程程序中。&nbsp;&nbsp;&nbsp;&nbsp;Hashtable 也是基于“拉链法”实现的散列表。它一般用于多线程程序中。&nbsp;&nbsp;&nbsp;&nbsp;WeakHashMap 也是基于“拉链法”实现的散列表，它一般也用于单线程程序中。相比HashMap，WeakHashMap中的键是“弱键”，当“弱键”被GC回收时，它对应的键值对也会被从WeakHashMap中删除；而HashMap中的键是强键。&nbsp;&nbsp;&nbsp;&nbsp;TreeMap 是有序的散列表，它是通过红黑树实现的。它一般用于单线程中存储有序的映射。 第2部分 HashMap和Hashtable异同第2.1部分 HashMap和Hashtable的相同点HashMap和Hashtable都是存储“键值对(key-value)”的散列表，而且都是采用拉链法实现的。存储的思想都是：通过table数组存储，数组的每一个元素都是一个Entry；而一个Entry就是一个单向链表，Entry链表中的每一个节点就保存了key-value键值对数据。 添加key-value键值对：首先，根据key值计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据数组索引找到Entry(即，单向链表)，再遍历单向链表，将key和链表中的每一个节点的key进行对比。若key已经存在Entry链表中，则用该value值取代旧的value值；若key不存在Entry链表中，则新建一个key-value节点，并将该节点插入Entry链表的表头位置。删除key-value键值对：删除键值对，相比于“添加键值对”来说，简单很多。首先，还是根据key计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据索引找出Entry(即，单向链表)。若节点key-value存在与链表Entry中，则删除链表中的节点即可。 上面介绍了HashMap和Hashtable的相同点。正是由于它们都是散列表，我们关注更多的是“它们的区别，以及它们分别适合在什么情况下使用”。那接下来，我们先看看它们的区别。 第2.2部分 HashMap和Hashtable的不同点1 继承和实现方式不同HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。 HashMap的定义: public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { ... }Hashtable的定义: public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable { ... }从中，我们可以看出： 1.1 HashMap和Hashtable都实现了Map、Cloneable、java.io.Serializable接口。实现了Map接口，意味着它们都支持key-value键值对操作。支持“添加key-value键值对”、“获取key”、“获取value”、“获取map大小”、“清空map”等基本的key-value键值对操作。实现了Cloneable接口，意味着它能被克隆。实现了java.io.Serializable接口，意味着它们支持序列化，能通过序列化去传输。 1.2 HashMap继承于AbstractMap，而Hashtable继承于DictionaryDictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且 Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代器)去遍历。 然而‘由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。关于这点，后面还会进一步说明。AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。 2 线程安全不同Hashtable的几乎所有函数都是同步的，即它是线程安全的，支持多线程。而HashMap的函数则是非同步的，它不是线程安全的。若要在多线程中使用HashMap，需要我们额外的进行同步处理。 对HashMap的同步处理可以使用Collections类提供的synchronizedMap静态方法，或者直接使用JDK 5.0之后提供的java.util.concurrent包里的ConcurrentHashMap类。 3 对null值的处理不同HashMap的key、value都可以为null。Hashtable的key、value都不可以为null。 我们先看看HashMap和Hashtable “添加key-value”的方法 HashMap的添加key-value的方法 // 将“key-value”添加到HashMap中 public V put(K key, V value) { // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null; } // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) { for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; // recordAccess()函数什么也没有做 e.recordAccess(this); return oldValue; } } // 添加第1个“key为null”的元素都table中的时候，会执行到这里。 // 它的作用是将“设置table[0]的key为null，值为value”。 modCount++; addEntry(0, null, value, 0); return null; }Hashtable的添加key-value的方法 // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) { // Hashtable中不能插入value为null的元素！！！ if (value == null) { throw new NullPointerException(); } // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; // Hashtable中不能插入key为null的元素！！！ // 否则，下面的语句会抛出异常！ int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { V old = e.value; e.value = value; return old; } } // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) { // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; } // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null; }根据上面的代码，我们可以看出： Hashtable的key或value，都不能为null！否则，会抛出异常NullPointerException。HashMap的key、value都可以为null。 当HashMap的key为null时，HashMap会将其固定的插入table[0]位置(即HashMap散列表的第一个位置)；而且table[0]处只会容纳一个key为null的值，当有多个key为null的值插入的时候，table[0]会保留最后插入的value。 4 支持的遍历种类不同HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 Enumeration 是JDK 1.0添加的接口，只有hasMoreElements(), nextElement() 两个API接口，不能通过Enumeration()对元素进行修改 。而Iterator 是JDK 1.2才添加的接口，支持hasNext(), next(), remove() 三个API接口。HashMap也是JDK 1.2版本才添加的，所以用Iterator取代Enumeration，HashMap只支持Iterator遍历。 5 通过Iterator迭代器遍历时，遍历的顺序不同HashMap是“从前向后”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。Hashtabl是“从后往前”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。 HashMap和Hashtable都实现Map接口，所以支持获取它们“key的集合”、“value的集合”、“key-value的集合”，然后通过Iterator对这些集合进行遍历。由于“key的集合”、“value的集合”、“key-value的集合”的遍历原理都是一样的；下面，我以遍历“key-value的集合”来进行说明。 HashMap 和Hashtable 遍历”key-value集合”的方式是：(01) 通过entrySet()获取“Map.Entry集合”。 (02) 通过iterator()获取“Map.Entry集合”的迭代器，再进行遍历。 HashMap的实现方式：先“从前向后”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。 // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { return entrySet0(); } // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); } // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { ... public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return newEntryIterator(); } ... } // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() { return new EntryIterator(); } // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; { public Map.Entry&lt;K,V&gt; next() { return nextEntry(); } } private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; { // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fail-fast机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() { expectedModCount = modCount; if (size &gt; 0) { // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } } public final boolean hasNext() { return next != null; } // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) { Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } current = e; return e; } ... }Hashtable的实现方式：先从“后向往前”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; } private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return getIterator(ENTRIES); } ... } private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; { // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) { this.type = type; this.iterator = iterator; } // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() { Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) { e = t[--i]; } entry = e; index = i; return e != null; } // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() { Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) { et = t[--i]; } entry = et; index = i; if (et != null) { Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); } throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;); } // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() { return hasMoreElements(); } // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); } ... }6 容量的初始值 和 增加方式都不一样HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。 HashMap默认的“加载因子”是0.75, 默认的容量大小是16。 // 默认的初始容量是16，必须是2的幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); }当HashMap的 “实际容量” &gt;= “阈值”时，(阈值 = 总的容量 * 加载因子)，就将HashMap的容量翻倍。 // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); }Hashtable默认的“加载因子”是0.75, 默认的容量大小是11。 // 默认构造函数。 public Hashtable() { // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f); }当Hashtable的 “实际容量” &gt;= “阈值”时，(阈值 = 总的容量 x 加载因子)，就将变为“原始容量x2 + 1”。 // 调整Hashtable的长度，将长度变成原来的(2倍+1) // (01) 将“旧的Entry数组”赋值给一个临时变量。 // (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组” // (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中 protected void rehash() { int oldCapacity = table.length; Entry[] oldMap = table; int newCapacity = oldCapacity * 2 + 1; Entry[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)(newCapacity * loadFactor); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) { Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; } } }7 添加key-value时的hash值算法不同HashMap添加元素时，是使用自定义的哈希算法。Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。 HashMap添加元素时，是使用自定义的哈希算法。 static int hash(int h) { h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); } // 将“key-value”添加到HashMap中 public V put(K key, V value) { // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null; }Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。 public synchronized V put(K key, V value) { // Hashtable中不能插入value为null的元素！！！ if (value == null) { throw new NullPointerException(); } // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { V old = e.value; e.value = value; return old; } } // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) { // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; } // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null; }8 部分API不同Hashtable支持contains(Object value)方法，而且重写了toString()方法；而HashMap不支持contains(Object value)方法，没有重写toString()方法。 最后，再说说“HashMap和Hashtable”使用的情景。其实，若了解它们之间的不同之处后，可以很容易的区分根据情况进行取舍。例如：(01) 若在单线程中，我们往往会选择HashMap；而在多线程中，则会选择Hashtable。(02)，若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。但这个不是绝对的标准。例如，在多线程中，我们可以自己对HashMap进行同步，也可以选择ConcurrentHashMap。当HashMap和Hashtable都不能满足自己的需求时，还可以考虑新定义一个类，继承或重新实现散列表；当然，一般情况下是不需要的了。 第3部分 HashMap和WeakHashMap异同3.1 HashMap和WeakHashMap的相同点1 它们都是散列表，存储的是“键值对”映射。2 它们都继承于AbstractMap，并且实现Map基础。3 它们的构造函数都一样。&nbsp;&nbsp;&nbsp;&nbsp;它们都包括4个构造函数，而且函数的参数都一样。4 默认的容量大小是16，默认的加载因子是0.75。5 它们的“键”和“值”都允许为null。6 它们都是“非同步的”。 3.2 HashMap和WeakHashMap的不同点1 HashMap实现了Cloneable和Serializable接口，而WeakHashMap没有。HashMap实现Cloneable，意味着它能通过clone()克隆自己。HashMap实现Serializable，意味着它支持序列化，能通过序列化去传输。 2 HashMap的“键”是“强引用(StrongReference)”，而WeakHashMap的键是“弱引用(WeakReference)”。WeakReference的“弱键”能实现WeakReference对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。这个“弱键”实现的动态回收“键值对”的原理呢？其实，通过WeakReference(弱引用)和ReferenceQueue(引用队列)实现的。 首先，我们需要了解WeakHashMap中：&nbsp;&nbsp;&nbsp;&nbsp;第一，“键”是WeakReference，即key是弱键。&nbsp;&nbsp;&nbsp;&nbsp;第二，ReferenceQueue是一个引用队列，它是和WeakHashMap联合使用的。当弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 WeakHashMap中的ReferenceQueue是queue。&nbsp;&nbsp;&nbsp;&nbsp;第三，WeakHashMap是通过数组实现的，我们假设这个数组是table。 接下来，说说“动态回收”的步骤。 (01) 新建WeakHashMap，将“键值对”添加到WeakHashMap中。将“键值对”添加到WeakHashMap中时，添加的键都是弱键。实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。(02) 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到queue队列中。例如，当我们在将“弱键”key添加到WeakHashMap之后；后来将key设为null。这时，便没有外部外部对象再引用该了key。接着，当Java虚拟机的GC回收内存时，会回收key的相关内存；同时，将key添加到queue队列中。(03) 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的“弱键”；同步它们，就是删除table中被GC回收的“弱键”对应的键值对。例如，当我们“读取WeakHashMap中的元素或获取WeakReference的大小时”，它会先同步table和queue，目的是“删除table中被GC回收的‘弱键’对应的键值对”。删除的方法就是逐个比较“table中元素的‘键’和queue中的‘键’”，若它们相当，则删除“table中的该键值对”。 3.3 HashMap和WeakHashMap的比较测试程序import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.WeakHashMap; import java.util.Date; import java.lang.ref.WeakReference; /** * @desc HashMap 和 WeakHashMap比较程序 * * @author skywang * @email kuiwu-wang@163.com */ public class CompareHashmapAndWeakhashmap { public static void main(String[] args) throws Exception { // 当“弱键”是String时，比较HashMap和WeakHashMap compareWithString(); // 当“弱键”是自定义类型时，比较HashMap和WeakHashMap compareWithSelfClass(); } /** * 遍历map，并打印map的大小 */ private static void iteratorAndCountMap(Map map) { // 遍历map for (Iterator iter = map.entrySet().iterator(); iter.hasNext(); ) { Map.Entry en = (Map.Entry)iter.next(); System.out.printf(&quot;map entry : %s - %s\\n &quot;,en.getKey(), en.getValue()); } // 打印HashMap的实际大小 System.out.printf(&quot; map size:%s\\n\\n&quot;, map.size()); } /** * 通过String对象测试HashMap和WeakHashMap */ private static void compareWithString() { // 新建4个String字符串 String w1 = new String(&quot;W1&quot;); String w2 = new String(&quot;W2&quot;); String h1 = new String(&quot;H1&quot;); String h2 = new String(&quot;H2&quot;); // 新建 WeakHashMap对象，并将w1,w2添加到 WeakHashMap中 Map wmap = new WeakHashMap(); wmap.put(w1, &quot;w1&quot;); wmap.put(w2, &quot;w2&quot;); // 新建 HashMap对象，并将h1,h2添加到 WeakHashMap中 Map hmap = new HashMap(); hmap.put(h1, &quot;h1&quot;); hmap.put(h2, &quot;h2&quot;); // 删除HashMap中的“h1”。 // 结果：删除“h1”之后，HashMap中只有 h2 ！ hmap.remove(h1); // 将WeakHashMap中的w1设置null，并执行gc()。系统会回收w1 // 结果：w1是“弱键”，被GC回收后，WeakHashMap中w1对应的键值对，也会被从WeakHashMap中删除。 // w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。 // 因此，WeakHashMap中只有 w2 // 注意：若去掉“w1=null” 或者“System.gc()”，结果都会不一样！ w1 = null; System.gc(); // 遍历并打印HashMap的大小 System.out.printf(&quot; -- HashMap --\\n&quot;); iteratorAndCountMap(hmap); // 遍历并打印WeakHashMap的大小 System.out.printf(&quot; -- WeakHashMap --\\n&quot;); iteratorAndCountMap(wmap); } /** * 通过自定义类测试HashMap和WeakHashMap */ private static void compareWithSelfClass() { // 新建4个自定义对象 Self s1 = new Self(10); Self s2 = new Self(20); Self s3 = new Self(30); Self s4 = new Self(40); // 新建 WeakHashMap对象，并将s1,s2添加到 WeakHashMap中 Map wmap = new WeakHashMap(); wmap.put(s1, &quot;s1&quot;); wmap.put(s2, &quot;s2&quot;); // 新建 HashMap对象，并将s3,s4添加到 WeakHashMap中 Map hmap = new HashMap(); hmap.put(s3, &quot;s3&quot;); hmap.put(s4, &quot;s4&quot;); // 删除HashMap中的s3。 // 结果：删除s3之后，HashMap中只有 s4 ！ hmap.remove(s3); // 将WeakHashMap中的s1设置null，并执行gc()。系统会回收w1 // 结果：s1是“弱键”，被GC回收后，WeakHashMap中s1对应的键值对，也会被从WeakHashMap中删除。 // w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。 // 因此，WeakHashMap中只有 s2 // 注意：若去掉“s1=null” 或者“System.gc()”，结果都会不一样！ s1 = null; System.gc(); /* // 休眠500ms try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } // */ // 遍历并打印HashMap的大小 System.out.printf(&quot; -- Self-def HashMap --\\n&quot;); iteratorAndCountMap(hmap); // 遍历并打印WeakHashMap的大小 System.out.printf(&quot; -- Self-def WeakHashMap --\\n&quot;); iteratorAndCountMap(wmap); } private static class Self { int id; public Self(int id) { this.id = id; } // 覆盖finalize()方法 // 在GC回收时会被执行 protected void finalize() throws Throwable { super.finalize(); System.out.printf(&quot;GC Self: id=%d addr=0x%s)\\n&quot;, id, this); } } }运行结果： -- HashMap -- map entry : H2 - h2 map size:1 -- WeakHashMap -- map entry : W2 - w2 map size:1 -- Self-def HashMap -- map entry : CompareHashmapAndWeakhashmap$Self@1ff9dc36 - s4 map size:1 -- Self-def WeakHashMap -- GC Self: id=10 addr=0xCompareHashmapAndWeakhashmap$Self@12276af2) map entry : CompareHashmapAndWeakhashmap$Self@59de3f2d - s2 map size:1更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/14/java/collection/2012-02-14-collection-14-mapsummary/"},{"title":"Java 反射机制(包括组成、结构、示例说明等内容)","text":"目录第1部分 Java 反射机制介绍第2部分 Class 详细说明 第1部分 Java 反射机制介绍Java 反射机制。通俗来讲呢，就是在运行状态中，我们可以根据“类的部分已经的信息”来还原“类的全部的信息”。这里“类的部分已经的信息”，可以是“类名”或“类的对象”等信息。“类的全部信息”就是指“类的属性，方法，继承关系和Annotation注解”等内容。 举个简单的例子：假设对于类ReflectionTest.java，我们知道的唯一信息是它的类名是“com.skywang.Reflection”。这时，我们想要知道ReflectionTest.java的其它信息(比如它的构造函数，它的成员变量等等)，要怎么办呢？ 这就需要用到“反射”。通过反射，我们可以解析出ReflectionTest.java的完整信息，包括它的构造函数，成员变量，继承关系等等。 在了解了“java 反射机制”的概念之后，接下来思考一个问题：如何根据类的类名，来获取类的完整信息呢？ 这个过程主要分为两步：第1步：根据“类名”来获取对应类的Class对象。第2步：通过Class对象的函数接口，来读取“类的构造函数，成员变量”等信息。 下面，我们根据示例来加深对这个概念的理解。示例如下(Demo1.java): package com.skywang.test; import java.lang.Class; public class Demo1 { public static void main(String[] args) { try { // 根据“类名”获取 对应的Class对象 Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 新建对象。newInstance()会调用类不带参数的构造函数 Object obj = cls.newInstance(); System.out.println(&quot;cls=&quot;+cls); } catch (Exception e) { e.printStackTrace(); } } } class Person { public Person() { System.out.println(&quot;create Person&quot;); } }运行结果： create Person cls=class com.skywang.test.Person说明：(01) Person类的完整包名是”com.skywang.test.Person”。而 Class.forName(“com.skywang.test.Person”); 这一句的作用是，就是根据Person的包名来获取Person的Class对象。(02) 接着，我们调用Class对象的newInstance()方法，创建Person对象。 现在，我们知道了“java反射机制”的概念以及它的原理。有了这个总体思想之后，接下来，我们可以开始对反射进行深入研究了。 第2部分 Class 详细说明1. 获取Class对象的方法我这里总结了4种常用的“获取Class对象”的方法：方法1：Class.forName(“类名字符串”) （注意：类名字符串必须是全称，包名+类名）方法2：类名.class方法3：实例对象.getClass()方法4：”类名字符串”.getClass() 下面，我们通过示例演示这4种方法。示例如下(Demo2.java): package com.skywang.test; import java.lang.Class; public class Demo2 { public static void main(String[] args) { try { // 方法1：Class.forName(&quot;类名字符串&quot;) （注意：类名字符串必须是全称，包名+类名） //Class cls1 = Class.forName(&quot;com.skywang.test.Person&quot;); Class&lt;?&gt; cls1 = Class.forName(&quot;com.skywang.test.Person&quot;); //Class&lt;Person&gt; cls1 = Class.forName(&quot;com.skywang.test.Person&quot;); // 方法2：类名.class Class cls2 = Person.class; // 方法3：实例对象.getClass() Person person = new Person(); Class cls3 = person.getClass(); // 方法4：&quot;类名字符串&quot;.getClass() String str = &quot;com.skywang.test.Person&quot;; Class cls4 = str.getClass(); System.out.printf(&quot;cls1=%s, cls2=%s, cls3=%s, cls4=%s\\n&quot;, cls1, cls2, cls3, cls4); } catch (Exception e) { e.printStackTrace(); } } } class Person { public Person() { System.out.println(&quot;create Person&quot;); } }运行结果： create Person cls1=class com.skywang.test.Person, cls2=class com.skywang.test.Person, cls3=class com.skywang.test.Person, cls4=class java.lang.String2 Class的API说明Class的全部API如下表: public static Class forName(String className) public static Class forName(String name, boolean initialize, ClassLoader loader) public Constructor getConstructor(Class[] parameterTypes) public Constructor[] getConstructors() public Constructor getDeclaredConstructor(Class[] parameterTypes) public Constructor[] getDeclaredConstructors() public Constructor getEnclosingConstructor() public Method getMethod(String name, Class[] parameterTypes) public Method[] getMethods() public Method getDeclaredMethod(String name, Class[] parameterTypes) public Method[] getDeclaredMethods() public Method getEnclosingMethod() public Field getField(String name) public Field[] getFields() public Field getDeclaredField(String name) public Field[] getDeclaredFields() public Type[] getGenericInterfaces() public Type getGenericSuperclass() public Annotation&lt;A&gt; getAnnotation(Class annotationClass) public Annotation[] getAnnotations() public Annotation[] getDeclaredAnnotations() public boolean isAnnotation() public boolean isAnnotationPresent(Class annotationClass) public boolean isAnonymousClass() public boolean isArray() public boolean isAssignableFrom(Class cls) public boolean desiredAssertionStatus() public Class&lt;U&gt; asSubclass(Class clazz) public Class getSuperclass() public Class getComponentType() public Class getDeclaringClass() public Class getEnclosingClass() public Class[] getClasses() public Class[] getDeclaredClasses() public Class[] getInterfaces() public boolean isEnum() public boolean isInstance(Object obj) public boolean isInterface() public boolean isLocalClass() public boolean isMemberClass() public boolean isPrimitive() public boolean isSynthetic() public String getSimpleName() public String getName() public String getCanonicalName() public String toString() public ClassLoader getClassLoader() public Package getPackage() public int getModifiers() public ProtectionDomain getProtectionDomain() public URL getResource(String name) public InputStream getResourceAsStream(String name) public Object cast(Object obj) public Object newInstance() public Object[] getSigners() public Object[] getEnumConstants() public TypeVariable[] getTypeParameters()我们根据类的特性，将Class中的类分为4部分进行说明：构造函数，成员方法，成员变量，类的其它信息(如注解、包名、类名、继承关系等等)。Class中涉及到Annotation(注解)的相关API，可以点击查看前一章节关于Annotation的详细介绍。 2.1 构造函数“构造函数”相关API // 获取“参数是parameterTypes”的public的构造函数 public Constructor getConstructor(Class[] parameterTypes) // 获取全部的public的构造函数 public Constructor[] getConstructors() // 获取“参数是parameterTypes”的，并且是类自身声明的构造函数，包含public、protected和private方法。 public Constructor getDeclaredConstructor(Class[] parameterTypes) // 获取类自身声明的全部的构造函数，包含public、protected和private方法。 public Constructor[] getDeclaredConstructors() // 如果这个类是“其它类的构造函数中的内部类”，调用getEnclosingConstructor()就是这个类所在的构造函数；若不存在，返回null。 public Constructor getEnclosingConstructor()接下来，我们通过示例对这些API进行说明。示例代码(DemoClassContructor.java)如下： package com.skywang.test; import java.lang.Class; import java.lang.reflect.Constructor; /** * java Class类的Constructor相关API的测试函数 * * @author skywang */ public class DemoClassContructor { public static void main(String[] args) { // getDeclaredConstructor() 的测试函数 testGetDeclaredConstructor() ; // getConstructor() 的测试函数 testGetConstructor() ; // getEnclosingConstructor() 的测试函数 testGetEnclosingConstructor() ; } /** * getDeclaredConstructor() 的测试函数 */ public static void testGetDeclaredConstructor() { try { // 获取Person类的Class Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 根据class，获取构造函数 Constructor cst1 = cls.getDeclaredConstructor(); Constructor cst2 = cls.getDeclaredConstructor(new Class[]{String.class}); Constructor cst3 = cls.getDeclaredConstructor(new Class[]{String.class, int.class, Gender.class}); // 根据构造函数，创建相应的对象 cst1.setAccessible(true); // 因为Person中Person()是private的，所以这里要设置为可访问 Object p1 = cst1.newInstance(); Object p2 = cst2.newInstance(&quot;Juce&quot;); Object p3 = cst3.newInstance(&quot;Jody&quot;, 34, Gender.MALE); System.out.printf(&quot;%-30s: p1=%s, p2=%s, p3=%s\\n&quot;, &quot;getConstructor()&quot;, p1, p2, p3); } catch (Exception e) { e.printStackTrace(); } } /** * getConstructor() 的测试函数 */ public static void testGetConstructor() { try { // 获取Person类的Class Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 根据class，获取构造函数 //Constructor cst1 = cls.getConstructor(); // 抛出异常，因为默认构造函数是private权限。 //Constructor cst2 = cls.getConstructor(new Class[]{String.class});// 抛出异常，因为该构造函数是protected权限。 Constructor cst3 = cls.getConstructor(new Class[]{String.class, int.class, Gender.class}); // 根据构造函数，创建相应的对象 //Object p1 = cst1.newInstance(); //cst1.setAccessible(true); // 因为Person中Person()是private的，所以这里要设置为可访问 //Object p1 = cst1.newInstance(); //Object p2 = cst2.newInstance(&quot;Kim&quot;); Object p3 = cst3.newInstance(&quot;Katter&quot;, 36, Gender.MALE); System.out.printf(&quot;%-30s: p3=%s\\n&quot;, &quot;getConstructor()&quot;, p3); } catch (Exception e) { e.printStackTrace(); } } /** * getEnclosingConstructor() 的测试函数 */ public static void testGetEnclosingConstructor() { try { // 获取Person类的Class Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 根据class，调用Person类中有内部类InnerA的构造函数 Constructor cst = cls.getDeclaredConstructor(new Class[]{String.class, int.class}); // 根据构造函数，创建相应的对象 Object obj = cst.newInstance(&quot;Ammy&quot;, 18); System.out.printf(&quot;%-30s: obj=%s\\n&quot;, &quot;getEnclosingConstructor()&quot;, obj); } catch (Exception e) { e.printStackTrace(); } } } // 枚举类型。表示“性别” enum Gender{ MALE, FEMALE } // 人 class Person { private Gender gender; // 性别 private int age; // 年龄 private String name; // 姓名 private Person() { this.name = &quot;unknown&quot;; this.age = 0; this.gender = Gender.FEMALE; System.out.println(&quot;call--\\&quot;private Person()\\&quot;&quot;); } protected Person(String name) { this.name = name; this.age = 0; this.gender = Gender.FEMALE; System.out.println(&quot;call--\\&quot;protected Person(String name)\\&quot;&quot;); } public Person(String name, int age, Gender gender) { this.name = name; this.age = age; this.gender = gender; System.out.println(&quot;call--\\&quot;public Person(String name, int age, Gender gender)\\&quot;&quot;); } public Person(String name, int age) { this.name = name; this.age = age; this.gender = Gender.FEMALE; //内部类在构造方法中 class InnerA{ } // 获取InnerA的Class对象 Class cls = InnerA.class; // 获取“封闭该内部类(InnerA)”的构造方法 Constructor cst = cls.getEnclosingConstructor(); System.out.println(&quot;call--\\&quot;public Person(String name, int age)\\&quot; cst=&quot;+cst); } @Override public String toString() { return &quot;(&quot;+name+&quot;, &quot;+age+&quot;, &quot;+gender+&quot;)&quot;; } }注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。 运行结果： call--&quot;private Person()&quot; call--&quot;protected Person(String name)&quot; call--&quot;public Person(String name, int age, Gender gender)&quot; getConstructor() : p1=(unknown, 0, FEMALE), p2=(Juce, 0, FEMALE), p3=(Jody, 34, MALE) call--&quot;public Person(String name, int age, Gender gender)&quot; getConstructor() : p3=(Katter, 36, MALE) call--&quot;public Person(String name, int age)&quot; cst=public com.skywang.test.Person(java.lang.String,int) getEnclosingConstructor() : obj=(Ammy, 18, FEMALE)说明：(01) 首先，要搞清楚Person类，它是我们自定义的类。专门用来测试这些API的。Person中有一个成员变量gender；它是Gender对象，Gender是一个枚举类。取值可以是MALE或者FEMALE。 (02) testGetDeclaredConstructor() 是“getDeclaredConstructor() 的测试函数”。getDeclaredConstructor()可以“获取类中任意的构造函数，包含public、protected和private方法”。 (03) testGetConstructor() 是“getConstructor() 的测试函数”。getConstructor()只能“获取类中public的构造函数”。 (04) testGetEnclosingConstructor() 是“getEnclosingConstructor() 的测试函数”。关于getEnclosingConstructor()的介绍，官方说法是“如果该 Class 对象表示构造方法中的一个本地或匿名类，则返回 Constructor 对象，它表示底层类的立即封闭构造方法。否则返回 null。” 通俗点来说，就是“如果一个类A的构造函数中定义了一个内部类InnerA，则通过InnerA的Class对象调用getEnclosingConstructor()方法，可以获取类A的这个构造函数”。 2.2 成员方法 “成员方法”相关API // 获取“名称是name，参数是parameterTypes”的public的函数(包括从基类继承的、从接口实现的所有public函数) public Method getMethod(String name, Class[] parameterTypes) // 获取全部的public的函数(包括从基类继承的、从接口实现的所有public函数) public Method[] getMethods() // 获取“名称是name，参数是parameterTypes”，并且是类自身声明的函数，包含public、protected和private方法。 public Method getDeclaredMethod(String name, Class[] parameterTypes) // 获取全部的类自身声明的函数，包含public、protected和private方法。 public Method[] getDeclaredMethods() // 如果这个类是“其它类中某个方法的内部类”，调用getEnclosingMethod()就是这个类所在的方法；若不存在，返回null。 public Method getEnclosingMethod()接下来，我们通过示例对这些API进行说明。示例代码(DemoClassMethod.java)如下： package com.skywang.test; import java.lang.Class; import java.lang.reflect.Method; /** * java Class类的Method相关API的测试函数 * * @author skywang */ public class DemoClassMethod { public static void main(String[] args) { // getDeclaredMethod() 的测试函数 testGetDeclaredMethod() ; // getMethod() 的测试函数 testGetMethod() ; // getEnclosingMethod() 的测试函数 testGetEnclosingMethod() ; } /** * getDeclaredMethod() 的测试函数 */ public static void testGetDeclaredMethod() { try { // 获取Person类的Class Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 根据class，调用类的默认构造函数(不带参数) Object person = cls.newInstance(); // 获取Person中的方法 Method mSetName = cls.getDeclaredMethod(&quot;setName&quot;, new Class[]{String.class}); Method mGetName = cls.getDeclaredMethod(&quot;getName&quot;, new Class[]{}); Method mSetAge = cls.getDeclaredMethod(&quot;setAge&quot;, new Class[]{int.class}); Method mGetAge = cls.getDeclaredMethod(&quot;getAge&quot;, new Class[]{}); Method mSetGender = cls.getDeclaredMethod(&quot;setGender&quot;, new Class[]{Gender.class}); Method mGetGender = cls.getDeclaredMethod(&quot;getGender&quot;, new Class[]{}); // 调用获取的方法 mSetName.invoke(person, new Object[]{&quot;Jimmy&quot;}); mSetAge.invoke(person, new Object[]{30}); mSetGender.setAccessible(true); // 因为Person中setGender()是private的，所以这里要设置为可访问 mSetGender.invoke(person, new Object[]{Gender.MALE}); String name = (String)mGetName.invoke(person, new Object[]{}); Integer age = (Integer)mGetAge.invoke(person, new Object[]{}); mGetGender.setAccessible(true); // 因为Person中getGender()是private的，所以这里要设置为可访问 Gender gender = (Gender)mGetGender.invoke(person, new Object[]{}); // 打印输出 System.out.printf(&quot;%-30s: person=%s, name=%s, age=%s, gender=%s\\n&quot;, &quot;getDeclaredMethod()&quot;, person, name, age, gender); } catch (Exception e) { e.printStackTrace(); } } /** * getMethod() 的测试函数 */ public static void testGetMethod() { try { // 获取Person类的Class Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 根据class，调用类的默认构造函数(不带参数) Object person = cls.newInstance(); // 获取Person中的方法 Method mSetName = cls.getMethod(&quot;setName&quot;, new Class[]{String.class}); Method mGetName = cls.getMethod(&quot;getName&quot;, new Class[]{}); //Method mSetAge = cls.getMethod(&quot;setAge&quot;, new Class[]{int.class}); // 抛出异常，因为setAge()是protected权限。 //Method mGetAge = cls.getMethod(&quot;getAge&quot;, new Class[]{}); // 抛出异常，因为getAge()是protected权限。 //Method mSetGender = cls.getMethod(&quot;setGender&quot;, new Class[]{Gender.class}); // 抛出异常，因为setGender()是private权限。 //Method mGetGender = cls.getMethod(&quot;getGender&quot;, new Class[]{}); // 抛出异常，因为getGender()是private权限。 // 调用获取的方法 mSetName.invoke(person, new Object[]{&quot;Phobe&quot;}); //mSetAge.invoke(person, new Object[]{38}); //mSetGender.invoke(person, new Object[]{Gender.FEMALE}); String name = (String)mGetName.invoke(person, new Object[]{}); //Integer age = (Integer)mGetAge.invoke(person, new Object[]{}); //Gender gender = (Gender)mGetGender.invoke(person, new Object[]{}); // 打印输出 System.out.printf(&quot;%-30s: person=%s\\n&quot;, &quot;getMethod()&quot;, person); } catch (Exception e) { e.printStackTrace(); } } /** * getEnclosingMethod() 的测试函数 */ public static void testGetEnclosingMethod() { try { // 获取Person类的Class Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 根据class，调用类的默认构造函数(不带参数) Object person = cls.newInstance(); // 根据class，调用Person类中有内部类InnerB的函数 Method mGetInner = cls.getDeclaredMethod(&quot;getInner&quot;, new Class[]{}); // 根据构造函数，创建相应的对象 mGetInner.invoke(person, new Object[]{}); System.out.printf(&quot;%-30s: person=%s\\n&quot;, &quot;getEnclosingMethod&quot;, person); } catch (Exception e) { e.printStackTrace(); } } } enum Gender{ MALE, FEMALE } class Person { private Gender gender; // 性别 private int age; // 年龄 private String name; // 姓名 public Person() { this(&quot;unknown&quot;, 0, Gender.FEMALE); } public Person(String name, int age, Gender gender) { this.name = name; this.age = age; this.gender = gender; } // 获取”姓名“。权限是 public public String getName() { return name; } // 设置”姓名“。权限是 public public void setName(String name) { this.name = name; } // 获取”年龄“。权限是 protected protected int getAge() { return age; } // 设置”年龄“。权限是 protected protected void setAge(int age) { this.age = age; } // 获取“性别”。权限是 private private Gender getGender() { return gender; } // 设置“性别”。权限是 private private void setGender(Gender gender) { this.gender = gender; } // getInner() 中有内部类InnerB，用来测试getEnclosingMethod() public void getInner() { // 内部类 class InnerB{ } // 获取InnerB的Class对象 Class cls = InnerB.class; // 获取“封闭该内部类(InnerB)”的构造方法 Method cst = cls.getEnclosingMethod(); System.out.println(&quot;call--\\&quot;getInner()\\&quot; cst=&quot;+cst); } @Override public String toString() { return &quot;(&quot;+name+&quot;, &quot;+age+&quot;, &quot;+gender+&quot;)&quot;; } }注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。 运行结果： getDeclaredMethod() : person=(Jimmy, 30, MALE), name=Jimmy, age=30, gender=MALE getMethod() : person=(Phobe, 0, FEMALE) call--&quot;getInner()&quot; cst=public void com.skywang.test.Person.getInner() getEnclosingMethod : person=(unknown, 0, FEMALE)2.3 成员变量“成员变量”的相关API // 获取“名称是name”的public的成员变量(包括从基类继承的、从接口实现的所有public成员变量) public Field getField(String name) // 获取全部的public成员变量(包括从基类继承的、从接口实现的所有public成员变量) public Field[] getFields() // 获取“名称是name”，并且是类自身声明的成员变量，包含public、protected和private成员变量。 public Field getDeclaredField(String name) // 获取全部的类自身声明的成员变量，包含public、protected和private成员变量。 public Field[] getDeclaredFields()接下来，我们通过示例对这些API进行说明。示例代码(DemoClassField.java)如下： package com.skywang.test; import java.lang.Class; import java.lang.reflect.Field; /** * java Class类的&quot;成员变量&quot;相关API的测试函数 * * @author skywang */ public class DemoClassField { public static void main(String[] args) { // getDeclaredField() 的测试函数 testGetDeclaredField() ; // getField() 的测试函数 testGetField() ; } /** * getDeclaredField() 的测试函数 * getDeclaredField() 用于获取的是类自身声明的所有成员遍历，包含public、protected和private方法。 */ public static void testGetDeclaredField() { try { // 获取Person类的Class Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 根据class，调用类的默认构造函数(不带参数) Object person = cls.newInstance(); // 根据class，获取Filed Field fName = cls.getDeclaredField(&quot;name&quot;); Field fAge = cls.getDeclaredField(&quot;age&quot;); Field fGender = cls.getDeclaredField(&quot;gender&quot;); // 根据构造函数，创建相应的对象 fName.set(person, &quot;Hamier&quot;); fAge.set(person, 31); fGender.setAccessible(true); // 因为&quot;flag&quot;是private权限，所以要设置访问权限为true；否则，会抛出异常。 fGender.set(person, Gender.FEMALE); System.out.printf(&quot;%-30s: person=%s\\n&quot;, &quot;getDeclaredField()&quot;, person); } catch (Exception e) { e.printStackTrace(); } } /** * getField() 的测试函数 * getField() 用于获取的是public的“成员” */ public static void testGetField() { try { // 获取Person类的Class Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 根据class，调用类的默认构造函数(不带参数) Object person = cls.newInstance(); // 根据class，获取Filed Field fName = cls.getField(&quot;name&quot;); Field fAge = cls.getDeclaredField(&quot;age&quot;); // 抛出异常，因为Person中age是protected权限。 Field fGender = cls.getDeclaredField(&quot;gender&quot;); // 抛出异常，因为Person中gender是private权限。 // 根据构造函数，创建相应的对象 fName.set(person, &quot;Grace&quot;); //fAge.set(person, 26); //fGender.set(person, Gender.FEMALE); System.out.printf(&quot;%-30s: person=%s\\n&quot;, &quot;getField()&quot;, person); } catch (Exception e) { e.printStackTrace(); } } } // 枚举类型。表示“性别” enum Gender{ MALE, FEMALE } // 人 class Person { // private。性别 private Gender gender; // protected。 年龄 protected int age; // public。 姓名 public String name; public Person() { this(&quot;unknown&quot;, 0, Gender.FEMALE); } public Person(String name, int age, Gender gender) { this.name = name; this.age = age; this.gender = gender; } @Override public String toString() { return &quot;(&quot;+name+&quot;, &quot;+age+&quot;, &quot;+gender+&quot;)&quot;; } }注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。 运行结果： getDeclaredField() : person=(Hamier, 31, FEMALE) getField() : person=(Grace, 0, FEMALE)2.4 类的其它信息2.4.1 “注解”相关的API // 获取类的&quot;annotationClass&quot;类型的注解 (包括从基类继承的、从接口实现的所有public成员变量) public Annotation&lt;A&gt; getAnnotation(Class annotationClass) // 获取类的全部注解 (包括从基类继承的、从接口实现的所有public成员变量) public Annotation[] getAnnotations() // 获取类自身声明的全部注解 (包含public、protected和private成员变量) public Annotation[] getDeclaredAnnotations()接下来，我们通过示例对这些API进行说明。示例代码(DemoClassAnnotation.java)如下： package com.skywang.test; import java.lang.Class; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; /** * java Class类getAnnotation()的测试程序 */ public class DemoClassAnnotation { public static void main(String[] args) { try { // 根据“类名”获取 对应的Class对象 Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 获取“Person类”的注解 MyAnnotation myann = cls.getAnnotation(MyAnnotation.class); System.out.println(&quot;myann=&quot;+myann); } catch (Exception e) { e.printStackTrace(); } } } /** * MyAnnotation是自定义个一个Annotation */ @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation { } /** * MyAnnotation 是Person的注解。 */ @MyAnnotation class Person { }注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。 运行结果： myann=@com.skywang.test.MyAnnotation()说明：(01) MyAnnotation 是我们自定义个一个Annotation注解。若读者不明白“注解”，可以参考博文“Java Annotation认知(包括框架图、详细介绍、示例说明)”(02) getAnnotation()就是获取这个类的注解。 2.4.2 “父类”和“接口”相关的API // 获取实现的全部接口 public Type[] getGenericInterfaces() // 获取父类 public Type getGenericSuperclass()示例代码(DemoClassInterface.java)如下： package com.skywang.test; import java.io.Serializable; import java.lang.Runnable; import java.lang.Thread; import java.lang.Class; import java.lang.reflect.Type; /** * java Class类的有关父类和接口的测试 */ public class DemoClassInterface { public static void main(String[] args) { try { // 根据“类名”获取 对应的Class对象 Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;); // 获取“Person”的父类 Type father = cls.getGenericSuperclass(); // 获取“Person”实现的全部接口 Type[] intfs = cls.getGenericInterfaces(); System.out.println(&quot;father=&quot;+father); for (Type t:intfs) System.out.println(&quot;t=&quot;+t); } catch (Exception e) { e.printStackTrace(); } } } /** * Person 继承于 Object，并且实现了Serializable和Runnable接口 */ class Person extends Object implements Serializable, Runnable{ @Override public void run() { } }注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。 运行结果： father=class java.lang.Object t=interface java.io.Serializable t=interface java.lang.Runnable2.4.3 剩余的API // 获取“类名” public String getSimpleName() // 获取“完整类名” public String getName() // 类是不是“枚举类” public boolean isEnum() // obj是不是类的对象 public boolean isInstance(Object obj) // 类是不是“接口” public boolean isInterface() // 类是不是“本地类”。本地类,就是定义在方法内部的类。 public boolean isLocalClass() // 类是不是“成员类”。成员类,是内部类的一种，但是它不是“内部类”或“匿名类”。 public boolean isMemberClass() // 类是不是“基本类型”。 基本类型，包括void和boolean、byte、char、short、int、long、float 和 double这几种类型。 public boolean isPrimitive() // 类是不是“复合类”。 JVM中才会产生复合类，在java应用程序中不存在“复合类”！ public boolean isSynthetic()示例代码(DemoClassOtherAPIs.java)如下： package com.skywang.test; import java.lang.Class; import java.lang.Runnable; import java.lang.annotation.ElementType; import java.util.TreeMap; /** * java Class类的getName(), isInterface()等测试程序 * * @author skywang */ public class DemoClassOtherAPIs { public static void main(String[] args) { Class cls = DemoClassOtherAPIs.class; // 获取“类名” System.out.printf(&quot;%-50s:getSimpleName()=%s\\n&quot;, cls, cls.getSimpleName()); // 获取“完整类名” System.out.printf(&quot;%-50s:getName()=%s\\n&quot;, cls, cls.getName()); // 测试其它的API testOtherAPIs() ; } public static void testOtherAPIs() { // 本地类 class LocalA { } // 测试枚举类型。ElementType是一个枚举类 Class elementtypeCls = ElementType.class; System.out.printf(&quot;%-50s:isEnum()=%s\\n&quot;, elementtypeCls, elementtypeCls.isEnum()); // 判断是不是类的对象 Class demoCls = DemoClassOtherAPIs.class; DemoClassOtherAPIs demoObj = new DemoClassOtherAPIs(); System.out.printf(&quot;%-50s:isInstance(obj)=%s\\n&quot;, demoCls, demoCls.isInstance(demoObj)); // 类是不是“接口” Class runCls = Runnable.class; System.out.printf(&quot;%-50s:isInterface()=%s\\n&quot;, runCls, runCls.isInterface()); // 类是不是“本地类”。本地类,就是定义在方法内部的类。 Class localCls = LocalA.class; System.out.printf(&quot;%-50s:isLocalClass()=%s\\n&quot;, localCls, localCls.isLocalClass()); // 类是不是“成员类”。成员类,是内部类的一种，但是它不是“内部类”或“匿名类”。 Class memCls = MemberB.class; System.out.printf(&quot;%-50s:isMemberClass()=%s\\n&quot;, memCls, memCls.isMemberClass()); // 类是不是“基本类型”。 基本类型，包括void和boolean、byte、char、short、int、long、float 和 double这几种类型。 Class primCls = int.class; System.out.printf(&quot;%-50s:isPrimitive()=%s\\n&quot;, primCls, primCls.isPrimitive()); // 类是不是“复合类”。 JVM中才会产生复合类，在java应用程序中不存在“复合类”！ Class synCls = DemoClassOtherAPIs.class; System.out.printf(&quot;%-50s:isSynthetic()=%s\\n&quot;, synCls, synCls.isSynthetic()); } // 内部成员类 class MemberB { } }注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。 运行结果： class com.skywang.test.DemoClassOtherAPIs :getSimpleName()=DemoClassOtherAPIs class com.skywang.test.DemoClassOtherAPIs :getName()=com.skywang.test.DemoClassOtherAPIs class java.lang.annotation.ElementType :isEnum()=true class com.skywang.test.DemoClassOtherAPIs :isInstance(obj)=true interface java.lang.Runnable :isInterface()=true class com.skywang.test.DemoClassOtherAPIs$1LocalA :isLocalClass()=true class com.skywang.test.DemoClassOtherAPIs$MemberB :isMemberClass()=true int :isPrimitive()=true class com.skywang.test.DemoClassOtherAPIs :isSynthetic()=false说明：isSynthetic()是用来判断Class是不是“复合类”。这在java应用程序中只会返回false，不会返回true。因为，JVM中才会产生复合类，在java应用程序中不存在“复合类”！","link":"/2012/03/04/java/others/2012-03-04-reflection/"},{"title":"Android Binder机制(二) Binder中的数据结构","text":"在对Binder代码展开详细介绍之前，先列举出Binder机制中涉及到的数据结构。本文是一篇参考文章，读者在阅读代码的过程中遇到相关的数据结构，就可以查阅此文中的内容。本文列举的数据结构，涵盖了内核空间和用户空间两个部分。内核空间部分就是Binder驱动中涉及到的数据结构；而用户空间的部分，包括ServiceManager守护进程，以及Android的C++层和Framework层的相关数据结构。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. 内核空间的Binder数据结构1.1. binder_proc1.2. binder_buffer1.3. binder_thread1.4. binder_node1.5. binder_ref1.6. binder_write_read1.7. flat_binder_object1.8. binder_transaction_data2. 用户空间的2.1. ServiceManager守护进程中的数据结构2.2. C++层的数据结构 1. 内核空间的Binder数据结构在介绍Binder驱动中的数据结构时，先回顾一下上一篇提到的”内核中的Binder设计图”，有一个整体印象。 前面说过，binder_proc是描述进程上下文信息的，每一个用户空间的进程都对应一个binder_proc结构体。binder_node是Binder实体对应的结构体，它是Server在Binder驱动中的体现。binder_ref是Binder引用对应的结构体，它是Client在Binder驱动中的体现。 1.1 binder_procbinder_proc是描述Binder进程上下文信息的结构体。Binder驱动的文件节点是”/dev/binder”，每当一个程序打开该文件节点时；Binder驱动中都会新建一个binder_proc对象来保存该进程的上下文信息。 struct binder_proc { struct hlist_node proc_node; // 根据proc_node，可以获取该进程在&quot;全局哈希表binder_procs(统计了所有的binder proc进程)&quot;中的位置 struct rb_root threads; // binder_proc进程内用于处理用户请求的线程组成的红黑树(关联binder_thread-&gt;rb_node) struct rb_root nodes; // binder_proc进程内的binder实体组成的红黑树(关联binder_node-&gt;rb_node) struct rb_root refs_by_desc; // binder_proc进程内的binder引用组成的红黑树，该引用以句柄来排序(关联binder_ref-&gt;rb_node_desc) struct rb_root refs_by_node; // binder_proc进程内的binder引用组成的红黑树，该引用以它对应的binder实体的地址来排序(关联binder_ref-&gt;rb_node) int pid; // 进程id struct vm_area_struct *vma; // 进程的内核虚拟内存 struct mm_struct *vma_vm_mm; struct task_struct *tsk; // 进程控制结构体(每一个进程都由task_struct 数据结构来定义)。 struct files_struct *files; // 保存了进程打开的所有文件表数据 struct hlist_node deferred_work_node; int deferred_work; void *buffer; // 该进程映射的物理内存在内核空间中的起始位置 ptrdiff_t user_buffer_offset; // 内核虚拟地址与进程虚拟地址之间的差值 // 内存管理的相关变量 struct list_head buffers; // 和binder_buffer-&gt;entry关联到同一链表，从而对Binder内存进行管理 struct rb_root free_buffers; // 空闲内存，和binder_buffer-&gt;rb_node关联。 struct rb_root allocated_buffers; // 已分配内存，和binder_buffer-&gt;rb_node关联。 size_t free_async_space; struct page **pages; // 映射内存的page页数组，page是描述物理内存的结构体 size_t buffer_size; // 映射内存的大小 uint32_t buffer_free; struct list_head todo; // 该进程的待处理事件队列。 wait_queue_head_t wait; // 等待队列。 struct binder_stats stats; struct list_head delivered_death; int max_threads; // 最大线程数。定义threads中可包含的最大进程数。 int requested_threads; int requested_threads_started; int ready_threads; long default_priority; // 默认优先级。 struct dentry *debugfs_entry; };说明：binder_proc定义在drivers/staging/android/binder.c中。由于定义在.c文件中，可见binder_proc是Binder驱动的私有结构体。上面已经给出了相关成员的注释，这里只对部分比较重要的成员进行说明。(01) proc_node, 它的作用是通过proc_node，将该binder_proc添加到”全局哈希表binder_procs(它记录了所有的binder_proc)”。不过binder_procs在Kernel驱动中暂时没有太大用处，所以不用太过关注该成员。(02) threads，它是包含该进程内用于处理用户请求的所有线程的红黑树。threads成员和binder_thread-&gt;rb_node关联到一棵红黑树，从而将binder_proc和binder_thread关联起来。(03) nodes，它是包行该进程内的所有Binder实体所组成的红黑树。nodes成员和binder_node-&gt;rb_node关联到一棵红黑树，从而将binder_proc和binder_node关联起来。(04) refs_by_desc，它是包行该进程内的所有Binder引用所组成的红黑树。refs_by_desc成员和binder_ref-&gt;rb_node_desc关联到一棵红黑树，从而将binder_proc和binder_ref关联起来。(05) refs_by_node，它是包行该进程内的所有Binder引用所组成的红黑树。refs_by_node成员和binder_ref-&gt;rb_node_node关联到一棵红黑树，从而将binder_proc和binder_ref关联起来。(06) buffer，它是该进程内核虚拟内存的起始地址。而user_buffer_offset，则是该内核虚拟地址和进程虚拟地址之间的差值。在Binder驱动中，将进程的内核虚拟地址和进程虚拟地址映射到同一物理页面，该user_buffer_offset则是它们之间的差值；这样，已知其中一个，就可以根据差值算出另外一个。(07) todo是该进程的待处理事务队列，而wait则是等待队列。它们的作用是实现进程的等待/唤醒。例如，当Server进程的wait等待队列为空时，Server就进入中断等待状态；当某Client向Server发送请求时，就将该请求添加到Server的todo待处理事务队列中，并尝试唤醒Server等待队列上的线程。如果，此时Server的待处理事务队列不为空，则Server被唤醒后；唤醒后，则取出待处理事务进行处理，处理完毕，则将结果返回给Client。 1.2 binder_bufferbinder_buffer是描述Binder进程所管理的每段内存的结构体。 struct binder_buffer { struct list_head entry; // 和binder_proc-&gt;buffers关联到同一链表，从而使Binder进程对内存进行管理。 struct rb_node rb_node; // 和binder_proc-&gt;free_buffers或binder_proc-&gt;allocated_buffers关联到同一红黑树，从而对已有内存和空闲内存进行管理。 unsigned free:1; // 空闲与否的标记 unsigned allow_user_free:1; unsigned async_transaction:1; unsigned debug_id:29; struct binder_transaction *transaction; struct binder_node *target_node; size_t data_size; size_t offsets_size; uint8_t data[0]; };说明：binder_buffer是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。Binder驱动将Binder进程的内存分成一段一段进行管理，而这每一段则是使用binder_buffer来描述的。 1.3 binder_threadbinder_thread是描述Binder线程的结构体。binder_proc是描述进程的，而binder_thread是描述进程中的线程。 struct binder_thread { struct binder_proc *proc; // 线程所属的Binder进程 struct rb_node rb_node; // 红黑树节点，关联到红黑树binder_proc-&gt;threads中。 int pid; // 进程id int looper; // 线程状态。可以取BINDER_LOOPER_STATE_REGISTERED等值 struct binder_transaction *transaction_stack; // 正在处理的事务栈 struct list_head todo; // 待处理的事务链表 uint32_t return_error; /* Write failed, return error code in read buf */ uint32_t return_error2; /* Write failed, return error code in read */ wait_queue_head_t wait; // 等待队列 struct binder_stats stats; // 保存一些统计信息 };说明：binder_thread是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。binder_thread是描述Binder线程相关信息的结构体。(01) proc，它是binder_proc(进程上下文信息)结构体对象。目的是保存该线程所属的Binder进程。(02) rb_node，它是红黑树节点。通过将rb_node binder关联到红黑树proc-&gt;threads中，从而将该线程添加到进程的threads红黑树中进行管理。 1.4 binder_nodebinder_node是描述Binder实体的结构体。 struct binder_node { int debug_id; struct binder_work work; union { struct rb_node rb_node; // 如果这个Binder实体还在使用，则将该节点链接到proc-&gt;nodes中。 struct hlist_node dead_node; // 如果这个Binder实体所属的进程已经销毁，而这个Binder实体又被其它进程所引用，则这个Binder实体通过dead_node进入到一个哈希表中去存放 }; struct binder_proc *proc; // 该binder实体所属的Binder进程 struct hlist_head refs; // 该Binder实体的所有Binder引用所组成的链表 int internal_strong_refs; int local_weak_refs; int local_strong_refs; void __user *ptr; // Binder实体在用户空间的地址(为Binder实体对应的Server在用户空间的本地Binder的引用) void __user *cookie; // Binder实体在用户空间的其他数据(为Binder实体对应的Server在用户空间的本地Binder自身) unsigned has_strong_ref:1; unsigned pending_strong_ref:1; unsigned has_weak_ref:1; unsigned pending_weak_ref:1; unsigned has_async_transaction:1; unsigned accept_fds:1; unsigned min_priority:8; struct list_head async_todo; };说明：binder_node是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。binder_node是描述Binder实体相关信息的结构体。(01) rb_node和dead_node属于一个union。如果该Binder实体还在使用，则通过rb_node将该节点链接到proc-&gt;nodes红黑树中；否则，则将该Binder实体通过dead_node链接到全局哈希表binder_dead_nodes中。(02) proc，它是binder_proc(进程上下文信息)结构体对象。目的是保存该Binder实体的进程。(03) refs，它是该Binder实体的所有引用所组成的链表。 在Binder驱动中，会为每一个Server都创建一个Binder实体，即会为每个Server都创建一个binder_node对象。 1.5 binder_refbinder_ref是描述Binder引用的结构体。 struct binder_ref { int debug_id; struct rb_node rb_node_desc; // 关联到binder_proc-&gt;refs_by_desc红黑树中 struct rb_node rb_node_node; // 关联到binder_proc-&gt;refs_by_node红黑树中 struct hlist_node node_entry; // 关联到binder_node-&gt;refs哈希表中 struct binder_proc *proc; // 该Binder引用所属的Binder进程 struct binder_node *node; // 该Binder引用对应的Binder实体 uint32_t desc; // 描述 int strong; int weak; struct binder_ref_death *death; };说明：binder_ref是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。它是用来描述Binder引用的相关信息的。(01) rb_node_desc和rb_node_node都是红黑树节点。通过rb_node_desc，Binder引用和binder_proc-&gt;refs_by_desc红黑树相关联；通过rb_node_node，Binder引用和binder_proc-&gt;refs_by_node红黑树相关联。(02) node是该Binder引用所引用的Binder实体。而node_entry在是关联到该Binder实体的binder_node-&gt;refs哈希表中。(03) proc，它是binder_proc(进程上下文信息)结构体对象。目的是保存该Binder引用所属的进程。(04) desc是Binder引用的描述，实际上它就是Binder驱动为该Binder分配的一个唯一的int型整数。通过该desc，可以在binder_proc-&gt;refs_by_desc中找到该Binder引用，进而可以找到该Binder引用所引用的Binder实体等信息。 在Binder驱动中，会为每个Client创建对应的Binder引用，即会为每个Client创建binder_ref对象。 “Binder实体”和”Binder引用”可以很好的将Server和Client关联起来：因为Binder实体和Binder引用分别是Server和Client在Binder驱动中的体现。 Client获取到Server对象后，”Binder引用所引用的Biner实体(即binder_ref.node)” 会指向 “Server对应的Biner实体”；同样的，Server被某个Client引用之后，”Server对应的Binder实体的引用列表(即，binder_node.refs)” 会包含 “Client对应的Binder引用”。 1.6 binder_write_readbinder_write_read是描述Binder读写信息的结构体。 struct binder_write_read { signed long write_size; signed long write_consumed; unsigned long write_buffer; signed long read_size; signed long read_consumed; unsigned long read_buffer; };说明：binder_write_read是内核空间和用户空间的通信结构体，它记录了Binder读写内容的相关信息。在内核中，它定义在drivers/staging/android/binder.h中；在Android中，它对应的引用在external/kernel-headers/original/linux/binder.h中。当用户空间的应用程序和Binder驱动通信时，它会将数据打包到binder_write_read中。write_开头的是记录应用程序要发送给Binder驱动的内容，而read_开头的是记录Binder驱动要反馈给应用程序的内容。(01) write_size，是写内容的总大小；write_consumed，是已写内容的大小；write_buffer，是写的内容的虚拟地址。(02) read_size，是读内容的总大小；read_consumed，是已读内容的大小；read_buffer，是读的内容的虚拟地址。 1.7 flat_binder_objectflat_binder_object是描述Binder对象信息的结构体。 struct flat_binder_object { unsigned long type; // binder类型：可以为BINDER_TYPE_BINDER或BINDER_TYPE_HANDLE等类型 unsigned long flags; // 标记 union { void *binder; // 当type=BINDER_TYPE_BINDER时，它指向Binder对象位于C++层的本地Binder对象(即BBinder对象)的弱引用。 signed long handle; // 当type=BINDER_TYPE_HANDLE时，它等于Binder对象在Binder驱动中对应的Binder实体的Binder引用的描述。 }; void *cookie; // 当type=BINDER_TYPE_BINDER时才有效，它指向Binder对象位于C++层的本地Binder对象(即BBinder对象)。 };说明： flat_binder_object是用来描述Binder信息的结构体。它也属于内核空间和用户空间的通信结构体。当它在用户空间被使用时(例如，Server发送添加服务请求给ServiceManager)，flat_binder_object就是记录的Server位于用户空间的Binder对象的信息的结构体；此时的type的值一般都是BINDER_TYPE_BINDER类型，对应的union中的binder的值是该Binder对象在用户空间的本地Binder(即BBinder对象)的引用；同时，cookie则是本地Binder自身。 而当flat_binder_object在Binder驱动中被使用(例如，当Binder驱动收到发送服务请求时)，它会将type修改为BINDER_TYPE_HANDLE，然后将联合体中的handle修改为”该Server对应的Binder实体的Binder引用”的描述；根据Binder引用的描述就能找到该Server。总体来说，在用户空间，flat_binder_object是描述该Binder实体在用户空间的存在形式；而在内核空间中，flat_binder_object则描述该Binder实体在内核中的存在形式。 1.8 binder_transaction_databinder_transaction_data是描述Binder事务交互的数据格式的结构体。 struct binder_transaction_data { union { size_t handle; // 当binder_transaction_data是由用户空间的进程发送给Binder驱动时， // handle是该事务的发送目标在Binder驱动中的信息，即该事务会交给handle来处理； // handle的值是目标在Binder驱动中的Binder引用。 void *ptr; // 当binder_transaction_data是有Binder驱动反馈给用户空间进程时， // ptr是该事务的发送目标在用户空间中的信息，即该事务会交给ptr对应的服务来处理； // ptr是处理该事务的服务的服务在用户空间的本地Binder对象。 } target; // 该事务的目标对象(即，该事务数据包是给该target来处理的) void *cookie; // 只有当事务是由Binder驱动传递给用户空间时，cookie才有意思，它的值是处理该事务的Server位于C++层的本地Binder对象 unsigned int code; // 事务编码。如果是请求，则以BC_开头；如果是回复，则以BR_开头。 unsigned int flags; pid_t sender_pid; uid_t sender_euid; size_t data_size; // 数据大小 size_t offsets_size; // 数据中包含的对象的个数 union { struct { const void *buffer; const void *offsets; } ptr; uint8_t buf[8]; } data; // 数据 };说明： binder_transaction_data是用来描述Binder事务交互的数据结构体。它也属于内核空间和用户空间的通信结构体。 2. 用户空间的Binder数据结构 2.1 ServiceManager守护进程中的数据结构 2.1.1 binder_statestruct binder_state { int fd; // 文件节点&quot;/dev/binder&quot;的句柄 void *mapped; // 映射内存的起始地址 unsigned mapsize; // 映射内存的大小 }; 说明：binder_state定义在frameworks/native/cmds/servicemanager/binder.c中，它是ServiceManager用来描述打开的”/dev/binder”的信息结构体。 2.1.2 binder_objectbinder_object是与flat_binder_object对应的结构体。 struct binder_object { uint32_t type; // 类型 uint32_t flags; void *pointer; void *cookie; };说明：binder_object定义在frameworks/native/cmds/servicemanager/binder.h中，它是ServiceManager中与flat_binder_object对应的结构体。 2.1.3 binder_txnbinder_txn与binder_transaction_data对应的结构体。 struct binder_txn { void *target; void *cookie; uint32_t code; uint32_t flags; uint32_t sender_pid; uint32_t sender_euid; uint32_t data_size; uint32_t offs_size; void *data; void *offs; };说明：binder_txn定义在frameworks/native/cmds/servicemanager/binder.h中，它是ServiceManager中与binder_transaction_data对应的结构体。 2.1.4 svcinfostruct svcinfo { struct svcinfo *next; // 下一个&quot;服务的信息&quot; void *ptr; // 服务在Binder驱动中的Binder引用的描述 struct binder_death death; int allow_isolated; unsigned len; // 服务的名称长度 uint16_t name[0]; // 服务的名称 }; 说明：svcinfo定义在frameworks/native/cmds/servicemanager/service_manager.c中。它是ServiceManager守护进程的私有结构体。 svcinfo是保存”注册到ServiceManager中的服务”的相关信息的结构体。它是一个单链表，在ServiceManager守护进程中的svclist是保存注册到ServiceManager中的服务的链表，它就是struct info类型。svcinfo中的next是指向下一个服务的节点，而ptr是该服务在Binder驱动中Binder引用的描述。name则是服务的名称。 2.2 C++层的数据结构 2.2.1 ParcelParcel是描述Binder通信信息的结构体。 class Parcel { public: ... // 获取数据(返回mData) const uint8_t* data() const; // 获取数据大小(返回mDataSize) size_t dataSize() const; // 获取数据指针的当前位置(返回mDataPos) size_t dataPosition() const; private: ... status_t mError; uint8_t* mData; // 数据 size_t mDataSize; // 数据大小 size_t mDataCapacity; // 数据容量 mutable size_t mDataPos; // 数据指针的当前位置 size_t* mObjects; // 对象在mData中的偏移地址 size_t mObjectsSize; // 对象个数 size_t mObjectsCapacity; // 对象的容量 ... }说明：Parcel定义在frameworks/native/include/binder/Parcel.h中。","link":"/2014/09/02/android/os/binder/2014-09-02-Binder-Datastruct/"},{"title":"Android 之Animation动画(七)之 Drawable Animation","text":"本章介绍Android中的Drawable Animation。 目录1. Drawable Animation的简介和语法2. Drawable Animation的示例 Drawable Animation的简介和语法Drawable Animation(Frame Animation)：帧动画，就像GIF图片，通过一系列Drawable依次显示来模拟动画的效果。 Drawable Animation的定义是通过在res/anim目录下新建一个xml文件来定义。xml文件的格式如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust1&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust2&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust3&quot; android:duration=&quot;200&quot; /&gt; &lt;/animation-list&gt;说明：(01) oneshot表示是否循环播放。true表示不循环播放，否则就循环播放。(02) duration表示每帧的播放时间。 Drawable Animation的示例点击查看：Drawable Animation示例的完整源码 示例中是通过ImageView来使用Drawable Animation的。 下面是获取ImageView的AnimationDrawable对象的方法： mImage = (ImageView)findViewById(R.id.animation); mImage.setBackgroundResource(R.anim.anim_kof); mAnimation = (AnimationDrawable) mImage.getBackground();说明：res/anim/anim_kof.xml就是动画的定义。 得到AnimationDrawable对象之后，就可以通过mAnimation.start()直接启动动画了。","link":"/2014/07/26/android/api_guide/animation/drawable_animation/2014-07-24-DrawableAnimation-BasicUsage/"},{"title":"Android 之Animation动画(二)之 Property Animation的基本介绍和使用示例","text":"本章介绍Android的Property Animation。 目录1. Property Animation简介2. Property Animation的基本用法和示例源码 Property Animation简介Property Animation是属性动画。它是在Android 3.0中才引进的，它比View Animation和Drawable Animation功能更加强大。 1. Property Animation支持的属性在Property Animation中，可以对动画应用以下属性：Duration：动画的持续时间。TimeInterpolation：属性值的计算方式，如先快后慢。TypeEvaluator：根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值。Repeat Count and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以此动画一直重复，或播放完时再反向播放。Animation sets：动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同开始偏移。Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响。 2. Property Animation的工作原理对于下图的动画，这个对象的X坐标在40ms内从0移动到40 pixel。默认的10ms刷新一次，这个对象会移动4次，每次移动40/4=10pixel。 也可以改变属性值的改变方法，即设置不同的interpolation，在下图中运动速度先快后慢。 3. Property Animation的框架Animator&nbsp;&nbsp; – &nbsp;&nbsp; ValueAnimator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; – &nbsp;&nbsp; ObjectAnimator&nbsp;&nbsp; – AnimatorSetAnimatorInflaterKeyframeKeyframeSetPropertyValuesHolderAnimatorListenerAdapter.javaTypeEvaluator&nbsp;&nbsp; – IntEvaluator&nbsp;&nbsp; – FloatEvaluator&nbsp;&nbsp; – ArgbEvaluator 说明：(01) Animator, ValueAnimator, ObjectAnimator是描述动画的核心类。其中，Animator是父类，它定义了动画开始/结束/暂停/恢复/重复等接口，并实现了公共函数。ValueAnimator和ObjectAnimator是描述动画的具体类。(02) AnimatorSet是动画集合。(03) AnimatorInflater是解析xml定义的动画的核心类。(04) Keyframe是关键帧，通过关键帧可以实现较复杂的动画(例如，曲线运动等)。KeyframeSet是关键帧的辅助类。(05) PropertyValuesHolder通常用于动画中有多个属性需要同时变化的情况。(06) AnimatorUpdateListener中实现了全部的动画监听接口。但是，监听函数体都没有执行任何动作。在我们需要监听动画相应动作时，可以实现Animator提供的接口，也可以继承于AnimatorUpdateListener。(07) TypeEvaluator则是动画中需要变化的属性值的计算类。Android提供了三种：用于计算int类型属性的IntEvaluator，用于计算float类型属性的FloatEvaluator，和用于计算rgb颜色类属性的ArgbEvaluator。若上面的三种均无法满足你的需求，则你可以自定义属性计算类。 4. Property Animation和View Animation的区别 Property Animation的动画对象是Object类型，而View Animation仅仅适用于View对象。 View Animation动画的功能有限：它可以进行缩放和旋转，但是却无法改变背景色。 View Animation动画在变化时，仅仅改变了View的绘制位置，并没有改变View本身的实际位置。比如，如果当通过View Animation让一个按钮移动到屏幕上的另一个位置时；虽然它绘制在目标位置，但是它的点击区域并没改变，还是和变化之前的点击区域一样。 Property Animation就不存在上面的问题，它是确实地改变了View对象的属性。虽然，View Animation存在上述缺点；但它一个明显的有点就是使用方法更简单。在View Animation能满足你的需求时，就不需要使用Property Animation。 Property Animation的基本用法和示例源码Android提供的Property Animation动画类主要有两个：ValueAnimator和ObjectAnimator。 点击查看: PropertyAnimation基本用法的完整源码 1. ValueAnimator的基本用法在显示动画的具体图像之前，需要执行两步操作：(01) 计算属性值。(02) 根据此时的属性值执行相应的动作，如改变对象的某一属性。 ValueAnimator只完成了第一步。当我们使用ValueAnimator时，需要自己完成第二步。如下示例： // 创建ValueAnimator动画。ofFloat()的参数是从&quot;动画开始&quot; 到 &quot;动画结束&quot;对应的值。 ValueAnimator anim2 = ValueAnimator.ofFloat(0f, (float)(view2.getHeight() - view2.getWidth())); // 总的显示时间 anim2.setDuration(500); // 变化模式(加速) anim2.setInterpolator(new AccelerateInterpolator()); // 监听：每次变化时的回调函数 anim2.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { // 设置view2的纵坐标y view2.setY((Float) animation.getAnimatedValue()); // 更新view2 view2.invalidate(); } });说明：(01) view2是自定义的View试图，它是一个圆。(02) 对于ValueAnimator而言，需要我们实现AnimatorUpdateListener()接口，并在接口中处理试图的位置变化。例如，view2.setY()就是用于设置view2的位置。这就是上面所说的第二步。(03) onAnimationUpdate()是动画变化的回调函数。当动画发生变化时，回执行该函数。 2. ObjectAnimator的基本用法ObjectAnimator继承于ValueAnimator。它相比于ValueAnimator，完成了第二部。下面看看ObjectAnimator的使用方法。 // 创建ObjectAnimator动画。view1中必须有setY方法 ObjectAnimator anim1 = ObjectAnimator.ofFloat(view1, &quot;y&quot;, 0f, (float)(view1.getHeight() - view1.getWidth())); // 总的显示时间 anim1.setDuration(1200); // 变化模式(弹跳) anim1.setInterpolator(new BounceInterpolator()); // 监听：每次变化时的回调函数 anim1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { // 更新view1 view1.invalidate(); } });说明(01) 虽然ObjectAnimator完成了第二步。ObjectAnimator的操作对象必须有对应的set方法。例如，上面的示例中操作的属性是”y”，因此view1类中必须要有setY(float)函数。(02) 虽然Object完成了位置的计算和设置。但是，我们还必须在onAnimationUpdate()中更新要显示的视图。 3. AnimatorSet的基本用法AnimatorSet是动画集合。用于来管理多个动画的播放次序。 如下示例： AnimatorSet animSet = new AnimatorSet(); animSet.playTogether(anim1, anim2, anim3);// 并行 animSet.playSequentially(anim3, anim4, anim5);// 串行 animSet.start();","link":"/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-BasicUsage/"},{"title":"Android 之Animation动画(五)之 Property Animation的布局动画","text":"本章如何通过Property Animation设置Android的布局动画。 目录1. Property Animation布局动画简介2. Property Animation布局动画示例 Property Animation布局动画简介Property Animation支持对ViewGroup中的View设置动画。 例如，当你添加或者移除ViewGroup中的View时，或者你调用View的setVisibility()方法来控制其显示或消失时；就可以设置相应的Property Animation动画。 Android的View视图支持动画的主要有四种行为：APPEARING：某个View被添加到ViewGroup中时，该View的动画。DISAPPEARING：某个View从ViewGroup中删除时，该View的动画。CHANGE_APPEARING：某个View被添加到ViewGroup中，并引起该ViewGroup中其他View的变化位置时，其他View的动画。CHANGE_DISAPPEARING：某个View从ViewGroup中删除，，并引起该ViewGroup中其他View的变化位置时，其他View的动画。 Property Animation布局动画示例点击查看：Property Animation布局动画示例 该示例中，包括：Android默认的动画，以及前面介绍的View的四种类型的动画的演示。以APPEARING来简单说明下布局动画的使用。 // 设置ViewGroup(mSelfLayout)对应的LayoutTransition。 LayoutTransition transition = new LayoutTransition(); mSelfLayout.setLayoutTransition(transition); // (添加)动画：APPEARING ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 90f, 0f); animIn.setDuration(transition.getDuration(LayoutTransition.APPEARING)); transition.setAnimator(LayoutTransition.APPEARING, animIn); animIn.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator anim) { View view = (View) ((ObjectAnimator) anim).getTarget(); view.setRotationY(0f); } });","link":"/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-Layout/"},{"title":"Android 之Animation动画(四)之 Property Animation的多属性变化","text":"本章介绍Property Animation中多属性变化的情况。 目录1. Property Animation的多属性变化的种类2. Property Animation的关键帧3. Property Animation的完整示例 Property Animation的多属性变化的种类给同一个View实现同一个动画效果(同时变化x和y)，有下面三种方法。 方法一：用多个ObjectAnimator对象 ObjectAnimator animX = ObjectAnimator.ofFloat(myView, &quot;x&quot;, 50f); ObjectAnimator animY = ObjectAnimator.ofFloat(myView, &quot;y&quot;, 100f); AnimatorSet animSetXY = new AnimatorSet(); animSetXY.playTogether(animX, animY); animSetXY.start();方法二：用一个ObjectAnimator对象加多个PropertyValuesHolder PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(&quot;x&quot;, 50f); PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(&quot;y&quot;, 100f); ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();方法三：用ViewPropertyAnimator myView.animate().x(50f).y(100f); Property Animation的关键帧通过关键帧，我们能实现较为复杂的动画；例如，实现曲线运动。下面给出关键帧的使用示例： // ==== view4的动画 ==== (利用&quot;关键帧&quot;实现曲线运动) PropertyValuesHolder anim4Y = PropertyValuesHolder.ofFloat( &quot;y&quot;, 0f, (float)(view2.getHeight() - view2.getWidth())); float x = view2.getX(); // 三个关键帧 Keyframe kf0 = Keyframe.ofFloat(0f, x); Keyframe kf1 = Keyframe.ofFloat(.5f, x + 20f); Keyframe kf2 = Keyframe.ofFloat(1f, x); PropertyValuesHolder anim4X = PropertyValuesHolder.ofKeyframe( &quot;x&quot;, kf0, kf1, kf2); ObjectAnimator anim4 = ObjectAnimator.ofPropertyValuesHolder(view4, anim4Y, anim4X); anim4.setDuration(1000); anim4.setInterpolator(new AccelerateInterpolator()); anim4.setRepeatCount(1); anim4.setRepeatMode(ValueAnimator.REVERSE); anim4.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { //view4.invalidate(); mContainer.invalidate(); } }); Property Animation的完整示例点击查看：多属性变化和关键帧的完整源码","link":"/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-MultiPropChange/"},{"title":"Android 之Animation动画(三)之 Property Animation的XML属性和使用示例","text":"前面介绍了Property Animation的相关类和类的基本使用方法，本章将介绍Property Animation的属性以及如何通过属性来使用Property Animation。 目录1. Property Animation属性介绍2. Property Animation属性使用示例 Property Animation属性介绍我们可以用XML文件来定义Property Animation。XML的基本语法如下： &lt;set android:ordering=[&quot;together&quot; | &quot;sequentially&quot;]&gt; &lt;objectAnimator android:propertyName=&quot;string&quot; android:duration=&quot;int&quot; android:valueFrom=&quot;float | int | color&quot; android:valueTo=&quot;float | int | color&quot; android:startOffset=&quot;int&quot; android:repeatCount=&quot;int&quot; android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;] android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt; &lt;animator android:duration=&quot;int&quot; android:valueFrom=&quot;float | int | color&quot; android:valueTo=&quot;float | int | color&quot; android:startOffset=&quot;int&quot; android:repeatCount=&quot;int&quot; android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;] android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt; &lt;set&gt; ... &lt;/set&gt; &lt;/set&gt;说明：(01) : 是objectAnimator和animator的集合。标签是可以嵌套的。(02) : 对应是ObjectAnimator动画。(03) : 对应是ValueAnimator动画。(04) android:propertyName: 属性名。仅ObjectAnimator才有该属性。(05) android:duration: 动画的总时间，以ms为单位，默认是300ms。(06) android:valueFrom: 动画的起始值。(07) android:valueTo: 动画的结束值。(08) android:startOffset: 动画的起始偏移时间，以ms为单位。(09) android:repeatCount: 动画重复播放重复次数。-1表示无穷次，默认是0。(10) android:repeatMode: 动画重复播放时的模式。repeat表示和原来一样从头开始播放，reverse表示反向播放；默认是repeat。(11) android:valueType: 属性的值的类型。可以位intType或floatType。 假设存在res/anim/property_animator.xml文件，该文件中定义了Property Animation动画。则动画的使用方法如下： AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator); set.setTarget(myObject); set.start();此外，补充说明两点：(01) View Animation的部分属性在Property Animation中也是可以使用的。例如，android:interpolator。(02) 为了区分Property Animation和View Animation的资源文件，从Android 3.1开始，Property Animation的xml文件存在res/animator/目录下（View Animation存在res/anim/目录下）， animator这个名是可选的。 Property Animation属性使用示例点击查看：Property Animation属性使用示例的源码 在该示例中存在多种动画。下面列举一种：球加速下落，并具有弹跳效果。 动画的配置文件res/anim/view01.xml的内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1200&quot; android:propertyName=&quot;y&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;249&quot; android:valueType=&quot;floatType&quot; android:interpolator=&quot;@android:anim/bounce_interpolator&quot; android:repeatCount=&quot;0&quot; /&gt;动画的使用代码如下： ObjectAnimator anim1 = (ObjectAnimator) AnimatorInflater.loadAnimator(context, R.anim.view01); anim1.setTarget(view1); anim1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { view1.invalidate(); } });","link":"/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-XmlUsage/"},{"title":"Android 之Animation动画(六)之 View Animation","text":"本章介绍Android中的View Animation。 目录1. View Animation简介2. View Animation的语法规则3. View Animation的示例 View Animation简介View Animation(Tween Animation): 补间动画，给出两个关键帧，通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。 View Animation只能用来实现四种基本动作：透明/伸缩/移动/旋转。它与”Property Animation适用于任意Object类型不同”，View Animation只适用于View。但是View Animation相比于Property Animation的使用更加简单。 View Animation的语法规则1. View Animation的样式View Animation通常在res/anim目录下新建一个xml文件来定义。xml文件的格式如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@[package:]anim/interpolator_resource&quot; android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;alpha android:fromAlpha=&quot;float&quot; android:toAlpha=&quot;float&quot; /&gt; &lt;scale android:fromXScale=&quot;float&quot; android:toXScale=&quot;float&quot; android:fromYScale=&quot;float&quot; android:toYScale=&quot;float&quot; android:pivotX=&quot;float&quot; android:pivotY=&quot;float&quot; /&gt; &lt;translate android:fromXDelta=&quot;float&quot; android:toXDelta=&quot;float&quot; android:fromYDelta=&quot;float&quot; android:toYDelta=&quot;float&quot; /&gt; &lt;rotate android:fromDegrees=&quot;float&quot; android:toDegrees=&quot;float&quot; android:pivotX=&quot;float&quot; android:pivotY=&quot;float&quot; /&gt; &lt;set&gt; ... &lt;/set&gt; &lt;/set&gt;说明：(01) set: 是动画的集合，相当于一个容器。(02) interpolator: 动画的动作类型，比如accelerate_interpolator类型的动画是加速的，它会越来越快。(03) shareInterpolator: 将set的interpolator应用到set所包行的动画中。(04) alpha: 透明度。&nbsp;&nbsp; a) fromAlpha: 起始动画的透明度。它的值是01.0之间；0表示完全透明，1.0表示完全不透明。&nbsp;&nbsp; b) toAlpha: 结束动画的透明度。它的值是01.0之间；0表示完全透明，1.0表示完全不透明。(05) scale: 缩放。&nbsp;&nbsp; a) fromXScale: 起始动画在X轴上的缩放倍数。0表示没有，2表示2倍。&nbsp;&nbsp; b) toXScale: 结束动画在X轴上的缩放倍数。0表示没有，2表示2倍。&nbsp;&nbsp; c) fromYScale: 起始动画在Y轴上的缩放倍数。0表示没有，2表示2倍。&nbsp;&nbsp; d) toYScale: 结束动画在Y轴上的缩放倍数。0表示没有，2表示2倍。&nbsp;&nbsp; e) pivotX: 动画缩放时，中心点在X轴上的位置(相对于原始的视图)。50%表示在视图的X轴中间。&nbsp;&nbsp; f) pivotY: 动画缩放时，中心点在Y轴上的位置(相对于原始的视图)。50%表示在视图的Y轴中间。(06) training: 移动。&nbsp;&nbsp; a) fromXDelta: 起始动画在X轴上的偏移像素(相对于视图左上角)。&nbsp;&nbsp; b) toXDelta: 结束动画在X轴上的偏移像素(相对于视图左上角)。&nbsp;&nbsp; c) fromYDelta: 起始动画在Y轴上的偏移像素(相对于视图左上角)。&nbsp;&nbsp; d) toYDelta: 结束动画在Y轴上的偏移像素(相对于视图左上角)。(07) rotate: 旋转。&nbsp;&nbsp; a) fromDegrees: 起始动画在的角度。可以是负数，也可以大于360。&nbsp;&nbsp; b) toDegrees: 起始动画在的角度。可以是负数，也可以大于360。&nbsp;&nbsp; c) pivotX: 动画旋转时，中心点在X轴上的位置(相对于原始的视图)。50%表示在视图的X轴中间。&nbsp;&nbsp; d) pivotY: 动画旋转时，中心点在Y轴上的位置(相对于原始的视图)。50%表示在视图的Y轴中间。rotate既可以顺时针旋转，也可以逆时针旋转。 2. interpolator的样式系统自带的interpolator样式如下： @android:anim/accelerate_decelerate_interpolator@android:anim/accelerate_interpolator@android:anim/anticipate_interpolator@android:anim/anticipate_overshoot_interpolator@android:anim/bounce_interpolator@android:anim/cycle_interpolator@android:anim/decelerate_interpolator@android:anim/linear_interpolator@android:anim/overshoot_interpolator View Animation的示例点击查看: View Animation的示例源码 该示例包括View Animation的”透明/伸缩/移动/旋转”，也包括”它们的组合”。 View Animation的具体播放代码如下： Animation anim = AnimationUtils.loadAnimation(this, R.anim.anim_alpha); view.startAnimation(anim);说明：view是一个View对象。","link":"/2014/07/25/android/api_guide/animation/view_animation/2014-07-24-ViewAnimation-BasicUsage/"},{"title":"Android 四大组件之Activity篇01之 概述","text":"本章介绍会对Android的四大组建(Activity、Service、BroadcastReceiver、ContentProvider)中的Activity作概括性的介绍。 首先，了解一下”什么是Activity”，Android中Activity的介绍如下： An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(). While activities are often presented to the user as full-screen windows, they can also be used in other ways: as floating windows (via a theme with windowIsFloating) or embedded inside of another activity (using ActivityGroup). 从中，可以看出： Activity 是用户接口程序，原则上它会提供给用户一个交互式的接口功能。它是 android 应用程序的基本功能单元。Activity 本身是没有界面的。所以activity类创建了一个窗口，开发人员可以通过setContentView(View)接口把UI放到activity创建的窗口上，当activity指向全屏窗口时，也可以用其他方式实现：作为漂浮窗口（通过windowIsFloating的主题集合），或者嵌入到其他的activity（使用ActivityGroup）。activity是单独的，用于处理用户操作。几乎所有的activity都要和用户打交道 接下来，我们将围绕Activity，依次介绍：(1) Activity的生命周期(2) Activity的启动方式和获取结果(3) Activity的启动模式(4) Activity和Application、进程之间的关系","link":"/2014/04/01/android/api_guide/app_component/activity/2014-04-01-Activity01/"},{"title":"Android组件--Fragment(五)之 DialogFragment","text":"关于DialogFragment的相关内容。请参考：android对话框","link":"/2014/06/23/android/api_guide/app_component/fragment/2014-06-23-DialogFragment/"},{"title":"Android 之Activity启动模式(三)之 启动模式的其它属性","text":"前面两章分别介绍了”四种launchMode”以及”Intent中与启动模式相关的Flag标签”，本章补充介绍一下manifest中其他与启动模式相关的属性。除非是有特殊需求，否则本章涉及到的知识很少会被用到。 属性介绍android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;] android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;] android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;] android:noHistory=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:taskAffinity 它在前面两章都已经涉及到了。它的作用是描述了不同Activity之间的亲密关系。拥有相同的taskAffinity的Activity是亲密的，它们之间在相互跳转时，会位于同一个task中，而不会新建一个task！如果在manifest中没有对Activity的android:taskAffinity进行配置，则每个Activity都采用和Application相同的taskAffinity；这也就意味着，同一个Application中的所有Activity的taskAffinity在默认情况下是相同的！ allowTaskReparenting 与字面理解相同，本属性允许activity重新指定Task。默认值是false。假设存在A并且它allowTaskReparenting为true。当系统中存在一个A的实例，并且A位于task1中时；此时，task2中的某一个Activity要跳转到A中，则此时会将A从task1转移到task2中。 alwaysRetainTaskState 总是保留task的状态。默认值是false。如果某个Activity的allowTaskReparenting设置为true；那么当该Activity位于某个task的栈底时，不管出现任何情况, 系统都会一直会保留task栈中Activity的状态。 clearTaskOnLaunch 默认值是false。如果某个Activity的clearTaskOnLaunch设置为true。当该Activity位于某个task的栈底时，如果你离开当前的task而转到别的task；那么，该task中除了该Activity之外的其它Activity都会被删除！ finishOnTaskLaunch 默认值是false。如果某个Activity的finishOnTaskLaunch设置位true。只要你一离开这个task栈, 则系统会马上清除这个Activity, 不管这个Activity在堆栈的任何位置。","link":"/2014/06/26/android/api_guide/app_component/activity/2014-06-26-OtherModeAttrs/"},{"title":"Android组件--Fragment(一)之 基础知识","text":"Fragment的内容很多。本章介绍Fragment的基础知识，包括：生命周期，以及如何使用Fragment。 目录1. Fragment生命周期图2. Fragment创建方式3. Google示例说明 Fragment生命周期图Fragment的生命周期图如下： 说明：总的来说，Fragment和Activity的生命周期类似。需要注意的是，它相比于Activity，多了onAttach(), onDetch(), onCreateView()和onDestroyView()这几个回调函数；但是，却少了onRestart()。点击查看：Fragment生命周期测试源码“ Fragment创建方式Fragment有两种使用方式：静态方式 和 动态方式。 1. 静态方式第一步：先定义一个Fragment子类。 public class ExampleFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.example_fragment, container, false); } }说明：ExampleFragment是Fragment的子类，它的布局定义是example_fragment.xml文件。 第二步：定义Fragment子类对应的布局文件。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;EditText android:id=&quot;@+id/edit_message&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:hint=&quot;@string/edit_message&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/button_send&quot; android:onClick=&quot;sendMessage&quot; /&gt; &lt;/LinearLayout&gt;说明：上面是example_fragment.xml的内容。 第三步：在需要用到该Fragment的Activity对应的布局中使用该Fragment。 下面是引用Fragment的Activity的代码： public class FragmentLayoutTest extends Activity { /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } }下面是main.xml的内容： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; &gt; &lt;TextView android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/fragment_intro&quot; /&gt; &lt;fragment android:name=&quot;com.skw.fragmentlayouttest.ExampleFragment&quot; android:id=&quot;@+id/frag_example&quot; android:layout_weight=&quot;1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;/LinearLayout&gt;说明：在该布局文件中通过调用了先前自定义的ExampleFragment。 点击查看：静态方式的完整源码 2. 动态方式重复”上面的第一步和第二步”，实现一个Fragment子类。 第三步：在需要用到该Fragment的Activity对应的布局中使用定义一个FrameLayout。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; &gt; &lt;TextView android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/fragment_intro&quot; /&gt; &lt;FrameLayout android:id=&quot;@+id/frag_example&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;/LinearLayout&gt;第四步：在Activity中将Fragment填充到FrameLayout中。 public class FragmentLayoutTest extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // 获取FragmentManager FragmentManager fragmentManager = getFragmentManager(); // 获取FragmentTransaction FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); // 获取ExampleFragment ExampleFragment fragment = new ExampleFragment(); // 将fragment添加到容器frag_example中 fragmentTransaction.add(R.id.frag_example, fragment); fragmentTransaction.commit(); } }点击查看：动态方式的完整源码 Google示例说明点击查看：Google给出的Fragment的源码 Google的官网上以此APK来对Fragment进行了简单介绍，点击查看：Google官网Fragment简介 实际上，Google官网关于Fragment的讲解内容包括三部分：创建Fragment，用Fragment创建灵活的UI，Fragments之间的通信。 如何创建Fragment，我在上面已经详细介绍过了。 灵活的创建UI，主要是指采用动态方式创建Fragment，并根据屏幕大小，来选择适当的Fragment对UI进行布局。 Fragment之间的通信。Fragments之间是无法直接通信的，那怎么办呢？Google官网给出的解答是，采用类似于回调函数的机制。Fragment都是通过Acitivty来显示的，不同的Fragment可以通过Activity这个中介来进行通信。具体的做法是在Fragment给出接口定义，然后再在Activity中实现给接口，从而实现不同Fragment之间的通信。","link":"/2014/06/23/android/api_guide/app_component/fragment/2014-06-23-Fragment/"},{"title":"Android组件--Fragment(四)之 ListFragment","text":"本文介绍ListFragment。 ListFragment简介ListFragment继承于Fragment。因此它具有Fragment的特性，能够作为activity中的一部分，目的也是为了使页面设计更加灵活。 相比Fragment，ListFragment的内容是以列表(list)的形式显示的。ListFragment的布局默认包含一个ListView。因此，在ListFragment对应的布局文件中，必须指定一个 android:id 为 “@android:id/list” 的ListView控件! ListFragment使用示例点击查看：ListFragment的完整代码 下面介绍在Activity中显示ListFragment的步骤。 1. Activity对应的代码public class FragmentTest extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } }2. Activity对应的布局&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;fragment android:name=&quot;com.skw.fragmenttest.MyListFragment&quot; android:id=&quot;@+id/myfragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt;说明：该Activity的布局中只包行了一个Fragment。下面看看MyListFragment的内容。 3. MyListFragment的内容public class MyListFragment extends ListFragment { private static final String TAG = &quot;##MyListFragment##&quot;; private ListView selfList; String[] cities = { &quot;Shenzhen&quot;, &quot;Beijing&quot;, &quot;Shanghai&quot;, &quot;Guangzhou&quot;, &quot;Wuhan&quot;, &quot;Tianjing&quot;, &quot;Changsha&quot;, &quot;Xi&apos;an&quot;, &quot;Chongqing&quot;, &quot;Guilin&quot;, }; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Log.d(TAG, &quot;onCreateView&quot;); return inflater.inflate(R.layout.list_fragment, container, false); } @Override public void onCreate(Bundle savedInstanceState) { Log.d(TAG, &quot;onCreate&quot;); super.onCreate(savedInstanceState); // 设置ListFragment默认的ListView，即@id/android:list this.setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), android.R.layout.simple_list_item_1, cities)); } public void onListItemClick(ListView parent, View v, int position, long id) { Log.d(TAG, &quot;onListItemClick&quot;); Toast.makeText(getActivity(), &quot;You have selected &quot; + cities[position], Toast.LENGTH_SHORT).show(); } }说明：MyListFragment是自定义的ListFragment。它使用了list_fragment.xml作为布局，并通过android.R.layout.simple_list_item_1显示ListView中的每一项。 4. list_fragment.xml的内容&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;!-- ListFragment对应的android:id值固定为&quot;@id/android:list&quot; --&gt; &lt;ListView android:id=&quot;@id/android:list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:drawSelectorOnTop=&quot;false&quot; /&gt; &lt;/LinearLayout&gt;自定义ListFragment点击查看：自定义ListFragment的完整代码 “Activity的布局以及代码”和前面一样，这里就不再重复说明。 3. MyListFragment的内容public class MyListFragment extends ListFragment { private static final String TAG = &quot;##MyListFragment##&quot;; private ListView selfList; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Log.d(TAG, &quot;onCreateView&quot;); return inflater.inflate(R.layout.list_fragment, container, false); } @Override public void onCreate(Bundle savedInstanceState) { final String[] from = new String[] {&quot;title&quot;, &quot;info&quot;}; final int[] to = new int[] {R.id.text1, R.id.text2}; Log.d(TAG, &quot;onCreate&quot;); super.onCreate(savedInstanceState); // 建立SimpleAdapter，将from和to对应起来 SimpleAdapter adapter = new SimpleAdapter( this.getActivity(), getSimpleData(), R.layout.item, from, to); this.setListAdapter(adapter); } public void onListItemClick(ListView parent, View v, int position, long id) { Log.d(TAG, &quot;onListItemClick&quot;); Toast.makeText(getActivity(), &quot;You have selected &quot; + position, Toast.LENGTH_SHORT).show(); } private List&lt;Map&lt;String, Object&gt;&gt; getSimpleData() { List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;, &quot;Ferris wheel&quot;); map.put(&quot;info&quot;, &quot;Suzhou Ferris wheel&quot;); list.add(map); map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;, &quot;Flower&quot;); map.put(&quot;info&quot;, &quot;Roser&quot;); list.add(map); map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;, &quot;Disk&quot;); map.put(&quot;info&quot;, &quot;Song Disk&quot;); list.add(map); return list; } }说明：MyListFragment使用了R.layout.list_fragment作为布局，并且对于ListView中的每一项都使用了R.layout.item作为布局。 4. list_fragment.xml的内容&lt;!-- ListFragment对应的android:id值固定为&quot;@id/android:list&quot; --&gt; &lt;ListView android:id=&quot;@id/android:list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:drawSelectorOnTop=&quot;false&quot; /&gt;5. item.xml的内容&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;TextView android:id=&quot;@+id/text1&quot; android:textSize=&quot;12sp&quot; android:textStyle=&quot;bold&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;TextView android:id=&quot;@+id/text2&quot; android:textSize=&quot;24sp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/LinearLayout&gt;","link":"/2014/06/23/android/api_guide/app_component/fragment/2014-06-23-ListFragment/"},{"title":"Android 之ContentProvider(三)之 Permission权限设置","text":"前面自定义Permission权限。自定义权限除了用在ContentProvider中之外，也可以用在Activity与Service中。 目录1. Permission介绍2. 自定义Permission示例 Permission介绍&lt;permission android:name=&quot;com.skw.permission.myprovider&quot; android:protectionLevel=&quot;normal&quot; android:label=&quot;@string/permission_label&quot; android:description=&quot;@string/permission_description&quot; /&gt;说明：permission常用的几个属性如下：(01) android:name: 必需的。权限的名称，通常应遵循android 命名方案(.permission.)。(02) android:protectionLevel: 必需的。权限的安全级别，共包括”normal, dangerous, signature, signatureOrSystem”四种。 normal 表示权限是低风险的，不会对系统、用户或其他应用程序造成危害；dangerous 表示权限是高风险的，系统将可能要求用户输入相关信息，才会授予此权限；signature 表示只有当应用程序所用数字签名与声明引权限的应用程序所用数字签名相同时，才能将权限授给它；signatureOrSystem 表示将权限授给具有相同数字签名的应用程序或android 包类。 (03) android:permissionGroup: 非必需的。可以将权限放在一个组中，但对于自定义权限，应该避免设置此属性。(04) android:label: 非必需的。标签。(05) android:description: 非必需的。描述。(06) android:icon非必需的。图标。 自定义Permission示例点击查看：自定义Permission完整源码 1. 设置权限&lt;application android:exported=&quot;true&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;provider android:name=&quot;MyProvider&quot; android:authorities=&quot;com.skw.myprovider&quot; android:permission=&quot;com.skw.permission.myprovider&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/provider&gt; &lt;/application&gt; &lt;permission android:name=&quot;com.skw.permission.myprovider&quot; android:protectionLevel=&quot;normal&quot; android:label=&quot;@string/permission_label&quot; android:description=&quot;@string/permission_description&quot; /&gt;说明：上面是自定义权限的manifest文件内容。(01) 首先，在需要定义权限的ContentProvider中声明权限android:permission=”com.skw.permission.myprovider”。(02) 接着，再定义permission。permission对应的name与声明的权限对应。 2. 获取权限在需要使用ContentProvider的APK的manifest中需要声明使用该权限。声明方法如下： &lt;uses-permission android:name=&quot;com.skw.permission.myprovider&quot; /&gt;","link":"/2014/07/06/android/api_guide/app_component/content_provider/2014-07-06-ContentProvider-Permission/"},{"title":"Android组件--Fragment(二)之 PreferenceFragment","text":"本文介绍PreferenceFragment。PreferenceFragment是Android提供的设置碎片。 PreferenceFragment使用说明点击查看：PreferenceFragment的完整代码 1. 创建配置文件新建res/xml/preferences.xml，内容如下： &lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;PreferenceCategory android:title=&quot;PreferenceCategory A&quot;&gt; &lt;!-- (01) android:key是Preferece的id (02) android:title是Preferece的大标题 (03) android:summary是Preferece的小标题 --&gt; &lt;CheckBoxPreference android:key=&quot;checkbox_preference&quot; android:title=&quot;title_checkbox_preference&quot; android:summary=&quot;summary_checkbox_preference&quot; /&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=&quot;PreferenceCategory B&quot;&gt; &lt;!-- android:dialogTitle是对话框的标题 android:defaultValue是默认值 --&gt; &lt;EditTextPreference android:key=&quot;edittext_preference&quot; android:title=&quot;title_edittext_preference&quot; android:summary=&quot;null&quot; android:dialogTitle=&quot;dialog_title_edittext_preference&quot; android:defaultValue=&quot;null&quot; /&gt; &lt;!-- android:entries是列表中各项的说明 android:entryValues是列表中各项的值 --&gt; &lt;ListPreference android:key=&quot;list_preference&quot; android:dialogTitle=&quot;Choose font&quot; android:entries=&quot;@array/pref_font_types&quot; android:entryValues=&quot;@array/pref_font_types_values&quot; android:summary=&quot;sans&quot; android:title=&quot;Font&quot; android:defaultValue=&quot;sans&quot;/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=&quot;PreferenceCategory C&quot;&gt; &lt;SwitchPreference android:key=&quot;switch_preferece&quot; android:title=&quot;title_switch_preferece&quot; android:defaultValue=&quot;true&quot; /&gt; &lt;SeekBarPreference android:key=&quot;seekbar_preference&quot; android:title=&quot;title_seekbar_preference&quot; android:max=&quot;100&quot; android:defaultValue=&quot;30&quot; /&gt; &lt;/PreferenceCategory&gt; &lt;/PreferenceScreen&gt;说明：PreferenceFragment的组件很多，包括CheckBoxPreference, EditTextPreference, ListPreference, SwitchPreference, SeekBarPreference, VolumePreference等。这些组建的属性定义如下。(01) android:key是Preferece的id，它是Preferece的唯一标识。(02) android:title是Preferece的大标题。(03) android:summary是Preferece的小标题。(04) android:dialogTitle是对话框的标题。(05) android:defaultValue是默认值。(06) android:entries是列表中各项的说明。(07) android:entryValues是列表中各项的值。 注意：SwitchPreference是API 14(Android4.0)才支持的。所以，要想使用SwitchPreference的话，必须在manifest中定义apk支持的最小版本。 &lt;uses-sdk android:minSdkVersion=&quot;14&quot; /&gt;2. 自定义PreferenceFragmentpublic class PrefsFragment extends PreferenceFragment implements SharedPreferences.OnSharedPreferenceChangeListener, Preference.OnPreferenceClickListener { private static final String TAG = &quot;##PrefsFragment##&quot;; private static final String CHECK_PREFERENCE = &quot;checkbox_preference&quot;; private static final String EDITTEXT_PREFERENCE = &quot;edittext_preference&quot;; private static final String LIST_PREFERENCE = &quot;list_preference&quot;; private static final String SWITCH_PREFERENCE = &quot;switch_preferece&quot;; private static final String SEEKBAR_PREFERENCE = &quot;seekbar_preference&quot;; private Preference mEditText; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Load the preferences from an XML resource addPreferencesFromResource(R.xml.preferences); mEditText = (Preference) findPreference(EDITTEXT_PREFERENCE); mEditText.setOnPreferenceClickListener(this); } @Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) { // Set summary to be the user-description for the selected value Preference connectionPref = findPreference(key); if (key.equals(CHECK_PREFERENCE)) { boolean checked = sharedPreferences.getBoolean(key, false); Log.d(TAG, &quot;CheckBox: checked=&quot;+checked); } else if (key.equals(EDITTEXT_PREFERENCE)) { String value = sharedPreferences.getString(key, &quot;&quot;); connectionPref.setSummary(value); Log.d(TAG, &quot;EditText: value=&quot;+value); } else if (key.equals(LIST_PREFERENCE)) { String value = sharedPreferences.getString(key, &quot;&quot;); connectionPref.setSummary(value); Log.d(TAG, &quot;List: value=&quot;+value); } else if (key.equals(SWITCH_PREFERENCE)) { boolean checked = sharedPreferences.getBoolean(key, false); Log.d(TAG, &quot;Switch: checked=&quot;+checked); } else if (key.equals(SEEKBAR_PREFERENCE)) { int value = sharedPreferences.getInt(key, 0); Log.d(TAG, &quot;Seekbar: value=&quot;+value); } } @Override public boolean onPreferenceClick(Preference preference) { SharedPreferences sharedPreferences = preference.getSharedPreferences(); String value = sharedPreferences.getString(preference.getKey(), &quot;&quot;); Log.d(TAG, &quot;onPreferenceClick: value=&quot;+value); return true; } @Override public void onResume() { super.onResume(); getPreferenceManager().getSharedPreferences().registerOnSharedPreferenceChangeListener(this); } @Override public void onPause() { getPreferenceManager().getSharedPreferences().unregisterOnSharedPreferenceChangeListener(this); super.onPause(); } }说明：PreferenceFragment中的每一项都是一个SharedPreferences对象，它们会像SharedPreferences存储在该APK的私有数据区。监听PreferenceFragment中的成员有多种方式，常用的两种就是：(01) 监听数据的变化：通过实现SharedPreferences.OnSharedPreferenceChangeListener接口，来监听PreferenceFragment中每一项的数据变化。(02) 监听点击事件：通过实现Preference.OnPreferenceClickListener接口，来监听PreferenceFragment中每一项的点击动作。 3. 使用PreferenceFragment前面已经定义好了一个PreferenceFragment。接下来，就可以实例化它的对象，并将其在Activity中进行显示。 public class FragmentTest extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); getFragmentManager().beginTransaction().replace(android.R.id.content, new PrefsFragment()).commit(); } }","link":"/2014/06/23/android/api_guide/app_component/fragment/2014-06-23-PreferenceFragment/"},{"title":"Android 之ContentProvider(一)之 Uri介绍","text":"本章介绍Uri及其相关内容。 目录1. URI简介2. Content URIs介绍 URI简介URI(Universal Resource Identifier)，又被称为”通用资源标志符”。 URI由许多部分所组成，示例及解说如下： Content URIs介绍Android遵循URI的标准，定义了一套专用的Uri(即，Content URIs)。并且，Android提供了ContentUris、UriMatcher等类用于操作Content URIs。 1. Content URIs语法Content URIs的语法如下： content://authority/path/id Content URIs的示例及说明如下： 说明：content: Content URIs前缀，它对应与标准URI的scheme。它的值为ContentResolver.SCHEME_CONTENT(即，content://)。authority: 一个唯一的标识符，Google建议使用类的全名来作为authority。外部调用者可以根据这个标识来找到它。path: 它可以用来表示我们要操作的数据，外部调用者根据这个路径信息来判断要返回什么类型的数据。这个后缀路径可以自由定义。id: 唯一的数字标识符。它表示要具体操作的数据类型中的具体某一项。 2. Content URIs相关类介绍2.1 ContentUrisContentUris中包含了三个静态函数: long parseId(Uri uri): 解析Uri中的末尾id。成功返回id，失败则返回-1。 Uri withAppendedId(Uri uri, long id): 将id追加到uri中，并返回追加id后的uri。 Uri.Builder appendId(Uri.Builder builder, long id): 将id追加到builder中，并返回追加id后的builder。 2.2 UriMatcherUriMatcher用于匹配Uri。它的用法如下：(01) 创建UriMatcher对象。(02) 把你需要匹配Uri路径通过addURI()注册到UriMatcher对象上。(03) 注册成功后，ContentProvider就可以通过UriMatcher监听你注册的Uri。当有匹配的Uri动作(如插入)时，再就可以通过UriMatcher的match()函数来获取Uri的一个标识，该标识是在addURI()时传入的。这个标识的作用是方便在switch语句中对不同的Uri进行处理。 UriMatcher的主要API说明： void addURI(String authority, String path, int code): 将”authority”+”path”注册的Uri注册到UriMatcher中，code是该Uri对应的标识。int match(Uri uri): 匹配Uri，并返回Uri对应的标识。这里返回的标识与addURI中的标识对应。","link":"/2014/07/06/android/api_guide/app_component/content_provider/2014-07-06-ContentProvider-Uri/"},{"title":"Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例","text":"这一章，我们对WeakHashMap进行学习。我们先对WeakHashMap有个整体认识，然后再学习它的源码，最后再通过实例来学会使用WeakHashMap。 目录第1部分 WeakHashMap介绍第2部分 WeakHashMap数据结构第3部分 WeakHashMap源码解析(基于JDK1.6.0_45)第4部分 WeakHashMap遍历方式第5部分 WeakHashMap示例 第1部分 WeakHashMap介绍WeakHashMap简介 WeakHashMap 继承于AbstractMap，实现了Map接口。和HashMap一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是null。不过WeakHashMap的键是“弱键”。在 WeakHashMap 中，当某个键不再正常使用时，会被从WeakHashMap中被自动移除。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。某个键被终止时，它对应的键值对也就从映射中有效地移除了。这个“弱键”的原理呢？大致上就是，通过WeakReference和ReferenceQueue实现的。 WeakHashMap的key是“弱键”，即是WeakReference类型的；ReferenceQueue是一个队列，它会保存被GC回收的“弱键”。实现步骤是：&nbsp;&nbsp;(01) 新建WeakHashMap，将“键值对”添加到WeakHashMap中。&nbsp;&nbsp;&nbsp;&nbsp;实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。&nbsp;&nbsp;(02) 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。&nbsp;&nbsp;(03) 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是删除table中被GC回收的键值对。 这就是“弱键”如何被自动从WeakHashMap中删除的步骤了。 和HashMap一样，WeakHashMap是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap。 WeakHashMap的构造函数 WeakHashMap共有4个构造函数,如下： // 默认构造函数。 WeakHashMap() // 指定“容量大小”的构造函数 WeakHashMap(int capacity) // 指定“容量大小”和“加载因子”的构造函数 WeakHashMap(int capacity, float loadFactor) // 包含“子Map”的构造函数 WeakHashMap(Map&lt;? extends K, ? extends V&gt; map)WeakHashMap的API void clear() Object clone() boolean containsKey(Object key) boolean containsValue(Object value) Set&lt;Entry&lt;K, V&gt;&gt; entrySet() V get(Object key) boolean isEmpty() Set&lt;K&gt; keySet() V put(K key, V value) void putAll(Map&lt;? extends K, ? extends V&gt; map) V remove(Object key) int size() Collection&lt;V&gt; values() 第2部分 WeakHashMap数据结构WeakHashMap的继承关系如下 java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.WeakHashMap&lt;K, V&gt;WeakHashMap的声明 public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; {}WeakHashMap与Map关系如下图： 从图中可以看出：(01) WeakHashMap继承于AbstractMap，并且实现了Map接口。(02) WeakHashMap是哈希表，但是它的键是”弱键”。WeakHashMap中保护几个重要的成员变量：table, size, threshold, loadFactor, modCount, queue。&nbsp;&nbsp;table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。&nbsp;&nbsp;size是Hashtable的大小，它是Hashtable保存的键值对的数量。&nbsp;&nbsp;threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。&nbsp;&nbsp;loadFactor就是加载因子。&nbsp;&nbsp;modCount是用来实现fail-fast机制的&nbsp;&nbsp;queue保存的是“已被GC清除”的“弱引用的键”。 第3部分 WeakHashMap源码解析(基于JDK1.6.0_45)下面对WeakHashMap的源码进行说明 package java.util; import java.lang.ref.WeakReference; import java.lang.ref.ReferenceQueue; public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; { // 默认的初始容量是16，必须是2的幂。 private static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 private static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // WeakHashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表 private Entry[] table; // WeakHashMap的大小，它是WeakHashMap保存的键值对的数量 private int size; // WeakHashMap的阈值，用于判断是否需要调整WeakHashMap的容量（threshold = 容量*加载因子） private int threshold; // 加载因子实际大小 private final float loadFactor; // queue保存的是“已被GC清除”的“弱引用的键”。 // 弱引用和ReferenceQueue 是联合使用的：如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中 private final ReferenceQueue&lt;K&gt; queue = new ReferenceQueue&lt;K&gt;(); // WeakHashMap被改变的次数 private volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public WeakHashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Initial Capacity: &quot;+ initialCapacity); // WeakHashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load factor: &quot;+ loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 创建Entry数组，用来保存数据 table = new Entry[capacity]; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“WeakHashMap阈值”，当WeakHashMap中存储数据的数量达到threshold时，就需要将WeakHashMap的容量加倍。 threshold = (int)(capacity * loadFactor); } // 指定“容量大小”的构造函数 public WeakHashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } // 默认构造函数。 public WeakHashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; threshold = (int)(DEFAULT_INITIAL_CAPACITY); table = new Entry[DEFAULT_INITIAL_CAPACITY]; } // 包含“子Map”的构造函数 public WeakHashMap(Map&lt;? extends K, ? extends V&gt; m) { this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, 16), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到WeakHashMap中 putAll(m); } // 键为null的mask值。 // 因为WeakReference中允许“null的key”，若直接插入“null的key”，将其当作弱引用时，会被删除。 // 因此，这里对于“key为null”的清空，都统一替换为“key为NULL_KEY”，“NULL_KEY”是“静态的final常量”。 private static final Object NULL_KEY = new Object(); // 对“null的key”进行特殊处理 private static Object maskNull(Object key) { return (key == null ? NULL_KEY : key); } // 还原对“null的key”的特殊处理 private static &lt;K&gt; K unmaskNull(Object key) { return (K) (key == NULL_KEY ? null : key); } // 判断“x”和“y”是否相等 static boolean eq(Object x, Object y) { return x == y || x.equals(y); } // 返回索引值 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) { return h &amp; (length-1); } // 清空table中无用键值对。原理如下： // (01) 当WeakHashMap中某个“弱引用的key”由于没有再被引用而被GC收回时， // 被回收的“该弱引用key”也被会被添加到&quot;ReferenceQueue(queue)&quot;中。 // (02) 当我们执行expungeStaleEntries时， // 就遍历&quot;ReferenceQueue(queue)&quot;中的所有key // 然后就在“WeakReference的table”中删除与“ReferenceQueue(queue)中key”对应的键值对 private void expungeStaleEntries() { Entry&lt;K,V&gt; e; while ( (e = (Entry&lt;K,V&gt;) queue.poll()) != null) { int h = e.hash; int i = indexFor(h, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; p = prev; while (p != null) { Entry&lt;K,V&gt; next = p.next; if (p == e) { if (prev == e) table[i] = next; else prev.next = next; e.next = null; // Help GC e.value = null; // &quot; &quot; size--; break; } prev = p; p = next; } } } // 获取WeakHashMap的table(存放键值对的数组) private Entry[] getTable() { // 删除table中“已被GC回收的key对应的键值对” expungeStaleEntries(); return table; } // 获取WeakHashMap的实际大小 public int size() { if (size == 0) return 0; // 删除table中“已被GC回收的key对应的键值对” expungeStaleEntries(); return size; } public boolean isEmpty() { return size() == 0; } // 获取key对应的value public V get(Object key) { Object k = maskNull(key); // 获取key的hash值。 int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int index = indexFor(h, tab.length); Entry&lt;K,V&gt; e = tab[index]; // 在“该hash值对应的链表”上查找“键值等于key”的元素 while (e != null) { if (e.hash == h &amp;&amp; eq(k, e.get())) return e.value; e = e.next; } return null; } // WeakHashMap是否包含key public boolean containsKey(Object key) { return getEntry(key) != null; } // 返回“键为key”的键值对 Entry&lt;K,V&gt; getEntry(Object key) { Object k = maskNull(key); int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int index = indexFor(h, tab.length); Entry&lt;K,V&gt; e = tab[index]; while (e != null &amp;&amp; !(e.hash == h &amp;&amp; eq(k, e.get()))) e = e.next; return e; } // 将“key-value”添加到WeakHashMap中 public V put(K key, V value) { K k = (K) maskNull(key); int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int i = indexFor(h, tab.length); for (Entry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) { // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (h == e.hash &amp;&amp; eq(k, e.get())) { V oldValue = e.value; if (value != oldValue) e.value = value; return oldValue; } } // 若“该key”对应的键值对不存在于WeakHashMap中，则将“key-value”添加到table中 modCount++; Entry&lt;K,V&gt; e = tab[i]; tab[i] = new Entry&lt;K,V&gt;(k, value, queue, h, e); if (++size &gt;= threshold) resize(tab.length * 2); return null; } // 重新调整WeakHashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) { Entry[] oldTable = getTable(); int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } // 新建一个newTable，将“旧的table”的全部元素添加到“新的newTable”中， // 然后，将“新的newTable”赋值给“旧的table”。 Entry[] newTable = new Entry[newCapacity]; transfer(oldTable, newTable); table = newTable; if (size &gt;= threshold / 2) { threshold = (int)(newCapacity * loadFactor); } else { // 删除table中“已被GC回收的key对应的键值对” expungeStaleEntries(); transfer(newTable, oldTable); table = oldTable; } } // 将WeakHashMap中的全部元素都添加到newTable中 private void transfer(Entry[] src, Entry[] dest) { for (int j = 0; j &lt; src.length; ++j) { Entry&lt;K,V&gt; e = src[j]; src[j] = null; while (e != null) { Entry&lt;K,V&gt; next = e.next; Object key = e.get(); if (key == null) { e.next = null; // Help GC e.value = null; // &quot; &quot; size--; } else { int i = indexFor(e.hash, dest.length); e.next = dest[i]; dest[i] = e; } e = next; } } } // 将&quot;m&quot;的全部元素都添加到WeakHashMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; m) { int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) { int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); } // 将“m”中的元素逐个添加到WeakHashMap中。 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); } // 删除“键为key”元素 public V remove(Object key) { Object k = maskNull(key); // 获取哈希值。 int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int i = indexFor(h, tab.length); Entry&lt;K,V&gt; prev = tab[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) { Entry&lt;K,V&gt; next = e.next; if (h == e.hash &amp;&amp; eq(k, e.get())) { modCount++; size--; if (prev == e) tab[i] = next; else prev.next = next; return e.value; } prev = e; e = next; } return null; } // 删除“键值对” Entry&lt;K,V&gt; removeMapping(Object o) { if (!(o instanceof Map.Entry)) return null; Entry[] tab = getTable(); Map.Entry entry = (Map.Entry)o; Object k = maskNull(entry.getKey()); int h = HashMap.hash(k.hashCode()); int i = indexFor(h, tab.length); Entry&lt;K,V&gt; prev = tab[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) { Entry&lt;K,V&gt; next = e.next; if (h == e.hash &amp;&amp; e.equals(entry)) { modCount++; size--; if (prev == e) tab[i] = next; else prev.next = next; return e; } prev = e; e = next; } return null; } // 清空WeakHashMap，将所有的元素设为null public void clear() { while (queue.poll() != null) ; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; size = 0; while (queue.poll() != null) ; } // 是否包含“值为value”的元素 public boolean containsValue(Object value) { // 若“value为null”，则调用containsNullValue()查找 if (value==null) return containsNullValue(); // 若“value不为null”，则查找WeakHashMap中是否有值为value的节点。 Entry[] tab = getTable(); for (int i = tab.length ; i-- &gt; 0 ;) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; } // 是否包含null值 private boolean containsNullValue() { Entry[] tab = getTable(); for (int i = tab.length ; i-- &gt; 0 ;) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value==null) return true; return false; } // Entry是单向链表。 // 它是 “WeakHashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 private static class Entry&lt;K,V&gt; extends WeakReference&lt;K&gt; implements Map.Entry&lt;K,V&gt; { private V value; private final int hash; // 指向下一个节点 private Entry&lt;K,V&gt; next; // 构造函数。 Entry(K key, V value, ReferenceQueue&lt;K&gt; queue, int hash, Entry&lt;K,V&gt; next) { super(key, queue); this.value = value; this.hash = hash; this.next = next; } public K getKey() { return WeakHashMap.&lt;K&gt;unmaskNull(get()); } public V getValue() { return value; } public V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) { Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; } return false; } // 实现hashCode() public int hashCode() { Object k = getKey(); Object v = getValue(); return ((k==null ? 0 : k.hashCode()) ^ (v==null ? 0 : v.hashCode())); } public String toString() { return getKey() + &quot;=&quot; + getValue(); } } // HashIterator是WeakHashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;T&gt; implements Iterator&lt;T&gt; { // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; entry = null; // 上一次返回元素 Entry&lt;K,V&gt; lastReturned = null; // expectedModCount用于实现fast-fail机制。 int expectedModCount = modCount; // 下一个键(强引用) Object nextKey = null; // 当前键(强引用) Object currentKey = null; // 构造函数 HashIterator() { index = (size() != 0 ? table.length : 0); } // 是否存在下一个元素 public boolean hasNext() { Entry[] t = table; // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 while (nextKey == null) { Entry&lt;K,V&gt; e = entry; int i = index; while (e == null &amp;&amp; i &gt; 0) e = t[--i]; entry = e; index = i; if (e == null) { currentKey = null; return false; } nextKey = e.get(); // hold on to key in strong ref if (nextKey == null) entry = entry.next; } return true; } // 获取下一个元素 protected Entry&lt;K,V&gt; nextEntry() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (nextKey == null &amp;&amp; !hasNext()) throw new NoSuchElementException(); lastReturned = entry; entry = entry.next; currentKey = nextKey; nextKey = null; return lastReturned; } // 删除当前元素 public void remove() { if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); WeakHashMap.this.remove(currentKey); expectedModCount = modCount; lastReturned = null; currentKey = null; } } // value的迭代器 private class ValueIterator extends HashIterator&lt;V&gt; { public V next() { return nextEntry().value; } } // key的迭代器 private class KeyIterator extends HashIterator&lt;K&gt; { public K next() { return nextEntry().getKey(); } } // Entry的迭代器 private class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; { public Map.Entry&lt;K,V&gt; next() { return nextEntry(); } } // WeakHashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K&gt; keySet() { Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); } // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private class KeySet extends AbstractSet&lt;K&gt; { public Iterator&lt;K&gt; iterator() { return new KeyIterator(); } public int size() { return WeakHashMap.this.size(); } public boolean contains(Object o) { return containsKey(o); } public boolean remove(Object o) { if (containsKey(o)) { WeakHashMap.this.remove(o); return true; } else return false; } public void clear() { WeakHashMap.this.clear(); } } // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values())); } // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private class Values extends AbstractCollection&lt;V&gt; { public Iterator&lt;V&gt; iterator() { return new ValueIterator(); } public int size() { return WeakHashMap.this.size(); } public boolean contains(Object o) { return containsValue(o); } public void clear() { WeakHashMap.this.clear(); } } // 返回“WeakHashMap的Entry集合” // 它实际是返回一个EntrySet对象 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); } // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new EntryIterator(); } // 是否包含“值(o)” public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k = e.getKey(); Entry candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); } // 删除“值(o)” public boolean remove(Object o) { return removeMapping(o) != null; } // 返回WeakHashMap的大小 public int size() { return WeakHashMap.this.size(); } // 清空WeakHashMap public void clear() { WeakHashMap.this.clear(); } // 拷贝函数。将WeakHashMap中的全部元素都拷贝到List中 private List&lt;Map.Entry&lt;K,V&gt;&gt; deepCopy() { List&lt;Map.Entry&lt;K,V&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(size()); for (Map.Entry&lt;K,V&gt; e : this) list.add(new AbstractMap.SimpleEntry&lt;K,V&gt;(e)); return list; } // 返回Entry对应的Object[]数组 public Object[] toArray() { return deepCopy().toArray(); } // 返回Entry对应的T[]数组(T[]我们新建数组时，定义的数组类型) public &lt;T&gt; T[] toArray(T[] a) { return deepCopy().toArray(a); } } }说明：WeakHashMap和HashMap都是通过”拉链法”实现的散列表。它们的源码绝大部分内容都一样，这里就只是对它们不同的部分就是说明。 WeakReference是“弱键”实现的哈希表。它这个“弱键”的目的就是：实现对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。“弱键”是一个“弱引用(WeakReference)”，在Java中，WeakReference和ReferenceQueue 是联合使用的。在WeakHashMap中亦是如此：如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 接着，WeakHashMap会根据“引用队列”，来删除“WeakHashMap中已被GC回收的‘弱键’对应的键值对”。另外，理解上面思想的重点是通过 expungeStaleEntries() 函数去理解。 第4部分 WeakHashMap遍历方式4.1 遍历WeakHashMap的键值对第一步：根据entrySet()获取WeakHashMap的“键值对”的Set集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是WeakHashMap对象 // map中的key是String类型，value是Integer类型 Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue(); }4.2 遍历WeakHashMap的键第一步：根据keySet()获取WeakHashMap的“键”的Set集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是WeakHashMap对象 // map中的key是String类型，value是Integer类型 String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key); }4.3 遍历WeakHashMap的值第一步：根据value()获取WeakHashMap的“值”的集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是WeakHashMap对象 // map中的key是String类型，value是Integer类型 Integer value = null; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) { value = (Integer)iter.next(); }WeakHashMap遍历测试程序如下： import java.util.Map; import java.util.Random; import java.util.Iterator; import java.util.WeakHashMap; import java.util.HashSet; import java.util.Map.Entry; import java.util.Collection; /* * @desc 遍历WeakHashMap的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorHashMapByEntryset() * (02) 通过keySet()去遍历key、value，参考实现函数： * iteratorHashMapByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorHashMapJustValues() * * @author skywang */ public class WeakHashMapIteratorTest { public static void main(String[] args) { int val = 0; String key = null; Integer value = null; Random r = new Random(); WeakHashMap map = new WeakHashMap(); for (int i=0; i&lt;12; i++) { // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到WeakHashMap中 map.put(key, value); System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value); } // 通过entrySet()遍历WeakHashMap的key-value iteratorHashMapByEntryset(map) ; // 通过keySet()遍历WeakHashMap的key-value iteratorHashMapByKeyset(map) ; // 单单遍历WeakHashMap的value iteratorHashMapJustValues(map); } /* * 通过entry set遍历WeakHashMap * 效率高! */ private static void iteratorHashMapByEntryset(WeakHashMap map) { if (map == null) return ; System.out.println(&quot;\\niterator WeakHashMap By entryset&quot;); String key = null; Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+&quot; -- &quot;+integ.intValue()); } } /* * 通过keyset来遍历WeakHashMap * 效率低! */ private static void iteratorHashMapByKeyset(WeakHashMap map) { if (map == null) return ; System.out.println(&quot;\\niterator WeakHashMap By keyset&quot;); String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { key = (String)iter.next(); integ = (Integer)map.get(key); System.out.println(key+&quot; -- &quot;+integ.intValue()); } } /* * 遍历WeakHashMap的values */ private static void iteratorHashMapJustValues(WeakHashMap map) { if (map == null) return ; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) { System.out.println(iter.next()); } } } 第5部分 WeakHashMap示例下面通过实例来学习如何使用WeakHashMap import java.util.Iterator; import java.util.Map; import java.util.WeakHashMap; import java.util.Date; import java.lang.ref.WeakReference; /** * @desc WeakHashMap测试程序 * * @author skywang * @email kuiwu-wang@163.com */ public class WeakHashMapTest { public static void main(String[] args) throws Exception { testWeakHashMapAPIs(); } private static void testWeakHashMapAPIs() { // 初始化3个“弱键” String w1 = new String(&quot;one&quot;); String w2 = new String(&quot;two&quot;); String w3 = new String(&quot;three&quot;); // 新建WeakHashMap Map wmap = new WeakHashMap(); // 添加键值对 wmap.put(w1, &quot;w1&quot;); wmap.put(w2, &quot;w2&quot;); wmap.put(w3, &quot;w3&quot;); // 打印出wmap System.out.printf(&quot;\\nwmap:%s\\n&quot;,wmap ); // containsKey(Object key) :是否包含键key System.out.printf(&quot;contains key two : %s\\n&quot;,wmap.containsKey(&quot;two&quot;)); System.out.printf(&quot;contains key five : %s\\n&quot;,wmap.containsKey(&quot;five&quot;)); // containsValue(Object value) :是否包含值value System.out.printf(&quot;contains value 0 : %s\\n&quot;,wmap.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 wmap.remove(&quot;three&quot;); System.out.printf(&quot;wmap: %s\\n&quot;,wmap ); // ---- 测试 WeakHashMap 的自动回收特性 ---- // 将w1设置null。 // 这意味着“弱键”w1再没有被其它对象引用，调用gc时会回收WeakHashMap中与“w1”对应的键值对 w1 = null; // 内存回收。这里，会回收WeakHashMap中与“w1”对应的键值对 System.gc(); // 遍历WeakHashMap Iterator iter = wmap.entrySet().iterator(); while (iter.hasNext()) { Map.Entry en = (Map.Entry)iter.next(); System.out.printf(&quot;next : %s - %s\\n&quot;,en.getKey(),en.getValue()); } // 打印WeakHashMap的实际大小 System.out.printf(&quot; after gc WeakHashMap size:%s\\n&quot;, wmap.size()); } }运行结果： wmap:{three=w3, one=w1, two=w2} contains key two : true contains key five : false contains value 0 : false wmap: {one=w1, two=w2} next : two - w2 after gc WeakHashMap size:1更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/13/java/collection/2012-02-13-collection-13-weakhashmap/"},{"title":"Android Binder机制(一) Binder的设计和框架","text":"这是关于Android中Binder机制的一系列纯技术贴。花了一个多礼拜的时间，才终于将其整理完毕。行文于此，以做记录；也是将自己所得与大家分享。和以往一样，介绍Binder时，先讲解框架，然后再从设计和细节等方面一一展开。若文章若错误或纰漏，请不吝指出。谢谢！ 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. Binder架构解析1.1. Binder模型1.2. Binder驱动存在的原因和意义1.3. ServiceManager存在的原因和意义1.4. 为什么采用Binder机制，而不是其他的IPC通信方式1.5. Binder中各角色之间关系2. Binder设计解析2.1. Binder设计2.1.1. 内核空间的Binder设计2.1.2. 用户空间的Binder设计2.2. Binder通信2.2.1. Binder通信模型2.2.2. Binder通信数据 1. Binder架构解析 1.1 Binder模型 上图中涉及到Binder模型的4类角色：Binder驱动，ServiceManager，Server和Client。 因为后面章节讲解Binder时，都是以MediaPlayerService和MediaPlayer为代表进行讲解的；这里就使用MediaPlayerService代表了Server，而MediaPlayer则代表了Client。 Binder机制的目的是实现IPC(Inter-Process Communication)，即实现进程间通信。在上图中，由于MediaPlayerService是Server的代表，而MediaPlayer是Client的代表；因此，对于上图而言，Binder机制则表现为”实现MediaPlayerService和MediaPlayer之间的通信”。 1.2 Binder驱动存在的原因和意义在回答”Binder机制中Binder驱动存在的原因和意义”之前，先介绍几个基本的概念。 1. Linux系统中的内存划分Android是基于Linux内核而打造的操作系统。以32位Linux系统而言，它的内存最大是4G。在这4G内存中，03G为用户空间，34G为内核空间。应用程序都运行在用户空间，而Kernel和驱动都运行在内核空间。用户空间和内核空间若涉及到通信(即，数据交互)，两者不能简单地使用指针传递数据，而必须在”内核”中通过copy_from_user(),copy_to_user(),get_user()或put_user()等函数传递数据。copy_from_user()和get_user()是将内核空间的数据拷贝到用户空间，而copy_to_user()和put_user()则是将用户空间的数据拷贝到内核空间。 2. 进程的基本概念进程拥有独立的内存单元，它是系统进行资源分配和调度的基本单位。对于Linux系统而言，每一个运行在用户空间的应用程序都可以看作一个进程。不同的进程在不同的内存中，因此当一个程序崩溃之后，不会对其它的程序造成影响。 通过上面的\"Linux的内存划分\"和\"进程\"，我们可以了解到：**应用程序都运行在用户空间，每个应用程序都有它自己独立的内存空间；若不同的应用程序之间涉及到通信，需要通过内核进行中转，因为需要用到内核的copy_from_user()和copy_to_user()等函数。** 现在，再回到上面的框架图中。图中的ServiceManager, MediaPlayerService和MediaPlayer都位于用户空间，它们是不同的进程。前面说过，Binder机制的最终目的是实现\"MediaPlayerService和MediaPlayer这两个不同进程之间的通信\"。而这两个不同进程的通信必须要内核进行中转，对于Android而言，在内核中起中转作用便是Binder驱动。那么Binder驱动是如何进行数据中转的呢？这里概括的介绍一下，后面再详细说明。 Android的通信是基于Client-Server架构的，进程间的通信无非就是Client向Server发起请求，Server响应Client的请求。这里以发起请求为例：当Client向Server发起请求(例如，MediaPlayer向MediaPlayerService发起请求)，Client会先将请求数据从用户空间拷贝到内核空间(将数据从MediaPlayer发给Binder驱动)；数据被拷贝到内核空间之后，再通过驱动程序，将内核空间中的数据拷贝到Server位于用户空间的缓存中(Binder驱动将数据发给MediaPlayerService)。这样，就成功的将Client进程中的请求数据传递到了Server进程中。 实际上，Binder驱动是整个Binder机制的核心。除了实现上面所说的数据传输之外，Binder驱动还是实现线程控制(通过中断等待队列实现线程的等待/唤醒)，以及UID/PID等安全机制的保证。 1.3 ServiceManager存在的原因和意义Binder是要实现Android的C-S架构的，即Client-Server架构。而ServiceManager，是以服务管理者的身份存在的。 ServiceManager也是运行在用户空间的一个独立进程。(01) 对于Binder驱动而言，ServiceManager是一个守护进程，更是Android系统各个服务的管理者。Android系统中的各个服务，都是添加到ServiceManager中进行管理的，而且每个服务都对应一个服务名。当Client获取某个服务时，则通过服务名来从ServiceManager中获取相应的服务。(02) 对于MediaPlayerService和MediaPlayer而言，ServiceManager是一个Server服务端，是一个服务器。当要将MediaPlayerService等服务添加到ServiceManager中进行管理时，ServiceManager是服务器，它会收到MediaPlayerService进程的添加服务请求。当MediaPlayer等客户端要获取MediaPlayerService等服务时，它会向ServiceManager发起获取服务请求。 当MediaPlayer和MediaPlayerService通信时，MediaPlayerService是服务端；而当MediaPlayerService则ServiceManager通信时，ServiceManager则是服务端。这样，就造就了ServiceManager的特殊性。于是，在Binder驱动中，将句柄0指定为ServiceManager对应的句柄，通过这个特殊的句柄就能获取ServiceManager对象。这部分的知识后面会详细介绍。 1.4 为什么采用Binder机制，而不是其他的IPC通信方式前面说过，Android是在Linux内核的基础上设计的。而在Linux中，已经拥有”管道/消息队列/共享内存/信号量/Socket等等”众多的IPC通信手段；但是，Google为什么单单选择了Binder，而不是其它的IPC机制呢？ 这肯定是因为Binder具有无可比拟的优势。下面就从 “实用性(Client-Server架构)/传输效率/操作复杂度/安全性” 等几方面进行分析。 第一. Binder能够很好的实现Client-Server架构对于Android系统，Google想提供一套基于Client-Server的通信方式。例如，将”电池信息/马达控制/wifi信息/多媒体服务”等等不同的服务都由不同的Server提供，当Client需要获取某Server的服务时，只需要Client向Server发送相应的请求，Server收到请求之后进行处理，处理完毕再将反馈内容发送给Client。 但是，目前Linux支持的”传统的管道/消息队列/共享内存/信号量/Socket等”IPC通信手段中，只有Socket是Client-Server的通信方式。但是，Socket主要用于网络间通信以及本机中进程间的低速通信，它的传输效率太低。 第二. Binder的传输效率和可操作性很好前面已经说了，Socket传输效率很低，已经被排除。而消息队列和管道又采用存储-转发方式，使用它们进行IPC通信时，需要经过2次内存拷贝！效率太低！ 为什么消息队列和管道的数据传输需要经过2次内存拷贝呢？ 首先，数据先从发送方的缓存区(即，Linux中的用户存储空间)拷贝到内核开辟的缓存区(即，Linux中的内核存储空间)中，是第1次拷贝。接着，再从内核缓存区拷贝到接收方的缓存区(也是Linux中的用户存储空间)，这是第2次拷贝。而采用Binder机制的话，则只需要经过1次内存拷贝即可！ 即，从发送方的缓存区拷贝到内核的缓存区，而接收方的缓存区与内核的缓存区是映射到同一块物理地址的，因此只需要1次拷贝即可。 至于共享内存呢，虽然使用它进行IPC通信时进行的内存拷贝次数是0。但是，共享内存操作复杂，也将它排除。 第三. Binder机制的安全性很高传统IPC没有任何安全措施，完全依赖上层协议来确保。传统IPC的接收方无法获得对方进程可靠的UID/PID(用户ID/进程ID)，从而无法鉴别对方身份。而Binder机制则为每个进程分配了UID/PID来作为鉴别身份的标示，并且在Binder通信时会根据UID/PID进行有效性检测。 1.5 Binder中各角色之间关系先看看下面的关系图 在解释上面的图之前，先解释图中涉及到的几个非常重要的概念。 1. Binder实体 Binder实体，是各个Server以及ServiceManager在内核中的存在形式。 Binder实体实际上是内核中binder_node结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。 在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。 2. Binder引用 说到Binder实体，就不得不说”Binder引用”。所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。 如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。 Binder实体和Binder引用都是内核(即，Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。 3. 远程服务 Server都是以服务的形式注册到ServiceManager中进行管理的。如果将Server本身看作是”本地服务”的话，那么Client中的”远程服务”就是本地服务的代理。如果你对代理模式比较熟悉的话，就很容易理解了，远程服务就是本地服务的一个代理，通过该远程服务Client就能和Server进行通信。 理解上面3个概念之后，下面再通过几个典型的通信示例来解析该关系图。 ServiceManager守护进程 ServiceManager是用户空间的一个守护进程。当该应用程序启动时，它会和Binder驱动进行通信，告诉Binder驱动它是服务管理者；对Binder驱动而言，它则会新建ServiceManager对应的Binder实体，并将该Binder实体设为全局变量。为什么要将它设为全局变量呢？这点应该很容易理解–因为Client和Server都需要和ServiceManager进行通信，不将它设为全局变量的话，怎么找到ServiceManager呢！ Server注册到ServiceManager中 Server首先会向Binder驱动发起注册请求，而Binder驱动在收到该请求之后就将该请求转发给ServiceManager进程。但是Binder驱动怎么才能知道该请求是要转发给ServiceManager的呢？这是因为Server在发送请求的时候，会告诉Binder驱动这个请求是交给0号Binder引用对应的进程来进行处理的。而Binder驱动中指定了0号引用是与ServiceManager对应的。 在Binder驱动转发该请求之前，它其实还做了两件很重要的事：(01) 当它知道该请求是由一个Server发送的时候，它会新建该Server对应的Binder实体。 (02) 它在ServiceManager的”保存Binder引用的红黑树”中查找是否存在该Server的Binder引用；找不到的话，就新建该Server对应的Binder引用，并将其添加到”ServiceManager的保存Binder引用的红黑树”中。简言之，Binder驱动会创建Server对应的Binder实体，并在ServiceManager的红黑树中添加该Binder实体的Binder引用。 当ServiceManager收到Binder驱动转发的注册请求之后，它就将该Server的相关信息注册到”Binder引用组成的单链表”中。这里所说的Server相关信息主要包括两部分：Server对应的服务名 + Server对应的Binder实体的一个Binder引用。 Client获取远程服务 Client要和某个Server通信，需要先获取到该Server的远程服务。那么Client是如何获取到Server的远程服务的呢？ Client首先会向Binder驱动发起获取服务的请求。Binder驱动在收到该请求之后也是该请求转发给ServiceManager进程。ServiceManager在收到Binder驱动转发的请求之后，会从”Binder引用组成的单链表”中找到要获取的Server的相关信息。至于ServiceManager是如何从单链表中找到需要的Server的呢？答案是Client发送的请求数据中，会包括它要获取的Server的服务名；而ServiceManager正是根据这个服务名来找到Server的。 接下来，ServiceManager通过Binder驱动将Server信息反馈给Client的。它反馈的信息是Server对应的Binder实体的Binder引用信息。而Client在收到该Server的Binder引用信息之后，就根据该Binder引用信息创建一个Server对应的远程服务。这个远程服务就是Server的代理，Client通过调用该远程服务的接口，就相当于在调用Server的服务接口一样；因为Client调用该Server的远程服务接口时，该远程服务会对应的通过Binder驱动和真正的Server进行交互，从而执行相应的动作。 2. Binder设计解析有了上面Binder模型的理论基础，接下来就可以逐步来讲解Binder的设计了。实际上，在设计C-S架构时，要考虑以下两个非常重要的因素。 第一，Server要提供接入点 如果C-S架构中的Client和Server属于同一进程的话，那么Client和Server之间的通信将非常容易。只需要在Client端先获取相应的Server端对象；然后，再通过Server对象调用Server的相应接口即可。但是，Binder机制中涉及到的Client和Server是位于不同的进程中的，这也就意味着，不可能直接获取到Server对象。那么怎么办呢？ 那就需要Server提供一个接入点给Client。 这个接入点就是“Server的远程服务代理”！ Client能够获取到Server的远程服务，它就相当于Server的代理。Client要和Server通信时，它只需要调用该远程服务的相应接口即可，其他的工作都交给远程服务来处理。远程服务收到Client请求之后，会和Binder驱动通信；因为远程服务中有Server在Binder驱动中的Binder引用信息，因此远程服务就能轻易的找到对应的Server，进而将Client的请求内容发送Server。 第二，通信协议 Binder机制中，涉及到大量的”内核的Binder驱动 和 用户空间的引用程序”之间的通信。需要指定对应的通信协议，确保通信的安全和正常。关于这部分，稍候再详细展开。 有了上面的两个中心思想之后，再来对Binder驱动的设计和协议进行逐步展开。 2.1 Binder设计讲解Binder设计时，分为”内核空间”和”用户空间”这两部分进程讲解。内核空间就是Binder驱动中的Binder设计，而用户空间则是Android的C++层中的Binder设计。 2.1.1 内核空间的Binder设计内核空间的Binder设计涉及到3个非常重要的结构体：binder_proc，binder_node和binder_ref。由于本文的重点是介绍Binder机制的理论知识，因此，在这里我并不打算展开这3个结构体对它们进行详细介绍。当然，后面会再撰文对这些类进行详细说明。这里只需要了解个大概即可。 binder_proc是描述进程上下文信息的，每一个用户空间的进程都对应一个binder_proc结构体。binder_node是Binder实体对应的结构体，它是Server在Binder驱动中的体现。binder_ref是Binder引用对应的结构体，它是Client在Binder驱动中的体现。 如上图所示，binder_proc中包含了3棵红黑树。(01) Binder实体红黑树是保存”binder_proc对应的进程”所包含的Binder实体的，而Binder实体是与Server的服务对应的。可以将Binder实体红黑树理解为Server进程中包行的Server服务的红黑树。(02) 图中有两棵Binder引用红黑树，这两棵树所包含的Binder引用都是一样的。不同的是，红黑树的排序基准不同，一个是以Binder实体来排序，而另一个则是以Binder引用描述(Binder引用描述实际上就是一个32位的整型数)来排序。以Binder引用描述的红黑树是为了方便进行快速查找。 上图是描述Binder驱动中Binder实体结构体的。如图所示，Binder实体中有一个Binder引用的哈希表，专门来存放该Binder实体的Binder引用。这也如我们之前所说，每个Binder实体则可以多个Binder引用，而每个Binder引用则都只对应一个Binder实体。 2.1.2 用户空间的Binder设计 上面是用户空间中Binder模型图，该图仅仅只描述出Server的相关类图，并没有Client部分。不过不要紧，通过这个Server的模型图，就能理清用户空间的Binder框架。 前面说过，Server是以服务的形式注册到ServiceManager中，而Server在Client中则是以远程服务的形式存在的。因此，这个图的主干就是理清楚本地服务和远程服务这两者之间的关系。 “本地服务”就是Server提供的服务本身，而”远程服务”就是服务的代理；”服务接口”则是抽象出了它们的通用接口。这3个角色都是通用的，对于不同的服务而言，它们的名称都不相同。例如，对于MediaPlayerService服务而言，本地服务就是MediaPlayerService自身，远程服务是BpMediaPlayerService，而服务接口是IMediaPlayerService。当Client需要向MediaPlayerService发送请求时，它需要先获取到服务的代理(即，远程服务对象)，也就是BpMediaPlayerService实例，然后通过该实例和MediaPlayerService进行通信。 图中的ProcessState和IPCThreadState都是采用单例模式实现的，它们的实例都是全局的，而且只有唯一一个。 (01) 当Server启动之后，它会先将自己注册到ServiceManager中。注册时，Binder驱动会创建Server对应的Binder实体，并将”Server对应的本地服务对象的地址”保存到Binder实体中。注册成功之后，Server就进入消息循环，等待Client的请求。(02) 当Client需要和Server通信时，会先获取到Server接入点，即获取到远程服务对象；而且Client要获取的远程服务对象是”服务接口”类型的。Client向ServiceManager发送获取服务的请求时，会通过IPCThreadState和Binder驱动进行通信；当ServiceManager反馈之后，IPCThreadState会将ServiceManager反馈的”Server的Binder引用信息”保存BpBinder中(具体来说，BpBinder的mHandle成员保存的就是Server的Binder引用信息)。然后，会根据该BpBinder对象创建对应的远程服务。这样，Client就获取到了远程服务对象，而且远程服务对象的成员中保存了Server的Binder引用信息。(03) 当Client获取到远程服务对象之后，它就可以轻松的和Server进行通信了。当它需要向Server发送请求时，它会调用远程服务接口；远程服务能够获取到BpBinder对象，而BpBinder则通过IPCThreadState和Binder驱动进行通信。由于BpBinder中保存了Server在Binder驱动中的Binder引用；因此，IPCThreadState和Binder驱动通信时，是知道该请求是需要传给哪个Server的。Binder驱动通过Binder引用找到对应的Binder实体，然后将Binder实体中保存的”Server对应的本地服务对象的地址”返回给用户空间。当IPC收到Binder驱动反馈的内容之后，它从内容中找到”Server对应的本地服务对象”，然后调用该对象的onTransact()。不同的本地服务都可以实现自己的onTransact()；这样，不同的服务就可以按照自己的需求来处理请求。 2.2 Binder通信Binder通信协议是基于Command-Reply的方式的。 2.2.1 Binder通信模型下面是Client和Server的交互模型图。 图中的原理很简单。(01) Server进程启动之后，会进入中断等待状态，等待Client的请求。(02) 当Client需要和Server通信时，会将请求发送给Binder驱动。(03) Binder驱动收到请求之后，会唤醒Server进程。(04) 接着，Binder驱动还会反馈信息给Client，告诉Client：它发送给Binder驱动的请求，Binder驱动已经收到。(05) Client将请求发送成功之后，就进入等待状态。等待Server的回复。(06) Binder驱动唤醒Server之后，就将请求转发给Server进程。(07) Server进程解析出请求内容，并将回复内容发送给Binder驱动。(08) Binder驱动收到回复之后，唤醒Client进程。(09) 接着，Binder驱动还会反馈信息给Server，告诉Server：它发送给Binder驱动的回复，Binder驱动已经收到。(10) Server将回复发送成功之后，再次进入等待状态，等待Client的请求。(11) 最后，Binder驱动将回复转发给Client。 2.2.2 Binder通信数据 上面是用户空间和内核空间进行交互时，数据的打包方式。例如，当Client向Server发送请求时，Client会将数据打包成上诉格式，然后通过ioctl()发送给Binder驱动。根据数据的层次，从外到里分为3层进行说明。 第一层：这是用户空间的进程调用ioctl(fd,BINDER_WRITE_READ,&amp;bwr)时传递给Binder驱动的信息。fd是Binder驱动的文件句柄，BINDER_WRITE_READ是ioctl()的一个标识，而bwr是传递的数据，它对应是途中的binder_write_read结构体的指针。binder_write_read中以write_开头的是保存请求数据的，而read_开头的是保存反馈数据的。其中，write_size是请求数据的大小，write_buffer是请求数据的内容，而write_consumed是用来记录请求数据中已经被Binder驱动处理过的数据的大小。 第二层：这层的数据是”事务指令”+”binder_transaction_data结构体”组成的。图中给出的事务指令是BC_TRANSACTION，表示该事务是请求；如果是回复，则是BR_开头的，例如BR_TRANSACTION。binder_transaction_data是描述事务交互数据的结构体；例如，target是指定事务目标，用来表示这个事务是交给谁进行处理的；code是事务编码，用来表示这是一个什么样的事务(例如，注册服务事务/获取服务事务等待)；data是保存事务中具体数据的内存地址。 第三层：这层是有效数据。如果该请求是传递给ServiceManager进行处理的，则有效数据是：消息头+”Server的相关信息”。消息头是用来进行有效性检查的，而”Server的相关信息”则是请求要处理的信息。","link":"/2014/09/01/android/os/binder/2014-09-01-Binder-Introduce/"},{"title":"Android之Loader介绍","text":"本文介绍Loader, CursorLoader, AsyncTaskLoader 和 LoaderManager。先给出它们的使用示例，然后再对它们的架构和原理进行分析。 目录1. Loader简介2. Loader使用示例3. Loader架构和原理 Loader简介Loader：是一个执行异步数据加载的抽象类。它是AsyncTaskLoader的父类，CursorLoader的祖父类。 AsyncTaskLoader：它是继承于Loader的抽象类。在AsyncTaskLoader中有AsyncTask用来执行异步工作。 CursorLoader：它是AsyncTaskLoader的子类。它可以查询ContentResolver然后返回一个Cursor，同时CursorLoader内包含ContentObserver对象来监听Cursor数据的变化。 LoaderManager：它是一个抽像类，作用是用来管理Loader。LoaderManager关联到一个Activity或Fragment；例如，在Activity中通过getLoaderManager()可以获取到一个LoaderManager对象。 LoaderManager.LoaderCallbacks：它提供了与”Activity或Fragment”交互的接口。LoaderCallbacks中共包行三个接口： onCreateLoader()：根据所给出的ID，初始化并返回一个新的加载器。 onLoadFinished()：当一个先前被创建的加载器完成了它的加载过程时被调用。 onLoaderReset()：当一个先前被创建的加载器被重置时被调用，然后使加载器的数据无效。 总结：Loader, AsyncTaskLoader和CursorLoader都是用来提供异步加载的类；而LoaderManager则提供了管理这些异步加载类的接口。此外，Activity或Fragment保护了获取LoaderManager的接口，通过这样的接口，就可以在Activity或Fragment中实现异步加载任务！ Loader使用示例下面通过一则示例演示Fragment中执行异步加载的完整流程！该示例中，会在FragmentActivity中采用异步加载的方式查找并显示数据库中所有的图片的相关信息。 点击查看：Loader示例的完整源码 1. 获取LoaderManager，并执行initLoader()public class LoaderTest extends FragmentActivity implements LoaderCallbacks&lt;Cursor&gt;, OnItemClickListener { ... @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); listView = (ListView)findViewById(android.R.id.list); simpleCursorAdapter = new SimpleCursorAdapter( this, R.layout.list_item, null, STORE_IMAGES, new int[] { R.id.item_title, R.id.item_value} ); simpleCursorAdapter.setViewBinder(new ImageLocationBinder()); listView.setAdapter(simpleCursorAdapter); // 注意此处是getSupportLoaderManager()，而不是getLoaderManager()方法。 getSupportLoaderManager().initLoader(0, null, this); listView.setOnItemClickListener(this); } }说明：需要重点关注的是getSupportLoaderManager()，它的作用是获取LoaderManager。然后，通过initLoader()初始化Loader。 initLoader()的完整声明如下： public &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback);说明：(01) id是Loader的唯一标识。(02) args是Bundle，这里赋值位null。(03) callback是回调函数。后面会给出回调的实现。 2. 实现LoaderManager.LoaderCallbacks接口LoaderCallbacks中包行onCreateLoader(), onLoaderReset(), onLoadFinished()三个接口。下面是它们的实现： @Override public Loader&lt;Cursor&gt; onCreateLoader(int arg0, Bundle arg1) { CursorLoader cursorLoader = new CursorLoader( this, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, STORE_IMAGES, null, null, null); return cursorLoader; } @Override public void onLoaderReset(Loader&lt;Cursor&gt; arg0) { simpleCursorAdapter.swapCursor(null); } @Override public void onLoadFinished(Loader&lt;Cursor&gt; arg0, Cursor cursor) { simpleCursorAdapter.swapCursor(cursor); }说明：(01) onCreateLoader()会在初始化Loader之后执行，它的作用是返回一个Loader对象。(02) 而onLoadFinished()是当异步加载完成之后会被执行，当Loader加载完数据时，我们会通过 simpleCursorAdapter.swapCursor(cursor)将simpleCursorAdapter切换到新的Cursor对象(即，加载完后保存数据的对象)。不同于changeCursor()，changeCursor()在切换到新的Cursor之后，会将旧的Cursor关闭掉；而swapCursor()切换到新的Cursor之后，不会关闭旧的Cursor，如果旧的Cursor存在的话，它会返回旧的Cursor。(03) onLoaderReset()则是当异步加载起被重置时会被调用。当Loader被重置会，我们通过simpleCursorAdapter.swapCursor(null)将Cursor设为null。 3. 其他操作经过上面两步之后，已经能成功的使用异步加载数据了。得到的数据保存在SimpleCursorAdapter对象中，接下来需要做的就是在SimpleCursorAdapter中显示数据。 在onCreate()中，我们通过simpleCursorAdapter.setViewBinder(new ImageLocationBinder())设置了SimpleCursorAdapter的ViewBinder对象。下面看看ViewBinder中是如何显示的： // 将图片的位置绑定到视图 private class ImageLocationBinder implements ViewBinder { @Override public boolean setViewValue(View view, Cursor cursor, int columnIndex) { if (columnIndex == 1) { int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA); String path = cursor.getString(column_index); ((TextView)view).setText(&quot;Location: &quot;+path); return true; } return false; } }至此，数据的异步加载示例差不多介绍完了。总的来说很简单，先获取LoaderManager对象，然后通过initLoader()初始化Loader。接着，需要作的是实现LoaderCallbacks接口！LoaderCallbacks接口中，需要重点关注的是onCreateLoader()和onLoadFinished()接口！ Loader架构和原理在Loader简介中，我们大致介绍了Loader, LoaderManager各个类的作用。这里，我们分析一下它们的源码来查看它们是如何工作的。主要解决的有以下几个问题：(01) Loader的异步加载原理。也就是说Loader异步是通过什么实现的？是一个Thread，还是AsyncTask，还是其他的什么方式？(02) onCreateLoader()和onLoadFinished()是如何回调的。尤其是onLoadFinished()，当数据加载完时，是如何回调的？(03) 当发生Activity或Fragment被重新加载(例如，发生旋屏动作)时，Loader不会重新加载，它里面的数据仍然存在。这是如何做到的？(04) Loader异步加载器，能够自动更新数据。它又是如何做到的？ 1. 异步加载原理涉及到的文件：frameworks/base/core/java/android/app/LoaderManager.javaframeworks/base/core/java/android/content/Loader.javaframeworks/base/core/java/android/content/AsyncTaskLoader.javaframeworks/base/core/java/android/content/CursorLoader.java 1.1 initLoader()LoaderManager.java中initLoader()源码如下： public &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback) { if (mCreatingLoader) { throw new IllegalStateException(&quot;Called while creating a loader&quot;); } LoaderInfo info = mLoaders.get(id); if (DEBUG) Log.v(TAG, &quot;initLoader in &quot; + this + &quot;: args=&quot; + args); if (info == null) { // Loader doesn&apos;t already exist; create. info = createAndInstallLoader(id, args, (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback); if (DEBUG) Log.v(TAG, &quot; Created new loader &quot; + info); } else { if (DEBUG) Log.v(TAG, &quot; Re-using existing loader &quot; + info); info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback; } if (info.mHaveData &amp;&amp; mStarted) { // If the loader has already generated its data, report it now. info.callOnLoadFinished(info.mLoader, info.mData); } return (Loader&lt;D&gt;)info.mLoader; } 说明：(01) initLoader()会现通过mLoaders.get(id)来根据id获取LoaderInfo对象。如果Activity或Fragment第一次调用initLoader()，则获取到的LoaderInfo对象为null。(02) 如果info为null，则执行createAndInstallLoader()来创建LoaderInfo对象。 1.2 createAndInstallLoader()LoaderManager.java中createAndInstallLoader()源码如下： private LoaderInfo createLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;Object&gt; callback) { LoaderInfo info = new LoaderInfo(id, args, (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback); Loader&lt;Object&gt; loader = callback.onCreateLoader(id, args); info.mLoader = (Loader&lt;Object&gt;)loader; return info; } private LoaderInfo createAndInstallLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;Object&gt; callback) { try { mCreatingLoader = true; LoaderInfo info = createLoader(id, args, callback); installLoader(info); return info; } finally { mCreatingLoader = false; } } void installLoader(LoaderInfo info) { mLoaders.put(info.mId, info); if (mStarted) { // The activity will start all existing loaders in it&apos;s onStart(), // so only start them here if we&apos;re past that point of the activitiy&apos;s // life cycle info.start(); } }说明：(01) createAndInstallLoader()会分别调用createLoader()和installLoader()接口。(02) createLoader()会新建LoaderInfo对象，然后调用callback.onCreateLoader()接口。这里的onCreateLoader()就是我们实现的LoaderCallbacks接口中的onCreateLoader()接口。(03) initLoader()中会调用info.start()接口。 1.3 LoaderInfo中的start()LoaderManager.java中的内部类LoaderInfo的源码如下： final class LoaderInfo implements Loader.OnLoadCompleteListener&lt;Object&gt;, Loader.OnLoadCanceledListener&lt;Object&gt; { final int mId; final Bundle mArgs; LoaderManager.LoaderCallbacks&lt;Object&gt; mCallbacks; Loader&lt;Object&gt; mLoader; ... public LoaderInfo(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;Object&gt; callbacks) { mId = id; mArgs = args; mCallbacks = callbacks; } void start() { if (mRetaining &amp;&amp; mRetainingStarted) { mStarted = true; return; } if (mStarted) { return; } mStarted = true; if (DEBUG) Log.v(TAG, &quot; Starting: &quot; + this); if (mLoader == null &amp;&amp; mCallbacks != null) { mLoader = mCallbacks.onCreateLoader(mId, mArgs); } if (mLoader != null) { if (mLoader.getClass().isMemberClass() &amp;&amp; !Modifier.isStatic(mLoader.getClass().getModifiers())) { throw new IllegalArgumentException( &quot;Object returned from onCreateLoader must not be a non-static inner member class: &quot; + mLoader); } if (!mListenerRegistered) { mLoader.registerListener(mId, this); mLoader.registerOnLoadCanceledListener(this); mListenerRegistered = true; } mLoader.startLoading(); } } ... }说明：start()中一个非常重要的成员是mLoader。它就是onCreateLoader()返回的Loader对象。start()会调用mLoaders.startLoading()。 1.4 startLoading()下面查看startLoading的相关代码。查看代码时，请记得：Loader.java, AsyncTaskLoader和CursorLoader这三者之间存在继承关系！ // 在Loader.java中 public final void startLoading() { mStarted = true; mReset = false; mAbandoned = false; onStartLoading(); } // 在CursorLoader.java中 @Override protected void onStartLoading() { if (mCursor != null) { deliverResult(mCursor); } if (takeContentChanged() || mCursor == null) { forceLoad(); } } 说明：startLoading()是在Loader.java中定义的，它调用了onStartLoading()。而CursorLoader.java覆盖了onStartLoading()函数。在onStartLoading()中，此时的mCursor是为null；所以，它会执行forceLoad()。 1.5 forceLoad()下面查看forceLoad的相关代码。 // 在Loader.java中 public void forceLoad() { onForceLoad(); } // 在AsyncTaskLoader.java中 @Override protected void onForceLoad() { super.onForceLoad(); cancelLoad(); mTask = new LoadTask(); if (DEBUG) Slog.v(TAG, &quot;Preparing load: mTask=&quot; + mTask); executePendingTask(); } // 在AsyncTaskLoader.java中 void executePendingTask() { if (mCancellingTask == null &amp;&amp; mTask != null) { if (mTask.waiting) { mTask.waiting = false; mHandler.removeCallbacks(mTask); } if (mUpdateThrottle &gt; 0) { long now = SystemClock.uptimeMillis(); if (now &lt; (mLastLoadCompleteTime+mUpdateThrottle)) { // Not yet time to do another load. if (DEBUG) Slog.v(TAG, &quot;Waiting until &quot; + (mLastLoadCompleteTime+mUpdateThrottle) + &quot; to execute: &quot; + mTask); mTask.waiting = true; mHandler.postAtTime(mTask, mLastLoadCompleteTime+mUpdateThrottle); return; } } if (DEBUG) Slog.v(TAG, &quot;Executing: &quot; + mTask); mTask.executeOnExecutor(mExecutor, (Void[]) null); } }说明：forceLoad()会调用onForceLoad()。而onForceLoad()中会新建LoadTask对象，然后执行executePendingTask()。在executePendingTask()中会调用LoadTask对象的executeOnExecutor()。 1.6 LoadTaskLoadTask是AsyncTaskLoader的内部类。实际上，它是AsyncTask的子类。在介绍AsyncTask的文章中，我们知道executeOnExecutor()会将任务提交到线程池中去执行，而这个被提交到线程池的任务会执行AsyncTask的doInBackground()。 // AsyncTaskLoader.java中 final class LoadTask extends AsyncTask&lt;Void, Void, D&gt; implements Runnable { private final CountDownLatch mDone = new CountDownLatch(1); boolean waiting; @Override protected D doInBackground(Void... params) { if (DEBUG) Slog.v(TAG, this + &quot; &gt;&gt;&gt; doInBackground&quot;); try { D data = AsyncTaskLoader.this.onLoadInBackground(); if (DEBUG) Slog.v(TAG, this + &quot; &lt;&lt;&lt; doInBackground&quot;); return data; } catch (OperationCanceledException ex) { if (!isCancelled()) { throw ex; } if (DEBUG) Slog.v(TAG, this + &quot; &lt;&lt;&lt; doInBackground (was canceled)&quot;, ex); return null; } } /* Runs on the UI thread */ @Override protected void onPostExecute(D data) { if (DEBUG) Slog.v(TAG, this + &quot; onPostExecute&quot;); try { AsyncTaskLoader.this.dispatchOnLoadComplete(this, data); } finally { mDone.countDown(); } } ... }说明：LoadTask的doInBackground()会调用onLoadInBackground()。 1.7 onLoadInBackground()下面查看onLoadInBackground()的相关代码。 // AsyncTaskLoader.java中 protected D onLoadInBackground() { return loadInBackground(); } // CursorLoader.java中 @Override public Cursor loadInBackground() { synchronized (this) { if (isLoadInBackgroundCanceled()) { throw new OperationCanceledException(); } mCancellationSignal = new CancellationSignal(); } try { Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder, mCancellationSignal); if (cursor != null) { try { // Ensure the cursor window is filled. cursor.getCount(); cursor.registerContentObserver(mObserver); } catch (RuntimeException ex) { cursor.close(); throw ex; } } return cursor; } finally { synchronized (this) { mCancellationSignal = null; } } } 说明：loadInBackground()会执行查询。这就是后台任务真正执行的动作所在！ 至此，我们已经回答了第一个问题：Loader的异步加载原理。实际上，Loader的异步加载是通过AsyncTask启动一个后台任务，在后台任务中再执行query()查询操作！ 2. onLoadFinished是如何被回调的我们知道，当AsyncTask中的任务执行完时，会通过onPostExecute()反馈执行结果。下面，我们看看AsyncTask反馈的结果中是如何调用onLoadFinished()的。 2.1 onPostExecute下面看看onPostExecute()的相关代码。 // AsyncTaskLoader.java中 @Override protected void onPostExecute(D data) { if (DEBUG) Slog.v(TAG, this + &quot; onPostExecute&quot;); try { AsyncTaskLoader.this.dispatchOnLoadComplete(this, data); } finally { mDone.countDown(); } } // AsyncTaskLoader.java中 void dispatchOnLoadComplete(LoadTask task, D data) { if (mTask != task) { if (DEBUG) Slog.v(TAG, &quot;Load complete of old task, trying to cancel&quot;); dispatchOnCancelled(task, data); } else { if (isAbandoned()) { // This cursor has been abandoned; just cancel the new data. onCanceled(data); } else { commitContentChanged(); mLastLoadCompleteTime = SystemClock.uptimeMillis(); mTask = null; if (DEBUG) Slog.v(TAG, &quot;Delivering result&quot;); deliverResult(data); } } }说明：onPostExecute()会执行dispatchOnLoadComplete()，而后者会调用deliverResult()来分发消息。 2.2 deliverResult()// CursorLoader.java中 @Override public void deliverResult(Cursor cursor) { if (isReset()) { // An async query came in while the loader is stopped if (cursor != null) { cursor.close(); } return; } Cursor oldCursor = mCursor; mCursor = cursor; if (isStarted()) { super.deliverResult(cursor); } if (oldCursor != null &amp;&amp; oldCursor != cursor &amp;&amp; !oldCursor.isClosed()) { oldCursor.close(); } } // Loader.java中 public void deliverResult(D data) { if (mListener != null) { mListener.onLoadComplete(this, data); } }说明：CursorLoader.java中的deliverResult()会通过super.deliverResult()调用父类的deliverResult()，也就是会执行Loader.java中的deliverResult()。最终会执行mListener.onLoadComplete()。mListener是什么呢？它是我们在执行LoaderManager.java的start()函数时，通过mLoader.registerListener(mId, this)注册到Loader上的。也就是说，mListener是LoaderManager中的LoaderInfo对象。 2.3 LoaderInfo中的onLoadComplete()@Override public void onLoadComplete(Loader&lt;Object&gt; loader, Object data) { if (DEBUG) Log.v(TAG, &quot;onLoadComplete: &quot; + this); if (mDestroyed) { if (DEBUG) Log.v(TAG, &quot; Ignoring load complete -- destroyed&quot;); return; } if (mLoaders.get(mId) != this) { if (DEBUG) Log.v(TAG, &quot; Ignoring load complete -- not active&quot;); return; } LoaderInfo pending = mPendingLoader; if (pending != null) { mPendingLoader = null; mLoaders.put(mId, null); destroy(); installLoader(pending); return; } if (mData != data || !mHaveData) { mData = data; mHaveData = true; if (mStarted) { callOnLoadFinished(loader, data); } } LoaderInfo info = mInactiveLoaders.get(mId); if (info != null &amp;&amp; info != this) { info.mDeliveredData = false; info.destroy(); mInactiveLoaders.remove(mId); } if (mActivity != null &amp;&amp; !hasRunningLoaders()) { mActivity.mFragments.startPendingDeferredFragments(); } } void callOnLoadFinished(Loader&lt;Object&gt; loader, Object data) { if (mCallbacks != null) { String lastBecause = null; if (mActivity != null) { lastBecause = mActivity.mFragments.mNoTransactionsBecause; mActivity.mFragments.mNoTransactionsBecause = &quot;onLoadFinished&quot;; } try { if (DEBUG) Log.v(TAG, &quot; onLoadFinished in &quot; + loader + &quot;: &quot; + loader.dataToString(data)); mCallbacks.onLoadFinished(loader, data); } finally { if (mActivity != null) { mActivity.mFragments.mNoTransactionsBecause = lastBecause; } } mDeliveredData = true; } }说明：onLoadComplete()会调用callOnLoadFinished()，而callOnLoadFinished()最终会调用onLoadFinished()。这就是我们实现的LoaderCallbacks接口中的onLoadFinished()。 至此，我们也搞明白了第二个问题onLoadFinished()是如何被回调的。当AsyncTask任务执行完时，会调用onPostExecute()；而onPostExecute()会通过LoaderManager，LoaderManager最终会调用onLoadFinished()。 3. 当Activity或Fragment被重新加载时，Loader不会被重新加载。这个原理其实非常简单，关键就是initLoader()的实现方式。 public &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback) { if (mCreatingLoader) { throw new IllegalStateException(&quot;Called while creating a loader&quot;); } LoaderInfo info = mLoaders.get(id); if (DEBUG) Log.v(TAG, &quot;initLoader in &quot; + this + &quot;: args=&quot; + args); if (info == null) { // Loader doesn&apos;t already exist; create. info = createAndInstallLoader(id, args, (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback); if (DEBUG) Log.v(TAG, &quot; Created new loader &quot; + info); } else { if (DEBUG) Log.v(TAG, &quot; Re-using existing loader &quot; + info); info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback; } if (info.mHaveData &amp;&amp; mStarted) { // If the loader has already generated its data, report it now. info.callOnLoadFinished(info.mLoader, info.mData); } return (Loader&lt;D&gt;)info.mLoader; } 说明：initLoader()会首先调用mLoaders.get(id)来获取id对应的LoaderInfo对象。如果Activity或Fragment是由于旋屏而发生重载，那么通过id获取到的LoaderInfo就不是null。那么initLoader()就会调用info.callOnLoadFinished()。 4. Loader异步加载器自动更新数据Loader自动更新数据是通过ContentObserver来实现的。 4.1 注册ContentResolver// CursorLoader.java中 @Override public Cursor loadInBackground() { synchronized (this) { if (isLoadInBackgroundCanceled()) { throw new OperationCanceledException(); } mCancellationSignal = new CancellationSignal(); } try { Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder, mCancellationSignal); if (cursor != null) { try { // Ensure the cursor window is filled. cursor.getCount(); cursor.registerContentObserver(mObserver); } catch (RuntimeException ex) { cursor.close(); throw ex; } } return cursor; } finally { synchronized (this) { mCancellationSignal = null; } } } 说明：在执行query()查询之后，如果得到的Cursor对象不是null。则通过cursor.registerContentObserver(mObserver)来监听该cursor的内容。 4.2 注册mObserver// CursorLoader.java中 public CursorLoader(Context context) { super(context); mObserver = new ForceLoadContentObserver(); } // CursorLoader.java中 public CursorLoader(Context context, Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { super(context); mObserver = new ForceLoadContentObserver(); mUri = uri; mProjection = projection; mSelection = selection; mSelectionArgs = selectionArgs; mSortOrder = sortOrder; }说明：在创建CursorLoader对象时，就创建了mObserver，它是ForceLoadContentObserver对象。 4.3 ForceLoadContentObserver// Loader.java public final class ForceLoadContentObserver extends ContentObserver { public ForceLoadContentObserver() { super(new Handler()); } @Override public boolean deliverSelfNotifications() { return true; } @Override public void onChange(boolean selfChange) { onContentChanged(); } } // Loader.java中 public void onContentChanged() { if (mStarted) { forceLoad(); } else { // This loader has been stopped, so we don&apos;t want to load // new data right now... but keep track of it changing to // refresh later if we start again. mContentChanged = true; } }说明：ForceLoadContentObserver是Loader.java的内部类，它继承于ContentObserver。当数据发生变化时，它会回调onChange()，进而调用onContentChanged()。而onContentChanged()则会执行forceLoad()。forceLoad()在前面已经介绍过了，它会启动AsyncTask被执行query查询操作！ 至此，几个问题都回答完了。Loader, AsyncTaskLoader, CursorLoader和LoaderManager的相互关系也整理完了！谢谢观赏！","link":"/2014/06/25/android/api_guide/tasks/2014-06-25-Loader/"},{"title":"Android Binder机制(四) defaultServiceManager()的实现","text":"本文介绍defaultServiceManager()的流程。这里的defaultServiceManager()返回的是”IServiceManager对象”，获取”IServiceManager对象”的目的是为了和”ServiceManager进程”进行通信。例如，Server要通过”IServiceManager对象”发送请求指令注册到”ServiceManager进程”中，Client要通过”IServiceManager对象”发送请求来获取”Server对象”。这里要搞清楚：defaultServiceManager()获取到的，不是”ServiceManager进程”，而是”IServiceManager对象”。”ServiceManager进程”是一个守护进程，而defaultServiceManager()获取到的是C++层的IServiceManager类的一个实例。当然，通过该defaultServiceManager()返回的”IServiceManager对象”是可以和ServiceManager进行通信的。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. defaultServiceManager概述2. defaultServiceManager流程详解2.1. defaultServiceManager()2.2. ProcessState::self()2.3. ProcessState::ProcessState()2.4. ProcessState::open_driver()2.5. mmap()2.6. ProcessState::getContextObject()2.7. ProcessState::getStrongProxyForHandle()2.8. ProcessState::lookupHandleLocked()2.9. BpBinder::BpBinder2.10. IPCThreadState::self()2.11. IPCThreadState::IPCThreadState()2.12. interface_cast() defaultServiceManager概述1. defaultServiceManager流程图 上面是defaultServiceManager()的时序图。defaultServiceManager()会返回一个sp类型的对象。IServiceManager提供了addService()供MediaPlayerService等服务注册到ServiceManager中，提供了getService()供MediaPlayer等MediaPlayer等客户端获取服务。它首先会调用ProcessState::self()获取到ProcessState对象，该ProcessState对象是采用单例模式创建的；因此，当ProcessState::self()第一次被调用时，会新建ProcessState对象。在ProcessState的构造函数中，会先通过open_driver()打开”/dev/binder”，接着调用mmap()映射内存到当前进程中。此时，ProcessState就初始化完毕，它将”/dev/binder”的文件句柄以及映射内存都保存在自己的私有成员中。在获取到ProcessState对象之后，会通过该对象调用getContextObject()来获取一个IBinder对象。getContextObject()会调用getStrongProxyForHandle(0)来获取”句柄0的强引用代理对象”，这里的句柄0被赋予了特殊意义；它就是ServiceManager的句柄，在Binder驱动中，若获取到句柄的值是0，则会将其目标当作是ServiceManager。getStrongProxyForHandle(0)会先通过lookupHandleLocked()在”ProcessState的矢量数组mHandleToObject”中查找句柄为0的对象；找不到的话，则新建句柄为0的对象，并将其添加到mHandleToObject矢量数组中；这样，下次再通过getStrongProxyForHandle()查找时，就能快速的找到。由此可见，mHandleToObject是ProcessState中保存句柄的缓冲数组。 随后，会新建句柄0对应的BpBinder对象，BpBinder是IBinder的代理；这里就获取到了ServiceManager的BpBinder代理对象。简而言之，getContextObject()的目的就是获取ServiceManager对应的BpBinder代理对象。 在新建BpBinder时，会通过IPCThreadState::self()获取IPCThreadState对象；因为，需要通过IPCThreadState对象来与Binder驱动进行交互。前面已经成功获取到了ServiceManager的BpBinder代理，而defaultServiceManager()返回的是IServiceManager对象。这里，使用了一个技巧，通过宏interface_cast而调用asInterface()函数，从而返回IServiceManager的代理BpServiceManager。这样，defaultServiceManager()就执行完毕了。 在上面的流程中，涉及到了比较多的类。下面通过类图理清它们之间的关系。 2. defaultServiceManager相关类的类图 上面是获取defaultServiceManager()时涉及到的类的类图。defaultServiceManager()虽然在IServiceManager.cpp中实现，但它并不属于IServiceManager的成员方法，而是一个全局方法。 RefBase它定义在system/core/include/utils/RefBase.h中。RefBase是一个公共父类，它声明了许多常用的接口。包括增加引用计数，获取引用计数，新增对象的弱引用等接口。 IInterface它定义在frameworks/native/include/binder/IInterface.h中。和RefBase类似，它也是一个公共父类，IInterface中声明了asBinder()方法，用于获取对象的IBinder对象。 IBinder它定义在frameworks/native/include/binder/IBinder.h中。IBinder也是一个抽象出来的类，它包括了localBinder(), remoteBinder()和transact()等非常重要的接口。IBinder有两个直接子类类：BpBinder和BBinder。BpBinder是Binder代理类。通过remoteBinder()可以获取BpBinder对象；而且，对于C++层而言，它相当于一个远程Binder。BpBinder的事务接口transact()会调用IPCThreadState的transact()，进而实现与Binder驱动的事务交互。此外，BpBinder中有一个mHandle句柄成员，它用来保存Server位于Binder驱动中的”Binder引用的描述”。句柄0是ServiceManager的句柄。BBinder是本地Binder。通过localBinder()可以获取BBinder对象。当Server收到请求之后，会调用BBinder的onTransact()函数进行处理。而不同的Server会重载onTransact()函数，从而可以根据各自的情况对事务进行处理。 BpInterface它定义在frameworks/native/include/binder/IInterface.h中。实际上，BpInterface是一个模板类，同时继承了BpRefBase和INTERFACE，这里的INTERFACE是模板。像IServiceManager，IMediaPlayerService等Server都是通过继承模板类是实现的。 BnInterface它定义在frameworks/native/include/binder/IInterface.h中。和BpInterface类似，BnInterface也是一个模板类，它同时继承了BBinder和INTERFACE。像BnServiceManager，BnMediaPlayerService等本地Server都是通过继承模板类是实现的。 BpRefBase它定义在frameworks/native/include/binder/Binder.h中。BpRefBase继承于RefBase，它有一个IBinder*类型的成员mRemote，同时提供了获取该mRemote的方法。实际上，该mRemote就是BpBinder对象。 ProcessState它定义在frameworks/native/libs/binder/ProcessState.cpp中中。ProcessState的实例是采用单例模式实现的，它拥有两个非常重要的成员：mDriverFD和mHandleToObject。mDriverFD是文件”/dev/binder”的句柄，而mHandleToObject是一个Vector矢量数组，矢量数组中的每个元素都保存了两个变量：Server的句柄，以及Server对应的BpBinder对象。实际上，Server的句柄是”Server在Binder驱动中的Binder引用的描述”；句柄0是ServiceManager的句柄。 关于Binder引用，可以回顾Android Binder机制(二) Binder中的数据结构。 IPCThreadState它定义在frameworks/native/libs/binder/IPCThreadState.cpp中中。IPCThreadState的实例也是采用单例模式实现的，它是正在与Binder驱动进行交互的类。 理解上面几个类的基本概念之后，现在在从整体上对它们进行一下介绍！ 对于一个Server而言，它都会存在一个\"远程BpBinder对象\"和\"本地BBinder对象\"。 (01) 远程BpBinder对象的作用，是和Binder驱动进行交互。具体的方式是，当Server要向Binder发起事务请求时，会调用BpBinder的transact()接口，而该接口会调用到IPCThreadState::transact()接口，通过IPCThreadState类来和Binder驱动交互。此外，该BpBinder在Binder驱动中的Binder引用的描述会被保存到ProcessState的mHandleToObject矢量缓冲数组中。 (02) 本地BBinder对象的作用，是Server响应Client请求的类。当Client有请求发送给Server时，都会调用到BBinder的onTransact()函数，而每个Server都会覆盖onTransact()函数。这样，每个Server就可以在onTransact()中根据自己的情况对请求进行处理。 defaultServiceManager流程详解接下来通过源码来查看defaultServiceManager()的实现。通过源码分析，会对上面的类图有更清楚的认识！ 1. defaultServiceManager()sp&lt;IServiceManager&gt; defaultServiceManager() { if (gDefaultServiceManager != NULL) return gDefaultServiceManager; { AutoMutex _l(gDefaultServiceManagerLock); while (gDefaultServiceManager == NULL) { gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;( ProcessState::self()-&gt;getContextObject(NULL)); if (gDefaultServiceManager == NULL) sleep(1); } } return gDefaultServiceManager; }说明：该代码定义在frameworks/native/libs/binder/IServiceManager.cpp中。它是获取IServiceManager对象，该函数的声明在frameworks/native/include/binder/IServiceManager.h中。虽然defaultServiceManager()在IServiceManager.cpp文件中实现，但是它并不是IServiceManager的一个成员方法，而是一个全局方法。(01) gDefaultServiceManagerLock是全局互斥锁，gDefaultServiceManager是全局的IServiceManager对象。它们都定义在frameworks/native/libs/binder/Static.cpp中。(02) gDefaultServiceManager是采用单例模式实现的，第一次调用该函数时，会创建gDefaultServiceManager对象。gDefaultServiceManager的实现可以简化为以下语句： gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL));下面逐个对该语句中的代码进行解析。 2. ProcessState::self()sp&lt;ProcessState&gt; ProcessState::self() { Mutex::Autolock _l(gProcessMutex); if (gProcess != NULL) { return gProcess; } gProcess = new ProcessState; return gProcess; }说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中，它的作用是返回gProcess对象。gProcess也是单例模式对象，它也定义在frameworks/native/libs/binder/Static.cpp中。第一次执行self()时，会新建ProcessState对象。 3. ProcessState::ProcessState()ProcessState::ProcessState() : mDriverFD(open_driver()) , mVMStart(MAP_FAILED) , mManagesContexts(false) , mBinderContextCheckFunc(NULL) , mBinderContextUserData(NULL) , mThreadPoolStarted(false) , mThreadPoolSeq(1) { if (mDriverFD &gt;= 0) { mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); if (mVMStart == MAP_FAILED) { // *sigh* ALOGE(&quot;Using /dev/binder failed: unable to mmap transaction memory.\\n&quot;); close(mDriverFD); mDriverFD = -1; } } ... }说明：在ProcessState的构造函数中，它会进行一系列的初始化。比较重要的有如下两步。(01) 通过open_driver()打开”/open/binder”，并将文件句柄赋值给mDriverFD。(02) 通过调用mmap()映射内存。下面，看看这两步的代码。 4. ProcessState::open_driver()static int open_driver() { // 打开文件/dev/binder int fd = open(&quot;/dev/binder&quot;, O_RDWR); if (fd &gt;= 0) { fcntl(fd, F_SETFD, FD_CLOEXEC); int vers; // 检查/dev/binder的版本 status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); if (result == -1) { close(fd); ... } if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) { close(fd); ... } // 设置该进程最大线程数 size_t maxThreads = 15; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); if (result == -1) { ... } } else { ... } return fd; }说明：(01) open_driver()首先打开”/dev/binder”文件。它会对应执行Binder驱动的binder_open()函数，该函数在Android Binder机制(三) ServiceManager守护进程中已经详细介绍过了。(02) 在成功打开文件之后，就会调用ioctl检查Binder版本，检查版本的部分非常简单(就是读取出版本号，判断读取的版本号与已有的版本号是否一样!)，这里就不再对Binder驱动的BINDER_VERSION进行展开了。(03) 在检查版本通过之后，在调用ioctl(,BINDER_SET_MAX_THREADS,)设置该进程的最大线程数。它会对应调用Binder驱动的binder_ioctl()函数。 注意：要区分”此处的open(“/dev/binder”,…)” 和 “ServiceManager守护进程中的open(“/dev/binder”,…)”。它们分别是属于不同的进程，本文的open(“/dev/binder”,…)是属于调用defaultServiceManager()的进程；而在ServiceManager中的open(“/dev/binder”,…)是属于ServiceManager进程的。 4.1 Binder驱动中binder_ioctl()的BINDER_SET_MAX_THREADS相关部分的源码static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。 thread = binder_get_thread(proc); ... switch (cmd) { case BINDER_SET_MAX_THREADS: if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) { ret = -EINVAL; goto err; } break; ... } ret = 0; ... return ret; }说明：BINDER_SET_MAX_THREADS的代码很简单，就是将最大线程数目从用户空间拷贝到内核空间，进而赋值给binder_proc-&gt;max_threads。 5. mmap()在执行完open_driver()之后，将调用mmap()映射内存到当前进程的虚拟地址空间。mmap()详细代码在Android Binder机制(三) ServiceManager守护进程中已经详细分析过，这里就不再重复说明了。 到目前为止，ProcessState::self()就分析完毕。gDefaultServiceManager的赋值语句可以进一步的简化： gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::getContextObject(NULL)); 6. ProcessState::getContextObject()sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; caller) { return getStrongProxyForHandle(0); }说明：getContextObject()调用了getStrongProxyForHandle(0)。这里的0是代表Service Manager的句柄。 7. ProcessState::getStrongProxyForHandle()sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle) { sp&lt;IBinder&gt; result; AutoMutex _l(mLock); // 在矢量数组mHandleToObject中查找&quot;句柄值为handle的handle_entry对象&quot;； // 找到的话，则直接返回；找不到的话，则新建handle对应的handle_entry，并将其添加到mHandleToObject中。 handle_entry* e = lookupHandleLocked(handle); if (e != NULL) { IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) { // 当handle==0(即是Service Manager的句柄)时，尝试去ping Binder驱动。 if (handle == 0) { Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, NULL, 0); if (status == DEAD_OBJECT) return NULL; } // 新建BpBinder代理 b = new BpBinder(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; } else { ... } } return result; }说明：getStrongProxyForHandle()的目的是返回句柄为handle的IBinder代理，这里是返回Service Manager的IBinder代理。(01) lookupHandleLocked()，是在矢量数组mHandleToObject中查找是否有句柄为handle的handle_entry对象。有的话，则返回该handle_entry对象；没有的话，则新建handle对应的handle_entry，并将其添加到矢量数组mHandleToObject中，然后再返回。mHandleToObject是用于保存各个IBinder代理对象的矢量数组，它相当于一个缓冲。(02) 很显然，此时e!=NULL为true，进入if(e!=NULL)中。而此时e-&gt;binder=NULL，并且handle=0；则调用IPCThreadState::self()-&gt;transact()尝试去和Binder驱动通信(尝试去ping内核中Binder驱动)。由于Binder驱动已启动，ping通信是能够成功的。ping通信涉及到”Binder机制中Server和Client的通信”，后面再专门对Server和Client的交互进行介绍；这里只要了解ping通信能够成功即可。(03) 接着，新建BpBinder对象，并赋值给e-&gt;binder。然后，将该BpBinder对象返回。 上面对流程进行了整体介绍，下面逐个进行分析！ 8. ProcessState::lookupHandleLocked()ProcessState::handle_entry* ProcessState::lookupHandleLocked(int32_t handle) { const size_t N=mHandleToObject.size(); if (N &lt;= (size_t)handle) { handle_entry e; e.binder = NULL; e.refs = NULL; status_t err = mHandleToObject.insertAt(e, N, handle+1-N); if (err &lt; NO_ERROR) return NULL; } return &amp;mHandleToObject.editItemAt(handle); } 说明：mHandleToObject是Vector矢量数组。mHandleToObject的初始大小为0，因此if (N &lt;= handle)为true。接下来，就新建handle_entry，并将其添加到mHandleToObject中，然后返回该handle_entry。mHandleToObject和handle_entry的定义如下： class ProcessState : public virtual RefBase { ... private: ... struct handle_entry { IBinder* binder; RefBase::weakref_type* refs; }; ... Vector&lt;handle_entry&gt;mHandleToObject; ... }说明：该代码定义在frameworks/native/include/binder/ProcessState.h中。前面说过，mHandleToObject是个缓冲矢量数组。它的成员binder是保存的Server的BpBinder对象，而refs是保存的Server在Binder驱动中的Binder引用的描述。 9. BpBinder::BpBindernew BpBinder(0)会新建BpBinder对象，下面看看BpBinder的构造函数。 BpBinder::BpBinder(int32_t handle) : mHandle(handle) , mAlive(1) , mObitsSent(0) , mObituaries(NULL) { ALOGV(&quot;Creating BpBinder %p handle %d\\n&quot;, this, mHandle); extendObjectLifetime(OBJECT_LIFETIME_WEAK); IPCThreadState::self()-&gt;incWeakHandle(handle); }说明：该代码定义在frameworks/native/libs/binder/BpBinder.cpp中。主要工作是初始化。(01) 将句柄handle保存到私有成员mHandle中。这里是将ServiceManager的句柄保存到mHandle中。(02) 增加IPCThreadState的引用计数。IPCThreadState::self()是获取IPCThreadState对象，实际上，在前面介绍的ProcessState::getStrongProxyForHandle()中已经调用过该函数。下面看看它的代码。 10. IPCThreadState::self()static pthread_mutex_t gTLSMutex = PTHREAD_MUTEX_INITIALIZER; static bool gHaveTLS = false; static pthread_key_t gTLS = 0; static bool gShutdown = false; static bool gDisableBackgroundScheduling = false; IPCThreadState* IPCThreadState::self() { if (gHaveTLS) { restart: const pthread_key_t k = gTLS; IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); if (st) return st; return new IPCThreadState; } if (gShutdown) return NULL; pthread_mutex_lock(&amp;gTLSMutex); if (!gHaveTLS) { if (pthread_key_create(&amp;gTLS, threadDestructor) != 0) { pthread_mutex_unlock(&amp;gTLSMutex); return NULL; } gHaveTLS = true; } pthread_mutex_unlock(&amp;gTLSMutex); goto restart; }说明：该代码定义在frameworks/native/libs/binder/IPCThreadState.cpp中。self()的源码比较简单，它的作用是获取IPCThreadState对象。若该对象已经存在，则直接返回；否则，新建IPCThreadState对象。 11. IPCThreadState::IPCThreadState()IPCThreadState::IPCThreadState() : mProcess(ProcessState::self()), mMyThreadId(androidGetTid()), mStrictModePolicy(0), mLastTransactionBinderFlags(0) { pthread_setspecific(gTLS, this); clearCaller(); mIn.setDataCapacity(256); mOut.setDataCapacity(256); }说明：(01) 获取ProcessState对象，并将其赋值给成员mProcess。ProcessState::self()在前面已经介绍国，它是获取全局的ProcessState对象。(02) 设置mIn和mOut的容量为256字节。IPCThreadState是和Binder驱动交互的类，mOut是用来保存”IPCThreadState需要发送给Binder驱动的内容的”，而mIn则是用来保存”Binder驱动反馈给IPCThreadState的内容的”。后面在介绍”Server和Client”通信中用到它们时，再进一步说明。 到目前为止，ProcessState::getContextObject()就分析完了。gDefaultServiceManager的赋值语句可以进一步的简化： gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(new BpBinder(0));接下来，看看interface_cast。 12. interface_cast()template&lt;typename INTERFACE&gt; inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj) { return INTERFACE::asInterface(obj); } 说明：该代码在frameworks/native/include/binder/IInterface.h中。它是一个模板函数，对于interface_cast而言，返回的结果是IServiceManager::asInterface()。 13. IServiceManager::asInterface()接下来，就是查找IServiceManager::asInterface()的实现了。在IServiceManager.cpp中不存在，追踪代码，发现asInterface()是通过DECLARE_META_INTERFACE()来声明，并通过IMPLEMENT_META_INTERFACE()来实现的。 (01) IServiceManager中的DECLARE_META_INTERFACE()声明和IMPLEMENT_META_INTERFACE()实现，分别在头文件frameworks/native/include/binder/IServiceManager.h 以及 frameworks/native/libs/binder/IServiceManager.cpp中。 // IServiceManager.h中的声明 class IServiceManager : public IInterface { public: DECLARE_META_INTERFACE(ServiceManager); ... } // IServiceManager.pp中的实现 IMPLEMENT_META_INTERFACE(ServiceManager, &quot;android.os.IServiceManager&quot;);(02) DECLARE_META_INTERFACE()和IMPLEMENT_META_INTERFACE()的定义在frameworks/native/include/binder/IInterface.h中。 #define DECLARE_META_INTERFACE(INTERFACE) \\ static const android::String16 descriptor; \\ static android::sp&lt;I##INTERFACE&gt; asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj); \\ virtual const android::String16&amp; getInterfaceDescriptor() const; \\ I##INTERFACE(); \\ virtual ~I##INTERFACE(); \\ #define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) \\ const android::String16 I##INTERFACE::descriptor(NAME); \\ const android::String16&amp; \\ I##INTERFACE::getInterfaceDescriptor() const { \\ return I##INTERFACE::descriptor; \\ } \\ android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj) \\ { \\ android::sp&lt;I##INTERFACE&gt; intr; \\ if (obj != NULL) { \\ intr = static_cast&lt;I##INTERFACE*&gt;( \\ obj-&gt;queryLocalInterface( \\ I##INTERFACE::descriptor).get()); \\ if (intr == NULL) { \\ intr = new Bp##INTERFACE(obj); \\ } \\ } \\ return intr; \\ } \\ I##INTERFACE::I##INTERFACE() { } \\ I##INTERFACE::~I##INTERFACE() { } \\ #define CHECK_INTERFACE(interface, data, reply) \\ if (!data.checkInterface(this)) { return PERMISSION_DENIED; } \\用ServiceManager替换INTERFACE之后，得到结果如下：IMPLEMENT_META_INTERFACE(ServiceManager, “android.os.IServiceManager”); #define DECLARE_META_INTERFACE(IServiceManager) \\ static const android::String16 descriptor; \\ static android::sp&lt;IServiceManager&gt; asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj); \\ virtual const android::String16&amp; getInterfaceDescriptor() const; \\ IServiceManager(); \\ virtual ~IServiceManager(); \\ #define IMPLEMENT_META_INTERFACE(IServiceManager, &quot;android.os.IServiceManager&quot;) \\ const android::String16 IServiceManager::descriptor(&quot;android.os.IServiceManager&quot;); \\ const android::String16&amp; \\ IServiceManager::getInterfaceDescriptor() const { \\ return IServiceManager::descriptor; \\ } \\ android::sp&lt;IServiceManager&gt; IServiceManager::asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj) \\ { \\ android::sp&lt;IServiceManager&gt; intr; \\ if (obj != NULL) { \\ intr = static_cast&lt;IServiceManager*&gt;( \\ obj-&gt;queryLocalInterface( \\ IServiceManager::descriptor).get()); \\ if (intr == NULL) { \\ intr = new BpServiceManager(obj); \\ } \\ } \\ return intr; \\ } \\ IServiceManager::IServiceManager() { } \\ IServiceManager::~IServiceManager() { }因此，得到IServiceManager::asInterface()的源码如下： android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(const android::sp&lt;android::IBinder&gt;&amp; obj) { android::sp&lt;IServiceManager&gt; intr; if (obj != NULL) { intr = static_cast&lt;IServiceManager*&gt;( obj-&gt;queryLocalInterface( IServiceManager::descriptor).get()); if (intr == NULL) { intr = new BpServiceManager(obj); } } return intr; }说明：asInterface()的作用是获取IServiceManager接口。(01) obj是传入的BpBinder对象，不为NULL。因此，执行obj-&gt;queryLocalInterface(“android.os.IServiceManager”)来查找名称为”android.os.IServiceManager”的本地接口，queryLocalInterface()的实现在BpBinder的父类IBinder中，具体在文件frameworks/native/libs/binder/Binder.cpp中。很显然，IServiceManager接口还没创建，因此intr=NULL。(02) 新建BpServiceManager(obj)对象，并返回。BpServiceManager的实现在frameworks/native/libs/binder/IServiceManager.cpp中。 sp&lt;IInterface&gt; IBinder::queryLocalInterface(const String16&amp; descriptor) { return NULL; } 到目前为止，gDefaultServiceManager的创建流程就分析完了，它实际返回的是一个BpServiceManager对象，该对象包含IBinder的代理BpBinder。以下是转换后的获取gDefaultServiceManager的语句。 gDefaultServiceManager = new BpServiceManager(new BpBinder(0));","link":"/2014/09/04/android/os/binder/2014-09-04-Binder-defaultServiceManager/"},{"title":"Android Binder机制(九) getService详解01之 请求的发送","text":"前面，以MediaPlayerService为例，介绍了Server服务是如何通过addService请求添加到ServiceManager中的。本文，将以MediaPlayer获取MediaPlayerService服务为例，介绍Client是如何通过getService请求从ServiceManager中获取到Server接入点的。在本文的getService请求中，MediaPlayer是Client，它要获取的Server接入点是MediaPlayerService。和addService一样，在分析getService时，会将文章分为请求的发送，请求的处理，和请求的反馈这3部分来进行介绍。 目录1. Android消息机制的架构 注意：本文是基于Android 4.4.2版本进行介绍的！ getService概述先看看getService的时序图 仔细观察，你会发现getService的时序图和”addService的时序图(在Android Binder机制(五) addService详解01之 请求的发送中)”几乎是一样的。 先是MediaPlayer进程将getService以BC_TRANSACTION事务的方式发给Binder驱动。Binder驱动收到之后，对内容进行解析；然后唤醒ServiceManager，同时反馈一个BR_TRANSACTION_COMPLETE给MediaPlayer。反馈的BR_TRANSACTION_COMPLETE是告诉MediaPlayer，它的getService请求已经被Binder驱动成功收到。接着，MediaPlayer就进入等待状态，等待ServiceManager的反馈。 ServiceManager被唤醒之后，读取Binder驱动传递给它的BR_TRANSACTION事务。在得知是获取MediaPlayerService的请求之后，就从缓冲中取出MediaPlayerService的相关信息；然后和BC_REPLY指令一起反馈给Binder驱动。Binder驱动收到ServiceManager的反馈之后，将内容进一步反馈给MediaPlayer，并将MediaPlayer唤醒。MediaPlayer被唤醒之后，从Binder驱动反馈的BR_REPLY中解析出MediaPlayerService的相关信息；这样，MediaPlayer就成功获取到了MediaPlayerService的接入点。 getService的代码解析 1. MediaPlayer的getService入口sp&lt;IMediaPlayerService&gt; IMediaDeathNotifier::sMediaPlayerService; ... const sp&lt;IMediaPlayerService&gt;&amp; IMediaDeathNotifier::getMediaPlayerService() { ... if (sMediaPlayerService == 0) { sp&lt;IServiceManager&gt; sm = defaultServiceManager(); sp&lt;IBinder&gt; binder; do { binder = sm-&gt;getService(String16(&quot;media.player&quot;)); ... usleep(500000); // 0.5 s } while (true); ... sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder); } ... return sMediaPlayerService; }说明：该代码在frameworks/av/media/libmedia/IMediaDeathNotifier.cpp中。(01) sMediaPlayerService是sp成员，初始化为null。因此if(sMediaPlayerService==0)为true。(02) 调用defaultServiceManager()获取IServiceManager对象，该对象实际上是BpServiceManager类的实例。defaultServiceManager()的详细流程请参考Android Binder机制(四) defaultServiceManager()的实现。(03) 接着就是调用sm-&gt;getService(String16(“media.player”))获取MediaPlayerService对象。 2. BpServiceManager::getService()virtual sp&lt;IBinder&gt; getService(const String16&amp; name) const { unsigned n; for (n = 0; n &lt; 5; n++){ sp&lt;IBinder&gt; svc = checkService(name); if (svc != NULL) return svc; sleep(1); } return NULL; } virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const { Parcel data, reply; data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply); return reply.readStrongBinder(); } 说明：该代码在frameworks/native/libs/binder/IServiceManager.cpp中。(01) getService()是通过调用checkService()来获取IBinder对象的。如果获取失败，它会调用sleep()休眠1ms之后再次尝试；若尝试5次都失败，则返回null。之所以要尝试5次，是由于可能此时MediaPlayerService服务还没有准备好。(02) 下面看看checkService()，它和”Android Binder机制(五) addService详解01之 请求的发送中的addService()”很多内容都相似。 checkService()会先调用writeInterfaceToken()写入一个消息头：”4字节的整型数” + “字符串android.os.IServiceManager”。然后，再调用writeString16(name)将服务名”media.player”写入到data中。 最后，调用remote()-&gt;transact()进行事务交互，其中remote()返回的是BpBinder对象。 3. BpBinder::transact()status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) { // mAlive的初始值为1 if (mAlive) { status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; } return DEAD_OBJECT; }说明：该代码在frameworks/native/libs/binder/BpBinder.cpp中。它会调用IPCThreadState::transact()。 4. IPCThreadState::transact()status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) { status_t err = data.errorCheck(); flags |= TF_ACCEPT_FDS; ... if (err == NO_ERROR) { ... err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); } ... if ((flags &amp; TF_ONE_WAY) == 0) { if (reply) { err = waitForResponse(reply); } else { ... } } else { ... } return err; }说明：该代码在frameworks/native/libs/binder/IPCThreadState.cpp中。它会先通过writeTransactionData()将要发送的指令和数据打包到binder_transaction_data中，然后调用waitForResponse()和Binder驱动进行通信。 5. IPCThreadState::writeTransactionData()status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer) { binder_transaction_data tr; tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) { tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t); tr.data.ptr.offsets = data.ipcObjects(); } else if (statusBuffer) { .. } else { ... } mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR; }说明：该函数会读取Parcel中的数据，然后将其打包到tr中，tr是binder_transaction_data结构体的对象。之后，将”指令”+”数据”写入到mOut中。指令(cmd)=BC_TRANSACTION，数据就是tr。 6. IPCThreadState::waitForResponse()status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult) { int32_t cmd; int32_t err; while (1) { // 先通过talkWithDriver()和Binder驱动交互 if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... if (mIn.dataAvail() == 0) continue; // 然后读取返回结果，再根据结果进行处理 cmd = mIn.readInt32(); switch (cmd) { case BR_TRANSACTION_COMPLETE: ... case BR_DEAD_REPLY: ... case BR_FAILED_REPLY: ... case BR_ACQUIRE_RESULT: ... case BR_REPLY: ... default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; } } finish: ... return err; }说明：waitForResponse()会先调用talkWithDriver()和Binder驱动交互，然后根据反馈结果来进行处理。 7. IPCThreadState::talkWithDriver()status_t IPCThreadState::talkWithDriver(bool doReceive) { ... binder_write_read bwr; // Is the read buffer empty? const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (long unsigned int)mOut.data(); // This is what we&apos;ll read. if (doReceive &amp;&amp; needRead) { bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (long unsigned int)mIn.data(); } else { bwr.read_size = 0; bwr.read_buffer = 0; } ... if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do { ... if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else ... ... } while (err == -EINTR); ... if (err &gt;= NO_ERROR) { // 清空已写的数据 if (bwr.write_consumed &gt; 0) { if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); } // 设置已读数据 if (bwr.read_consumed &gt; 0) { mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); } ... return NO_ERROR; } return err; }说明：talkWithDriver()会先初始化bwr(binder_write_read类型的变量)，然后将bwr通过ioctl()发送给Binder驱动。初始化之后的bwr各个成员的值如下： bwr.write_size = outAvail; // mOut中数据大小，大于0 bwr.write_buffer = (long unsigned int)mOut.data(); // mOut中数据的地址 bwr.write_consumed = 0; bwr.read_size = mIn.dataCapacity(); // 256 bwr.read_buffer = (long unsigned int)mIn.data(); // mIn.mData，实际上为空 bwr.read_consumed = 0;bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。 8. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; ... switch (cmd) { case BINDER_WRITE_READ: { struct binder_write_read bwr; ... // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot; if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) { ... } // 如果write_size&gt;0，则进行写操作 if (bwr.write_size &gt; 0) { ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... } // 如果read_size&gt;0，则进行读操作 if (bwr.read_size &gt; 0) { ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... } ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) { ret = -EFAULT; goto err; } break; } ... } ret = 0; ... return ret; }说明：首先，会将binder_write_read从用户空间拷贝到内核空间之后。拷贝之后，读取出来的bwr.write_size和bwr.read_size都&gt;0，因此先写后读。即，先执行binder_thread_write()，然后执行binder_thread_read()。 9. Binder驱动中binder_thread_write()的源码int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed) { uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) { // 从用户空间读取32bit到内核中，并赋值给cmd。 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) { ... case BC_TRANSACTION: case BC_REPLY: { struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; } ... } // 更新bwr.write_consumed的值 *consumed = ptr - buffer; } return 0; }说明：MediaPlayer发送的指令是BC_TRANSACTION，这里只关心与BC_TRANSACTION相关的部分。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。 10. Binder驱动中binder_transaction()的源码static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply) { struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) { ... } else { if (tr-&gt;target.handle) { ... } else { // 该getService是从ServiceManager中获取MediaPlayer； // 因此事务目标对象是ServiceManager的binder实体。 target_node = binder_context_mgr_node; ... } ... // 设置处理事务的目标进程 target_proc = target_node-&gt;proc; ... } if (target_thread) { ... } else { target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; } ... // 分配一个待处理的事务t，t是binder事务(binder_transaction对象) t = kzalloc(sizeof(*t), GFP_KERNEL); ... // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。 tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); ... t-&gt;debug_id = ++binder_last_id; ... // 设置from，表示该事务是MediaPlayer线程发起的 if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 下面的一些赋值是初始化事务t t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; // 事务将交给target_proc进程进行处理 t-&gt;to_proc = target_proc; // 事务将交给target_thread线程进行处理 t-&gt;to_thread = target_thread; // 事务编码 t-&gt;code = tr-&gt;code; // 事务标志 t-&gt;flags = tr-&gt;flags; // 事务优先级 t-&gt;priority = task_nice(current); ... // 分配空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); ... t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; // 保存事务 t-&gt;buffer-&gt;transaction = t; // 保存事务的目标对象(即处理该事务的binder对象) t-&gt;buffer-&gt;target_node = target_node; trace_binder_transaction_alloc_buf(t-&gt;buffer); if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 将&quot;用户空间的数据&quot;拷贝到内核中 // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小 if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) { ... } // 将&quot;用户空间的数据中所含对象的偏移地址&quot;拷贝到内核中 // MediaPlayer中不包含对象, offp=null if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) { ... } ... // MediaPlayer中不包含对象, off_end为null off_end = (void *)offp + tr-&gt;offsets_size; // MediaPlayer中不包含对象, offp=off_end for (; offp &lt; off_end; offp++) { ... } if (reply) { .. } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) { BUG_ON(t-&gt;buffer-&gt;async_transaction != 0); t-&gt;need_reply = 1; t-&gt;from_parent = thread-&gt;transaction_stack; // 将当前事务添加到当前线程的事务栈中 thread-&gt;transaction_stack = t; } else { ... } // 设置事务的类型为BINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // 将事务添加到target_list队列中，即target_list的待处理事务中 list_add_tail(&amp;t-&gt;work.entry, target_list); // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。 list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // 唤醒目标进程 if (target_wait) wake_up_interruptible(target_wait); return; ... }说明：参数reply=0，表明这是个请求事务，而不是反馈。binder_transaction新建会新建”一个待处理事务t”和”待完成的工作tcomplete”，并根据请求的数据对它们进行初始化。(01) MediaPlayer的getService请求是提交给ServiceManager进行处理的，因此，”待处理事务t”会被添加到ServiceManager的待处理事务队列中。此时的target_thread是ServiceManager对应的线程，而target_proc则是ServiceManager对应的进程上下文环境。(02) 此时，Binder驱动已经收到了MediaPlayer的getService请求；于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”添加到当前线程(即，MediaPlayer线程)的待处理事务队列中。目的是告诉MediaPlayer，Binder驱动已经收到它的getService请求了。(03) 最后，调用wake_up_interruptible(target_wait)将Service Manager唤醒。 接下来，还是先分析完MediaPlayer线程，再看ServiceManager被唤醒后做了些什么。 binder_transaction()执行完毕之后，就会返回到binder_thread_write()中。binder_thread_write()更新bwr.write_consumed的值后，就返回到binder_ioctl()继续执行”读”动作。即执行binder_thread_read()。 11. Binder驱动中binder_thread_read()的源码static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) { void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区 if (*consumed == 0) { if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); } retry: // 等待proc进程的事务标记。 // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。 wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); ... if (wait_for_proc_work) { ... } else { if (non_block) { ... } else ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread)); } ... while (1) { uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... else { if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */ goto retry; break; } ... switch (w-&gt;type) { ... case BINDER_WORK_TRANSACTION_COMPLETE: { cmd = BR_TRANSACTION_COMPLETE; // 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... // 待完成事务已经处理完毕，将其从待完成事务队列中删除。 list_del(&amp;w-&gt;entry); kfree(w); binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE); } break; ... } if (!t) continue; ... } ... // 更新bwr.read_consumed的值 *consumed = ptr - buffer; ... return 0; }说明：(01) bwr.read_consumed=0，即if (*consumed == 0)为true。因此，会将BR_NOOP写入到bwr.read_buffer中。(02) thread-&gt;transaction_stack不为空，thread-&gt;todo也不为空。因为，前面在binder_transaction()中有将一个BINDER_WORK_TRANSACTION_COMPLETE类型的待完成工作添加到thread的待完成工作队列中。因此，wait_for_proc_work为false。(03) binder_has_thread_work(thread)为true。因此，在调用wait_event_interruptible()时，不会进入等待状态，而是继续运行。(04) 进入while循环后，通过list_first_entry()取出待完成工作w。w的类型w-&gt;type=BINDER_WORK_TRANSACTION_COMPLETE，进入到对应的switch分支。随后，将BR_TRANSACTION_COMPLETE写入到bwr.read_buffer中。此时，待处理工作已经完成，将其从当前线程的待处理工作队列中删除。(05) 最后，更新bwr.read_consumed的值。 经过binder_thread_read()处理之后，bwr.read_buffer中包含了两个指令：BR_NOOP和BR_TRANSACTION_COMPLETE。 再回到binder_ioctl()中，在将bwr拷贝到用户空间之后，binder_ioctl()的工作就完成了。于是就返回到talkWithDriver()中。 12. IPCThreadState::talkWithDriver()status_t IPCThreadState::talkWithDriver(bool doReceive) { ... do { ... if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else ... ... } while (err == -EINTR); ... if (err &gt;= NO_ERROR) { // 清空已写的数据 if (bwr.write_consumed &gt; 0) { if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize()) ... else mOut.setDataSize(0); } // 设置已读数据 if (bwr.read_consumed &gt; 0) { mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); } ... return NO_ERROR; } return err; }说明：(01) 从Binder驱动返回后，bwr.write_consumed&gt;0，因此调用mOut.setDataSize(0)将mOut中的数据清空。这意味着，MediaPlayer的请求Binder驱动已经收到，并且已经将请求数据读取完毕。(02) bwr.read_consumed也&gt;0，因此会执行if(bwr.read_consumed&gt;0)中的代码，更新mIn中的mDataSize和mDataPos。这意味着，Binder驱动反馈给MediaPlayer的数据不为空。接下来，MediaPlayer线程肯定会读取Binder驱动反馈的数据(BR_NOOP和BR_TRANSACTION_COMPLETE)。在读取完这些数据之后，MediaPlayer线程会再次调用ioctl(,BINDER_WRITE_READ,)进行读动作；而当执行到binder_thread_read()时，由于此时MediaPlayer线程的待处理工作队列为空，因此MediaPlayer线程会进入中断等待状态。待ServiceManager守护进程处理完MediaPlayer的请求之后，就会将MediaPlayer唤醒。 至此，getService请求的发送部分就介绍完了。下面，就看看ServiceManager被唤醒后是如何获取MediaPlayerService进入点，然后再将该进入点反馈给MediaPlayer的。","link":"/2014/09/07/android/os/binder/2014-09-07-BinderCommunication-GetService01/"},{"title":"Android Binder机制(十) getService详解02之 请求的处理","text":"前面介绍了getService请求的发送部分，本文接着介绍请求的处理部分。下面看看ServiceManager被唤醒之后，是如何处理getService请求的 注意：本文是基于Android 4.4.2版本进行介绍的！ 1. Binder驱动中binder_thread_read()的源码前面说到，MediaPlayer线程在执行binder_transaction()时，会将一个待处理事务添加到”ServiceManager的待处理事务队列”中；然后，再将ServiceManager进程唤醒。下面，我们就接着看看ServiceManager被唤醒之后做了些什么。 static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) { ... if (wait_for_proc_work) { ... if (non_block) { ... } else ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); } else { ... } ... while (1) { struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... else { ... } ... switch (w-&gt;type) { case BINDER_WORK_TRANSACTION: { t = container_of(w, struct binder_transaction, work); } break; ... } if (!t) continue; // t-&gt;buffer-&gt;target_node是目标节点。 // 这里，MediaPlayer的getService请求的目标是ServiceManager，因此target_node是Service Manager对应的节点； if (t-&gt;buffer-&gt;target_node) { // 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体) struct binder_node *target_node = t-&gt;buffer-&gt;target_node; // Binder实体在用户空间的地址(ServiceManager的ptr为NULL) tr.target.ptr = target_node-&gt;ptr; // Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL) tr.cookie = target_node-&gt;cookie; t-&gt;saved_priority = task_nice(current); if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) binder_set_nice(t-&gt;priority); else if (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority) binder_set_nice(target_node-&gt;min_priority); cmd = BR_TRANSACTION; } else { ... } // 交易码 tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) { struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); } else { ... } // 数据大小 tr.data_size = t-&gt;buffer-&gt;data_size; // 数据中对象的偏移数组的大小(即对象的个数) tr.offsets_size = t-&gt;buffer-&gt;offsets_size; // 数据 tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; // 数据中对象的偏移数组 tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); // 将cmd指令写入到ptr，即传递到用户空间 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; // 将tr数据拷贝到用户空间 ptr += sizeof(uint32_t); if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); ... // 删除已处理的事务 list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) { // 将事务t添加到当前线程的事务栈transaction_stack中。 // 这是因为，Binder驱动需要等待Service Manager的反馈。 t-&gt;to_parent = thread-&gt;transaction_stack; t-&gt;to_thread = thread; thread-&gt;transaction_stack = t; } else { ... } break; } done: // 更新bwr.read_consumed的值 *consumed = ptr - buffer; ... return 0; }说明：ServiceManager进程被唤醒之后，binder_has_thread_work()为true，因为ServiceManager中有个待处理事务(即，MediaPlayer的getService求)。(01) 进入while循环后，首先取出待处理事务。(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。此时的指令为BR_TRANSACTION！(03) 最后，更新consumed的值，即更新bwr.read_consumed的值。 然后，binder_thread_read()会返回到binder_ioctl()中。binder_ioctl()在将数据bwr拷贝到用户空间之后会返回。这样，就又回到了ServiceManager守护进程中。 2. binder_loopvoid binder_loop(struct binder_state *bs, binder_handler func) { .. for (;;) { ... res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); ... res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func); ... } } 说明：该代码在frameworks/native/cmds/servicemanager/binder.c中。Binder驱动共反馈了BR_NOOP和BR_TRANSACTION两个指令给Service Manager守护进程。BR_NOOP什么实质性的工作也不会做，我们直接分析BR_TRANSACTION的处理情况。 3. binder_parseint binder_parse(struct binder_state *bs, struct binder_io *bio, uint32_t *ptr, uint32_t size, binder_handler func) { int r = 1; uint32_t *end = ptr + (size / 4); while (ptr &lt; end) { uint32_t cmd = *ptr++; switch(cmd) { case BR_NOOP: break; ... case BR_TRANSACTION: { struct binder_txn *txn = (void *) ptr; ... if (func) { unsigned rdata[256/4]; struct binder_io msg; // 用于保存&quot;Binder驱动反馈的信息&quot; struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot; int res; // 初始化reply bio_init(&amp;reply, rdata, sizeof(rdata), 4); // 根据txt(Binder驱动反馈的信息)初始化msg bio_init_from_txn(&amp;msg, txn); // 消息处理 res = func(bs, txn, &amp;msg, &amp;reply); // 反馈消息给Binder驱动。 binder_send_reply(bs, &amp;reply, txn-&gt;data, res); } ptr += sizeof(*txn) / sizeof(uint32_t); break; } ... } } return r; }说明：这里只关注BR_TRANSACTION分支。 首先，用bio_init()初始化reply。然后通过bio_init_from_txn()初始化msg。接着，是通过func函数指针对数据进行处理，func指向svcmgr_handler。处理完毕，再通过binder_send_reply()填写反馈信息给Binder驱动。这里的大部分内容在Android Binder机制(六) addService详解02之 请求的处理中都介绍过，这里重点关注svcmgr_handler()处理getService请求的流程。 4. svcmgr_handlerint svcmgr_handler(struct binder_state *bs, struct binder_txn *txn, struct binder_io *msg, struct binder_io *reply) { ... // 数据有效性检测(数据头) strict_policy = bio_get_uint32(msg); s = bio_get_string16(msg, &amp;len); if ((len != (sizeof(svcmgr_id) / 2)) || memcmp(svcmgr_id, s, sizeof(svcmgr_id))) { ... } switch(txn-&gt;code) { case SVC_MGR_GET_SERVICE: case SVC_MGR_CHECK_SERVICE: s = bio_get_string16(msg, &amp;len); ptr = do_find_service(bs, s, len, txn-&gt;sender_euid); if (!ptr) break; bio_put_ref(reply, ptr); return 0; ... } bio_put_uint32(reply, 0); return 0; }说明：该代码在frameworks/native/cmds/servicemanager/service_manager.c中。svcmgr_handler()首先读取出getService请求的消息头，进行有效性检测。然后，取出请求的编码；这里请求编码对应是SVC_MGR_CHECK_SERVICE。接着，便进入对应的switch分支。(01) 通过bio_get_string16()获取请求的IBinder对象的名称，即s=”media.player”。(02) 然后，通过do_find_service()查找名称为s的IBinder对象。 5. do_find_servicevoid *do_find_service(struct binder_state *bs, uint16_t *s, unsigned len, unsigned uid) { struct svcinfo *si; si = find_svc(s, len); if (si &amp;&amp; si-&gt;ptr) { ... return si-&gt;ptr; } else { return 0; } } struct svcinfo *find_svc(uint16_t *s16, unsigned len) { struct svcinfo *si; for (si = svclist; si; si = si-&gt;next) { if ((len == si-&gt;len) &amp;&amp; !memcmp(s16, si-&gt;name, len * sizeof(uint16_t))) { return si; } } return 0; }说明：(01) do_find_service()会调用find_svc()进行查找。在find_svc()中，会在svclist链表中查找是否有名称等于”media.player”的svcinfo对象。很显然，在Android Binder机制(六) addService详解02之 请求的处理中，已经将MediaPlayerService注册到svclist中，而MediaPlayerService的名称就是”media.player”。(02) find_svc()找到svcinfo对象后返回到do_find_service()中。此时，if (si &amp;&amp; si-&gt;ptr)为true，返回si-&gt;ptr。这里的si-&gt;ptr就是MediaPlayerService在Binder驱动中的Binder引用的描述。根据该引用描述，就能找到对应的MediaPlayerService对象。 随后，在成功获取Binder引用的描述之后，svcmgr_handler()会调用bio_put_ref()将该引用信息写入到binder_object中。 6. bio_put_ref()void bio_put_ref(struct binder_io *bio, void *ptr) { struct binder_object *obj; if (ptr) obj = bio_alloc_obj(bio); else obj = bio_alloc(bio, sizeof(*obj)); if (!obj) return; obj-&gt;flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS; // 类型 obj-&gt;type = BINDER_TYPE_HANDLE; // 句柄地址 obj-&gt;pointer = ptr; obj-&gt;cookie = 0; }说明：bio_put_ref()会将获取到的Binder引用描述打包到结构体binder_object中。而binder_object是与flat_binder_object对应的结构体，Binder驱动在收到个数据之后，就能对flat_binder_object进行解析处理。 在bio_put_ref()将数据打包到reply中之后，svcmgr_handle会调用binder_send_reply()将数据和指令整合到一起。 7. binder_send_reply()void binder_send_reply(struct binder_state *bs, struct binder_io *reply, void *buffer_to_free, int status) { struct { uint32_t cmd_free; void *buffer; uint32_t cmd_reply; struct binder_txn txn; } __attribute__((packed)) data; data.cmd_free = BC_FREE_BUFFER; data.buffer = buffer_to_free; data.cmd_reply = BC_REPLY; data.txn.target = 0; data.txn.cookie = 0; data.txn.code = 0; if (status) { ... } else { data.txn.flags = 0; data.txn.data_size = reply-&gt;data - reply-&gt;data0; data.txn.offs_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0); data.txn.data = reply-&gt;data0; data.txn.offs = reply-&gt;offs0; } binder_write(bs, &amp;data, sizeof(data)); }说明：binder_send_reply()在Android Binder机制(六) addService详解02之 请求的处理中已经介绍过。它共打包了两个指令：BC_FREE_BUFFER和BC_REPLY。在函数最后，它调用binder_write()和Binder驱动交互。 8. binder_write()int binder_write(struct binder_state *bs, void *data, unsigned len) { struct binder_write_read bwr; int res; bwr.write_size = len; bwr.write_consumed = 0; bwr.write_buffer = (unsigned) data; bwr.read_size = 0; bwr.read_consumed = 0; bwr.read_buffer = 0; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); if (res &lt; 0) { fprintf(stderr,&quot;binder_write: ioctl failed (%s)\\n&quot;, strerror(errno)); } return res; }说明：binder_write()会将数据封装到binder_write_read的变量bwr中；其中，bwr.read_size=0，而bwr.write_size&gt;0。接着，便通过ioctl(,BINDER_WRITE_READ,)和Binder驱动交互，将数据反馈给Binder驱动。 再次回到Binder驱动的binder_ioctl()对应的BINDER_WRITE_READ分支中。此时，由于bwr.read_size=0，而bwr.write_size&gt;0；因此，Binder驱动只调用binder_thread_write进行写操作，而不会进行读。 9. Binder驱动中binder_thread_write()的源码int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed) { uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) { // 从用户空间读取32bit到内核中，并赋值给cmd。 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) { case BC_FREE_BUFFER: ... case BC_TRANSACTION: case BC_REPLY: { struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; } ... } // 更新bwr.write_consumed的值 *consumed = ptr - buffer; } return 0; }说明：binder_thread_write()会逐个读出”Service Manager反馈的指令”。(01) 第一个指令是BC_FREE_BUFFER。binder_thread_write()进入BC_FREE_BUFFER对应的分支后后，执行的动作主要是释放”保存MediaPlayer请求数据的缓冲”。(02) 第二个指令是BC_REPLY。binder_thread_write()进入BC_REPLY之后，会将数据拷贝到内核空间，然后调用binder_transaction()进行处理 10. Binder驱动中binder_transaction()的源码static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply) { struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) { // 事务栈 in_reply_to = thread-&gt;transaction_stack; ... // 设置优先级 binder_set_nice(in_reply_to-&gt;saved_priority); ... thread-&gt;transaction_stack = in_reply_to-&gt;to_parent; // 发起请求的线程，即MediaPlayer所在线程。 // from的值，是MediaPlayer发起请求时在binder_transaction()中赋值的。 target_thread = in_reply_to-&gt;from; ... // MediaPlayer对应的进程 target_proc = target_thread-&gt;proc; } else { ... } if (target_thread) { e-&gt;to_thread = target_thread-&gt;pid; target_list = &amp;target_thread-&gt;todo; target_wait = &amp;target_thread-&gt;wait; } else { ... } e-&gt;to_proc = target_proc-&gt;pid; // 分配一个待处理的事务t，t是binder事务(binder_transaction对象) t = kzalloc(sizeof(*t), GFP_KERNEL); if (t == NULL) { return_error = BR_FAILED_REPLY; goto err_alloc_t_failed; } // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。 tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); if (tcomplete == NULL) { return_error = BR_FAILED_REPLY; goto err_alloc_tcomplete_failed; } binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE); t-&gt;debug_id = ++binder_last_id; e-&gt;debug_id = t-&gt;debug_id; if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 下面的一些赋值是初始化事务t t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; // 事务将交给target_proc进程进行处理 t-&gt;to_proc = target_proc; // 事务将交给target_thread线程进行处理 t-&gt;to_thread = target_thread; // 事务编码 t-&gt;code = tr-&gt;code; // 事务标志 t-&gt;flags = tr-&gt;flags; // 事务优先级 t-&gt;priority = task_nice(current); // 分配空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); if (t-&gt;buffer == NULL) { return_error = BR_FAILED_REPLY; goto err_binder_alloc_buf_failed; } t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; // 保存事务 t-&gt;buffer-&gt;transaction = t; // target_node为NULL t-&gt;buffer-&gt;target_node = target_node; trace_binder_transaction_alloc_buf(t-&gt;buffer); if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 将&quot;用户传入的数据&quot;保存到事务中 if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) { ... } // 将&quot;用户传入的数据偏移地址&quot;保存到事务中 if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) { ... } ... off_end = (void *)offp + tr-&gt;offsets_size; // 将flat_binder_object对象读取出来， // 这里就是Service Manager中反馈的MediaPlayerService对象。 for (; offp &lt; off_end; offp++) { struct flat_binder_object *fp; ... fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); switch (fp-&gt;type) { ... case BINDER_TYPE_HANDLE: case BINDER_TYPE_WEAK_HANDLE: { // 根据handle获取对应的Binder引用，即得到MediaPlayerService的Binder引用 struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle); if (ref == NULL) { ... } // ref-&gt;node-&gt;proc是MediaPlayerService的进程上下文环境， // 而target_proc是MediaPlayer的进程上下文环境 if (ref-&gt;node-&gt;proc == target_proc) { ... } else { struct binder_ref *new_ref; // 在MediaPlayer进程中引用&quot;MediaPlayerService&quot;。 // 表现为，执行binder_get_ref_for_node()会，会先在MediaPlayer进程中查找是否存在MediaPlayerService对应的Binder引用； // 很显然是不存在的。于是，并新建MediaPlayerService对应的Binder引用，并将其添加到MediaPlayer的Binder引用红黑树中。 new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node); if (new_ref == NULL) { ... } // 将new_ref的引用描述复制给fp-&gt;handle。 fp-&gt;handle = new_ref-&gt;desc; binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL); ... } } break; } } if (reply) { binder_pop_transaction(target_thread, in_reply_to); } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) { ... } else { ... } // 设置事务的类型为BINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // 将事务添加到target_list队列中，即target_list的待处理事务中 list_add_tail(&amp;t-&gt;work.entry, target_list); // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。 list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // 唤醒目标进程 if (target_wait) wake_up_interruptible(target_wait); return; ... }说明：reply=1，这里只关注reply部分。(01) 此反馈最终是要回复给MediaPlayer的。因此，target_thread被赋值为MediaPlayer所在的线程，target_proc则是MediaPlayer对应的进程，target_node为null。(02) 这里，先看看for循环里面的内容，取出BR_REPLY指令所发送的数据，然后获取数据中的flat_binder_object变量fp。因为fp-&gt;type为BINDER_TYPE_HANDLE，因此进入BINDER_TYPE_HANDLE对应的分支。接着，通过binder_get_ref()获取MediaPlayerService对应的Binder引用；很明显，能够正常获取到MediaPlayerService的Binder引用。因为在MediaPlayerService调用addService请求时，已经创建了它的Binder引用。 binder_get_ref_for_node()的作用是在MediaPlayer进程上下文中添加”MediaPlayerService对应的Binder引用”。这样，后面就可以根据该Binder引用一步步的获取MediaPlayerService对象。 最后，将Binder引用的描述赋值给fp-&gt;handle。(03) 此时，Service Manager已经处理了getService请求。便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayer线程的事务栈中删除该事务。(04) 新建的”待处理事务t”的type为设为BINDER_WORK_TRANSACTION后，会被添加到MediaPlayer的待处理事务队列中。(05) 此时，Service Manager已经处理了getService请求，而Binder驱动在等待它的回复。于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”(作为回复)添加到当前线程(即，Service Manager线程)的待处理事务队列中。(06) 最后，调用wake_up_interruptible()唤醒MediaPlayer。MediaPlayer被唤醒后，会对事务BINDER_WORK_TRANSACTION进行处理。 OK，到现在为止，还有两个待处理事务：(01) ServiceManager待处理事务列表中有个BINDER_WORK_TRANSACTION_COMPLETE类型的事务 (02) MediaPlayer待处理事务列表中有个BINDER_WORK_TRANSACTION事务。 关于BINDER_WORK_TRANSACTION_COMPLETE事务，它是用来告诉ServiceManager，ServiceManager的反馈信息已经处理完毕。下一篇文章，就说说MediaPlayer被唤醒后，执行BINDER_WORK_TRANSACTION的流程。","link":"/2014/09/07/android/os/binder/2014-09-07-BinderCommunication-GetService02/"},{"title":"Android Binder机制(十二) Binder机制的Java调用流程","text":"前面几篇文章，是基于Binder驱动和C/C++层对Binder机制进行了介绍。本文将从Java引用开始，逐步的分析Client是如何与Server进行交互的。本文的例子还是选取MediaPlayer。 目录1. MediaPlayer的使用示例2. MediaPlayer示例分析 1. MediaPlayer的使用示例下面是一个调用MediaPlayer播放音乐(test.mp3)的示例代码。 public class MainActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); testMediaPlayer(); } private void testMediaPlayer() { try { MediaPlayer mp = new MediaPlayer(); mp.setDataSource(&quot;/sdcard/test.mp3&quot;); mp.setAudioStreamType(AudioManager.STREAM_MUSIC); mp.prepare(); mp.start(); } catch (Exception e) { e.printStackTrace(); } } }说明：源码很简单，只需要关注testMediaPlayer()部分即可。首先，新建一个MediaPlayer对象。接着，设置数据源和音频流类型。最后，调用prepare()进行准备之后，再通过start()进行播放。 下面，我们就对该过程进行分析，看看该Binder机制是如何参与其中的。 2. MediaPlayer示例分析我们将MediaPlayer示例就看作一个MediaPlayer进程，接下来，就看看这个MediaPlayer进程是如何通过Binder机制来和MediaPlayerService通信的。重点需要关注的是mp.setDataSource()的实现。 2.1 MediaPlayer的构造函数先看看MediaPlayer的构造函数。 public MediaPlayer() { ... native_setup(new WeakReference&lt;MediaPlayer&gt;(this)); } private static native final void native_init(); private native final void native_setup(Object mediaplayer_this);说明：该代码在frameworks/base/media/java/android/media/MediaPlayer.java中。在MediaPlayer中，会调用本地方法native_setup()；而且在native_setup()之前，会调用静态方法native_init()进行初始化。下面就看看native_init()和native_setup()各自的代码。 2.2 native_init()和native_setup()的注册信息static JNINativeMethod gMethods[] = { ... {&quot;_setDataSource&quot;, &quot;(Ljava/io/FileDescriptor;JJ)V&quot;, (void *)android_media_MediaPlayer_setDataSourceFD}, ... {&quot;_start&quot;, &quot;()V&quot;, (void *)android_media_MediaPlayer_start}, ... {&quot;native_init&quot;, &quot;()V&quot;, (void *)android_media_MediaPlayer_native_init}, {&quot;native_setup&quot;, &quot;(Ljava/lang/Object;)V&quot;, (void *)android_media_MediaPlayer_native_setup}, ... }; static int register_android_media_MediaPlayer(JNIEnv *env) { return AndroidRuntime::registerNativeMethods(env, &quot;android/media/MediaPlayer&quot;, gMethods, NELEM(gMethods)); } jint JNI_OnLoad(JavaVM* vm, void* reserved) { ... if (register_android_media_MediaPlayer(env) &lt; 0) { ... } ... }说明：该代码在frameworks/base/media/jni/android_media_MediaPlayer.cpp中。gMethods是JNI本地方法的注册表；在Dalvik虚拟机启动之后，会调用JNI_OnLoad()；进而将上面的方法注册到系统中。这里，我们只需要了解native_init()与android_media_MediaPlayer_native_init()对应，而native_setup()和android_media_MediaPlayer_native_setup()对应即可。 2.3 native_init()的实现由于native_init()与android_media_MediaPlayer_native_init()对应，下面就看看native_init()的实现。 static void android_media_MediaPlayer_native_init(JNIEnv *env) { jclass clazz; clazz = env-&gt;FindClass(&quot;android/media/MediaPlayer&quot;); .. fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;, &quot;I&quot;); ... }说明：该代码在frameworks/base/media/jni/android_media_MediaPlayer.cpp中。env-&gt;FindClass(“android/media/MediaPlayer”)会加载Java层的MediaPlayer类；进而将fields.context初始化为MediaPlayer类中的mNativeContext成员。 2.4 native_setup()的实现由于native_setup()和android_media_MediaPlayer_native_setup()对应，下面就看看native_setup()的实现。 static void android_media_MediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this) { sp&lt;MediaPlayer&gt; mp = new MediaPlayer(); ... setMediaPlayer(env, thiz, mp); }说明：该函数会新建一个MediaPlayer对象，然后调用setMediaPlayer()来保存该MediaPlayer对象。下面看看setMediaPlayer()是如何保存MediaPlayer对象的。 2.5 setMediaPlayer()static sp&lt;MediaPlayer&gt; setMediaPlayer(JNIEnv* env, jobject thiz, const sp&lt;MediaPlayer&gt;&amp; player) { sp&lt;MediaPlayer&gt; old = (MediaPlayer*)env-&gt;GetIntField(thiz, fields.context); ... env-&gt;SetIntField(thiz, fields.context, (int)player.get()); return old; }说明：通过SetIntField()会将MediaPlayer对象保存到fields.context中。而在前面的，我们将fields.context初始化为MediaPlayer类(Java层)中的mNativeContext成员。这也就意味着，设置了Java层的MediaPlayer中的mNativeContext成员的值为C++层MediaPlayer对象。 至此，就分析完了MediaPlayer的构造函数。下面继续看Java示例代码中的mp.setDataSource(\"/sdcard/test.mp3\")。 2.6 setDataSource()public void setDataSource(String path) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException { setDataSource(path, null, null); } private void setDataSource(String path, String[] keys, String[] values) throws IOException, IllegalArgumentException, SecurityException, IllegalStateException { ... final File file = new File(path); if (file.exists()) { FileInputStream is = new FileInputStream(file); FileDescriptor fd = is.getFD(); setDataSource(fd); is.close(); } else { ... } ... } public void setDataSource(FileDescriptor fd) throws IOException, IllegalArgumentException, IllegalStateException { setDataSource(fd, 0, 0x7ffffffffffffffL); } public void setDataSource(FileDescriptor fd, long offset, long length) throws IOException, IllegalArgumentException, IllegalStateException { ... _setDataSource(fd, offset, length); } private native void _setDataSource(FileDescriptor fd, long offset, long length) throws IOException, IllegalArgumentException, IllegalStateException;说明：该代码在frameworks/base/media/java/android/media/MediaPlayer.java中。setDataSource()最终会调用到本地方法_setDataSource()。在前面的gMethods本地方法注册表中，将_setDataSource()和android_media_MediaPlayer_setDataSourceFD()匹配。下面，看看_setDataSource()的实现。 2.7 android_media_MediaPlayer_setDataSourceFD()static void android_media_MediaPlayer_setDataSourceFD(JNIEnv *env, jobject thiz, jobject fileDescriptor, jlong offset, jlong length) { sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz); ... int fd = jniGetFDFromFileDescriptor(env, fileDescriptor); ... process_media_player_call( env, thiz, mp-&gt;setDataSource(fd, offset, length), &quot;java/io/IOException&quot;, &quot;setDataSourceFD failed.&quot; ); }说明：该代码在frameworks/base/media/jni/android_media_MediaPlayer.cpp中。该函数会先通过getMediaPlayer()获取MediaPlayer对象，然后在执行mp-&gt;setDataSource()时会调用MediaPlayer的setDataSource()方法。 2.8 getMediaPlayer()static sp&lt;MediaPlayer&gt; getMediaPlayer(JNIEnv* env, jobject thiz) { ... MediaPlayer* const p = (MediaPlayer*)env-&gt;GetIntField(thiz, fields.context); return sp&lt;MediaPlayer&gt;(p); }说明：前面在native_setup()中，将fields.context设置为MediaPlayer对象。这里就是返回fields.context中保存的MediaPlayer对象。 2.9 MediaPlayer::setDataSourcestatus_t MediaPlayer::setDataSource( const char *url, const KeyedVector&lt;String8, String8&gt; *headers) { ... status_t err = BAD_VALUE; if (url != NULL) { // 通过getMediaPlayerService()的代理BpMediaPlayerService。 const sp&lt;IMediaPlayerService&gt;&amp; service(getMediaPlayerService()); if (service != 0) { // 通过BpMediaPlayerService创建一个IMediaPlayer客户端 sp&lt;IMediaPlayer&gt; player(service-&gt;create(this, mAudioSessionId)); ... // 保存player err = attachNewPlayer(player); } } return err; }说明：该代码在frameworks/av/media/libmedia/mediaplayer.cpp中。(01) 它会新建一个service对象，而service是通过getMediaPlayerService()获取到的。getMediaPlayerService()已经在”介绍getService请求“时，详细分析过了。它会返回IMediaPlayerService的代理，即BpMediaPlayerService对象。(02) 接着，会调用service-&gt;create()返回一个IMediaPlayer对象。下面看看这个MediaPlayer进程是如何通过BpMediaPlayerService这个远程代理来获取IMediaPlayer对象的。 2.10 BpMediaPlayerService::create()class BpMediaPlayerService: public BpInterface&lt;IMediaPlayerService&gt; { ... virtual sp&lt;IMediaPlayer&gt; create( const sp&lt;IMediaPlayerClient&gt;&amp; client, int audioSessionId) { Parcel data, reply; data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor()); data.writeStrongBinder(client-&gt;asBinder()); data.writeInt32(audioSessionId); remote()-&gt;transact(CREATE, data, &amp;reply); return interface_cast&lt;IMediaPlayer&gt;(reply.readStrongBinder()); } ... }说明：该代码在frameworks/av/media/libmedia/IMediaPlayerService.cpp中。这里无非是CREATE请求数据打包之后发送给Binder驱动，再由Binder驱动转发给MediaPlayerService进程。数据的发送和解析，在前面介绍”addService”和”getService”时已经多次介绍过了；这里就不再展开说明了。 Binder驱动在收到MediaPlayer的数据之后，会将添加一个事务到MediaPlayerService的待处理事务列表中，然后唤醒MediaPlayerService。下面就从MediaPlayerService被唤醒之后开始说明。 2.11 Binder驱动中binder_thread_read()的源码又回到了熟悉的binder_thread_read()中。 static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) { ... if (wait_for_proc_work) { ... if (non_block) { ... } else // 阻塞式的读取，则阻塞等待事务的发生。 ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); } else { ... } ... while (1) { struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... else { ... } ... switch (w-&gt;type) { case BINDER_WORK_TRANSACTION: { t = container_of(w, struct binder_transaction, work); } break; ... } if (!t) continue; // t-&gt;buffer-&gt;target_node是目标节点。 // 这里，MediaPlayer的CREATE请求的目标是MediaPlayerService，因此target_node是MediaPlayerService对应的节点； if (t-&gt;buffer-&gt;target_node) { // 事务目标对应的Binder实体(即，MediaPlayerService对应的Binder实体) struct binder_node *target_node = t-&gt;buffer-&gt;target_node; // Binder实体在用户空间的地址。 // MediaPlayerService的ptr为本地Binder的弱引用，即BBinder的弱引用 tr.target.ptr = target_node-&gt;ptr; // Binder实体在用户空间的其它数据 // MediaPlayerService的cookie为本地Binder本身，即BBinder对象 tr.cookie = target_node-&gt;cookie; t-&gt;saved_priority = task_nice(current); if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) binder_set_nice(t-&gt;priority); else if (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority) binder_set_nice(target_node-&gt;min_priority); cmd = BR_TRANSACTION; } else { ... } // 交易码，即CREATE tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) { struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); } else { tr.sender_pid = 0; } // 数据大小 tr.data_size = t-&gt;buffer-&gt;data_size; // 数据中对象的偏移数组的大小(即对象的个数) tr.offsets_size = t-&gt;buffer-&gt;offsets_size; // 数据 tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; // 数据中对象的偏移数组 tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); // 将cmd(即BR_TRANSACTION)指令写入到ptr，即传递到用户空间 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; // 将tr数据拷贝到用户空间 ptr += sizeof(uint32_t); if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); ... // 删除已处理的事务 list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; // 设置回复信息 if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) { t-&gt;to_parent = thread-&gt;transaction_stack; t-&gt;to_thread = thread; thread-&gt;transaction_stack = t; } else { ... } break; } done: // 更新bwr.read_consumed的值 *consumed = ptr - buffer; ... return 0; }说明：MediaPlayerService被唤醒之后，binder_has_thread_work()为true。因为MediaPlayerService的待处理事务队列中有个待处理事务(即，MediaPlayer添加的CREATE请求)。(01) 进入while循环后，首先取出待处理事务。(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让MediaPlayerService读取后进行处理。 这里，共添加了两个指令到bwr.read_consumed中：BR_NOOP和BR_TRANSACTION。其中，BR_TRANSACTION指令对应的数据中包含了CREATE请求的数据。 接下来，binder_thread_read()返回到binder_ioctl()中；binder_ioctl()将数据拷贝到用户空间之后，便返回到用户空间继续执行。而在Android Binder机制(八) MediaPlayerService服务的消息循环中介绍过，MediaPlayerService是通过调用IPCThreadState::joinThreadPool()进入消息循环的，而joinThreadPool()又会通过getAndExecuteCommand()调用到talkWithDriver()来和Binder驱动交互的。因此，Binder驱动返回到用户空间之后，会进入talkWithDriver()。 2.12 IPCThreadState::talkWithDriver()status_t IPCThreadState::talkWithDriver(bool doReceive) { ... do { ... if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else ... ... } while (err == -EINTR); ... if (err &gt;= NO_ERROR) { // 清空已写的数据 if (bwr.write_consumed &gt; 0) { if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); } // 设置已读数据 if (bwr.read_consumed &gt; 0) { mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); } ... return NO_ERROR; } return err; }说明：ioctl()返回之后，talkWithDriver()会清除已经发送的数据。然后，便返回到getAndExecuteCommand()中。 13. IPCThreadState::getAndExecuteCommand()status_t IPCThreadState::getAndExecuteCommand() { status_t result; int32_t cmd; // 和Binder驱动交互 result = talkWithDriver(); if (result &gt;= NO_ERROR) { ... // 读取mIn中的数据 cmd = mIn.readInt32(); ... // 调用executeCommand()对数据进行处理。 result = executeCommand(cmd); ... } return result; }说明：getAndExecuteCommand()会取出Binder反馈的指令，然后再调用executeCommand()根据指令进行解析。前面说过，Binder驱动共反馈了BR_NOOP和BR_TRANSACTION两个指令。而BR_NOOP指令什么也不会做。因此，我们直接分析BR_TRANSACTION指令。 14. IPCThreadState::executeCommand()status_t IPCThreadState::executeCommand(int32_t cmd) { BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch (cmd) { ... case BR_TRANSACTION: { binder_transaction_data tr; result = mIn.read(&amp;tr, sizeof(tr)); ... Parcel buffer; buffer.ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(size_t), freeBuffer, this); ... Parcel reply; ... if (tr.target.ptr) { sp&lt;BBinder&gt; b((BBinder*)tr.cookie); const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); if (error &lt; NO_ERROR) reply.setError(error); } else { ... } if ((tr.flags &amp; TF_ONE_WAY) == 0) { sendReply(reply, 0); } else { ... } ... } break; ... } ... return result; }说明：进入BR_TRANSACTION分支后，首先通过mIn.read()读取事务数据。接着，调用ipcSetDataReference()将事务数据解析出来。很显然，tr.target.ptr不为空，它的值是”MediaPlayerService的BBinder的弱引用”。然后，就将tr.cookie转换为BBinder*对象b；而b实际上是MediaPlayerService的本地Binder实例，即BnMediaPlayerService的实例。最终，通过b-&gt;transact()进行事务处理。 下面看看BBinder的transact()代码。 status_t BBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) { data.setDataPosition(0); status_t err = NO_ERROR; switch (code) { case PING_TRANSACTION: reply-&gt;writeInt32(pingBinder()); break; default: err = onTransact(code, data, reply, flags); break; } if (reply != NULL) { reply-&gt;setDataPosition(0); } return err; }该代码在frameworks/native/libs/binder/Binder.cpp中。此时的code是CREATE，因此，它会调用onTransact()对事务进行处理。而BnMediaPlayerService重写了onTransact()方法；因此会调用到BnMediaPlayerService的onTransact()方法。在Binder机制中也是根据这种方式来实现不同Server的对各自的的请求进行区分处理的：Server的本地Binder实现类，通过覆盖onTransact()方法来处理事务。 下面看看BnMediaPlayerService的onTransact()方法。 15. BnMediaPlayerService::onTransact()status_t BnMediaPlayerService::onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) { switch (code) { case CREATE: { ... sp&lt;IMediaPlayerClient&gt; client = interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder()); int audioSessionId = data.readInt32(); sp&lt;IMediaPlayer&gt; player = create(client, audioSessionId); reply-&gt;writeStrongBinder(player-&gt;asBinder()); return NO_ERROR; } break; ... } ... }说明：该代码在frameworks/av/media/libmedia/IMediaPlayerService.cpp中。(01) 先通过interface_cast宏获取IMediaPlayerClient对象，该对象是BpMediaPlayerClient实例。BpMediaPlayerClient定义在frameworks/av/media/libmedia/IMediaPlayer.cpp中。(02) 接着，通过create()创建IMediaPlayerService对象。该create()的实现是在BnMediaPlayerService的子类MediaPlayerService.cpp中，即在frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp中实现。在create()中会新建一个Client，并返回。(03) 最后，将这个Client通过Binder返回给MediaPlayer。 后面的流程就不再多说了。本文的核心是Binder机制，而不是MediaPlayer的框架，让我们了解MediaPlayer进程是如何与MediaPlayerService交互即可！而目前，通过CREATE请求，我们已经知道了MediaPlayer是如何和MediaPlayerService进行事务交互的。后面的内容更多的涉及到MediaPlayerService的框架，它不是本章的重点；感兴趣的读者可以自行研究。","link":"/2014/09/08/android/os/binder/2014-09-08-Binder-Java/"},{"title":"Android 触摸事件机制(四) ViewGroup中触摸事件详解","text":"本文将对ViewGroup中触摸事件相关的内容进行介绍。ViewGroup继承于View，所以说，ViewGroup中对触摸事件的处理，很多都继承于View。但是，ViewGroup又有自己对触摸事件的特定处理。本文重点介绍的是dispatchTouchEvent()；理解ViewGroup的dispatchTouchEvent()接口是理解Android触摸事件传递机制的关机。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. ViewGroup中触摸事件的概述2. ViewGroup中触摸事件的源码解析2.1. ViewGroup中的dispatchTouchEvent2.2. ViewGroup中的onTouchEvent 1. ViewGroup中触摸事件的概述ViewGroup继承于View，它中对触摸事件的处理，很多都继承于View。但是，ViewGroup又有自己对触摸事件的特定处理。(01) ViewGroup重载了dispatchTouchEvent()接口。(02) ViewGroup新增了onInterceptTouchEvent()接口。 2. ViewGroup中触摸事件的源码解析 2.1 ViewGroup中的dispatchTouchEvent@Override public boolean dispatchTouchEvent(MotionEvent ev) { // mInputEventConsistencyVerifier是调试用的，不会理会 if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } // 第1步：是否要分发该触摸事件 // // onFilterTouchEventForSecurity()表示是否要分发该触摸事件。 // 如果该View不是位于顶部，并且有设置属性使该View不在顶部时不响应触摸事件，则不分发该触摸事件，即返回false。 // 否则，则对触摸事件进行分发，即返回true。 boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 第2步：检测是否需要清空目标和状态 // // 如果是ACTION_DOWN(即按下事件)，则清空之前的触摸事件处理目标和状态。 // 这里的情况状态包括： // (01) 清空mFirstTouchTarget链表，并设置mFirstTouchTarget为null。 // mFirstTouchTarget是&quot;接受触摸事件的View&quot;所组成的单链表 // (02) 清空mGroupFlags的FLAG_DISALLOW_INTERCEPT标记 // 如果设置了FLAG_DISALLOW_INTERCEPT，则不允许ViewGroup对触摸事件进行拦截。 // (03) 清空mPrivateFlags的PFLAG_CANCEL_NEXT_UP_EVEN标记 if (actionMasked == MotionEvent.ACTION_DOWN) { cancelAndClearTouchTargets(ev); resetTouchState(); } // 第3步：检查当前ViewGroup是否想要拦截触摸事件 // // 是的话，设置intercepted为true；否则intercepted为false。 // 如果是&quot;按下事件(ACTION_DOWN)&quot; 或者 mFirstTouchTarget不为null；就执行if代码块里面的内容。 // 否则的话，设置intercepted为true。 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 检查禁止拦截标记：FLAG_DISALLOW_INTERCEPT // 如果调用了requestDisallowInterceptTouchEvent()标记的话，则FLAG_DISALLOW_INTERCEPT会为true。 // 例如，ViewPager在处理触摸事件的时候，就会调用requestDisallowInterceptTouchEvent() // ，禁止它的父类对触摸事件进行拦截 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { // 如果禁止拦截标记为false的话，则调用onInterceptTouchEvent()；并返回拦截状态。 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { intercepted = true; } // 第4步：检查当前的触摸事件是否被取消 // // (01) 对于ACTION_DOWN而言，mPrivateFlags的PFLAG_CANCEL_NEXT_UP_EVENT位肯定是0；因此，canceled=false。 // (02) 当前的View或ViewGroup要被从父View中detach时，PFLAG_CANCEL_NEXT_UP_EVENT就会被设为true； // 此时，它就不再接受触摸事情。 final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // 第5步：将触摸事件分发给&quot;当前ViewGroup的子View和子ViewGroup&quot; // // 如果触摸&quot;没有被取消&quot;，同时也&quot;没有被拦截&quot;的话，则将触摸事件分发给它的子View和子ViewGroup。 // 如果当前ViewGroup的孩子有接受触摸事件的话，则将该孩子添加到mFirstTouchTarget链表中。 final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) { if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { // 这是获取触摸事件的序号 以及 触摸事件的id信息。 // (01) 对于ACTION_DOWN，actionIndex肯定是0 // (02) 而getPointerId()是获取的该触摸事件的id，并将该id信息保存到idBitsToAssign中。 // 这个触摸事件的id是为多指触摸而添加的；对于单指触摸，getActionIndex()返回的肯定是0； // 而对于多指触摸，第一个手指的id是0，第二个手指的id是1，第三个手指的id是2，...依次类推。 final int actionIndex = ev.getActionIndex(); final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // 清空这个手指之前的TouchTarget链表。 // 一个TouchTarget，相当于一个可以被触摸的对象；它中记录了接受触摸事件的View removePointersFromTouchTargets(idBitsToAssign); // 获取该ViewGroup包含的View和ViewGroup的数目， // 然后递归遍历ViewGroup的孩子，对触摸事件进行分发。 // 递归遍历ViewGroup的孩子：是指对于当前ViewGroup的所有孩子，都会逐个遍历，并分发触摸事件； // 对于逐个遍历到的每一个孩子，若该孩子是ViewGroup类型的话，则会递归到调用该孩子的孩子，... final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final View[] children = mChildren; final boolean customOrder = isChildrenDrawingOrderEnabled(); for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = children[childIndex]; // 如果child可以接受触摸事件， // 并且触摸坐标(x,y)在child的可视范围之内的话； // 则继续往下执行。否则，调用continue。 // child可接受触摸事件：是指child的是可见的(VISIBLE)；或者虽然不可见，但是位于动画状态。 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { continue; } // getTouchTarget()的作用是查找child是否存在于mFirstTouchTarget的单链表中。 // 是的话，返回对应的TouchTarget对象；否则，返回null。 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { newTouchTarget.pointerIdBits |= idBitsToAssign; break; } // 重置child的mPrivateFlags变量中的PFLAG_CANCEL_NEXT_UP_EVENT位。 resetCancelNextUpFlag(child); // 调用dispatchTransformedTouchEvent()将触摸事件分发给child。 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // 如果child能够接受该触摸事件，即child消费或者拦截了该触摸事件的话； // 则调用addTouchTarget()将child添加到mFirstTouchTarget链表的表头，并返回表头对应的TouchTarget // 同时还设置alreadyDispatchedToNewTouchTarget为true。 mLastTouchDownTime = ev.getDownTime(); mLastTouchDownIndex = childIndex; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } } } // 如果newTouchTarget为null，并且mFirstTouchTarget不为null； // 则设置newTouchTarget为mFirstTouchTarget链表中第一个不为空的节点。 if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // 第6步：进一步的对触摸事件进行分发 // // (01) 如果mFirstTouchTarget为null，意味着还没有任何View来接受该触摸事件； // 此时，将当前ViewGroup看作一个View； // 将会调用&quot;当前的ViewGroup的父类View的dispatchTouchEvent()&quot;对触摸事件进行分发处理。 // 即，会将触摸事件交给当前ViewGroup的onTouch(), onTouchEvent()进行处理。 // (02) 如果mFirstTouchTarget不为null，意味着有ViewGroup的子View或子ViewGroup中， // 有可以接受触摸事件的。那么，就将触摸事件分发给这些可以接受触摸事件的子View或子ViewGroup。 if (mFirstTouchTarget == null) { // 注意：这里的第3个参数是null handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // 第7步：再次检查取消标记，并进行相应的处理 // // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } // mInputEventConsistencyVerifier是调试用的，不会理会 if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; }说明：该代码定义在frameworks/base/core/java/android/view/ViewGroup.java中。流程比较复杂，但文章已经给出了非常详细的注释，相信根据注释应该能读懂。遇到不懂或有疑惑的地方，还需阅读源码才是！ 注意：第5步，即ViewGroup尝试将触摸事件分发给它的孩子。这只有在ACTION_DOWN的时候才发生。如果它的孩子接受了触摸事件，则会调用addTouchTarget()将该孩子添加到mFirstTouchTarget链表中。 在ACTION_DOWN之后，传递ACTION_MOVE或ACTION_UP时，ViewGroup不会再执行第5步；而是在第6步中，直接遍历mFirstTouchTarget链表，查找之前接受ACTION_DOWN的孩子，并将触摸事件分配给这些孩子。也就是说，如果ViewGroup的某个孩子没有接受ACTION_DOWN事件；那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！ 2.1.1 ViewGroup中的dispatchTransformedTouchEvent()private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // 检测是否需要发送ACTION_CANCEL。 // 如果cancel为true 或者 action是ACTION_CANCEL; // 则设置消息为ACTION_CANCEL，并将ACTION_CANCEL消息分发给对应的对象，并返回。 // (01) 如果child是空，则将ACTION_CANCEL消息分发给当前ViewGroup； // 只不过会将ViewGroup看作它的父类View，调用View的dispatchTouchEvent()接口。 // (02) 如果child不是空，调用child的dispatchTouchEvent()。 final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // 计算触摸事件的id信息 final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // 如果新的id信息为0，则返回false。 if (newPointerIdBits == 0) { return false; } // 如果计算得到的前后触摸事件id信息相同，则执行不需要重新计算MotionEvent，直接执行if语句块进行消费分发； // 否则，就重新计算MotionEvent之后，再进行消息分发。 final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { // (01) 如果child是空，则将ViewGroup看作它的父类View，调用View的dispatchTouchEvent()接口。 // (02) 如果child不是空，调用child的dispatchTouchEvent()。 if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // (01) 如果child是空，则将ViewGroup看作它的父类View，调用View的dispatchTouchEvent()接口。 // (02) 如果child不是空，调用child的dispatchTouchEvent()。 if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; }说明：dispatchTransformedTouchEvent()会对触摸事件进行重新打包后再分发。如果它的第三个参数child是null，则会将触摸消息分发给ViewGroup自己，只不过此时是将ViewGroup看作一个View，即调用View的dispatchTouchEvent()进行消息分发。而View的dispatchTouchEvent()在前面一篇文章中已经消息介绍过了，它会触摸事件分发给onTouch(), onTouchEvent()进行处理。如果它的第三个参数child不是null，则会调用child.dispatchTouchEvent()进行消息分发。而如果这个child是ViewGroup对象的话，它则又会递归的将消息分发给它的孩子。 2.1.2 ViewGroup中的cancelAndClearTouchTargets()private TouchTarget mFirstTouchTarget; private void cancelAndClearTouchTargets(MotionEvent event) { // 如果mFirstTouchTarget链表不为空，则清空该链表 if (mFirstTouchTarget != null) { ... // 遍历mFirstTouchTarget链表，请清空每一个TouchTarget中View的PFLAG_CANCEL_NEXT_UP_EVENT位 for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) { resetCancelNextUpFlag(target.child); ... } // 清空TouchTarget链表本身，并设置mFirstTouchTarget为null clearTouchTargets(); ... } } private static boolean resetCancelNextUpFlag(View view) { // 清空mPrivateFlags中的PFLAG_CANCEL_NEXT_UP_EVENT位 if ((view.mPrivateFlags &amp; PFLAG_CANCEL_NEXT_UP_EVENT) != 0) { view.mPrivateFlags &amp;= ~PFLAG_CANCEL_NEXT_UP_EVENT; return true; } return false; } private void clearTouchTargets() { TouchTarget target = mFirstTouchTarget; // 清空mFirstTouchTarget链表，并设置mFirstTouchTarget为null if (target != null) { do { TouchTarget next = target.next; target.recycle(); target = next; } while (target != null); mFirstTouchTarget = null; } }说明：cancelAndClearTouchTargets()的作用和明显。就是清空mFirstTouchTarget链表中每一个View的PFLAG_CANCEL_NEXT_UP_EVENT标记；然后清空mFirstTouchTarget链表，并设置mFirstTouchTarget为null。mFirstTouchTarget是TouchTarget类的成员。TouchTarget是ViewGroup的内部类，一个TouchTarget对象可以视为一个被触摸对象；即，在ViewGroup中，就通过TouchTarget表示一个可以接受触摸事件的对象。 private static final class TouchTarget { ... // 被触摸的View public View child; // pointerIdBits是记录触摸事件的id信息(对于多指触摸而言) public int pointerIdBits; // TouchTarget指向的下一个节点 public TouchTarget next; private TouchTarget() { } ... }2.1.3 ViewGroup中的resetTouchState()private void resetTouchState() { clearTouchTargets(); resetCancelNextUpFlag(this); mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; }说明：resetTouchState()是清空当前ViewGroup的点击状态。 2.1.4 ViewGroup中的removePointersFromTouchTargets()private void removePointersFromTouchTargets(int pointerIdBits) { TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if ((target.pointerIdBits &amp; pointerIdBits) != 0) { target.pointerIdBits &amp;= ~pointerIdBits; if (target.pointerIdBits == 0) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } }说明：理解removePointersFromTouchTargets()的关机，是理解ev.getPointerId()。而getPointerId()是获取的该触摸事件的id。对于多指触摸，第一个手指的id是0，第二个手指的id是1，第三个手指的id是2，…依次类推。而pointerIdBits就是记录的id信息的。第一个手指的pointerIdBits是0x0，第二个手指的的pointerIdBits是0x1，第三个手指的pointerIdBits是0x2，第四个手指的pointerIdBits是0x4，…所有手指的pointerIdBits是0xffffffff。理解了触摸id之后，再看看removePointersFromTouchTargets()就非常容易理解了。它是从mFirstTouchTarget链表中逐个遍历，清空pointerIdBits；如果清空pointerIdBits之后，TouchTarget的pointerIdBits为0，则将该节点从链表中删除。 2.1.5 ViewGroup中的canViewReceivePointerEvents()private static boolean canViewReceivePointerEvents(View child) { return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null; }说明：canViewReceivePointerEvents()是判断child是否可以接受触摸事件。如果child是VISIBLE；或者child是非VISIBLE，但是它处于动画状态；这两种状态都可以接受触摸事件。 2.1.6 ViewGroup中的isTransformedTouchPointInView()protected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint) { float localX = x + mScrollX - child.mLeft; float localY = y + mScrollY - child.mTop; if (! child.hasIdentityMatrix() &amp;&amp; mAttachInfo != null) { final float[] localXY = mAttachInfo.mTmpTransformLocation; localXY[0] = localX; localXY[1] = localY; child.getInverseMatrix().mapPoints(localXY); localX = localXY[0]; localY = localXY[1]; } final boolean isInView = child.pointInView(localX, localY); ... return isInView; }说明：isTransformedTouchPointInView()是判断(x,y)是否在child中。 2.1.7 ViewGroup中的getTouchTarget()private TouchTarget getTouchTarget(View child) { for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) { if (target.child == child) { return target; } } return null; }说明：getTouchTarget()的作用是查找child是否存在于mFirstTouchTarget的单链表中。是的话，返回对应的TouchTarget对象；否则，返回null。 2.2 ViewGroup中的onTouchEventViewGroup没有覆盖onTouchEvent()。因此，调用ViewGroup的onTouchEvent()的话；实际上调用的是它的父类View的onTouchEvent()。 2.3 ViewGroup中的onInterceptTouchEventpublic boolean onInterceptTouchEvent(MotionEvent ev) { return false; } 说明：ViewGroup的onInterceptTouchEvent()默认返回false。而且什么都不会执行！一般来说，若我们自定义ViewGroup时，需要拦截触摸消息；就可以覆盖onInterceptTouchEvent()来进行。 ViewGroup中关于触摸事件的代码就分析至此。总的来说：(01) ViewGroup中的dispatchTouchEvent()会将触摸事件进行递归遍历传递。ViewGroup会遍历它的所有孩子，对每个孩子都递归的调用dispatchTouchEvent()来分发触摸事件。(02) 如果ViewGroup的某个孩子没有接受(消费或者拦截)ACTION_DOWN事件；那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！(03) ViewGroup的onInterceptTouchEvent()默认返回false。","link":"/2015/01/04/android/os/event/2015-01-04-TouchEvent-ViewGroup/"},{"title":"Android 之Activity启动模式(二)之 Intent的Flag属性","text":"前面介绍了通过launchMode设置Activity的启动模式。本章接着介绍Activity的启动模式相关内容，讲解的内容是Intent与启动模式相关的Flag，以及android:taskAffinity的属性。 目录1. Intent与启动模式相关的Flag简介2. 1. FLAG_ACTIVITY_NEW_TASK标签测试3. 2. FLAG_ACTIVITY_CLEAR_TOP标签测试4. 3. FLAG_ACTIVITY_CLEAR_TASK标签测试5. 4. FLAG_ACTIVITY_SINGLE_TOP标签测试 Intent与启动模式相关的Flag简介这里仅仅对几个常用的与启动模式相关的Flag进行介绍。 FLAG_ACTIVITY_NEW_TASK在google的官方文档中介绍，它与launchMode=”singleTask”具有相同的行为。实际上，并不是完全相同！很少单独使用FLAG_ACTIVITY_NEW_TASK，通常与FLAG_ACTIVITY_CLEAR_TASK或FLAG_ACTIVITY_CLEAR_TOP联合使用。因为单独使用该属性会导致奇怪的现象，通常达不到我们想要的效果！尽管如何，后面还是会通过”FLAG_ACTIVITY_NEW_TASK示例一”和”FLAG_ACTIVITY_NEW_TASK示例二”会向你展示单独使用它的效果。 FLAG_ACTIVITY_SINGLE_TOP在google的官方文档中介绍，它与launchMode=”singleTop”具有相同的行为。实际上，的确如此！单独的使用FLAG_ACTIVITY_SINGLE_TOP，就能达到和launchMode=”singleTop”一样的效果。 FLAG_ACTIVITY_CLEAR_TOP顾名思义，FLAG_ACTIVITY_CLEAR_TOP的作用清除”包含Activity的task”中位于该Activity实例之上的其他Activity实例。FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_NEW_TASK两者同时使用，就能达到和launchMode=”singleTask”一样的效果！ FLAG_ACTIVITY_CLEAR_TASKFLAG_ACTIVITY_CLEAR_TASK的作用包含Activity的task。使用FLAG_ACTIVITY_CLEAR_TASK时，通常会包含FLAG_ACTIVITY_NEW_TASK。这样做的目的是启动Activity时，清除之前已经存在的Activity实例所在的task；这自然也就清除了之前存在的Activity实例！ 注意：当同时使用launchMode和上面的FLAG_ACTIVITY_NEW_TASK等标签时，以FLAG_ACTIVITY_NEW_TASK为标准。也就是说，代码的优先级比manifest中配置文件的优先级更高！ 下面，通过几个实例加深对这几个标记的理解。 1. FLAG_ACTIVITY_NEW_TASK标签测试1.1 FLAG_ACTIVITY_NEW_TASK示例一点击查看：FLAG_ACTIVITY_NEW_TASK示例一的源码 在该实例中，有两个Activity：ActivityTest和SecondActivity。manifest定义如下： &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;activity android:name=&quot;ActivityTest&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;SecondActivity&quot; /&gt; &lt;/application&gt;说明：通过manifest可以看出，ActivityTest和SecondActivity在同一个APK中。这也就意味着它们的android:taskAffinity是一样的！ ActivityTest的源码 public class ActivityTest extends Activity { private static final String TAG=&quot;##ActivityTest##&quot;; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Log.d(TAG, &quot;onCreate: &quot;+this.toString()+&quot;, taskId=&quot;+this.getTaskId()); TextView tv = (TextView) findViewById(R.id.tv); tv.setText(this.toString()+&quot;, taskId=&quot;+this.getTaskId()); } public void onJump(View view) { Intent intent = new Intent(this, SecondActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); } @Override protected void onNewIntent(Intent intent) { Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this+&quot;, taskId=&quot;+this.getTaskId()); } }说明：onJump()是ActivityTest中一个按钮的回调函数，点击该按钮会跳转到SecondActivity。注意，跳转的Intent添加了FLAG_ACTIVITY_NEW_TASK标志。 SecondActivity的源码 public class SecondActivity extends Activity { private static final String TAG=&quot;##SecondActivity##&quot;; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.second); Log.d(TAG, &quot;onCreate: &quot;+this.toString()+&quot;, taskId=&quot;+this.getTaskId()); TextView tv = (TextView) findViewById(R.id.tv2); tv.setText(this.toString()+&quot;, taskId=&quot;+this.getTaskId()); } public void onBack(View view) { Intent intent = new Intent(this, ActivityTest.class); startActivity(intent); } @Override protected void onNewIntent(Intent intent) { Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this+&quot;, taskId=&quot;+this.getTaskId()); } }说明：onBack()是SecondActivity中一个按钮的回调函数，点击该按钮会跳转回ActivityTest。 测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity测试结果：(01) ActivityTest和SecondActivity在同一个task中。 (02) 两个SecondActivity不同的实例！结果分析：如果说FLAG_ACTIVITY_NEW_TASK的作用和singleTask具有相同的效果。那么这个示例很明显的否则了这个结论！事实上，在相互跳转的两个Activity的android:taskAffinity相同的情况下，单独使用FLAG_ACTIVITY_NEW_TASK不会产生任何效果！ 那如果两个Activity的android:taskAffinity不相同呢？此时会导致什么效果呢？下面，我们通过示例来看看效果。 1.2 FLAG_ACTIVITY_NEW_TASK示例二点击查看：FLAG_ACTIVITY_NEW_TASK示例二的源码 我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中manifest，将ActivityTest和SecondActivity的android:taskAffinity改为不同；其余的保持不变！修改后的manifest如下： &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;activity android:name=&quot;ActivityTest&quot; android:taskAffinity=&quot;com.skw.activitytest01&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;SecondActivity&quot; android:taskAffinity=&quot;com.skw.activitytest02&quot; /&gt; &lt;/application&gt;测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity测试结果：(01) ActivityTest和SecondActivity在不同task中！ (02) 当第二次进入到ActivityTest中，再企图从ActivityTest中进入到SecondActivity时，没有产生任何效果，仍然停留在ActivityTest中！即第二次ActivityTest –&gt; SecondActivity压根就没发生！结果分析：当相互跳转的两个Activity的android:taskAffinity不同时，添加FLAG_ACTIVITY_NEW_TASK确实产生了一些效果：第一次启动Activity时，会新建一个task，并将Activity添加到该task中。这与singleTask产生的效果是一样的！但是，当企图再次从ActivityTest进入到SecondActivity时，却什么也没有发生！为什么呢？是因为此时SecondActivity实例已经存在，但是它所在的task的栈顶是ActivityTest；而单独的添加FLAG_ACTIVITY_NEW_TASK又不会”删除task中位于SecondActivity之上的Activity实例”，所以就没有发生跳转！ 好的，那下面，我们添加FLAG_ACTIVITY_CLEAR_TOP之后，再来看看效果。 2. FLAG_ACTIVITY_CLEAR_TOP标签测试2.1 FLAG_ACTIVITY_CLEAR_TOP示例一点击查看：FLAG_ACTIVITY_CLEAR_TOP示例一的源码。 我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下： public void onJump(View view) { Intent intent = new Intent(this, SecondActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); } 测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity测试结果：(01) ActivityTest和SecondActivity在同一个task中！ (02) 两个SecondActivity是不同的实例。结果分析：这与没有添加FLAG_ACTIVITY_CLEAR_TOP时效果一样！这说明，当相互跳转的两个Activity的android:taskAffinity一样时，不会产生任何效果！ 接下来，看看不同android:taskAffinity的情况。 2.2 FLAG_ACTIVITY_CLEAR_TOP示例二点击查看：FLAG_ACTIVITY_CLEAR_TOP示例二的源码。 我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下： public void onJump(View view) { Intent intent = new Intent(this, SecondActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); } 测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity测试结果：(01) ActivityTest和SecondActivity在不同task中！ (02) 两个SecondActivity是同一个实例。结果分析：此时的表现和SecondActivity是singleTask一样！ 这说明，在相互跳转的Activity的android:taskAffinity不同时，同时使用FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP，才具有和singleTask一样的效果！ 总的来说：FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP的使用和android:taskAffinity相关。在同时使用FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP的情况下，以A启动B来说(01) 当A和B的taskAffinity相同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP没有任何作用。和没有添加时的效果一样！(02) 当A和B的taskAffinity不同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP后，表现的和B是singleTask一样！ 3. FLAG_ACTIVITY_CLEAR_TASK标签测试3.1 FLAG_ACTIVITY_CLEAR_TASK示例一点击查看：FLAG_ACTIVITY_CLEAR_TASK示例一的源码 我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下： public void onJump(View view) { Intent intent = new Intent(this, SecondActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK); startActivity(intent); } 测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity测试结果：(01) ActivityTest和SecondActivity在同一个task中！ (02) 两个SecondActivity是不同的实例。结果分析：这与没有添加FLAG_ACTIVITY_CLEAR_TASK时效果一样！这说明，当相互跳转的两个Activity的android:taskAffinity一样时，不会产生任何效果！ 接下来，看看不同android:taskAffinity的情况。 3.2 FLAG_ACTIVITY_CLEAR_TASK示例二点击查看：FLAG_ACTIVITY_CLEAR_TASK示例二的源码 我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下： public void onJump(View view) { Intent intent = new Intent(this, SecondActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK); startActivity(intent); } 测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity –&gt; 返回键 –&gt; 返回键测试结果：(01) ActivityTest和SecondActivity在不同的task中！ (02) 两个SecondActivity是不同的实例。 (03) 第一次返回键，返回到第一个ActivityTest中。 (04) 第二次返回键，返回到进入第一个ActivityTest之前的画面。结果分析：当同时使用FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK时，每次启动Activity时，若该Activity的实例已经存在于某个task中，则清除该task中的全部内容；然后重新创建task并将Activity添加到新建的task中；否则，直接启动新的task并将该Activity添加到新建的task中。 总的来说：FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TASK的使用和android:taskAffinity相关。在同时使用FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK的情况下，以A启动B来说(01) 当A和B的taskAffinity相同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK没有任何作用。和没有添加时的效果一样！(02) 当A和B的taskAffinity不同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK后，启动B时，若该B已经存在于某个task中，则清除该task中的全部内容；然后重新创建task并将B添加到新建的task中；否则，直接启动新的task并将B添加到新建的task中。 4. FLAG_ACTIVITY_SINGLE_TOP标签测试FLAG_ACTIVITY_SINGLE_TOP的特性和launchMode=”singleTop”一样！这里就不做过多的说明了。 点击查看：FLAG_ACTIVITY_SINGLE_TOP示例一的源码。该示例中，只有一个Activity示例，点击该Activity会跳转到它自身。 点击查看：FLAG_ACTIVITY_SINGLE_TOP示例二的源码。该示例中，有两个Activity示例，两个Activity之间可以相互跳转。","link":"/2014/06/26/android/api_guide/app_component/activity/2014-06-26-IntentFlag/"},{"title":"Android组件--Fragment(三)之 自定义ListPreference","text":"本文介绍自定义ListPreference的相关内容。 ListPreference自定义属性系统自带的ListPreference的列表中只能显示文本。如果想显示图片或其他内容，只有通过自定义ListPreference的方式。 接下来，将通过示例来演示如何在ListPreference中显示图片。 点击查看：ListPreference示例的完整代码 1. 自定义属性添加文件res/values/attrs.xml，内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;declare-styleable name=&quot;IconListPreference&quot;&gt; &lt;attr name=&quot;entryIcons&quot; format=&quot;reference&quot; /&gt; &lt;/declare-styleable&gt; &lt;/resources&gt;说明：(01) name=”IconListPreference”，与自定义的ListPreference类的名称相对应。后面会实现一个继承于ListPreference的IconListPreference.java。(02) name=”entryIcons”，这是属性的名称。(03) format=”reference”，这描述属性的值是引用类型。因为，后面会根据资源id设置该属性，所以将属性格式设为reference。如果是颜色，设为format=”color”；如果是布尔类型，format=”boolean”；如果是字符串，设为format=”string”。 2. 自定义ListPreference2.1 构造函数public IconListPreference(Context context, AttributeSet attrs) { super(context, attrs); mContext = context; // 获取自定义的属性(attrs.xml中)对应行的TypedArray TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.IconListPreference); // 获取entryIcons属性对应的值 int iconResId = a.getResourceId(R.styleable.IconListPreference_entryIcons, -1); if (iconResId != -1) { setEntryIcons(iconResId); } // 获取Preferece对应的key mKey = getKey(); // 获取SharedPreferences mPref = PreferenceManager.getDefaultSharedPreferences(context); // 获取SharedPreferences.Editor mEditor = mPref.edit(); // 获取Entry // 注意：如果配置文件中没有android:entries属性，则getEntries()为空； mEntries = getEntries(); // 获取Entry对应的值 // 注意：如果配置文件中没有android:entryValues属性，则getEntries()为空 mEntryValues = getEntryValues(); // 获取该ListPreference保存的值 String value = mPref.getString(mKey, &quot;&quot;); mPosition = findIndexOfValue(value); // 设置Summary if (mPosition!=-1) { setSummary(mEntries[mPosition]); setIcon(mEntryIcons[mPosition]); } a.recycle(); } 说明：(01) 首先，根据obtainStyledAttributes()能获取自定义属性对应的TypedArray对象。(02) 在自定义属性中，entryIcons对应的类名是IconListPreference。因为需要通过”类名”_”属性名”，即IconListPreference_entryIcons的方式来获取资源信息。(03) getKey()是获取Preferece对应的Key。该Key是Preference对象的唯一标识。(04) getEntries()是获取Preferece的Entry数组。(05) getEntryValues()是获取Preferece的Entry对应的值的数组。(06) setSummary()是设置Preferece的summary标题内容。(07) setIcon()是设置Preferece的图标。 2.2 自定义ListPreference中图片相关代码/** * 设置图标：icons数组 */ private void setEntryIcons(int[] entryIcons) { mEntryIcons = entryIcons; } /** * 设置图标：根据icon的id数组 */ public void setEntryIcons(int entryIconsResId) { TypedArray icons = getContext().getResources().obtainTypedArray(entryIconsResId); int[] ids = new int[icons.length()]; for (int i = 0; i &lt; icons.length(); i++) ids[i] = icons.getResourceId(i, -1); setEntryIcons(ids); icons.recycle(); }说明：这两个函数是读取图片信息的。 2.3 自定义ListPreference弹出的列表选项@Override protected void onPrepareDialogBuilder(Builder builder) { super.onPrepareDialogBuilder(builder); IconAdapter adapter = new IconAdapter(mContext); builder.setAdapter(adapter, null); }说明：点击ListPreference，会弹出一个列表对话框。通过重写onPrepareDialogBuilder()，我们可以自定义弹出的列表对话框。这里是通过IconAdapter来显示的。 public class IconAdapter extends BaseAdapter{ private LayoutInflater mInflater; public IconAdapter(Context context){ this.mInflater = LayoutInflater.from(context); } @Override public int getCount() { return mEntryIcons.length; } @Override public Object getItem(int arg0) { return null; } @Override public long getItemId(int arg0) { return 0; } @Override public View getView(int position, View convertView, ViewGroup parent) { ViewHolder holder = null; if (convertView == null) { holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.icon_adapter, parent, false); holder.layout = (LinearLayout)convertView.findViewById(R.id.icon_layout); holder.img = (ImageView)convertView.findViewById(R.id.icon_img); holder.info = (TextView)convertView.findViewById(R.id.icon_info); holder.check = (RadioButton)convertView.findViewById(R.id.icon_check); convertView.setTag(holder); }else { holder = (ViewHolder)convertView.getTag(); } holder.img.setBackgroundResource(mEntryIcons[position]); holder.info.setText(mEntries[position]); holder.check.setChecked(mPosition == position); final ViewHolder fholder = holder; final int fpos = position; convertView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { v.requestFocus(); // 选中效果 fholder.layout.setBackgroundColor(Color.CYAN); // 更新mPosition mPosition = fpos; // 更新Summary IconListPreference.this.setSummary(mEntries[fpos]); IconListPreference.this.setIcon(mEntryIcons[fpos]); // 更新该ListPreference保存的值 mEditor.putString(mKey, mEntryValues[fpos].toString()); mEditor.commit(); // 取消ListPreference设置对话框 getDialog().dismiss(); } }); return convertView; } // ListPreference每一项对应的Layout文件的结构体 private final class ViewHolder { ImageView img; TextView info; RadioButton check; LinearLayout layout; } }说明：弹出的列表对话框中的每一项的内容是通过布局icon_adapter.xml来显示的。下面看看icon_adapter.xml的源码。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/icon_layout&quot; android:orientation=&quot;horizontal&quot; android:paddingLeft=&quot;6dp&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/icon_img&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:layout_margin=&quot;4dp&quot;/&gt; &lt;TextView android:id=&quot;@+id/icon_info&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:paddingLeft=&quot;6dp&quot; android:layout_gravity=&quot;left|center_vertical&quot; android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/icon_check&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:checked=&quot;false&quot; android:layout_gravity=&quot;right|center_vertical&quot; android:layout_marginRight=&quot;6dp&quot;/&gt; &lt;/LinearLayout&gt;至此，自定义的ListPreference就算完成了。下面就是如何使用它了。 3. 使用该自定义ListPreference我们是通过PreferenceFragment使用该自定义的ListPreference。 3.1 PreferenceFragment的配置文件res/xml/preferences.xml的内容如下： &lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:iconlistpreference=&quot;http://schemas.android.com/apk/res/com.skw.fragmenttest&quot;&gt; &lt;!-- 系统默认的ListPreference --&gt; &lt;PreferenceCategory android:title=&quot;PreferenceCategory A&quot;&gt; &lt;!-- (01) android:key是Preferece的id (02) android:title是Preferece的大标题 (03) android:summary是Preferece的小标题 (04) android:dialogTitle是对话框的标题 (05) android:defaultValue是默认值 (06) android:entries是列表中各项的说明 (07) android:entryValues是列表中各项的值 --&gt; &lt;ListPreference android:key=&quot;list_preference&quot; android:dialogTitle=&quot;Choose font&quot; android:entries=&quot;@array/pref_font_types&quot; android:entryValues=&quot;@array/pref_font_types_values&quot; android:summary=&quot;sans&quot; android:title=&quot;Font&quot; android:defaultValue=&quot;sans&quot;/&gt; &lt;/PreferenceCategory&gt; &lt;!-- 自定义的ListPreference --&gt; &lt;PreferenceCategory android:title=&quot;PreferenceCategory B&quot;&gt; &lt;!-- iconlistpreference:entryIcons是自定义的属性 --&gt; &lt;com.skw.fragmenttest.IconListPreference android:key=&quot;icon_list_preference&quot; android:dialogTitle=&quot;ChooseIcon&quot; android:entries=&quot;@array/android_versions&quot; android:entryValues=&quot;@array/android_version_values&quot; iconlistpreference:entryIcons=&quot;@array/android_version_icons&quot; android:icon=&quot;@drawable/cupcake&quot; android:summary=&quot;summary_icon_list_preference&quot; android:title=&quot;title_icon_list_preference&quot; /&gt; &lt;/PreferenceCategory&gt; &lt;/PreferenceScreen&gt;说明：该配置文件中使用了”系统默认的ListPreference”和”自定义的ListPreference(即IconListPreference)”。注意，IconListPreference中的”iconlistpreference:entryIcons”属性。前面的”iconlistpreference”与该文件的命名空间表示”xmlns:iconlistpreference=”http://schemas.android.com/apk/res/com.skw.fragmenttest&quot;中的iconlistpreference一样! 而entryIcons则是我们自定义的属性名称。 3.2 自定义PreferenceFragment的代码public class PrefsFragment extends PreferenceFragment { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.preferences); } ... }4. 使用PrefsFragment下面，就可以在Activity中使用该PrefsFragment了。 4.1 使用PrefsFragment的Activity的代码public class FragmentTest extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // 获取FragmentManager FragmentManager fragmentManager = getFragmentManager(); // 获取FragmentTransaction FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); PrefsFragment fragment = new PrefsFragment(); // 将fragment添加到容器frag_example中 fragmentTransaction.add(R.id.prefs, fragment); fragmentTransaction.commit(); } }4.2 使用PrefsFragment的Activity的配置文件res/layout/main.xml的内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; &gt; &lt;FrameLayout android:id=&quot;@+id/prefs&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;/LinearLayout&gt; ListPreference自定义说明如果你想通过提供API的方式，而不是配置属性的方式完成上面的工作。那么，也是可以办到的！ 点击查看：修改后的自定义ListPreference源码 不过，还是建议采用配置属性的方式！","link":"/2014/06/23/android/api_guide/app_component/fragment/2014-06-23-SelfDefine-ListPreference/"},{"title":"Android 之ContentProvider(二)之 ContentProvider基本用法","text":"本章给出ContentProvider的完整示例，并对之进行介绍。 目录1. ContentProvider简介2. ContentProvider示例 ContentProvider简介ContentProvider通常用于共享数据。 当其他程序需要访问本程序的数据，并且数据的结构比较复杂时，就可以使用ContentProvider来共享数据。如果数据不需要跨程序访问，使用数据库即可；如果数据结构比较简单，可以考虑前面提到的通过Intent共享文本等简单数据，或者通过FileProvider共享文件。 ContentProvider示例接下来，实现一个ContentProvider。该ContentProvider包括两部分：ContentProvider提供者APK 和 ContentProvider测试APK。(01) ContentProvider提供者：自定义一个ContentProvider，并监听相应的URI。客户可以通过URI插入/删除/更新/查询数据。ContentProvider中的数据记录的是人的信息，包括”姓名，出生年月，email，性别”等信息。(02) ContentProvider测试APK：通过URI向ContentProvider发起插入/删除/更新/查询等操作。 点击查看：ContentProvider示例的完整源码 下面介绍ContentProvider的实现步骤。 1. ContentProvider提供者APK1.1 ContentProvider的存储表格根据ContentProvider的数据特性，我们建立一张表，表格包括”id/姓名/出生年月/email/性别”这些信息。表对应的类如下： public final class MyContract { public MyContract() {} /** * BaseColumns类中有两个属性：_ID 和 _COUNT */ public static abstract class Entry implements BaseColumns { public static final String TABLE_NAME = &quot;mytable01&quot;; public static final String NAME = &quot;name&quot;; public static final String BIRTH_DAY = &quot;birthday&quot;; public static final String EMAIL = &quot;email&quot;; public static final String GENDER = &quot;gender&quot;; } }说明：BaseColumns是Android自带的类，它集成了”_ID”和”_COUNT”两个属性。 1.2 ContentProvider对应的manifest在manifest中声明我们自定义的ContentProvider。 &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;provider android:name=&quot;MyProvider&quot; android:authorities=&quot;com.skw.myprovider&quot; /&gt; &lt;/application&gt;1.3 自定义的ContentProvider类完成ContentProvider类，主要需要注意以下几点：(01) ContentProvider的数据一般是以”数据库”或”网络数据”的方式存储的。如果是数据库，则需要实现SQLiteOpenHelper类。通过SQLiteOpenHelper类新建/管理数据库。(02) ContentProvider主要是以Uri的形式方式访问的(也可以通过Intent)。要通过UriMatcher注册ContentProvider监听的Uri。(03) ContentProvider是一个抽象类。当我们需要以继承ContentProvider的方式自定义ContentProvider时，需要实现query(), insert(), update(), delete(), getType(), onCreate()这六个函数。 1.3.1 数据库下面，先介绍ContentProvider的数据库的实现。 // 创建表格的SQL语句 private static final String SQL_CREATE_ENTRIES = &quot;CREATE TABLE &quot; + Entry.TABLE_NAME + &quot; (&quot; + Entry._ID + &quot; INTEGER PRIMARY KEY,&quot; + Entry.NAME + &quot; TEXT NOT NULL, &quot; + Entry.BIRTH_DAY + &quot; TEXT, &quot; + Entry.EMAIL + &quot; TEXT, &quot; + Entry.GENDER + &quot; INTEGER &quot; + &quot; )&quot;; ... private class DBLiteHelper extends SQLiteOpenHelper { public static final int DATABASE_VERSION = 1; public static final String DATABASE_NAME = &quot;MyProvider.db&quot;; public DBLiteHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(SQL_CREATE_ENTRIES); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } }说明：关于SQLiteOpenHelper的内容在”数据存储章节“中已经详细介绍过了。 1.3.2 注册Uri// Uri的authority public static final String AUTHORITY = &quot;com.skw.myprovider&quot;; // Uri的path public static final String PATH = &quot;table01&quot;; // UriMatcher中URI对应的序号 public static final int ITEM_ALL = 1; public static final int ITEM_ID = 2; private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH); static { URI_MATCHER.addURI(AUTHORITY, PATH, ITEM_ALL); URI_MATCHER.addURI(AUTHORITY, PATH+&quot;/#&quot;, ITEM_ID); }说明：通过addURI()就可以将URI注册到UriMatcher中，从而实现ContentProvider对URI的监听。这里的AUTHORITY与manifest中的android:authorities一致！例如， URI_MATCHER.addURI(AUTHORITY, PATH, ITEM_ALL); 意味着ContentProvider对”content://con.skw.myprovider/table01”进行监听。例如， URI_MATCHER.addURI(AUTHORITY, PATH+”/#”, ITEM_ALL); 意味着ContentProvider对”content://con.skw.myprovider/table01/5”进行监听。 1.3.2 实现ContentProvider的抽象函数onCreate()@Override public boolean onCreate() { mDbHelper = new DBLiteHelper(this.getContext()); Log.d(TAG, &quot;open/create table&quot;); return true; }说明：onCreate()中新建SQLiteOpenHelper对象。 delete()@Override public int delete(Uri uri, String selection, String[] selectionArgs) { SQLiteDatabase db = mDbHelper.getWritableDatabase(); int count = 0; switch (URI_MATCHER.match(uri)) { case ITEM_ALL: count = db.delete(Entry.TABLE_NAME, selection, selectionArgs); Log.d(TAG, &quot;delete ITEM uri=&quot;+uri+&quot;, count=&quot;+count); break; case ITEM_ID: // 获取id列的值 String id = uri.getPathSegments().get(1); count = db.delete(Entry.TABLE_NAME, Entry._ID+&quot;=?&quot;, new String[]{id}); Log.d(TAG, &quot;delete ITEM_ID id=&quot;+id+&quot;, uri=&quot;+uri+&quot;, count=&quot;+count); break; default: throw new IllegalArgumentException(&quot;Unknown URI&quot;+uri); } getContext().getContentResolver().notifyChange(uri, null); return count; }说明：delete()中会通过match()获取uri对应的编码。这里的编码就是和addURI()注册uri的编码是相对应的。此外，notifyChange()的作用是通常数据库变化，若有ContentObserver监听该Uri，则notifyChange()最终会将消息传递给监听者。 insert(), update(), query()的实现与delete()类似，就不再说明。 getType()@Override public String getType(Uri uri) { switch (URI_MATCHER.match(uri)) { case ITEM_ALL: return &quot;skw.myprovider.dir/table01&quot;; case ITEM_ID: return &quot;skw.myprovider.item/table01&quot;; default: throw new IllegalArgumentException(&quot;Unknown URI&quot;+uri); } }说明：getType()是返回Uri对应的数据类型。 2. ContentProvider测试APKpublic class ProviderTest extends Activity implements View.OnClickListener { private static final String TAG = &quot;##ProviderTest##&quot;; // 数据库的属性，与MyProvider的表格属性一致 public static final String NAME = &quot;name&quot;; public static final String BIRTH_DAY = &quot;birthday&quot;; public static final String EMAIL = &quot;email&quot;; public static final String GENDER = &quot;gender&quot;; // 数据库的URI public static final Uri CONTENT_URI = Uri.parse(&quot;content://com.skw.myprovider/table01&quot;); private ContentResolver mContentResolver = null; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); ((Button)findViewById(R.id.insert)).setOnClickListener(this); ((Button)findViewById(R.id.deleteFirst)).setOnClickListener(this); ((Button)findViewById(R.id.deleteKate)).setOnClickListener(this); ((Button)findViewById(R.id.deleteAll)).setOnClickListener(this); ((Button)findViewById(R.id.update)).setOnClickListener(this); ((Button)findViewById(R.id.show)).setOnClickListener(this); // 删除第一行，然后全部打印出来 mContentResolver = getContentResolver(); } @Override public void onClick(View view) { switch(view.getId()) { case R.id.insert: // 添加 insert(&quot;Jimmy&quot;, &quot;20020201&quot;, &quot;Jimmy20020201@126.com&quot;, 1); insert(&quot;Kate&quot;, &quot;20030104&quot;, &quot;kate20030104@126.com&quot;, 0); insert(&quot;Li Lei&quot;, &quot;20021124&quot;, &quot;lilei20101124@126.com&quot;, 1); insert(&quot;Lucy&quot;, &quot;20010624&quot;, &quot;lucy20101124@126.com&quot;, 0); break; case R.id.deleteFirst: ContentUris cus = new ContentUris(); Uri uri = cus.withAppendedId(CONTENT_URI, 1); Log.d(TAG, &quot;delete uri=&quot;+uri); mContentResolver.delete(uri, null, null); break; case R.id.deleteKate: // 删除“username=Kate”的行，然后全部打印出来 mContentResolver.delete(CONTENT_URI, NAME+&quot;=?&quot;, new String[]{&quot;Kate&quot;}); break; case R.id.deleteAll: // 删除全部的行，然后全部打印出来 deleteAll() ; break; case R.id.update: // 更新第1个值，然后全部打印出来 updateItem() ; break; case R.id.show: // 打印全部的值 printAll() ; break; default: // 查找第2个值 //querySecondItem() ; break; } } /* * 通过ContentResolver,将值插入到MyProvider中 */ private void insert(String name, String date, String email, int gender) { ContentResolver cr = getContentResolver(); ContentValues cv = new ContentValues(); cv.put(NAME, name); cv.put(BIRTH_DAY, date); cv.put(EMAIL, email); cv.put(GENDER, gender); Uri uri = cr.insert(CONTENT_URI, cv); Log.d(TAG, &quot;insert uri=&quot;+uri); } private void updateItem() { ContentResolver cr = getContentResolver(); ContentUris cus = new ContentUris(); Uri uri = cus.withAppendedId(CONTENT_URI, 1); ContentValues cv = new ContentValues(); cv.put(NAME, &quot;update_name&quot;); cv.put(BIRTH_DAY, &quot;update_date&quot;); cv.put(EMAIL, &quot;update_email&quot;); cv.put(GENDER, 1); cr.update(uri, cv, null, null); } /* * 通过ContentResolver,将MyProvider中的值全部删除 */ private void deleteAll() { Log.d(TAG, &quot;delete all value!&quot;); ContentResolver cr = getContentResolver(); cr.delete(CONTENT_URI, null, null); } private void querySecondItem() { ContentResolver cr = getContentResolver(); ContentUris cus = new ContentUris(); Uri uri = cus.withAppendedId(CONTENT_URI, 2); String[] proj = new String[] { NAME, BIRTH_DAY, EMAIL, GENDER}; Cursor cursor = cr.query(uri, proj, null, null, null); int index = 0; while (cursor.moveToNext()) { Log.d(TAG, &quot;querySecondItem--&quot;+index+&quot;--&quot; +&quot;, email=&quot; + cursor.getString(cursor.getColumnIndex(EMAIL)) +&quot;, username=&quot; + cursor.getString(cursor.getColumnIndex(NAME)) +&quot;, date=&quot; + cursor.getString(cursor.getColumnIndex(BIRTH_DAY)) +&quot;, gender=&quot; + cursor.getInt(cursor.getColumnIndex(GENDER))); index++; } } private void printAll() { //通过contentResolver进行查找 ContentResolver cr = getContentResolver(); Log.d(TAG, &quot;print all value!&quot;); // query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) // 返回的列 String[] proj = new String[] { NAME, BIRTH_DAY, EMAIL, GENDER}; Cursor cursor = cr.query( CONTENT_URI, proj, null, null, null); int index = 0; while (cursor.moveToNext()) { Log.d(TAG, &quot;printAll--&quot;+index+&quot;--&quot; +&quot;, email=&quot; + cursor.getString(cursor.getColumnIndex(EMAIL)) +&quot;, username=&quot; + cursor.getString(cursor.getColumnIndex(NAME)) +&quot;, date=&quot; + cursor.getString(cursor.getColumnIndex(BIRTH_DAY)) +&quot;, gender=&quot; + cursor.getString(cursor.getColumnIndex(GENDER))); index++; } startManagingCursor(cursor); //查找后关闭游标 } }","link":"/2014/07/06/android/api_guide/app_component/content_provider/2014-07-06-ContentProvider-Usage/"},{"title":"Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例","text":"前面，我们已经学习了ArrayList，并了解了fail-fast机制。这一章我们接着学习List的实现类——LinkedList。和学习ArrayList一样，接下来呢，我们先对LinkedList有个整体认识，然后再学习它的源码；最后再通过实例来学会使用LinkedList。内容包括： 目录第1部分 LinkedList介绍第2部分 LinkedList数据结构第3部分 LinkedList源码解析(基于JDK1.6.0_45)第4部分 LinkedList遍历方式第5部分 LinkedList示例 第1部分 LinkedList介绍LinkedList简介LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList 实现 List 接口，能对它进行队列操作。LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。LinkedList 是非同步的。 LinkedList构造函数// 默认构造函数 LinkedList() // 创建一个LinkedList，保护Collection中的全部元素。 LinkedList(Collection&lt;? extends E&gt; collection)LinkedList的APILinkedList的API boolean add(E object) void add(int location, E object) boolean addAll(Collection&lt;? extends E&gt; collection) boolean addAll(int location, Collection&lt;? extends E&gt; collection) void addFirst(E object) void addLast(E object) void clear() Object clone() boolean contains(Object object) Iterator&lt;E&gt; descendingIterator() E element() E get(int location) E getFirst() E getLast() int indexOf(Object object) int lastIndexOf(Object object) ListIterator&lt;E&gt; listIterator(int location) boolean offer(E o) boolean offerFirst(E e) boolean offerLast(E e) E peek() E peekFirst() E peekLast() E poll() E pollFirst() E pollLast() E pop() void push(E e) E remove() E remove(int location) boolean remove(Object object) E removeFirst() boolean removeFirstOccurrence(Object o) E removeLast() boolean removeLastOccurrence(Object o) E set(int location, E object) int size() &lt;T&gt; T[] toArray(T[] contents) Object[] toArray()AbstractSequentialList简介在介绍LinkedList的源码之前，先介绍一下AbstractSequentialList。毕竟，LinkedList是AbstractSequentialList的子类。 AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。 此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。 第2部分 LinkedList数据结构LinkedList的继承关系 java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.AbstractSequentialList&lt;E&gt; ↳ java.util.LinkedList&lt;E&gt;LinkedList的声明 public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable {}LinkedList与Collection关系如下图： LinkedList的本质是双向链表。(01) LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。(02) LinkedList包含两个重要的成员：header 和 size。 header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。size是双向链表中节点的个数。 第3部分 LinkedList源码解析(基于JDK1.6.0_45)为了更了解LinkedList的原理，下面对LinkedList源码代码作出分析。 在阅读源码之前，我们先对LinkedList的整体实现进行大致说明：(01) LinkedList实际上是通过双向链表去实现的。既然是双向链表，那么它的顺序访问会非常高效，而随机访问效率比较低。(02) 既然LinkedList是通过双向链表的，但是它也实现了List接口{也就是说，它实现了get(int location)、remove(int location)等“根据索引值来获取、删除节点的函数”}。LinkedList是如何实现List的这些接口的，如何将“双向链表和索引值联系起来的”？(03) 实际原理非常简单，它就是通过一个计数索引值来实现的。例如，当我们调用get(int location)时，首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到location位置；否则，从链表末尾开始先前查找，直到location位置。这就是“双线链表和索引值联系起来”的方法。 好了，接下来开始阅读源码(只要理解双向链表，那么LinkedList的源码很容易理解的)。 package java.util; public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable { // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() { header.next = header.previous = header; } // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c); } // 获取LinkedList的第一个元素 public E getFirst() { if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; } // 获取LinkedList的最后一个元素 public E getLast() { if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; } // 删除LinkedList的第一个元素 public E removeFirst() { return remove(header.next); } // 删除LinkedList的最后一个元素 public E removeLast() { return remove(header.previous); } // 将元素添加到LinkedList的起始位置 public void addFirst(E e) { addBefore(e, header.next); } // 将元素添加到LinkedList的结束位置 public void addLast(E e) { addBefore(e, header); } // 判断LinkedList是否包含元素(o) public boolean contains(Object o) { return indexOf(o) != -1; } // 返回LinkedList的大小 public int size() { return size; } // 将元素(E)添加到LinkedList中 public boolean add(E e) { // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; } // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) { if (o==null) { // 若o为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) { if (e.element==null) { remove(e); return true; } } } else { // 若o不为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) { if (o.equals(e.element)) { remove(e); return true; } } } return false; } // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E&gt; c) { return addAll(size, c); } // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) { if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E&gt; successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E&gt; predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) { Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; } successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; } // 清空双向链表 public void clear() { Entry&lt;E&gt; e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) { Entry&lt;E&gt; next = e.next; e.next = e.previous = null; e.element = null; e = next; } header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; } // 返回LinkedList指定位置的元素 public E get(int index) { return entry(index).element; } // 设置index位置对应的节点的值为element public E set(int index, E element) { Entry&lt;E&gt; e = entry(index); E oldVal = e.element; e.element = element; return oldVal; } // 在index前添加节点，且节点的值为element public void add(int index, E element) { addBefore(element, (index==size ? header : entry(index))); } // 删除index位置的节点 public E remove(int index) { return remove(entry(index)); } // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) { if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) { for (int i = 0; i &lt;= index; i++) e = e.next; } else { for (int i = size; i &gt; index; i--) e = e.previous; } return e; } // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) { int index = 0; if (o==null) { for (Entry e = header.next; e != header; e = e.next) { if (e.element==null) return index; index++; } } else { for (Entry e = header.next; e != header; e = e.next) { if (o.equals(e.element)) return index; index++; } } return -1; } // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) { int index = size; if (o==null) { for (Entry e = header.previous; e != header; e = e.previous) { index--; if (e.element==null) return index; } } else { for (Entry e = header.previous; e != header; e = e.previous) { index--; if (o.equals(e.element)) return index; } } return -1; } // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() { if (size==0) return null; return getFirst(); } // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() { return getFirst(); } // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() { if (size==0) return null; return removeFirst(); } // 将e添加双向链表末尾 public boolean offer(E e) { return add(e); } // 将e添加双向链表开头 public boolean offerFirst(E e) { addFirst(e); return true; } // 将e添加双向链表末尾 public boolean offerLast(E e) { addLast(e); return true; } // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() { if (size==0) return null; return getFirst(); } // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() { if (size==0) return null; return getLast(); } // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() { if (size==0) return null; return removeFirst(); } // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() { if (size==0) return null; return removeLast(); } // 将e插入到双向链表开头 public void push(E e) { addFirst(e); } // 删除并返回第一个节点 public E pop() { return removeFirst(); } // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) { return remove(o); } // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) { if (o==null) { for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) { if (e.element==null) { remove(e); return true; } } } else { for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) { if (o.equals(e.element)) { remove(e); return true; } } } return false; } // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E&gt; listIterator(int index) { return new ListItr(index); } // List迭代器 private class ListItr implements ListIterator&lt;E&gt; { // 上一次返回的节点 private Entry&lt;E&gt; lastReturned = header; // 下一个节点 private Entry&lt;E&gt; next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) { // index的有效性处理 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size &gt;&gt; 1)) { next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; } else { next = header; for (nextIndex=size; nextIndex&gt;index; nextIndex--) next = next.previous; } } // 是否存在下一个元素 public boolean hasNext() { // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; } // 获取下一个元素 public E next() { checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; } // 是否存在上一个元素 public boolean hasPrevious() { // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; } // 获取上一个元素 public E previous() { if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; } // 获取下一个元素的索引 public int nextIndex() { return nextIndex; } // 获取上一个元素的索引 public int previousIndex() { return nextIndex-1; } // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() { checkForComodification(); Entry&lt;E&gt; lastNext = lastReturned.next; try { LinkedList.this.remove(lastReturned); } catch (NoSuchElementException e) { throw new IllegalStateException(); } if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; } // 设置当前节点为e public void set(E e) { if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; } // 将e添加到当前节点的前面 public void add(E e) { checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; } // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; { // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) { this.element = element; this.next = next; this.previous = previous; } } // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) { // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; } // 将节点从链表中删除 private E remove(Entry&lt;E&gt; e) { if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; } // 反向迭代器 public Iterator&lt;E&gt; descendingIterator() { return new DescendingIterator(); } // 反向迭代器实现类。 private class DescendingIterator implements Iterator { final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() { return itr.hasPrevious(); } // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() { return itr.previous(); } // 删除当前节点 public void remove() { itr.remove(); } } // 返回LinkedList的Object[]数组 public Object[] toArray() { // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; return result; } // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) { // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length &gt; size) a[size] = null; return a; } // 克隆函数。返回LinkedList的克隆对象。 public Object clone() { LinkedList&lt;E&gt; clone = null; // 克隆一个LinkedList克隆对象 try { clone = (LinkedList&lt;E&gt;) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(); } // 新建LinkedList表头节点 clone.header = new Entry&lt;E&gt;(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) clone.add(e.element); return clone; } // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); } // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E&gt;(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); } }总结：(01) LinkedList 实际上是通过双向链表去实现的。 它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。(02) 从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。(03) LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。(04) LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。(05) 由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。 总结起来如下表格： 第一个元素（头部） 最后一个元素（尾部） 抛出异常 特殊值 抛出异常 特殊值 插入 addFirst(e) offerFirst(e) addLast(e) offerLast(e) 移除 removeFirst() pollFirst() removeLast() pollLast() 检查 getFirst() peekFirst() getLast() peekLast() (06) LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价： 队列方法 等效方法 add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() (07) LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价： 栈方法 等效方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() 第4部分 LinkedList遍历方式LinkedList遍历方式LinkedList支持多种遍历方式。建议不要采用随机访问的方式去遍历LinkedList，而采用逐个遍历的方式。 (01) 第一种，通过迭代器遍历。即通过Iterator去遍历 for(Iterator iter = list.iterator(); iter.hasNext();) iter.next();(02) 通过快速随机访问遍历LinkedList int size = list.size(); for (int i=0; i&lt;size; i++) { list.get(i); }(03) 通过另外一种for循环来遍历LinkedList for (Integer integ:list) ;(04) 通过pollFirst()来遍历LinkedList while(list.pollFirst() != null) ;(05) 通过pollLast()来遍历LinkedList while(list.pollLast() != null) ;(06) 通过removeFirst()来遍历LinkedList try { while(list.removeFirst() != null) ; } catch (NoSuchElementException e) { }(07) 通过removeLast()来遍历LinkedList try { while(list.removeLast() != null) ; } catch (NoSuchElementException e) { }测试这些遍历方式效率的代码如下： import java.util.List; import java.util.Iterator; import java.util.LinkedList; import java.util.NoSuchElementException; /* * @desc 测试LinkedList的几种遍历方式和效率 * * @author skywang */ public class LinkedListThruTest { public static void main(String[] args) { // 通过Iterator遍历LinkedList iteratorLinkedListThruIterator(getLinkedList()) ; // 通过快速随机访问遍历LinkedList iteratorLinkedListThruForeach(getLinkedList()) ; // 通过for循环的变种来访问遍历LinkedList iteratorThroughFor2(getLinkedList()) ; // 通过PollFirst()遍历LinkedList iteratorThroughPollFirst(getLinkedList()) ; // 通过PollLast()遍历LinkedList iteratorThroughPollLast(getLinkedList()) ; // 通过removeFirst()遍历LinkedList iteratorThroughRemoveFirst(getLinkedList()) ; // 通过removeLast()遍历LinkedList iteratorThroughRemoveLast(getLinkedList()) ; } private static LinkedList getLinkedList() { LinkedList llist = new LinkedList(); for (int i=0; i&lt;100000; i++) llist.addLast(i); return llist; } /** * 通过快迭代器遍历LinkedList */ private static void iteratorLinkedListThruIterator(LinkedList&lt;Integer&gt; list) { if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext();) iter.next(); // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(&quot;iteratorLinkedListThruIterator：&quot; + interval+&quot; ms&quot;); } /** * 通过快速随机访问遍历LinkedList */ private static void iteratorLinkedListThruForeach(LinkedList&lt;Integer&gt; list) { if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); int size = list.size(); for (int i=0; i&lt;size; i++) { list.get(i); } // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(&quot;iteratorLinkedListThruForeach：&quot; + interval+&quot; ms&quot;); } /** * 通过另外一种for循环来遍历LinkedList */ private static void iteratorThroughFor2(LinkedList&lt;Integer&gt; list) { if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); for (Integer integ:list) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;); } /** * 通过pollFirst()来遍历LinkedList */ private static void iteratorThroughPollFirst(LinkedList&lt;Integer&gt; list) { if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); while(list.pollFirst() != null) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(&quot;iteratorThroughPollFirst：&quot; + interval+&quot; ms&quot;); } /** * 通过pollLast()来遍历LinkedList */ private static void iteratorThroughPollLast(LinkedList&lt;Integer&gt; list) { if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); while(list.pollLast() != null) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(&quot;iteratorThroughPollLast：&quot; + interval+&quot; ms&quot;); } /** * 通过removeFirst()来遍历LinkedList */ private static void iteratorThroughRemoveFirst(LinkedList&lt;Integer&gt; list) { if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); try { while(list.removeFirst() != null) ; } catch (NoSuchElementException e) { } // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(&quot;iteratorThroughRemoveFirst：&quot; + interval+&quot; ms&quot;); } /** * 通过removeLast()来遍历LinkedList */ private static void iteratorThroughRemoveLast(LinkedList&lt;Integer&gt; list) { if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); try { while(list.removeLast() != null) ; } catch (NoSuchElementException e) { } // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(&quot;iteratorThroughRemoveLast：&quot; + interval+&quot; ms&quot;); } }执行结果： iteratorLinkedListThruIterator：8 ms iteratorLinkedListThruForeach：3724 ms iteratorThroughFor2：5 ms iteratorThroughPollFirst：8 ms iteratorThroughPollLast：6 ms iteratorThroughRemoveFirst：2 ms iteratorThroughRemoveLast：2 ms由此可见，遍历LinkedList时，使用removeFist()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取，而不删除，应该使用第3种遍历方式。无论如何，千万不要通过随机访问去遍历LinkedList！ 第5部分 LinkedList示例下面通过一个示例来学习如何使用LinkedList的常用API import java.util.List; import java.util.Iterator; import java.util.LinkedList; import java.util.NoSuchElementException; /* * @desc LinkedList测试程序。 * * @author skywang * @email kuiwu-wang@163.com */ public class LinkedListTest { public static void main(String[] args) { // 测试LinkedList的API testLinkedListAPIs() ; // 将LinkedList当作 LIFO(后进先出)的堆栈 useLinkedListAsLIFO(); // 将LinkedList当作 FIFO(先进先出)的队列 useLinkedListAsFIFO(); } /* * 测试LinkedList中部分API */ private static void testLinkedListAPIs() { String val = null; //LinkedList llist; //llist.offer(&quot;10&quot;); // 新建一个LinkedList LinkedList llist = new LinkedList(); //---- 添加操作 ---- // 依次添加1,2,3 llist.add(&quot;1&quot;); llist.add(&quot;2&quot;); llist.add(&quot;3&quot;); // 将“4”添加到第一个位置 llist.add(1, &quot;4&quot;); System.out.println(&quot;\\nTest \\&quot;addFirst(), removeFirst(), getFirst()\\&quot;&quot;); // (01) 将“10”添加到第一个位置。 失败的话，抛出异常！ llist.addFirst(&quot;10&quot;); System.out.println(&quot;llist:&quot;+llist); // (02) 将第一个元素删除。 失败的话，抛出异常！ System.out.println(&quot;llist.removeFirst():&quot;+llist.removeFirst()); System.out.println(&quot;llist:&quot;+llist); // (03) 获取第一个元素。 失败的话，抛出异常！ System.out.println(&quot;llist.getFirst():&quot;+llist.getFirst()); System.out.println(&quot;\\nTest \\&quot;offerFirst(), pollFirst(), peekFirst()\\&quot;&quot;); // (01) 将“10”添加到第一个位置。 返回true。 llist.offerFirst(&quot;10&quot;); System.out.println(&quot;llist:&quot;+llist); // (02) 将第一个元素删除。 失败的话，返回null。 System.out.println(&quot;llist.pollFirst():&quot;+llist.pollFirst()); System.out.println(&quot;llist:&quot;+llist); // (03) 获取第一个元素。 失败的话，返回null。 System.out.println(&quot;llist.peekFirst():&quot;+llist.peekFirst()); System.out.println(&quot;\\nTest \\&quot;addLast(), removeLast(), getLast()\\&quot;&quot;); // (01) 将“20”添加到最后一个位置。 失败的话，抛出异常！ llist.addLast(&quot;20&quot;); System.out.println(&quot;llist:&quot;+llist); // (02) 将最后一个元素删除。 失败的话，抛出异常！ System.out.println(&quot;llist.removeLast():&quot;+llist.removeLast()); System.out.println(&quot;llist:&quot;+llist); // (03) 获取最后一个元素。 失败的话，抛出异常！ System.out.println(&quot;llist.getLast():&quot;+llist.getLast()); System.out.println(&quot;\\nTest \\&quot;offerLast(), pollLast(), peekLast()\\&quot;&quot;); // (01) 将“20”添加到第一个位置。 返回true。 llist.offerLast(&quot;20&quot;); System.out.println(&quot;llist:&quot;+llist); // (02) 将第一个元素删除。 失败的话，返回null。 System.out.println(&quot;llist.pollLast():&quot;+llist.pollLast()); System.out.println(&quot;llist:&quot;+llist); // (03) 获取第一个元素。 失败的话，返回null。 System.out.println(&quot;llist.peekLast():&quot;+llist.peekLast()); // 将第3个元素设置300。不建议在LinkedList中使用此操作，因为效率低！ llist.set(2, &quot;300&quot;); // 获取第3个元素。不建议在LinkedList中使用此操作，因为效率低！ System.out.println(&quot;\\nget(3):&quot;+llist.get(2)); // ---- toArray(T[] a) ---- // 将LinkedList转行为数组 String[] arr = (String[])llist.toArray(new String[0]); for (String str:arr) System.out.println(&quot;str:&quot;+str); // 输出大小 System.out.println(&quot;size:&quot;+llist.size()); // 清空LinkedList llist.clear(); // 判断LinkedList是否为空 System.out.println(&quot;isEmpty():&quot;+llist.isEmpty()+&quot;\\n&quot;); } /** * 将LinkedList当作 LIFO(后进先出)的堆栈 */ private static void useLinkedListAsLIFO() { System.out.println(&quot;\\nuseLinkedListAsLIFO&quot;); // 新建一个LinkedList LinkedList stack = new LinkedList(); // 将1,2,3,4添加到堆栈中 stack.push(&quot;1&quot;); stack.push(&quot;2&quot;); stack.push(&quot;3&quot;); stack.push(&quot;4&quot;); // 打印“栈” System.out.println(&quot;stack:&quot;+stack); // 删除“栈顶元素” System.out.println(&quot;stack.pop():&quot;+stack.pop()); // 取出“栈顶元素” System.out.println(&quot;stack.peek():&quot;+stack.peek()); // 打印“栈” System.out.println(&quot;stack:&quot;+stack); } /** * 将LinkedList当作 FIFO(先进先出)的队列 */ private static void useLinkedListAsFIFO() { System.out.println(&quot;\\nuseLinkedListAsFIFO&quot;); // 新建一个LinkedList LinkedList queue = new LinkedList(); // 将10,20,30,40添加到队列。每次都是插入到末尾 queue.add(&quot;10&quot;); queue.add(&quot;20&quot;); queue.add(&quot;30&quot;); queue.add(&quot;40&quot;); // 打印“队列” System.out.println(&quot;queue:&quot;+queue); // 删除(队列的第一个元素) System.out.println(&quot;queue.remove():&quot;+queue.remove()); // 读取(队列的第一个元素) System.out.println(&quot;queue.element():&quot;+queue.element()); // 打印“队列” System.out.println(&quot;queue:&quot;+queue); } }运行结果： Test &quot;addFirst(), removeFirst(), getFirst()&quot; llist:[10, 1, 4, 2, 3] llist.removeFirst():10 llist:[1, 4, 2, 3] llist.getFirst():1 Test &quot;offerFirst(), pollFirst(), peekFirst()&quot; llist:[10, 1, 4, 2, 3] llist.pollFirst():10 llist:[1, 4, 2, 3] llist.peekFirst():1 Test &quot;addLast(), removeLast(), getLast()&quot; llist:[1, 4, 2, 3, 20] llist.removeLast():20 llist:[1, 4, 2, 3] llist.getLast():3 Test &quot;offerLast(), pollLast(), peekLast()&quot; llist:[1, 4, 2, 3, 20] llist.pollLast():20 llist:[1, 4, 2, 3] llist.peekLast():3 get(3):300 str:1 str:4 str:300 str:3 size:4 isEmpty():true useLinkedListAsLIFO stack:[4, 3, 2, 1] stack.pop():4 stack.peek():3 stack:[3, 2, 1] useLinkedListAsFIFO queue:[10, 20, 30, 40] queue.remove():10 queue.element():20 queue:[20, 30, 40]更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/05/java/collection/2012-02-05-collection-05-linkedlist/"},{"title":"Android Binder机制(六) addService详解02之 请求的处理","text":"前面一文介绍了addService的请求发送部分，Binder驱动在处理addService请求时，将一个待处理事务添加到ServiceManager中，然后将ServiceManager唤醒。在Android Binder机制(三) ServiceManager守护进程的末尾，我们说过ServiceManager启动之后，由于没有事务可处理，就进入了等待状态。这里，从ServiceManager被唤醒后开始讲解。 目录1. Android消息机制的架构 注意：本文是基于Android 4.4.2版本进行介绍的！ 1. Binder驱动中binder_thread_read()的源码下面，就接着Android Binder机制(三) ServiceManager守护进程中的休眠部分进行讲解，看看Service Manager被唤醒后，会干些什么。 static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) { ... if (wait_for_proc_work) { ... if (non_block) { ... } else // 阻塞式的读取，则阻塞等待事务的发生。 ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); } else { ... } ... while (1) { struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... else { ... } ... switch (w-&gt;type) { case BINDER_WORK_TRANSACTION: { t = container_of(w, struct binder_transaction, work); } break; ... } if (!t) continue; // t-&gt;buffer-&gt;target_node是目标节点。 // 这里，addService请求的目标是ServiceManager，因此target_node是ServiceManager对应的节点； // 它的值在事务交互时(binder_transaction中)，被赋值为ServiceManager对应的Binder实体。 if (t-&gt;buffer-&gt;target_node) { // 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体) struct binder_node *target_node = t-&gt;buffer-&gt;target_node; // Binder实体在用户空间的地址(ServiceManager的ptr为NULL) tr.target.ptr = target_node-&gt;ptr; // Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL) tr.cookie = target_node-&gt;cookie; t-&gt;saved_priority = task_nice(current); if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) binder_set_nice(t-&gt;priority); else if (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority) binder_set_nice(target_node-&gt;min_priority); cmd = BR_TRANSACTION; } else { tr.target.ptr = NULL; tr.cookie = NULL; cmd = BR_REPLY; } // 交易码 tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) { struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); } else { tr.sender_pid = 0; } // 数据大小 tr.data_size = t-&gt;buffer-&gt;data_size; // 数据中对象的偏移数组的大小(即对象的个数) tr.offsets_size = t-&gt;buffer-&gt;offsets_size; // 数据 tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; // 数据中对象的偏移数组 tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); // 将cmd指令写入到ptr，即传递到用户空间 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; // 将tr数据拷贝到用户空间 ptr += sizeof(uint32_t); if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); ... // 删除已处理的事务 list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; // 设置回复信息 if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) { // 该事务会发送给Service Manager守护进程进行处理。 // Service Manager处理之后，还需要给Binder驱动回复处理结果。 // 这里设置Binder驱动回复信息。 t-&gt;to_parent = thread-&gt;transaction_stack; // to_thread表示Service Manager反馈后，将反馈结果交给当前thread进行处理 t-&gt;to_thread = thread; // transaction_stack交易栈保存当前事务。用于之处反馈是针对哪个事务的。 thread-&gt;transaction_stack = t; } else { ... } break; } done: // 更新bwr.read_consumed的值 *consumed = ptr - buffer; ... return 0; }说明：ServiceManager进程在调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))进入等待之后，被MediaPlayerService进程唤醒。唤醒之后，binder_has_thread_work()为true，因为ServiceManager的待处理事务队列中有个待处理事务(即，MediaPlayerService添加服务的请求)。(01) 进入while循环后，首先取出待处理事务。(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。下面列举比较重要的几个部分进行说明。 // 数据大小 tr.data_size = t-&gt;buffer-&gt;data_size; // 数据中对象的偏移数组的大小(即对象的个数) tr.offsets_size = t-&gt;buffer-&gt;offsets_size; // 数据 tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; // 数据中对象的偏移数组 tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *));这里着重强调一下地址的赋值方式，因为它涉及到Binder机制的数据拷贝原理！t-&gt;buffer是在binder_transaction()中，通过binder_alloc_buf()分配的内核空间地址。现在要将数据返回给Service Manager守护进程，需要将内核空间的数据拷贝到用户空间。如果你还记得的话，前面在Android Binder机制(三) ServiceManager守护进程的mmap()中，我们将内核虚拟地址和进程虚拟地址映射到同一个物理存储区；现在，已知内核虚拟地址(即t-&gt;buffer-&gt;data)。那么，只需要将t-&gt;buffer-&gt;data加上proc-&gt;user_buffer_offset(内核虚拟地址和进程虚拟地址的偏移)即可得到在用户空间的地址。 在tr赋值完毕之后，就将完整数据拷贝到用户空间。此时，该事务已经在Binder驱动中被处理，于是将事务从Service Manager的待处理事务队列中删除。Binder驱动随后会将该事务发送给Service Manager守护进程，Service Manager守护进程在处理完事务之后，需要反馈结果给Binder驱动。因此，接下来会设置t-&gt;to_thread和t-&gt;transaction_stack等成员。最后，修改*consumed的值，即bwr.read_consumed的值，表示待读取内容的大小。执行完binder_thread_read()之后，回到binder_ioctl()中，执行copy_to_user()将数据拷贝到用户空间。接下来，就回到了Service Manager的守护进程当中，即回到binder_loop()中。 2. binder_loop()void binder_loop(struct binder_state *bs, binder_handler func) { struct binder_write_read bwr; unsigned readbuf[32]; ... for (;;) { bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (unsigned) readbuf; bwr.read_buffer = (unsigned) readbuf; // 向Kernel中发送消息(先写后读)。 // 先将消息传递给Kernel，然后再从Kernel读取消息反馈 res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); ... // 解析读取的消息反馈 res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func); ... } }说明：binder_loop()会将ioctl()反馈的数据发送给binder_parse()进行解析。 3. binder_parse()int binder_parse(struct binder_state *bs, struct binder_io *bio, uint32_t *ptr, uint32_t size, binder_handler func) { int r = 1; uint32_t *end = ptr + (size / 4); while (ptr &lt; end) { uint32_t cmd = *ptr++; switch(cmd) { case BR_NOOP: break; ... case BR_TRANSACTION: { struct binder_txn *txn = (void *) ptr; ... if (func) { unsigned rdata[256/4]; struct binder_io msg; // 用于保存&quot;Binder驱动反馈的信息&quot; struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot; int res; // 初始化reply bio_init(&amp;reply, rdata, sizeof(rdata), 4); // 根据txt(Binder驱动反馈的信息)初始化msg bio_init_from_txn(&amp;msg, txn); // 消息处理 res = func(bs, txn, &amp;msg, &amp;reply); // 反馈消息给Binder驱动。 binder_send_reply(bs, &amp;reply, txn-&gt;data, res); } ptr += sizeof(*txn) / sizeof(uint32_t); break; } ... } } return r; }说明：此处里的cmd就是bwr.read_buffer指针。而在Binder驱动的binder_thread_read()中，反馈的第一个指令是BR_NOOP；因此这里的cmd=BR_NOOP，不执行任何动作，继续取出下一个指令cmd=BR_TRANSACTION。在BR_TRANSACTION中，会先取出消息，在对消息处理之后，再将反馈信息发送给Binder驱动。下面是BR_TRANSACTION的详细内容。(01) 首先，将ptr转换成struct binder_txn结构体指针。struct binder_txn是与binder_transaction_datad对应的结构体，在Android Binder机制(二) Binder中的数据结构中有它的详细介绍。(02) 此处的func是函数指针svcmgr_handler，不为空；因此，先调用bio_init()初始化reply，再调用bio_init_from_txn()来初始化msg。(03) 初始化完毕之后，就调用svcmgr_handler()对消息进行处理。(04) 消息处理完毕，就通过binder_send_reply()将处理结果反馈给Binder驱动。 4. bio_init()void bio_init(struct binder_io *bio, void *data, uint32_t maxdata, uint32_t maxoffs) { uint32_t n = maxoffs * sizeof(uint32_t); if (n &gt; maxdata) { bio-&gt;flags = BIO_F_OVERFLOW; bio-&gt;data_avail = 0; bio-&gt;offs_avail = 0; return; } bio-&gt;data = bio-&gt;data0 = (char *) data + n; bio-&gt;offs = bio-&gt;offs0 = data; bio-&gt;data_avail = maxdata - n; bio-&gt;offs_avail = maxoffs; bio-&gt;flags = 0; }说明：bio_init()就是对struct binder_io的各个成员赋值。 5. bio_init_from_txn()void bio_init_from_txn(struct binder_io *bio, struct binder_txn *txn) { bio-&gt;data = bio-&gt;data0 = txn-&gt;data; // 数据起始地址 bio-&gt;offs = bio-&gt;offs0 = txn-&gt;offs; // 数据中对象的偏移数组的起始地址 bio-&gt;data_avail = txn-&gt;data_size; // 数据大小 bio-&gt;offs_avail = txn-&gt;offs_size / 4; // 对象个数 bio-&gt;flags = BIO_F_SHARED; }说明：bio_init_from_txn()就是根据已有的数据txn初始化struct binder_io的各个成员。 6. svcmgr_handler()int svcmgr_handler(struct binder_state *bs, struct binder_txn *txn, struct binder_io *msg, struct binder_io *reply) { struct svcinfo *si; uint16_t *s; unsigned len; void *ptr; uint32_t strict_policy; int allow_isolated; if (txn-&gt;target != svcmgr_handle) return -1; ... // 数据有效性检测(数据头) strict_policy = bio_get_uint32(msg); s = bio_get_string16(msg, &amp;len); if ((len != (sizeof(svcmgr_id) / 2)) || memcmp(svcmgr_id, s, sizeof(svcmgr_id))) { ... } switch(txn-&gt;code) { case SVC_MGR_GET_SERVICE: case SVC_MGR_CHECK_SERVICE: ... case SVC_MGR_ADD_SERVICE: s = bio_get_string16(msg, &amp;len); ptr = bio_get_ref(msg); allow_isolated = bio_get_uint32(msg) ? 1 : 0; if (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated)) return -1; break; case SVC_MGR_LIST_SERVICES: ... } bio_put_uint32(reply, 0); return 0; }说明：(01) txt-&gt;target对应tr.target.ptr，而tr.target.ptr是Binder驱动的在binder_thread_read()中赋值的，它指向Service Manager的Binder实体在用户空间的句柄，是NULL。而svcmgr_handle=BINDER_SERVICE_MANAGER=((void*) 0)。显然，txt-&gt;target=svcmgr_handler。(02) 接下来，先通过bio_get_uint32(msg)和bio_get_string16(msg, &amp;len)进行有效性检测。通过bio_get_uint32()从msg中取出32位的整型数，就是MediaPlayerService请求数据中的STRICT_MODE_PENALTY_GATHER。然后，通过bio_get_string16(msg, &amp;len)获取数据中字符串，也就是”android.os.IServiceManager”。接着，将该字符串和svcmgr_id进行比较(依次比较长度和内容)；很显然，这里是相当的。(03) 在通过有效性检测之后，就根据相应的事务编码进行处理。这里txt-&gt;code的值是SVC_MGR_ADD_SERVICE。先通过bio_get_string16()获取MediaPlayerService的名称，也就是s=”media.player”，然后就通过bio_get_ref()获取MediaPlayerService对象的引用。 7. svcmgr_handler()void *bio_get_ref(struct binder_io *bio) { struct binder_object *obj; obj = _bio_get_obj(bio); if (!obj) return 0; if (obj-&gt;type == BINDER_TYPE_HANDLE) return obj-&gt;pointer; return 0; } 说明：binder_object是与flat_binder_object对应的结构体，关于它的详细介绍可以参考Android Binder机制(二) Binder中的数据结构。(01) _bio_get_obj(bio)的代码就不展开了，它是根据bio创建binder_object对象。实际上，obj就是MediaPlayerService打包成的flat_binder_object对象。(02) obj-&gt;type的值是BINDER_TYPE_HANDLE。原来MediaPlayerService对应的type是BINDER_TYPE_BINDER，但在Binder驱动的binder_transaction()中，将type修改成了BINDER_TYPE_HANDLE。因此，返回obj-&gt;pointer，而obj-&gt;pointer实际上是flat_binder_object中的handle，而该handle在Binder驱动中被赋值为”MediaPlayerService对应的Binder引用的描述，即binder_ref-&gt;desc”。根据该引用描述，可以在Binder驱动中找到MediaPlayerService对应的Binder实体以及MediaPlayerService对应的进程上下文信息，进而可以给MediaPlayerService发送消息。 8. svcmgr_handler()接下来，回到svcmgr_handler()中，继续执行do_add_service()。 int do_add_service(struct binder_state *bs, uint16_t *s, unsigned len, void *ptr, unsigned uid, int allow_isolated) { struct svcinfo *si; ... if (!svc_can_register(uid, s)) { ... } si = find_svc(s, len); if (si) { ... } else { si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t)); if (!si) { ... } si-&gt;ptr = ptr; si-&gt;len = len; memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t)); si-&gt;name[len] = &apos;\\0&apos;; si-&gt;death.func = svcinfo_death; si-&gt;death.ptr = si; si-&gt;allow_isolated = allow_isolated; si-&gt;next = svclist; svclist = si; } binder_acquire(bs, ptr); binder_link_to_death(bs, ptr, &amp;si-&gt;death); return 0; }说明：do_add_service()是将该MediaPlayerService(01) 先看看参数。bs是struct binder_state类型，它在保存了打开”/dev/binder”文件的相关信息。s是IBinder对象的名称，即”media.player”。len是s的长度。ptr是MediaPlayerService在Binder驱动中的引用描述。uid是MediaPlayerService的uid。allow_isolated是flase。(02) svc_can_register()是检测能否将uid线程的信息注册到Service Manager中。这里，返回true。(03) find_svc(s, len)是在Service Manager的服务队列svclist中，查找是否有名称为s的服务。由于之前没有将MediaPlayerService注册到Service Manager中，这里返回的si=null；接下来，就将MediaPlayerService的信息保存到si中，然后再将si注册到svclist中。这样，MediaPlayerService就注册到Service Manager中了。 9. svcmgr_handler()接下来，回到svcmgr_handler()中，调用bio_put_uint32(reply, 0)。这里就不对bio_put_uint32()的代码进行展开了，bio_put_uint32(reply, val)的作用是将val写入到reply中。但是，当val=0时，不会写入任何数据；也就是说bio_put_uint32(reply, 0)不会写入任何数据到reply中！ int svcmgr_handler(struct binder_state *bs, struct binder_txn *txn, struct binder_io *msg, struct binder_io *reply) { ... switch(txn-&gt;code) { case SVC_MGR_ADD_SERVICE: s = bio_get_string16(msg, &amp;len); ptr = bio_get_ref(msg); allow_isolated = bio_get_uint32(msg) ? 1 : 0; if (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated)) return -1; break; ... } bio_put_uint32(reply, 0); return 0; }接着，回到binder_parse()中，调用binder_send_reply()写入到即将发送Binder的缓冲区中。 10. svcmgr_handler()void binder_send_reply(struct binder_state *bs, struct binder_io *reply, void *buffer_to_free, int status) { struct { uint32_t cmd_free; void *buffer; uint32_t cmd_reply; struct binder_txn txn; } __attribute__((packed)) data; data.cmd_free = BC_FREE_BUFFER; data.buffer = buffer_to_free; data.cmd_reply = BC_REPLY; data.txn.target = 0; data.txn.cookie = 0; data.txn.code = 0; if (status) { ... } else { data.txn.flags = 0; data.txn.data_size = reply-&gt;data - reply-&gt;data0; data.txn.offs_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0); data.txn.data = reply-&gt;data0; data.txn.offs = reply-&gt;offs0; } binder_write(bs, &amp;data, sizeof(data)); } 说明：(01) 先看看参数。bs是struct binder_state，它保存了打开”/dev/binder”文件的相关信息。reply没有任何数据。buffer_to_free是对应binder_transaction_data中保存请求数据的buffer缓冲区，它是在Binder驱动的binder_transaction()中分配的。status_t=0。(02) 该函数中的私有结构体struct是用来描述返回给Binder驱动的数据。我们知道，Binder机制的交互数据的格式是”指令+数据”。这里，返回的指令有两个BC_FREE_BUFFER和BC_REPLY，BC_FREE_BUFFER是告诉Binder驱动，请求处理完毕，让Binder驱动释放数据缓冲；而BC_REPLY是告诉Binder驱动，这是回复，回复的内容是data.txt.data，实际上，这里的回复内容是空！(03) 最后，调用binder_write()将数据打包。 11. binder_write()的源码int binder_write(struct binder_state *bs, void *data, unsigned len) { struct binder_write_read bwr; int res; bwr.write_size = len; // 数据长度 bwr.write_consumed = 0; bwr.write_buffer = (unsigned) data; // 数据是BINDER_WRITE_READ bwr.read_size = 0; bwr.read_consumed = 0; bwr.read_buffer = 0; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); if (res &lt; 0) { fprintf(stderr,&quot;binder_write: ioctl failed (%s)\\n&quot;, strerror(errno)); } return res; }说明：binder_write()单单只是向Binder驱动发送一个消息，而不会去读取消息反馈。 12. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码下面我们看看Binder驱动部分的对应代码。 static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { ... switch (cmd) { case BINDER_WRITE_READ: { struct binder_write_read bwr; ... // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot; if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) { ... } // 如果write_size&gt;0，则进行写操作 if (bwr.write_size &gt; 0) { ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... } // 如果read_size&gt;0，则进行读操作 if (bwr.read_size &gt; 0) { ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... } ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) { ret = -EFAULT; goto err; } break; } ... } ret = 0; ... return ret; }说明：bwr.write_size&gt;0，而bwr.read_size=0；因此，只会执行写动作，而不会进行读取动作。下面看看binder_thread_write()到底写了些什么。 13. Binder驱动中binder_thread_write()的源码int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed) { uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) { if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) { case BC_FREE_BUFFER: { void __user *data_ptr; struct binder_buffer *buffer; // 获取要释放的内存地址 if (get_user(data_ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 根据用户空间地址，得到进程空间地址； // 再根据进程空间地址，在proc-&gt;allocated_buffers红黑树中进行查找该地址对应的binder_buffer对象。 buffer = binder_buffer_lookup(proc, data_ptr); ... // 释放内存 trace_binder_transaction_buffer_release(buffer); binder_transaction_buffer_release(proc, buffer, NULL); binder_free_buf(proc, buffer); break; } case BC_TRANSACTION: case BC_REPLY: { struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; } ... } // 更新bwr.write_consumed的值 *consumed = ptr - buffer; } return 0; }说明：在Service Manager中，反馈给Binder驱动的指令有两个，分别是BC_FREE_BUFFER和BC_REPLY。(01) binder_write_read()先读出BC_FREE_BUFFER指令，然后释放内存。代码中给出了相应的注释，这里就不再详细说明了。(02) 接着，读出BC_REPLY指令，将数据拷贝到内核空间之后，便执行binder_transaction()对数据进行处理。 14. Binder驱动中binder_transaction()的源码static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply) { struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) { // 事务栈 in_reply_to = thread-&gt;transaction_stack; ... // 设置优先级 binder_set_nice(in_reply_to-&gt;saved_priority); ... thread-&gt;transaction_stack = in_reply_to-&gt;to_parent; // 发起请求的线程，即MediaPlayerService所在线程。 // from的值，是MediaPlayerService发起请求时在binder_transaction()中赋值的。 target_thread = in_reply_to-&gt;from; ... // MediaPlayerService对应的进程 target_proc = target_thread-&gt;proc; } else { ... } if (target_thread) { e-&gt;to_thread = target_thread-&gt;pid; target_list = &amp;target_thread-&gt;todo; target_wait = &amp;target_thread-&gt;wait; } else { ... } e-&gt;to_proc = target_proc-&gt;pid; // 分配一个待处理的事务t，t是binder事务(binder_transaction对象) t = kzalloc(sizeof(*t), GFP_KERNEL); if (t == NULL) { return_error = BR_FAILED_REPLY; goto err_alloc_t_failed; } // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。 tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); if (tcomplete == NULL) { return_error = BR_FAILED_REPLY; goto err_alloc_tcomplete_failed; } binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE); t-&gt;debug_id = ++binder_last_id; e-&gt;debug_id = t-&gt;debug_id; if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 下面的一些赋值是初始化事务t t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; // 事务将交给target_proc进程进行处理 t-&gt;to_proc = target_proc; // 事务将交给target_thread线程进行处理 t-&gt;to_thread = target_thread; // 事务编码 t-&gt;code = tr-&gt;code; // 事务标志 t-&gt;flags = tr-&gt;flags; // 事务优先级 t-&gt;priority = task_nice(current); // 分配空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); if (t-&gt;buffer == NULL) { return_error = BR_FAILED_REPLY; goto err_binder_alloc_buf_failed; } t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; // 保存事务 t-&gt;buffer-&gt;transaction = t; // target_node为NULL t-&gt;buffer-&gt;target_node = target_node; trace_binder_transaction_alloc_buf(t-&gt;buffer); if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 将&quot;用户传入的数据&quot;保存到事务中 if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) { ... } // 将&quot;用户传入的数据偏移地址&quot;保存到事务中 if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) { ... } ... off_end = (void *)offp + tr-&gt;offsets_size; for (; offp &lt; off_end; offp++) { ... } if (reply) { binder_pop_transaction(target_thread, in_reply_to); } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) { ... } else { ... } // 设置事务的类型为BINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // 将事务添加到target_list队列中，即target_list的待处理事务中 list_add_tail(&amp;t-&gt;work.entry, target_list); // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。 list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // 唤醒目标进程 if (target_wait) wake_up_interruptible(target_wait); return; ... }说明：(01) reply=1。这里只关注reply部分。target_thread被赋值为MediaPlayerService所在的线程，而target_proc则是MediaPlayerService对应的进程。(02) 接着，会新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。这部分前面已经介绍过了；这里就不再重复说明了。从Service Manager反馈的信息中，仅仅包含了数据0，而没有flat_binder_object对象；因此，off_end=offp，不会执行for循环。(03) 此时，MediaPlayerService已经成功的添加到了Server Manager守护进程中，接下来便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayerService线程的事务栈中删除该事务。(04) 之后，便是设置事务的类型为BINDER_WORK_TRANSACTION，然后将其添加到target_list队列中。即，将事务添加到MediaPlayerService的待处理事务队列中。(05) 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE，然后将其添加到thread-&gt;todo中。即，将其添加到当前线程(Service Manager守护进程的线程)的待处理事务队列中。(06) 最后，调用wake_up_interruptible()唤醒MediaPlayerService进程。 此时，Binder驱动就将addService的反馈内容以待处理事务t的方式添加到MediaPlayerService的待处理事务队列当中，并将MediaPlayerService进程唤醒了。而对于待完成工作tcomplete，肯定是告诉ServiceManager进程，它的反馈已经被Binder驱动收到。 下面，还是先说完ServiceManager的流程，然后再来看MediaPlayerService被唤醒后做了什么。 ServiceManager执行完binder_transaction()后，回到binder_thread_write()中；此时，数据已经处理完毕，便返回到binder_ioctl()中。binder_ioctl()将数据拷贝到用户空间后，Binder驱动的工作就结束了。于是，又回到ServiceManager守护进程中，binder_write()执行完ioctl()后，返回到binder_send_reply()中，binder_send_reply()则进一步返回到binder_parse()。binder_parse()已经解析完请求数据，于是进一步返回到binder_loop()中。而binder_loop()会再次开始循环，调用ioctl(,BINDER_WRITE_READ,)到Binder驱动执行读操作。当ServiceManager再次进入到Binder驱动，并通过binder_ioctl()调用到binder_thread_read()时。由于此时的ServiceManager线程中有一个类型为BINDER_WORK_TRANSACTION_COMPLETE的待处理事务；于是，便取出该事务进行执行。执行完毕之后，将该事务从Service Manager的待处理事务队列中删除，并反馈cmd=BR_TRANSACTION_COMPLETE信息给ServiceManager守护进程。ServiceManager守护进程收到Binder驱动的反馈后，解析出BR_TRANSACTION_COMPLETE，该指令什么也不做；它的目的是让ServiceManager知道，此次addService的反馈已经顺利完成！于是，ServiceManager继续它的循环；当它再次调用ioctl()，进而进入到Binder驱动中读取请求时；由于此时的待处理事务队列为空，因此，ServiceManager会再次进入中断等待状态，等待Client的请求。 至此，MediaPlayerService进程的addService的请求处理部分就讲解完了。在继续了解请求的反馈之前，先回顾一下本部分的内容。 MediaPlayerService将addService请求发送到Binder驱动，Binder驱动将addService转换成一个待处理事务并添加到ServiceManager的事务队列中，并将ServiceManager唤醒。ServiceManager被唤醒后，取出该处理；接着，Binder驱动将BR_TRANSACTION发送到ServiceManager守护进程中。ServiceManager通过BR_TRANSACTION解析出addService请求；在从请求数据中解析出MediaPlayerService的相关信息后，并将这些信息存储在一个链表中。接着，ServiceManager守护进程反馈BC_FREE_BUFFER和BC_REPLY给Binder驱动。Binder驱动收到BC_FREE_BUFFER后，释放保存事务数据的内存；在收到BC_REPLY之后，得知ServiceManager已经处理完addService请求。于是，将一个待处理事务添加到MediaPlayerService的事务队列中；然后将MediaPlayerService唤醒。目的是告诉MediaPlayerService，它已经处理完了addService请求。 最后，Binder驱动还需要反馈一个BR_TRANSACTION_COMPLETE给ServiceManager进程，目的是告诉ServiceManager，Binder驱动已经收到了它的回复。","link":"/2014/09/05/android/os/binder/2014-09-05-BinderCommunication-AddService02/"},{"title":"Android消息机制架构和源码解析","text":"本文会介绍Android的消息处理机制。 目录1. Android消息机制的架构2. Android消息机制的源码解析2.1. 消息循环2.2. 消息的发送2.3. 消息的处理 注意：本文是基于Android 4.4.2版本进行介绍的！ Android消息机制的架构 上面是消息机制的框架图。(01) Looper是消息循环类，它包括了mQueue成员变量；mQueue是消息队列MessageQueue的实例。Looper还包含了loop()方法，通过调用loop()就能进入到消息循环中。(02) MessageQueue是消息队列类，它包含了mMessages成员；mMessages是消息Message的实例。MessageQueue提供了next()方法来获取消息队列的下一则消息。(03) Message是消息类。Message包含了next，next是Message的实例；由此可见，Message是一个单链表。Message还包括了target成员，target是Handler实例。此外，它还包括了arg1,arg2,what,obj等参数，它们都是用于记录消息的相关内容。(04) Handler是消息句柄类。Handler提供了sendMessage()来向消息队列发送消息；发送消息的API有很多，它们的原理都是一样的，这里仅仅只列举了sendMessage()一个。 此外，Handler还提供了handleMessage()来处理消息队列的消息；这样，用户通过覆盖handleMessage()就能处理相应的消息。消息机制位于Java层的框架主要就有上面4个类所组成。在C++层，比较重要的是NativeMessageQueue和Loop这两个类。当我们启动一个APK时，ActivityManagerService会为我们的Activity创建并启动一个主线程(ActivityThread对象)；在启动主线程时，就会创建主线程对应的消息循环，并通过调用loop()进入到消息循环中。当我们需要往消息队列发送消息时，可以继承Handler类，然后创建Handler类的实例；接着，通过该实例的sendMessage()方法就可以向消息队列发送消息。 也就是说，主线程的消息队列也一直存在的。当消息队列中没有消息时，消息队列会进入空闲等待状态；当有消息时，则消息队列会进入运行状态，进而将相应的消息发送给handleMessage()进行处理。 下面是消息机制的流程图：消息队列没有消息时进入空闲等待，有消息时才获取并发送消息。这种机制是通过pipe(管道)机制实现的，关于pipe机制的相关内容，后面再详细说明。 Android消息机制的源码解析下面从”消息循环、消息发送和消息处理”这3个方面对消息机制进行介绍。 1. 消息循环Looper是消息循环类。下面先看看ActivityThread中是如何使用Looper的。 public final class ActivityThread { ... public static void main(String[] args) { ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); ... Looper.loop(); ... } }说明：上面是frameworks/base/core/java/android/app/ActivityThread.java中的main()函数代码。通常在新打开一个APK界面时，系统会为APK启动创建一个ActivityThread对象，并调用它的main()方法。该main函数主要做了两件事：(01),新建ActivityThread对象。 (02),使用主线程进入消息循环。 public final class Looper { private static final String TAG = &quot;Looper&quot;; static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); private static Looper sMainLooper; // guarded by Looper.class final MessageQueue mQueue; final Thread mThread; public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); } public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); } sMainLooper = myLooper(); } } public static Looper getMainLooper() { synchronized (Looper.class) { return sMainLooper; } } public static Looper myLooper() { return sThreadLocal.get(); } private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } ... }说明：上面是frameworks/base/core/java/android/os/Looper.java中创建消息循环的相关代码。(01), prepareMainLooper()是新调用prepare()创建一个Looper对象，并且该Looper对象对应的消息队列是不能退出(quit)的。(02), 新建的Looper对象是存放在sThreadLocal成员变量里面的，而sThreadLocal的类型为ThreadLocal。这意味着，它是一个线程局部变量，即保证每一个调用了prepareMainLooper函数的线程里面都有一个独立的Looper对象。(03)，Looper()的构造函数中会新建消息队列MessageQueue对象，并且将当前的主线程保存到mThread中。实际上，Looper中的消息都是通过存放到MessageQueue消息队列中再进行处理的。 public final class MessageQueue { // True if the message queue can be quit. private final boolean mQuitAllowed; @SuppressWarnings(&quot;unused&quot;) private int mPtr; // used by native code private native static int nativeInit(); ... MessageQueue(boolean quitAllowed) { mQuitAllowed = quitAllowed; mPtr = nativeInit(); } ... }说明：该代码在frameworks/base/core/java/android/os/MessageQueue.java中。MessageQueue的构造函数会执行nativeInit()，nativeInit()是一个JNI函数，它的实现在frameworks/base/core/jni/android_os_MessageQueue.cpp中。 static jint android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) { NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) { jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;); return 0; } nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jint&gt;(nativeMessageQueue); }说明：该代码在frameworks/base/core/jni/android_os_MessageQueue.cpp中。android_os_MessageQueue_nativeInit()是与nativeInit()对应的JNI函数。(01) 在该函数中，会新建NativeMessageQueue对象。这是我们分析的重点。(02) nativeMessageQueue-&gt;incStrong(env); 它的作用是增加引用计数。 NativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) { mLooper = Looper::getForThread(); if (mLooper == NULL) { mLooper = new Looper(false); Looper::setForThread(mLooper); } }说明：该代码在frameworks/base/core/jni/android_os_MessageQueue.cpp中。NativeMessageQueue继承于MessageQueue，而MessageQueue包含mLooper成员，mLooper是一个Looper对象。 该函数中，会新建Looper对象，并调用setForThread()。 Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) { int wakeFds[2]; int result = pipe(wakeFds); LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not create wake pipe. errno=%d&quot;, errno); mWakeReadPipeFd = wakeFds[0]; mWakeWritePipeFd = wakeFds[1]; result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK); LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake read pipe non-blocking. errno=%d&quot;, errno); result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK); LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake write pipe non-blocking. errno=%d&quot;, errno); mIdling = false; // Allocate the epoll instance and register the wake pipe. mEpollFd = epoll_create(EPOLL_SIZE_HINT); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance. errno=%d&quot;, errno); struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union eventItem.events = EPOLLIN; eventItem.data.fd = mWakeReadPipeFd; result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem); LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake read pipe to epoll instance. errno=%d&quot;, errno); }说明：该代码在system/core/libutils/Looper.cpp中。Looper构造函数所在做的事情非常重要，它跟消息机制的原理息息相关：Looper是通过管道(pipe)实现的。 关于管道，简单来说，管道就是一个文件。在管道的两端，分别是两个打开文件文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的。一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。这个等待和唤醒的操作是如何进行的呢，这就要借助Linux系统中的epoll机制了。 Linux系统中的epoll机制为处理大批量句柄而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。 (01) pipe(wakeFds)，该函数创建了两个管道句柄。(02) mWakeReadPipeFd=wakeFds[0]，是读管道的句柄。(03) mWakeWritePipeFd=wakeFds[1]，是写管道的句柄。(04) epoll_create(EPOLL_SIZE_HINT)是创建epoll句柄。(05) epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem)，它的作用是告诉mEpollFd，它要监控mWakeReadPipeFd文件描述符的EPOLLIN事件，即当管道中有内容可读时，就唤醒当前正在等待管道中的内容的线程。 至此，就介绍完消息循环的创建/准备阶段。该节点的主要工作可以概括为2部分内容： (01) Java层，创建Looper对象，Looper的构造函数中会创建消息队列MessageQueue的对象。MessageQueue的作用存储消息队列，用来管理消息的。 (02) C++层，消息队列创建时，会调用JNI函数，初始化NativeMessageQueue对象。NativeMessageQueue则会初始化Looper对象。Looper的作用就是，当Java层的消息队列中没有消息时，就使Android应用程序主线程进入等待状态，而当Java层的消息队列中来了新的消息后，就唤醒Android应用程序的主线程来处理这个消息。 下面分析Looper.loop()函数。 public final class Looper { ... public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); } final MessageQueue queue = me.mQueue; ... for (;;) { Message msg = queue.next(); // might block if (msg == null) { return; } ... msg.target.dispatchMessage(msg); ... msg.recycle(); } } ... }说明：loop()的作用就是不断的从消息队列中获取消息，然后分发处理。(01) myLooper()，是获取当前的Looper对象；而mQueue则是Looper对应的消息队列对象。(02) queue.next()是消息队列的下一个要处理消息。如果消息为空，则退出loop循环；否则，调用dispatchMessage()分发消息。 Message next() { int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } // 调用JNI函数Poll消息。nextPollTimeoutMillis是消息队列中没消息时的等待时间。 // (01) nextPollTimeoutMillis = 0，不等待。 // (02) nextPollTimeoutMillis = -1，无限等待。 nativePollOnce(mPtr, nextPollTimeoutMillis); synchronized (this) { final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; // 如果当前消息非空，但是当前消息的目标是空；则获取下一则消息。 if (msg != null &amp;&amp; msg.target == null) { do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // 如果消息队列中有消息，并且当前时间小于于消息中的执行时间， // 则设置消息的等待时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // 如果消息队列中有消息，并且当前时间大于/等于消息中的执行时间， // 则将该消息返回给Looper。 mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (false) Log.v(&quot;MessageQueue&quot;, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // 如果消息队列中无消息，则设置nextPollTimeoutMillis=-1； // 下次调用nativePollOnce()时，则会进入无穷等待状态。 nextPollTimeoutMillis = -1; } // 如主线程调用的quit()函数，则退出消息循环。 if (mQuitting) { dispose(); return null; } // 查看空闲等待(不是忙等待)对应的pendingIdleHandlerCount数量。 // 如果pendingIdleHandlerCount=0，则继续下一次循环。 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } // 将mIdleHandlers转换位数组 mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // 执行mPendingIdleHandlers中每一个IdleHandler的queueIdle()， // 即，进行空闲等待。 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(&quot;MessageQueue&quot;, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } }说明：next()的作用是获取消息队列的下一条待处理消息。该函数可能导致主线程进入等待状态。源码中已经消息标明了注释，这里就不再重复说明了。 下面分析next()中的nativePollOnce()，它对应的实现函数是android_os_MessageQueue_nativePollOnce()。 static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jclass clazz, jint ptr, jint timeoutMillis) { NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, timeoutMillis); }说明：该函数调用了pollOnce()。 void NativeMessageQueue::pollOnce(JNIEnv* env, int timeoutMillis) { ... mLooper-&gt;pollOnce(timeoutMillis); ... }说明：NativeMessageQueue的pollOnce()，调用了Looper.java中(即mLooper)的pollOnce()。 int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) { ... int result = 0; for (;;) { ... if (result != 0) { ... return result; } result = pollInner(timeoutMillis); } }说明：pollOnce()调用了pollInner()。 int Looper::pollInner(int timeoutMillis) { ... // 通过epoll_wait()等待mEpollFd上IO事件的发生 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); ... // 如果epoll_wait()时出错，则直接跳到Done处。 if (eventCount &lt; 0) { ... goto Done; } // 如果没有IO事件发生，则直接跳到Done处。 if (eventCount == 0) { ... goto Done; } // 如果有IO事件发生，则逐个取出IO事件，如果是写事件(EPOLLIN)，则调用awoken() for (int i = 0; i &lt; eventCount; i++) { int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) { if (epollEvents &amp; EPOLLIN) { awoken(); } else { ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;, epollEvents); } } else { ... } } Done: ; ... return result; }说明：pollInner()就是先通过epoll_wait()进入空闲等待状态，等待消息队列的管道上的消息(IO事件)。如果有消息待处理(即管道上有IO写事件发生，写事件是EPOLLIN类型)，则调用awoken()将消息读取出来。 void Looper::awoken() { ... char buffer[16]; ssize_t nRead; do { nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer)); } while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer)); }说明：awoken()的作用只是把管道中的内容都读取出来。在了解了后面将介绍的”发送消息”之后，会了解到，这里读取的数据内容是无所谓的(实际上读取到的数据就是一个”w”)。重要的是，通过往管道中读/写数据来使处于等待状态的主线程继续运行。 至此，\"消息循环\"部分就介绍完毕了！ 回到Looper.loop()中，next()获取到了消息队列的下一则待处理的消息之后；接着，会调用dispatchMessage()来分发处理消息了。dispatchMessage()的内容，我们放到后面的\"消息的处理\"部分再来介绍。 2. 消息的发送还是以ActivityThread为例，看看如何发送消息。在启动Activity时，会调用scheduleLaunchActivity()，下面看看scheduleLaunchActivity()是如何发送消息的。 public final class ActivityThread { ... private class ApplicationThread extends ApplicationThreadNative { ... public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, int procState, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward, String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) { ... sendMessage(H.LAUNCH_ACTIVITY, r); } ... } ... private void sendMessage(int what, Object obj) { sendMessage(what, obj, 0, 0, false); } private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } ... }说明：scheduleLaunchActivity()定义在类ApplicationThread中，而ApplicationThread是ActivityThread的内部类。(01) scheduleLaunchActivity()调用sendMessage()发送消息，实际上是调用的ActivityThread类中的sendMessage。(02) 在sendMessage()中，会新建一个Message；然后调用mH.sendMessage(msg)来发送消息。 public final class ActivityThread { ... final H mH = new H(); ... private class H extends Handler { ... public void handleMessage(Message msg) { ... switch (msg.what) { case LAUNCH_ACTIVITY: { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } break; ... } } } }说明：mH是H实例，H继承于Handler。sendMessage()的实现在Handler中，下面看看它的实现代码。 public class Handler { ... public final boolean sendMessage(Message msg) { return sendMessageDelayed(msg, 0); } public final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis &lt; 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } ... }说明：该代码在frameworks/base/core/java/android/os/Handler.java中。(01) sendMessage()调用sendMessageDelayed(msg, delayMillis)。sendMessageDelayed(msg, delayMillis)是延时发送消息函数，sendMessage()传入的delayMillis=0，表示延时是0。(02) sendMessageDelayed()调用sendMessageAtTime()。sendMessageAtTime()是指定消息的执行时间的函数。(03) sendMessageAtTime()调用enqueueMessage()。(04) enqueueMessage()queue.enqueueMessage()将消息添加到消息队列中。 public final class MessageQueue { ... boolean enqueueMessage(Message msg, long when) { ... synchronized (this) { if (mQuitting) { return false; } msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // 消息队列无消息 msg.next = p; mMessages = msg; needWake = mBlocked; } else { // 消息队列有消息。将当前消息插入到适当的位置 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // 唤醒主线程 if (needWake) { nativeWake(mPtr); } } return true; } ... }说明：enqueueMessage()会将消息加入到消息队列中。把消息加入到消息队列时，分2种情况：(01)，消息队列为空。 这时候应用程序的主线程一般就是处于空闲等待状态了，这时候就要唤醒它。(02)，消息队列不为空。 这时候就不需要唤醒应用程序的主线程了，因为这时候它一定是在忙着处于消息队列中的消息，因此不会处于空闲等待的状态。在添加完消息之后，如果主线程需要唤醒，则调用nativeWake()。nativeWake()是个JNI函数，它对应的实现是frameworks/base/core/jni/android_os_MessageQueue.cpp中的android_os_MessageQueue_nativeWake()。 static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jint ptr) { NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); return nativeMessageQueue-&gt;wake(); }说明：该函数会调用NativeMessageQueue类中的wake()。 void NativeMessageQueue::wake() { mLooper-&gt;wake(); }说明：该函数会调用system/core/libutils/Looper.cpp中的wake()。mLooper是创建NativeMessageQueue时创建的Looper对象，这在前面已经介绍过了。 void Looper::wake() { ... ssize_t nWrite; do { nWrite = write(mWakeWritePipeFd, &quot;W&quot;, 1); } while (nWrite == -1 &amp;&amp; errno == EINTR); ... } 说明：wake()的作用很简单，就是通过打开文件描述符mWakeWritePipeFd往管道的写入一个”W”字符串。其实，往管道写入什么内容并不重要，往管道写入内容的目的是为了唤醒应用程序的主线程。前面我们在分析应用程序的消息循环时说到，当应用程序的消息队列中没有消息处理时，应用程序的主线程就会进入空闲等待状态，而这个空闲等待状态就是通过调用这个Looper类的pollInner()函数来进入的，具体就是在pollInner()函数中调用epoll_wait()函数来等待管道中有内容可读的。这样，就将发送消息和接收消息联系起来了。 3. 消息的处理前面介绍了”消息的发送过程”；而且我们又知道，在”消息循环”中，会不断读取消息，然后调用dispatchMessage()来分发处理。 public final class Looper { ... public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); } final MessageQueue queue = me.mQueue; ... for (;;) { // 取出消息 Message msg = queue.next(); // might block if (msg == null) { return; } ... // 分发处理 msg.target.dispatchMessage(msg); ... msg.recycle(); } } ... }说明：上面就是loop()消息循环的代码，这在前面已经介绍过了。首先，从消息队列中通过next()取出消息；然后通过dispatchMessage()分发消息。下面，现看看msg.target是什么对象。 public class Handler { ... private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } ... }说明：实际上，msg.target是在”发送消息时”调用的enqueueMessage()中赋值的。this就是Handler对象，而在”消息的发送”中，真正发送消息的是Handler的子类H。也就是说，this是类H的实例。 public final class ActivityThread { ... private class H extends Handler { ... } ... }说明：上面就是ActivityThread中H的定义。现在，我们已经澄清了msg.target是H类的实例。那么，再次回到 msg.target.dispatchMessage(msg)中，它实际上是调用的Handler类(H类的父类)的dispatchMessage()函数。 public class Handler { ... public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } ... }说明：在本文的示例ActivityThread中，msg.callback为空。dispatchMessage()最终会调用handleMessage()处理消息。下面看看H中handleMessage()的代码。 public final class ActivityThread { ... final H mH = new H(); ... private class H extends Handler { ... public void handleMessage(Message msg) { ... switch (msg.what) { case LAUNCH_ACTIVITY: { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } break; ... } } } }说明：handleMessage()的内容不是重点，需要关注的是：消息队列的消息最终是通过handleMessage()来处理的！ 至此，消息机制的发送/接受/处理消息部分都介绍完毕了！总的来说： (01)，应用程序先通过Looper.prepareMainLooper()来创建消息队列。在创建消息队列的过程中，会创建Looper对象，MessageQueue对象，并调用JNI函数；最终，通过管道来进入空闲等待状态。 (02)，当应用程序调用sendMessage()或其他类似接口发送消息时，消息会被添加到消息队列；并最终会先管道中写入内容，从而唤醒管道上处于空闲等待状态的主线程。 (03)，管道上的空闲状态的主线程被唤醒之后，就会读出消息队列的消息，然后通过dispatchMessage()来分发处理。最终，消息会通过handleMessage()来进行处理。","link":"/2014/08/26/android/os/message/2014-08-26-MessageQueue/"},{"title":"Android 之Activity启动模式(一)之 lauchMode","text":"本章介绍Activity的四种launchMode。 目录1. launchMode简介2. 1. standard模式3. 2. singleTop模式4. 3. singleTask模式5. 4. singleInstance模式6. 模式总结 launchMode简介在讲解launchMode之前，需要先了解两个概念：task和taskAffinity。 task是一个”First In Last Out”的栈，task可以有一个或多个Activity。我们可以将task看作是管理Activity的单元。某一时刻，系统可以有多个task；每个task可以有一个或多个Activity。同一个Activity可能只允许存在一个实例，也可能可以有多个实例，而且这些实例既可以位于同一个task，也可以位于不同的task。Activity究竟是怎么处理它的实例，以及它在task中的分布情况；这些都可以通过launchMode进行设置。 android:taskAffinity是Activity的一个属性。例如,android:taskAffinity=”string”。它的作用是描述了不同Activity之间的亲密关系。拥有相同的taskAffinity的Activity是亲密的，它们之间在相互跳转时，会位于同一个task中，而不会新建一个task！如果在manifest中没有对Activity的android:taskAffinity进行配置，则每个Activity都采用和Application相同的taskAffinity；这也就意味着，同一个Application中的所有Activity的taskAffinity在默认情况下是相同的！ 下面开始介绍四种launchMode模式，在通过示例介绍之后，再来对这四种launchMode进行总结。 1. standard模式standard模式是默认模式。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个task，也可以位于不同的task。 下面通过示例来对standard进行验证。在该示例中，ActivityTest是standard模式的，而且点击ActivityTest中的按钮能跳转到它自身。 点击查看：standard模式的测试源码 manifest源码 &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;activity android:name=&quot;ActivityTest&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;ActivityTest的代码 public class ActivityTest extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); TextView tv = (TextView) findViewById(R.id.tv); tv.setText(this.toString()+&quot;, taskId=&quot;+this.getTaskId()); } public void onJump(View view) { Intent intent = new Intent(this, ActivityTest.class); startActivity(intent); } @Override protected void onNewIntent(Intent intent) { Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent); } }说明：上面的ActivityTest就是android:launchMode=”standard”模式的。onJump()是按钮的回调函数，点击该按钮，会重新创建一个ActivityTest实例。 测试内容：ActivityTest –&gt; ActivityTest –&gt; ActivityTest。 (注：ActivityTest –&gt; ActivityTest表示从ActivityTest跳转到ActivityTest)测试结果：每一个ActivityTest实例都是不同的，而且这三个ActivityTest实例都位于同一个task中。结果分析：这与我们前面介绍的standard模式的特性是相符的。 2. singleTop模式singleTop模式下，在同一个task中，如果存在该Activity的实例，并且该Activity实例位于栈顶(即，该Activity位于前端)，则调用startActivity()时，不再创建该Activity的示例；而仅仅只是调用Activity的onNewIntent()。否则的话，则新建该Activity的实例，并将其置于栈顶。 2.1 singleTop示例一点击查看：singleTop示例二的源码 我们将”standard示例”中ActivityTest的launchMode修改为singleTop，其他的保持不变。修改后的manifest如下： &lt;activity android:name=&quot;ActivityTest&quot; android:launchMode=&quot;singleTop&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;说明：上面的ActivityTest就是android:launchMode=”singleTop”模式的。并不会创建新的ActivityTest实例；但是会调用onNewIntent()。 测试内容：ActivityTest –&gt; ActivityTest –&gt; ActivityTest测试结果：每一个ActivityTest实例都是相同的！当从一个ActivityTest跳转到它自身时，没有创建新的ActivityTest实例，但是会调用onNewIntent()。结果分析：这与我们前面介绍的singleTop模式的特性是相符的。 如果是singleTop模式的Activity不在栈顶，那会如何呢？我们通过下面的示例来进行分析。 2.2 singleTop示例二在该示例中，有两个Activity：ActivityTest和SecondActivity。其中ActivityTest是singleTop类型的，而SecondActivity则是standard类型的。这两个Activity之间能相互跳转。 点击查看：singleTop示例二的源码 manifest的源码 &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;activity android:name=&quot;ActivityTest&quot; android:launchMode=&quot;singleTop&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;SecondActivity&quot; android:launchMode=&quot;standard&quot;/&gt; &lt;/application&gt;ActivityTest的代码 public class ActivityTest extends Activity { private static final String TAG=&quot;##ActivityTest##&quot;; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Log.d(TAG, &quot;onCreate: &quot;+this.toString()); TextView tv = (TextView) findViewById(R.id.tv); tv.setText(this.toString()); } public void onJump(View view) { Log.d(TAG, &quot;onJump: &quot;+this.toString()); Intent intent = new Intent(this, SecondActivity.class); startActivity(intent); } @Override protected void onNewIntent(Intent intent) { Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this); } }说明：上面的ActivityTest就是android:launchMode=”singleTop”模式的。onJump()是按钮的回调函数，点击该按钮，会跳转到SecondActivity中。 public class SecondActivity extends Activity { private static final String TAG=&quot;##SecondActivity##&quot;; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.second); Log.d(TAG, &quot;onCreate: &quot;+this.toString()); TextView tv = (TextView) findViewById(R.id.tv2); tv.setText(this.toString()); } public void onBack(View view) { Log.d(TAG, &quot;onBack: &quot;+this.toString()); Intent intent = new Intent(this, ActivityTest.class); startActivity(intent); } @Override protected void onNewIntent(Intent intent) { Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this); } }说明：上面的SecondActivity是standard模式的。onBack是按钮的回调函数，点击该按钮，会跳转回ActivityTest。 测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest测试结果：两个ActivityTest是不同的实例！结果分析：这与我们之前的描述是相符的，当singleTop类型的Activity不在栈顶时，会新建Activity实例。 4. singleTask模式Google官网对singleTask的描述如下： The system creates a new task and instantiates the activity at the root of the new task. However, if an instance of the activity already exists in a separate task, the system routes the intent to the existing instance through a call to its onNewIntent() method, rather than creating a new instance. Only one instance of the activity can exist at a time. 大致意思是： 在singleTask模式下，如果是第一次创建该Activity实例时，则会新建task并将该Activity添加到该task中。否则(该Activity的实例已存在)，则会打开已有的Activity实例，并调用Activity的onNewIntent()方法，而不会新建Activity实例。在任意时刻，最多只会有该一个Activity实例存在。 上面的描述…其实特别抽象。我们通过实例来对singleTask进行了解，最后再对singleTask进行总结。需要建立的一个概念是：singleTask，顾名思义，只容许有一个包含该Activity实例的task存在！ 4.1 singleTask示例一点击查看：singleTask示例一的测试源码 该示例是来验证：(01) 第一次创建singleTask类型的Activity时，会创建新的task！(02) 该Activity实例已经存在时，不会创建新的Activity实例，才是跳转到已有的Activity实例中。 将前面的”singleTop示例二”中的ActivityTest的模式改为”standard”，将SecondActivity的模式改为”singleTask”。修改后的manifest如下： &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;activity android:name=&quot;ActivityTest&quot; android:launchMode=&quot;standard&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;SecondActivity&quot; android:launchMode=&quot;singleTask&quot; /&gt; &lt;/application&gt;测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity测试结果：(01) ActivityTest和SecondActivity在同一个task中。 (02) 两个SecondActivity是相同的实例！结果分析：结论(01)验证失败，结论(02)验证成功! 为什么会出现结论(01)验证失败呢？根据Google官网的描述，分明会启动一个新的task才对啊？为什么呢？会不会是由于ActivityTest和SecondActivity位于同一个APK中，由于它们的android:taskAffinity相同导致的！嗯…到底是不是呢？下面就通过示例来进一步验证！ 4.2 singleTask示例二点击查看：singleTask示例二的测试源码 将”singleTask示例一”中的两个Activity的taskAffinity改为不同，其他保持不变。修改后的manifest如下： &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;activity android:name=&quot;ActivityTest&quot; android:launchMode=&quot;standard&quot; android:taskAffinity=&quot;com.skw.activitytest.task01&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;SecondActivity&quot; android:taskAffinity=&quot;com.skw.activitytest.task02&quot; android:launchMode=&quot;singleTask&quot; /&gt; &lt;/application&gt;测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity测试结果：(01) 第一个ActivityTest和第一个SecondActivity在不同task中。 (02) 两个SecondActivity是相同的实例！结果分析：结论(01)验证成功，结论(02)验证成功! 进一步进行测试：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity –&gt; 返回键 –&gt; 返回键测试结果：在前面测试的基础上，按两次返回键。结果：第一次按返回键的时候，回到第一次创建的ActivityTest实例；再按一次返回键的话，则返回到原始画面(第一次进入ActivityTest之前的画面)！结果分析：这个结果表明，再次进入SecondActivity时，会将SecondActivity所在task中位于SecondActivity之上的全部Activity都删除！ 总结来说：singleTask的结论与android:taskAffinity相关。以A启动B来说(01) 当A和B的taskAffinity相同时：第一次创建B的实例时，并不会启动新的task，而是直接将B添加到A所在的task；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。(02) 当A和B的taskAffinity不同时：第一次创建B的实例时，会启动新的task，然后将B添加到新建的task中；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。 5. singleInstance模式singleInstance，顾名思义，是单一实例的意思，即任意时刻只允许存在唯一的Activity实例！根据Google官网的描述，在模式下，只允许有一个Activity实例。当第一次创建该Activity实例时，会新建一个task，并将该Activity添加到该task中。注意：该task只能容纳该Activity实例，不会再添加其他的Activity实例！如果该Activity实例已经存在于某个task，则直接跳转到该task。 5.1 singleInstance示例一点击查看：singleInstance示例一的测试源码 将前面的”singleTop示例二”中的ActivityTest的模式改为”standard”，将SecondActivity的模式改为”singleInstance”。修改后的manifest如下： &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;activity android:name=&quot;ActivityTest&quot; android:launchMode=&quot;standard&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;SecondActivity&quot; android:launchMode=&quot;singleInstance&quot;/&gt; &lt;/application&gt;测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity测试结果：(01) 两个SecondActivity是同一个实例。 (02) 第一次进入的ActivityTest和第一次进入的SecondActivity位于不同的task中。 (03) 两个ActivityTest是位于同一个task中的不同实例。 结果分析：这个结论与预期是相同的，即，singleInstance类型的Activity的实例只能有一个，而且它只允许存在于单独的一个task中。singleInstance与相互跳转的两个Activity的taskAffinity无关系！ 至于为什么两个ActivityTest是位于同一个task中的不同实例，那是因为它是standard类型的。我们可以将ActivityTest修改为singleTop等其他类型进行测试。 5.2 singleInstance示例二点击查看：singleInstance示例二的测试源码 将前面的”singleInstance示例一”中的ActivityTest的模式改为”singleTop”。修改后的manifest如下： &lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt; &lt;activity android:name=&quot;ActivityTest&quot; android:launchMode=&quot;singleTop&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;SecondActivity&quot; android:launchMode=&quot;singleInstance&quot;/&gt; &lt;/application&gt;测试内容：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity测试结果：(01) 两个SecondActivity是同一个实例。 (02) 第一次进入的ActivityTest和第一次进入的SecondActivity位于不同的task中。 (03) 两个ActivityTest是同一个实例。 结果分析：这个结论与预期是相同的。 launchMode模式总结现在，总结一下launchMode的四种模式： 1. standard它是默认模式。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个task，也可以位于不同的task。 2.singleTop该模式下，在同一个task中，如果存在该Activity的实例，并且该Activity实例位于栈顶(即，该Activity位于前端)，则调用startActivity()时，不再创建该Activity的示例；而仅仅只是调用Activity的onNewIntent()。否则的话，则新建该Activity的实例，并将其置于栈顶。 3. singleTask顾名思义，只容许有一个包含该Activity实例的task存在！ 总的来说：singleTask的结论与android:taskAffinity相关。以A启动B来说(01) 当A和B的taskAffinity相同时：第一次创建B的实例时，并不会启动新的task，而是直接将B添加到A所在的task；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。(02) 当A和B的taskAffinity不同时：第一次创建B的实例时，会启动新的task，然后将B添加到新建的task中；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。 4. singleInstance顾名思义，是单一实例的意思，即任意时刻只允许存在唯一的Activity实例，而且该Activity所在的task不能容纳除该Activity之外的其他Activity实例！ 它与singleTask有相同之处，也有不同之处。相同之处：任意时刻，最多只允许存在一个实例。不同之处：(01) singleTask受android:taskAffinity属性的影响，而singleInstance不受android:taskAffinity的影响。 (02) singleTask所在的task中能有其它的Activity，而singleInstance的task中不能有其他Activity。 (03) 当跳转到singleTask类型的Activity，并且该Activity实例已经存在时，会删除该Activity所在task中位于该Activity之上的全部Activity实例；而跳转到singleInstance类型的Activity，并且该Activity已经存在时，不需要删除其他Activity，因为它所在的task只有该Activity唯一一个Activity实例。","link":"/2014/06/26/android/api_guide/app_component/activity/2014-06-26-LaunchMode/"},{"title":"Android Binder机制(三) ServiceManager守护进程","text":"ServiceManager是用户空间的一个守护进程，它一直运行在后台。它的职责是管理Binder机制中的各个Server。当Server启动时，Server会将”Server对象的名字”连同”Server对象的信息”一起注册到ServiceManager中；而当Client需要获取Server接入点时，则通过”Server的名字”来从ServiceManager中找到对应的Server。本文的主要内容就是对ServiceManager进行介绍，通过它的启动流程来分析它是如何成为Server管理者的。 注意：本文是基于Android 4.4.2版本进行介绍的！ 目录1. ServiceManager流程图2. ServiceManager流程详解2.1. main()2.2. binder_open()2.3. open(“/dev/binder”)2.4. mmap()2.5. binder_become_context_manager()2.6. ioctl(, BINDER_SET_CONTEXT_MGR,)2.7. binder_loop()2.8. for(;;)3. ServiceManager流程总结 ServiceManager流程图 上面是ServiceManager的时序图。它启动之后，会先打开”/dev/binder”文件(“/dev/binder”是Binder驱动注册的设备节点)。打开文件之后，再告诉Binder驱动，它是Binder的上下文管理者。之后，就进入到了消息循环中。进入消息循环之后，会不断的从Binder的待处理事务队列中读取事务(Binder请求或反馈)，读出事务之后就进行解析，然后交给相应的进程进行处理。若没有事务，则进入等待状态，等待被唤醒。 ServiceManager流程详解 1. main()ServiceManager是一个守护进程。它的main()函数源码如下： int main(int argc, char **argv) { struct binder_state *bs; void *svcmgr = BINDER_SERVICE_MANAGER; bs = binder_open(128*1024); if (binder_become_context_manager(bs)) { ALOGE(&quot;cannot become context manager (%s)\\n&quot;, strerror(errno)); return -1; } svcmgr_handle = svcmgr; binder_loop(bs, svcmgr_handler); return 0; }说明：该代码在frameworks/native/cmds/servicemanager/service_manager.c中。main()主要进行了三项工作：(01) 通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。(02) 调用binder_become_context_manager()，通过ioctl()告诉Binder驱动程序自己是Binder上下文管理者。(03) 调用binder_loop()进入消息循环，等待Client的请求。如果没有Client请求，则进入中断等待状态；当有Client请求时，就被唤醒，然后读取并处理Client请求。 ServiceManager是如何启动的？这里简要介绍一下ServiceManager的启动方式。当Kernel启动加载完驱动之后，会启动Android的init程序，init程序会解析init.rc，进而启动init.rc中定义的守护进程。而ServiceManager则正是通过注册在init.rc中，而被启动的。 2. binder_open()下面，对main()的逐个步骤进行详细分析。先看看binder_open()，代码如下： struct binder_state *binder_open(unsigned mapsize) { struct binder_state *bs; bs = malloc(sizeof(*bs)); ... bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR); ... bs-&gt;mapsize = mapsize; bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0); ... return bs; }说明： 该代码定义在frameworks/native/cmds/servicemanager/binder.c中。binder_open的作用是打开”/dev/binder”设备文件，然后调用mmap()将设备文件”/dev/binder”映射到进程空间的起始地址。(01) open(“/dev/binder”, O_RDWR)对应会调用驱动的open函数。(02) mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0)对应会调用驱动的mmap函数。第一个参数是映射内存的起始地址，NULL代表让系统自动选定地址；mapsize大小是128*1024B，即128K；PROT_READ表示映射区域是可读的；MAP_PRIVATE表示建立一个写入时拷贝的私有映射，即，当进程中对该内存区域进行写入时，是写入到映射的拷贝中；bs-&gt;fd是”/dev/binder”句柄；而0表示偏移。(03) binder_state结构体是来保存/dev/binder设备信息的。其中，fd是用来保存文件句柄，mmaped是映射内存的起始地址，mapsize映射内存大小。 3. open(“/dev/binder”)3.1 Binder驱动注册信息下面看看open(“/dev/binder”, O_RDWR)到底做了些什么。先看看下面的代码： static const struct file_operations binder_fops = { .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release, }; static struct miscdevice binder_miscdev = { .minor = MISC_DYNAMIC_MINOR, .name = &quot;binder&quot;, .fops = &amp;binder_fops }; static int __init binder_init(void) { ... ret = misc_register(&amp;binder_miscdev); ... } device_initcall(binder_init);说明：上面是Kernel中Binder驱动代码，定义在drivers/staging/android/binder.c中。(01) device_initcall(binder_init)的作用是将binder_init()函数注册到Kernel的初始化函数列表中。当Kernel启动后，会按照一定的次序调用初始化函数列表，也就会执行binder_init()函数；执行binder_init()时便会加载Binder驱动。(02) binder_init()函数中会通过misc_register(&amp;binder_miscdev)将Binder驱动注册到文件节点”/dev/binder”上。在Linux中，一切都是文件！将Binder驱动注册到文件节点上之后，就可以通过操作文件节点进而对Binder驱动进行操作。而该文件节点”/dev/binder”的设备信息是binder_miscdev这个结构体对象。(03) binder_miscdev变量是struct miscdevice类型。minor是次设备号，这个我们不需要关心；name是Binder驱动对应在/dev虚拟文件系统下的设备节点名称，也就是/dev/binder中的”binder”；fops是该设备节点的文件操作对象，它是我们需要重点关注的！fops指向binder_fops变量。(04) binder_fops变量是struct file_operations类型。owner是标明了该文件操作变量的拥有者，就是该驱动；poll则指定了poll函数指针，当我们对/dev/binder文件节点执行poll()操作时，实际上就是调用的binder_poll()函数；同理，mmap()对应binder_mmap()，open()对应binder_open()，ioctl()对应binder_ioctl()… 3.2 Binder驱动中的binder_open()函数源码经过上面的介绍，我们可以知道open(“/dev/binder”, O_RDWR)实际上是调用Binder驱动中的binder_open()函数。 static HLIST_HEAD(binder_procs); ... static int binder_open(struct inode *nodp, struct file *filp) { struct binder_proc *proc; binder_debug(BINDER_DEBUG_OPEN_CLOSE, &quot;binder_open: %d:%d\\n&quot;, current-&gt;group_leader-&gt;pid, current-&gt;pid); // 为proc分配内存 proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; get_task_struct(current); // 将proc-&gt;tsk指向当前线程 proc-&gt;tsk = current; // 初始化proc的待处理事务列表 INIT_LIST_HEAD(&amp;proc-&gt;todo); // 初始化proc的等待队列 init_waitqueue_head(&amp;proc-&gt;wait); // 设置proc的进程优先级为当前线程的优先级 proc-&gt;default_priority = task_nice(current); binder_lock(__func__); binder_stats_created(BINDER_STAT_PROC); // 将该进程上下文信息proc保存到&quot;全局哈希表binder_procs&quot;中 hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); // 设置进程id proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); // 将proc添加到私有数据中。 // 这样，mmap(),ioctl()等函数都可以通过私有数据获取到proc，即该进程的上下文信息 filp-&gt;private_data = proc; binder_unlock(__func__); if (binder_debugfs_dir_entry_proc) { char strbuf[11]; snprintf(strbuf, sizeof(strbuf), &quot;%u&quot;, proc-&gt;pid); proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO, binder_debugfs_dir_entry_proc, proc, &amp;binder_proc_fops); } return 0; }说明：binder_proc是记录进程上下文信息的结构体，它的详细介绍请参考Android Binder机制(二) Binder中的数据结构。该函数的作用如下。(01) 创建并初始化binder_proc结构体变量proc。binder_proc是描述Binder进程的上下文信息结构体。这里，就是将ServiceManager这个进程的信息都存储到proc中。(02) 将proc添加到全局哈希表binder_procs中。binder_procs不是我们关注的重点，也就不多说了。(03) 将proc设为filp的私有成员。这样，在mmap()，ioctl()等函数中，我们都可以根据filp的私有成员来获取proc信息。 4. mmap()分析完了open()，接下来看看mmap()。mmap()对应会调用Binder驱动的binder_mmap()函数。 4.1 Binder驱动中的binder_mmap()源码static int binder_mmap(struct file *filp, struct vm_area_struct *vma) { int ret; struct vm_struct *area; struct binder_proc *proc = filp-&gt;private_data; const char *failure_string; struct binder_buffer *buffer; // 有效性检查：映射的内存不能大于4M if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M) vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M; ... vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE; mutex_lock(&amp;binder_mmap_lock); // 获取空闲的内核空间地址 area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP); ... // 将内核空间地址赋值给proc-&gt;buffer，即保存到进程上下文中 proc-&gt;buffer = area-&gt;addr; // 计算 &quot;内核空间地址&quot; 和 &quot;进程虚拟地址&quot; 的偏移 proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer; mutex_unlock(&amp;binder_mmap_lock); // 为proc-&gt;pages分配内存 proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL); ... // 内核空间的内存大小 = 进程虚拟地址区域(用户空间)的内存大小 proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start; vma-&gt;vm_ops = &amp;binder_vm_ops; // 将 proc(进程上下文信息) 赋值给vma私有数据 vma-&gt;vm_private_data = proc; // 通过调用binder_update_page_range()来分配物理页面。 // 即，将物理内存映射到内核空间 以及 用户空间 if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) { goto err_alloc_small_buf_failed; } buffer = proc-&gt;buffer; INIT_LIST_HEAD(&amp;proc-&gt;buffers); // 将物理内存添加到proc-&gt;buffers链表中进行管理。 list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers); buffer-&gt;free = 1; binder_insert_free_buffer(proc, buffer); proc-&gt;free_async_space = proc-&gt;buffer_size / 2; barrier(); proc-&gt;files = get_files_struct(proc-&gt;tsk); // 将用户空间地址信息保存到proc中 proc-&gt;vma = vma; proc-&gt;vma_vm_mm = vma-&gt;vm_mm; return 0; ... }说明：mmap的作用是进行内存映射。当应用调用mmap()映射内存到进程虚拟地址时，该函数会进行两个操作：第一，将指定大小的”物理内存” 映射到 “用户空间”(即，进程的虚拟地址中)。 第二，将该”物理内存” 也映射到 “内核空间(即，内核的虚拟地址中)”。 简单来说，就是”将进程虚拟地址空间和内核虚拟地址空间映射同一个物理页面”。为什么要这么做呢？这就是Binder进程间通信机制的精髓所在了！在讲解之前，先回顾一下进程间通信的基础知识。 在32位Linux系统的内存地址划分中，03G为用户空间，34G为内核空间。应用程序都运行在用户空间，而kernel和驱动都运行在内核空间。应用程序之间若涉及到数据交换(例如，Client进程向Server进程发送请求)，即进程间通信，需要使用管道/消息队列/Socket/共享内存等IPC机制。共享内存控制比较复杂，而Socket常用于网络通信，这里将它们排除；剩下的就是管道/消息队列。下面对管道/消息队列的IPC等通信方式进行介绍。假如现在采用管道/消息队列从Client向Server发送请求，需要先将Client进程的数据拷贝到内核空间，然后再从内核空间拷贝到Server进程中。这其中，总共涉及到了2次内存拷贝！而Binder机制则只需要进行1次内存拷贝即可！ 在Binder通信机制中，mmap()会将Server进程的虚拟地址和内核虚拟地址映射到同一个物理页面。那么当Client进程向Server进程发送请求时，只需要将Client的数据拷贝到内核空间即可！由于Server进程的地址和内核空间映射到同一个物理页面，因此，Client中的数据拷贝到内核空间时，也就相当于拷贝到了Server进程中。因此，Binder通信机制中，数据传输时，只需要1次内存拷贝！ 有了上面的理论基础，再来看mmap()是如何实现的。 (01) proc = flip->private_data。该flip的私有数据是在binder_open()中设置的，这里通过该私有数据就获取binder_proc变量proc。 (02) area = get_vm_area(vma->vm_end - vma->vm_start, VM_IOREMAP)。 它的作用是从内核虚拟地址中，获取指定大小的空闲地址，将空闲地址的起始地址赋值给area。 area是vm_struct类型，vm_struct是描述内核虚拟地址信息的结构体。此外，vm_area_struct则是描述进程虚拟地址信息的结构体。 (03) 接着，给proc->buffer(内核空间地址)，proc->user_buffer_offset(内核空间地址和进程虚拟地址的偏移值)，proc->pages(内核空间所占物理页面的数目)，proc->buffer_size(内核地址空间的大小)赋值。 (04) 然后，调用binder_update_page_range(proc, 1, proc->buffer, proc->buffer + PAGE_SIZE, vma)。它作用是分配物理内存，下面看看它的实现。 4.2 Binder驱动中的binder_update_page_range()源码static int binder_update_page_range(struct binder_proc *proc, int allocate, void *start, void *end, struct vm_area_struct *vma) { void *page_addr; unsigned long user_page_addr; struct vm_struct tmp_area; struct page **page; ... // 分配物理页面， // 并将&quot;内核空间&quot;和&quot;用户空间(进程的内存区域)&quot;指向同一块物理内存。 for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) { int ret; struct page **page_array_ptr; page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE]; // 分配物理页面 *page = alloc_page(GFP_KERNEL | __GFP_ZERO); ... tmp_area.addr = page_addr; tmp_area.size = PAGE_SIZE + PAGE_SIZE /* guard page? */; page_array_ptr = page; // 将物理页面映射到内核空间中 ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr); ... user_page_addr = (uintptr_t)page_addr + proc-&gt;user_buffer_offset; // 将物理页面映射插入到进程的虚拟内存中 ret = vm_insert_page(vma, user_page_addr, page[0]); ... } return 0; ... }说明： binder_update_page_range()既可分配物理页面，也可以释放物理页面。当参数allocate=1时，会执行分配物理页面的操作；否则，会执行释放物理页面的操作。这里，allocate=1；因此，我们只关心分配物理页面的部分。在for循环中，每分配一个物理页面都会先通过map_vm_area()将该物理内存映射到内核虚拟地址中；然后再将该物理页面插入到进程的虚拟地址空间。 至此，binder_open(1281024)算是介绍完了。从”用户空间的ServiceManager进程” 和 “Binder驱动”这两个方面分析它的作用。(01) *ServiceManager进程：就是打开/dev/binder，同时映射物理内存到进程空间。(02) **Binder驱动：新建并初始化该进程对应的binder_proc结构体，同时将内核虚拟地址和该进程的虚拟地址映射到同一物理内存中。 5. binder_become_context_manager()下面接着分析binder_become_context_manager(bs)。 int binder_become_context_manager(struct binder_state *bs) { return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0); }说明：根据前面介绍的Binder驱动初始化信息可知，ioctl()就是调用Binder驱动中的binder_ioctl()函数。 6. ioctl(, BINDER_SET_CONTEXT_MGR,)6.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码// 全局binder实体，准确点说是ServiceManager的binder实体 static struct binder_node *binder_context_mgr_node; // ServiceManager守护进程的uid static uid_t binder_context_mgr_uid = -1; static int binder_stop_on_user_error; ... static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // 中断等待函数。 // 1. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。 // 2. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。 // 当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时； // 则继续执行；否则，再进入等待状态。 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); ... binder_lock(__func__); // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。 thread = binder_get_thread(proc); ... switch (cmd) { ... case BINDER_SET_CONTEXT_MGR: if (binder_context_mgr_node != NULL) { ... } if (binder_context_mgr_uid != -1) { ... } else // 设置ServiceManager对应的uid binder_context_mgr_uid = current-&gt;cred-&gt;euid; // 新建binder实体，并将proc进程上下文信息保存到binder实体中； // 然后，将该binder实体赋值给全局变量binder_context_mgr_node。 // 这个全局的binder实体，是ServiceManager对应的binder实体。 binder_context_mgr_node = binder_new_node(proc, NULL, NULL); ... // 设置binder实体的引用计数等参数 binder_context_mgr_node-&gt;local_weak_refs++; binder_context_mgr_node-&gt;local_strong_refs++; binder_context_mgr_node-&gt;has_strong_ref = 1; binder_context_mgr_node-&gt;has_weak_ref = 1; break; ... } ret = 0; err: // 去掉thread的BINDER_LOOPER_STATE_NEED_RETURN标记 if (thread) thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN; binder_unlock(__func__); wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); ... return ret; }说明：binder_ioctl()的内容很多，上面仅仅列出与BINDER_SET_CONTEXT_MGR相关的代码。(01) proc = flip-&gt;private_data。该flip的私有数据是在binder_open()中设置的，这里通过该私有数据就获取binder_proc变量proc。(02) 接着调用wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2)。由于binder_stop_on_user_error是全局变量，它的初始值是0，因此binder_stop_on_user_error &lt; 2为true，不进入中断等待，而是直接跳过该函数继续运行。(03) binder_get_thread()会在proc中查找当前线程对应的binder_thread结构体；由于之前还未创建该线程的binder_thread结构体，因此查找失败。进而创建一个binder_thread结构体变量，并将其添加到proc-&gt;threads红黑树中，然后返回该变量。(04) cmd的值是我们调用ioctl()传入的参数BINDER_SET_CONTEXT_MGR。在BINDER_SET_CONTEXT_MGR分支中，会设置binder_context_mgr_uid，binder_context_mgr_uid是一个全局变量，它代表ServiceManager对应的uid；接着，通过binder_new_node()新建一个Binder实体(即binder_node结构体对象)，并将该Binder实体赋值给全局变量binder_context_mgr_node，binder_context_mgr_node就是Serveice Manager对应的Binder实体；最后，设置binder实体的引用计数等参数。(05) 清除thread-&gt;looper的BINDER_LOOPER_STATE_NEED_RETURN标记。这个BINDER_LOOPER_STATE_NEED_RETURN标记，是在调用binder_get_thread()中创建binder_thread对象时添加的。 关于binder_node结构体，在Android Binder机制(二) Binder中的数据结构中有消息的介绍。特别需要了解的是，对于每一个Server，Binder驱动都会为其分配一个binder_node对象。对于ServiceManager这个Binder上下文管理者而言，Binder驱动更是会将它的Binder实体保存到全局变量中。 6.2 Binder驱动中的binder_get_thread()源码下面看看binder_get_thread()中做了什么。 static struct binder_thread *binder_get_thread(struct binder_proc *proc) { struct binder_thread *thread = NULL; struct rb_node *parent = NULL; struct rb_node **p = &amp;proc-&gt;threads.rb_node; // 在proc-&gt;threads这棵红黑树中，查找是否有线程的pid和current-&gt;pid相同。 // 即，查找当前线程中是否创建过binder_thread信息 while (*p) { parent = *p; thread = rb_entry(parent, struct binder_thread, rb_node); if (current-&gt;pid &lt; thread-&gt;pid) p = &amp;(*p)-&gt;rb_left; else if (current-&gt;pid &gt; thread-&gt;pid) p = &amp;(*p)-&gt;rb_right; else break; } // 若当前线程中没有创建过binder_thread信息； // 则创建binder_thread，并初始化；然后将其添加到binder_proc进程的proc-&gt;threads中 if (*p == NULL) { thread = kzalloc(sizeof(*thread), GFP_KERNEL); if (thread == NULL) return NULL; binder_stats_created(BINDER_STAT_THREAD); // 将进程的上下文信息保存到thread中 thread-&gt;proc = proc; thread-&gt;pid = current-&gt;pid; // 初始化thread的等待队列 init_waitqueue_head(&amp;thread-&gt;wait); // 初始化thread的待处理事件列表 INIT_LIST_HEAD(&amp;thread-&gt;todo); // 将该thread链接到proc-&gt;threads这棵红黑树中 rb_link_node(&amp;thread-&gt;rb_node, parent, p); rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads); thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN; thread-&gt;return_error = BR_OK; thread-&gt;return_error2 = BR_OK; } return thread; }说明：(01) 理解”红黑树”和”rb_entry”是理解while循环的前提。这里简单介绍下，proc-&gt;threads这棵红黑树是根据proc-&gt;thread-&gt;pid来排序的；而rb_entry(parent, struct binder_thread, rb_node)的作用根据binder_thread结构体对象中的已知成员的地址(binder_thread-&gt;rb_node的地址，也就是parent的值)来获取binder_thread结构体对象的地址。(02) 很显然，由于之前没有创建过当前线程对应的binder_thread对象，所以*p==null为true。那么，接下来就新建binder_thread对象，并对其进行初始化，然后再添加到红黑树proc-&gt;threads中。 6.3 Binder驱动中的binder_new_node()源码下面看看binder_ioctl()中调用的binder_new_node()的代码。 static struct binder_node *binder_new_node(struct binder_proc *proc, void __user *ptr, void __user *cookie) { struct rb_node **p = &amp;proc-&gt;nodes.rb_node; struct rb_node *parent = NULL; struct binder_node *node; // 在proc-&gt;nodes这棵红黑树中，查找有要查找的binder实体(通过ptr成员来判断) while (*p) { parent = *p; node = rb_entry(parent, struct binder_node, rb_node); if (ptr &lt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_left; else if (ptr &gt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_right; else return NULL; } // 如果没有要找的binder实体，则新建该binder实体 node = kzalloc(sizeof(*node), GFP_KERNEL); if (node == NULL) return NULL; binder_stats_created(BINDER_STAT_NODE); // 将node链接到红黑树proc-&gt;nodes中 rb_link_node(&amp;node-&gt;rb_node, parent, p); rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes); node-&gt;debug_id = ++binder_last_id; // 将进程上下文信息保存到node-&gt;proc中 node-&gt;proc = proc; node-&gt;ptr = ptr; node-&gt;cookie = cookie; node-&gt;work.type = BINDER_WORK_NODE; INIT_LIST_HEAD(&amp;node-&gt;work.entry); INIT_LIST_HEAD(&amp;node-&gt;async_todo); return node; }说明：跟binder_get_thread()类似，这里是先在proc-&gt;nodes这棵红黑树中查找是否有binder实体(即binder_node对象)存在。有的话，返回NULL，即不需要新建binder实体；没有的话，则新建并初始化binder_node对象，然后将其添加到proc-&gt;nodes红黑树中。 至此，binder_become_context_manager()就介绍完了。它的作用：(01) ServiceManager进程：告诉Kernel驱动，当前进程(即ServiceManager进程)是Binder上下文管理者。(02) Binder驱动：新建当前线程对应的binder_thread对象，并将其添加到进程上下文信息binder_proc的threads红黑树中；新建ServiceManager对应的binder实体，并将该binder实体保存到全局变量binder_context_mgr_node中。 7. binder_loop()我们继续回到main()函数，分析一下binder_loop(bs, svcmgr_handler)。 7.1 binder_loop()的源码void binder_loop(struct binder_state *bs, binder_handler func) { int res; struct binder_write_read bwr; unsigned readbuf[32]; bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; // 告诉Kernel，ServiceManager进程进入了消息循环状态。 readbuf[0] = BC_ENTER_LOOPER; binder_write(bs, readbuf, sizeof(unsigned)); for (;;) { bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (unsigned) readbuf; // 向Kernel中发送消息(先写后读)。 // 先将消息传递给Kernel，然后再从Kernel读取消息反馈 res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); ... // 解析读取的消息反馈 res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func); ... } }说明： 该代码定义在frameworks/native/cmds/servicemanager/binder.c中。 binder_loop()首先调用binder_write(,BC_ENTER_LOOPER,)告诉Kernel，ServiceManager进入了消息循环状态。紧接着，就通过ioctl(,BINDER_WRITE_READ,)进入消息循环，等待Client发送请求(例如，MediaPlayer进程调用addService将MediaPlayer注册到ServiceManager中进行管理)。如果没有消息，则进入中断等待状态；如果有消息，则进行消息处理！ 7.2 binder_write()的源码下面看看binder_loop()中的binder_write(,BC_ENTER_LOOPER,)。 int binder_write(struct binder_state *bs, void *data, unsigned len) { struct binder_write_read bwr; int res; bwr.write_size = len; // 数据长度 bwr.write_consumed = 0; bwr.write_buffer = (unsigned) data; // 数据是BINDER_WRITE_READ bwr.read_size = 0; bwr.read_consumed = 0; bwr.read_buffer = 0; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); if (res &lt; 0) { fprintf(stderr,&quot;binder_write: ioctl failed (%s)\\n&quot;, strerror(errno)); } return res; }说明：binder_write()单单只是向Kernel发送一个消息，而不会去读取消息反馈。这里的ioctl()又会调用到binder_ioctl()。这里涉及到了Binder通信中常用的数据结构体binder_write_read。bwr.write_size&gt;0，表示通过ServiceManager有数据(即BC_ENTER_LOOPER指令)发送给Binder驱动，而发送的数据就保存在bwr.write_buffer中，bwr.write_consumed则表示已经被读取并处理的数据的大小。bwr.read_XXX则是用来保存Binder驱动即将反馈给ServiceManager的信息的。更多关于binder_write_read的介绍，请参考Android Binder机制(二) Binder中的数据结构。 7.3 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码下面我们看看Binder驱动部分的对应代码。 static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // 中断等待函数。 // 1. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。 // 2. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。 // 当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时； // 则继续执行；否则，再进入等待状态。 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); binder_lock(__func__); // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。 thread = binder_get_thread(proc); ... switch (cmd) { case BINDER_WRITE_READ: { struct binder_write_read bwr; ... // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot; if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) { ... } // 如果write_size&gt;0，则进行写操作 if (bwr.write_size &gt; 0) { ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... } // 如果read_size&gt;0，则进行读操作 if (bwr.read_size &gt; 0) { ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... } ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) { ret = -EFAULT; goto err; } break; } ... } ret = 0; ... return ret; }说明：(01) wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2)中binder_stop_on_user_error &lt; 2为true。因此，不进入中断等待状态而是直接跳过该函数。(02) thread = binder_get_thread(proc)。由于在上一次调用ioctl时，已经创建了该线程对应的binder_thread对象。因此，这次能在proc-&gt;threads红黑树中找到对应的binder_thread对象，然后，返回给thread。(03) copy_from_user()的作用是将用户空间的数据拷贝到内核空间。即，将ServiceManager中调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)时的bwr对象拷贝到Binder驱动中。(04) 在binder_write()中，设置的bwr.write_size&gt;0；所以，调用binder_thread_write()进行写操作。(05) 在binder_write()中，设置的bwr.read_size为0；所以，不调用binder_thread_read()进行读操作。(06) 读写操作完毕之后，将bwr从内核空间再拷贝到用户空间。 7.4 Binder驱动中binder_thread_write()的源码int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed) { uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) { // 从用户空间读取32bit到内核中，并赋值给cmd。 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) { ... case BC_ENTER_LOOPER: ... // 设置线程的状态为BINDER_LOOPER_STATE_ENTERED； // 即，进入了循环状态 thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED; break; ... } // 更新bwr.write_consumed的值 *consumed = ptr - buffer; } return 0; }说明：binder_thread_write()从brw.write_buffer中读取4个字节作为cmd。这4个字节就是ServiceManager传递的指令BC_ENTER_LOOPER。在BC_ENTER_LOOPER对应的switch分支中，就是将BINDER_LOOPER_STATE_ENTERED加入到thread-&gt;looper中。即，告诉Binder驱动，ServiceManager进程进入了消息循环状态。 8. for(;;)继续往下走。回到binder_loop()中后，便进入了for(;;)消息循环中。进入循环后，首先调用ioctl(,BINDER_WRITE_READ,)；此时，对应的bwr内容如下： bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (unsigned) readbuf;bwr.write_size=0，而bwr.read_size&gt;0；表示只会从Binder驱动读取数据，而并不会向Binder驱动中写入数据。接着，调用ioctl()便再次进入到Binder驱动binder_ioctl()中。 8.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { ... switch (cmd) { case BINDER_WRITE_READ: { struct binder_write_read bwr; ... // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot; if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) { ... } // 如果write_size&gt;0，则进行写操作 if (bwr.write_size &gt; 0) { ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... } // 如果read_size&gt;0，则进行读操作 if (bwr.read_size &gt; 0) { ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... } ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) { ret = -EFAULT; goto err; } break; } ... } ret = 0; ... return ret; }说明：由于此次bwr.write_size=0，而bwr.read_size不为0。因此，在通过copy_from_user()将数据从用户空间拷贝到内核空间之后，不进行写操作，而只进行读操作，即只执行binder_thread_read()。 在读操作执行完毕之后，再通过copy_to_user()，将数据返回给用户空间。 8.2 Binder驱动中binder_thread_read()的源码static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) { void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区 if (*consumed == 0) { if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; // 修改指针位置 ptr += sizeof(uint32_t); } retry: // 等待proc进程的事务标记。 // 当线程的事务栈为空 并且 待处理事务列表为空时，该标记位true。 wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); ... // 设置线程为&quot;等待状态&quot; thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING; if (wait_for_proc_work) proc-&gt;ready_threads++; ... if (wait_for_proc_work) { ... // 设置当前线程的优先级=proc-&gt;default_priority。 // 即，当前线程要处理proc的事务，所以设置优先级和proc一样。 binder_set_nice(proc-&gt;default_priority); if (non_block) { // 非阻塞式的读取，则通过binder_has_proc_work()读取proc的事务； // 若没有，则直接返回 if (!binder_has_proc_work(proc, thread)) ret = -EAGAIN; } else // 阻塞式的读取，则阻塞等待事务的发生。 ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); } else { ... } ... }说明：(01) 很显然，bwr.read_consumed=0。因此，*consumed=0，那么就将BR_NOOP拷贝到用户空间的bwr.read_buffer缓存区中。(02) 目前为止，并没有进程将事务添加到当前线程中；因此，线程的事务栈和待处理事务队列都是为空。于是得到wait_for_proc_work的值是true。(03) binder_set_nice()的作用是设置当前线程的优先级=proc-&gt;default_priority。(04) 根据上下文，可知non_block为false。因此调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))。 而目前ServiceManager进程中没有待处理事务，因此binder_has_proc_work(proc, thread)为false。从而当前线程进入中断等待状态，等待其它进程将ServiceManager唤醒。 至此，ServiceManager进入了等待状态，binder_loop()就分析就暂告一段落。(01) ServiceManager进程：binder_loop()通过BC_ENTER_LOOPER告诉Kernel，ServiceManager进入了消息循环状态。接着，ServiceManager就进入等待状态，等待Client请求。(02) Binder驱动：已知ServiceManager进入了消息循环状态；在收到ServiceManager的BINDER_WRITE_READ消息之后，就去ServiceManager的从进程上下文binder_proc对象中读取是否有待处理事务，由于没有事务处理，则将ServiceManager线程设为中断等待状态。 ServiceManager流程总结总结上面的分析，ServiceManager的main()进程完成了以下工作。 对于ServiceManager进程而言它打开了Binder设备文件，并且将内存映射到ServiceManager的进程空间。然后，它告诉Binder驱动自己是Binder上下文的管理者。最后，进入消息循环，等待Client请求。 对于Binder驱动而言初始化了ServiceManager对应的进程上下文环境(即binder_proc变量)，并将内核虚拟地址和进程虚拟地址映射到同一物理内存中。然后，新建当前线程对应的binder_thread对象，并将其添加到进程上下文信息binder_proc-&gt;threads红黑树中。在得知ServiceManager是Binder上下文管理者后，建立ServiceManager对应的Binder实体，并将该Binder实体保存到全局变量中。最后，得知ServiceManager进入消息循环后，由于当前线程中没有事务可处理，则进入中断等待状态，等待其他进程将其唤醒。","link":"/2014/09/03/android/os/binder/2014-09-03-Binder-ServiceManager-Daemon/"},{"title":"Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例","text":"这一章，我们对HashMap进行学习。我们先对HashMap有个整体认识，然后再学习它的源码，最后再通过实例来学会使用HashMap。内容包括： 目录第1部分 HashMap介绍第2部分 HashMap数据结构第3部分 HashMap源码解析(基于JDK1.6.0_45)&nbsp;&nbsp;第3.1部分 HashMap的“拉链法”相关内容&nbsp;&nbsp;第3.2部分 HashMap的构造函数&nbsp;&nbsp;第3.3部分 HashMap的主要对外接口&nbsp;&nbsp;第3.4部分 HashMap实现的Cloneable接口&nbsp;&nbsp;第3.5部分 HashMap实现的Serializable接口第4部分 HashMap遍历方式第5部分 HashMap示例 第1部分 HashMap介绍HashMap简介HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 HashMap的构造函数HashMap共有4个构造函数,如下： // 默认构造函数。 HashMap() // 指定“容量大小”的构造函数 HashMap(int capacity) // 指定“容量大小”和“加载因子”的构造函数 HashMap(int capacity, float loadFactor) // 包含“子Map”的构造函数 HashMap(Map&lt;? extends K, ? extends V&gt; map)HashMap的APIvoid clear() Object clone() boolean containsKey(Object key) boolean containsValue(Object value) Set&lt;Entry&lt;K, V&gt;&gt; entrySet() V get(Object key) boolean isEmpty() Set&lt;K&gt; keySet() V put(K key, V value) void putAll(Map&lt;? extends K, ? extends V&gt; map) V remove(Object key) int size() Collection&lt;V&gt; values() 第2部分 HashMap数据结构HashMap的继承关系 java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.HashMap&lt;K, V&gt;HashMap的声明 public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { }HashMap与Map关系如下图： 从图中可以看出：(01) HashMap继承于AbstractMap类，实现了Map接口。Map是”key-value键值对”接口，AbstractMap实现了”键值对”的通用函数接口。(02) HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。 table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。size是HashMap的大小，它是HashMap保存的键值对的数量。threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。loadFactor就是加载因子。modCount是用来实现fail-fast机制的。 第3部分 HashMap源码解析(基于JDK1.6.0_45)为了更了解HashMap的原理，下面对HashMap源码代码作出分析。在阅读源码时，建议参考后面的说明来建立对HashMap的整体认识，这样更容易理解HashMap。 package java.util; import java.io.*; public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { // 默认的初始容量是16，必须是2的幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的大小，它是HashMap保存的键值对的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init(); } // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } // 默认构造函数。 public HashMap() { // 设置“加载因子” this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); } // 包含“子Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m); } static int hash(int h) { h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); } // 返回索引值 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) { return h &amp; (length-1); } public int size() { return size; } public boolean isEmpty() { return size == 0; } // 获取key对应的value public V get(Object key) { if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; } return null; } // 获取“key为null”的元素的值 // HashMap将“key为null”的元素存储在table[0]位置！ private V getForNullKey() { for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) { if (e.key == null) return e.value; } return null; } // HashMap是否包含key public boolean containsKey(Object key) { return getEntry(key) != null; } // 返回“键为key”的键值对 final Entry&lt;K,V&gt; getEntry(Object key) { // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } return null; } // 将“key-value”添加到HashMap中 public V put(K key, V value) { // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null; } // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) { for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 这里的完全不会被执行到! modCount++; addEntry(0, null, value, 0); return null; } // 创建HashMap对应的“添加方法”， // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap // 而put()是对外提供的往HashMap中添加元素的方法。 private void putForCreate(K key, V value) { int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { e.value = value; return; } } // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中 createEntry(hash, key, value, i); } // 将“m”中的全部元素都添加到HashMap中。 // 该方法被内部的构造HashMap的方法所调用。 private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) { // 利用迭代器将元素逐个添加到HashMap中 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); putForCreate(e.getKey(), e.getValue()); } } // 重新调整HashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); } // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) { Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) { Entry&lt;K,V&gt; e = src[j]; if (e != null) { src[j] = null; do { Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } while (e != null); } } } // 将&quot;m&quot;的全部元素都添加到HashMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; m) { // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) { int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); } // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); put(e.getKey(), e.getValue()); } } // 删除“键为key”元素 public V remove(Object key) { Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); } // 删除“键为key”的元素 final Entry&lt;K,V&gt; removeEntryForKey(Object key) { // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) { Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; } prev = e; e = next; } return e; } // 删除“键值对” final Entry&lt;K,V&gt; removeMapping(Object o) { if (!(o instanceof Map.Entry)) return null; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; Object key = entry.getKey(); int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) { Entry&lt;K,V&gt; next = e.next; if (e.hash == hash &amp;&amp; e.equals(entry)) { modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; } prev = e; e = next; } return e; } // 清空HashMap，将所有的元素设为null public void clear() { modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0; } // 是否包含“值为value”的元素 public boolean containsValue(Object value) { // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; } // 是否包含null值 private boolean containsNullValue() { Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false; } // 克隆一个HashMap，并返回Object对象 public Object clone() { HashMap&lt;K,V&gt; result = null; try { result = (HashMap&lt;K,V&gt;)super.clone(); } catch (CloneNotSupportedException e) { // assert false; } result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result; } // Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) { value = v; next = n; key = k; hash = h; } public final K getKey() { return key; } public final V getValue() { return value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) { Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; } return false; } // 实现hashCode() public final int hashCode() { return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); } public final String toString() { return getKey() + &quot;=&quot; + getValue(); } // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) { } // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) { } } // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); } // 创建Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 // 它和addEntry的区别是： // (01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。 // 例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素； // put()是通过addEntry()新增Entry的。 // 在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”； // 因此，需要调用addEntry() // (02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。 // 例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中； // 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中 // 的全部元素添加到HashMap中，都不会超过HashMap的阈值”。 // 此时，调用createEntry()即可。 void createEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++; } // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; { // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() { expectedModCount = modCount; if (size &gt; 0) { // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } } public final boolean hasNext() { return next != null; } // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) { Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } current = e; return e; } // 删除当前元素 public void remove() { if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; } } // value的迭代器 private final class ValueIterator extends HashIterator&lt;V&gt; { public V next() { return nextEntry().value; } } // key的迭代器 private final class KeyIterator extends HashIterator&lt;K&gt; { public K next() { return nextEntry().getKey(); } } // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; { public Map.Entry&lt;K,V&gt; next() { return nextEntry(); } } // 返回一个“key迭代器” Iterator&lt;K&gt; newKeyIterator() { return new KeyIterator(); } // 返回一个“value迭代器” Iterator&lt;V&gt; newValueIterator() { return new ValueIterator(); } // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() { return new EntryIterator(); } // HashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K&gt; keySet() { Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); } // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private final class KeySet extends AbstractSet&lt;K&gt; { public Iterator&lt;K&gt; iterator() { return newKeyIterator(); } public int size() { return size; } public boolean contains(Object o) { return containsKey(o); } public boolean remove(Object o) { return HashMap.this.removeEntryForKey(o) != null; } public void clear() { HashMap.this.clear(); } } // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values())); } // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private final class Values extends AbstractCollection&lt;V&gt; { public Iterator&lt;V&gt; iterator() { return newValueIterator(); } public int size() { return size; } public boolean contains(Object o) { return containsValue(o); } public void clear() { HashMap.this.clear(); } } // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { return entrySet0(); } // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); } // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return newEntryIterator(); } public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o; Entry&lt;K,V&gt; candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); } public boolean remove(Object o) { return removeMapping(o) != null; } public int size() { return size; } public void clear() { HashMap.this.clear(); } } // java.io.Serializable的写入函数 // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException { Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) { while (i.hasNext()) { Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); } } } private static final long serialVersionUID = 362498820763181265L; // java.io.Serializable的读取函数：根据写入方式读出 // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) { K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); } } // 返回“HashMap总的容量” int capacity() { return table.length; } // 返回“HashMap的加载因子” float loadFactor() { return loadFactor; } }说明:在详细介绍HashMap的代码之前，我们需要了解：HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的。还需要再补充说明的一点是影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 第3.1部分 HashMap的“拉链法”相关内容3.1.1 HashMap数据存储数组transient Entry[] table;HashMap中的key-value都是存储在Entry数组中的。 3.1.2 数据节点Entry的数据结构static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) { value = v; next = n; key = k; hash = h; } public final K getKey() { return key; } public final V getValue() { return value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) { Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; } return false; } // 实现hashCode() public final int hashCode() { return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); } public final String toString() { return getKey() + &quot;=&quot; + getValue(); } // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) { } // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) { } }从中，我们可以看出 Entry 实际上就是一个单向链表。这也是为什么我们说HashMap是通过拉链法解决哈希冲突的。Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。 第3.2部分 HashMap的构造函数HashMap共包括4个构造函数 // 默认构造函数。 public HashMap() { // 设置“加载因子” this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); } // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init(); } // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } // 包含“子Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m); } 第3.3部分 HashMap的主要对外接口3.3.1 clear()clear() 的作用是清空HashMap。它是通过将所有的元素设为null来实现的。 public void clear() { modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0; }3.3.2 containsKey()containsKey() 的作用是判断HashMap是否包含key。 public boolean containsKey(Object key) { return getEntry(key) != null; }containsKey() 首先通过getEntry(key)获取key对应的Entry，然后判断该Entry是否为null。getEntry()的源码如下： final Entry&lt;K,V&gt; getEntry(Object key) { // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } return null; }getEntry() 的作用就是返回“键为key”的键值对，它的实现源码中已经进行了说明。这里需要强调的是：HashMap将“key为null”的元素都放在table的位置0处，即table[0]中；“key不为null”的放在table的其余位置！ 3.3.3 containsValue()containsValue() 的作用是判断HashMap是否包含“值为value”的元素。 public boolean containsValue(Object value) { // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; }从中，我们可以看出containsNullValue()分为两步进行处理：第一，若“value为null”，则调用containsNullValue()。第二，若“value不为null”，则查找HashMap中是否有值为value的节点。 containsNullValue() 的作用判断HashMap中是否包含“值为null”的元素。 private boolean containsNullValue() { Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false; }3.3.4 entrySet()、values()、keySet()它们3个的原理类似，这里以entrySet()为例来说明。entrySet()的作用是返回“HashMap中所有Entry的集合”，它是一个集合。实现代码如下： // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { return entrySet0(); } // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); } // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return newEntryIterator(); } public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o; Entry&lt;K,V&gt; candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); } public boolean remove(Object o) { return removeMapping(o) != null; } public int size() { return size; } public void clear() { HashMap.this.clear(); } }HashMap是通过拉链法实现的散列表。表现在HashMap包括许多的Entry，而每一个Entry本质上又是一个单向链表。那么HashMap遍历key-value键值对的时候，是如何逐个去遍历的呢？ 下面我们就看看HashMap是如何通过entrySet()遍历的。entrySet()实际上是通过newEntryIterator()实现的。 下面我们看看它的代码： // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() { return new EntryIterator(); } // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; { public Map.Entry&lt;K,V&gt; next() { return nextEntry(); } } // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; { // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() { expectedModCount = modCount; if (size &gt; 0) { // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } } public final boolean hasNext() { return next != null; } // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) { Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } current = e; return e; } // 删除当前元素 public void remove() { if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; } }当我们通过entrySet()获取到的Iterator的next()方法去遍历HashMap时，实际上调用的是 nextEntry() 。而nextEntry()的实现方式，先遍历Entry(根据Entry在table中的序号，从小到大的遍历)；然后对每个Entry(即每个单向链表)，逐个遍历。 3.3.5 get()get() 的作用是获取key对应的value，它的实现代码如下： public V get(Object key) { if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; } return null; }3.3.6 put()put() 的作用是对外提供接口，让HashMap对象可以通过put()将“key-value”添加到HashMap中。 public V put(K key, V value) { // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null; }若要添加到HashMap中的键值对对应的key已经存在HashMap中，则找到该键值对；然后新的value取代旧的value，并退出！若要添加到HashMap中的键值对对应的key不在HashMap中，则将其添加到该哈希值对应的链表中，并调用addEntry()。下面看看addEntry()的代码： void addEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); }addEntry() 的作用是新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 说到addEntry()，就不得不说另一个函数createEntry()。createEntry()的代码如下： void createEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++; }它们的作用都是将key、value添加到HashMap中。而且，比较addEntry()和createEntry()的代码，我们发现addEntry()多了两句： if (size++ &gt;= threshold) resize(2 * table.length);那它们的区别到底是什么呢？阅读代码，我们可以发现，它们的使用情景不同。 (01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。&nbsp;&nbsp;&nbsp;&nbsp; 例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素；put()是通过addEntry()新增Entry的。&nbsp;&nbsp;&nbsp;&nbsp; 在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”；&nbsp;&nbsp;&nbsp;&nbsp; 因此，需要调用addEntry()。(02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。&nbsp;&nbsp;&nbsp;&nbsp; 例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中；&nbsp;&nbsp;&nbsp;&nbsp; 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中的全部元素添加到HashMap中，都不会超过HashMap的阈值”。此时，调用createEntry()即可。 3.3.7 putAll()putAll() 的作用是将”m”的全部元素都添加到HashMap中，它的代码如下： public void putAll(Map&lt;? extends K, ? extends V&gt; m) { // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) { int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); } // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); put(e.getKey(), e.getValue()); } }3.3.8 remove() remove() 的作用是删除“键为key”元素 public V remove(Object key) { Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); } // 删除“键为key”的元素 final Entry&lt;K,V&gt; removeEntryForKey(Object key) { // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) { Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; } prev = e; e = next; } return e; } 第3.4部分 HashMap实现的Cloneable接口HashMap实现了Cloneable接口，即实现了clone()方法。clone()方法的作用很简单，就是克隆一个HashMap对象并返回。 // 克隆一个HashMap，并返回Object对象 public Object clone() { HashMap&lt;K,V&gt; result = null; try { result = (HashMap&lt;K,V&gt;)super.clone(); } catch (CloneNotSupportedException e) { // assert false; } result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result; } 第3.5部分 HashMap实现的Serializable接口HashMap实现java.io.Serializable，分别实现了串行读取、写入功能。串行写入函数是writeObject()，它的作用是将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中。而串行读取函数是readObject()，它的作用是将HashMap的“总的容量，实际容量，所有的Entry”依次读出 // java.io.Serializable的写入函数 // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException { Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) { while (i.hasNext()) { Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); } } } // java.io.Serializable的读取函数：根据写入方式读出 // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) { K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); } } 第4部分 HashMap遍历方式4.1 遍历HashMap的键值对第一步：根据entrySet()获取HashMap的“键值对”的Set集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是HashMap对象 // map中的key是String类型，value是Integer类型 Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue(); }4.2 遍历HashMap的键第一步：根据keySet()获取HashMap的“键”的Set集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是HashMap对象 // map中的key是String类型，value是Integer类型 String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key); }4.3 遍历HashMap的值第一步：根据value()获取HashMap的“值”的集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是HashMap对象 // map中的key是String类型，value是Integer类型 Integer value = null; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) { value = (Integer)iter.next(); }遍历测试程序如下： import java.util.Map; import java.util.Random; import java.util.Iterator; import java.util.HashMap; import java.util.HashSet; import java.util.Map.Entry; import java.util.Collection; /* * @desc 遍历HashMap的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorHashMapByEntryset() * (02) 通过keySet()去遍历key、value，参考实现函数： * iteratorHashMapByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorHashMapJustValues() * * @author skywang */ public class HashMapIteratorTest { public static void main(String[] args) { int val = 0; String key = null; Integer value = null; Random r = new Random(); HashMap map = new HashMap(); for (int i=0; i&lt;12; i++) { // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到HashMap中 map.put(key, value); System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value); } // 通过entrySet()遍历HashMap的key-value iteratorHashMapByEntryset(map) ; // 通过keySet()遍历HashMap的key-value iteratorHashMapByKeyset(map) ; // 单单遍历HashMap的value iteratorHashMapJustValues(map); } /* * 通过entry set遍历HashMap * 效率高! */ private static void iteratorHashMapByEntryset(HashMap map) { if (map == null) return ; System.out.println(&quot;\\niterator HashMap By entryset&quot;); String key = null; Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+&quot; -- &quot;+integ.intValue()); } } /* * 通过keyset来遍历HashMap * 效率低! */ private static void iteratorHashMapByKeyset(HashMap map) { if (map == null) return ; System.out.println(&quot;\\niterator HashMap By keyset&quot;); String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { key = (String)iter.next(); integ = (Integer)map.get(key); System.out.println(key+&quot; -- &quot;+integ.intValue()); } } /* * 遍历HashMap的values */ private static void iteratorHashMapJustValues(HashMap map) { if (map == null) return ; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) { System.out.println(iter.next()); } } } 第5部分 HashMap示例下面通过一个实例学习如何使用HashMap import java.util.Map; import java.util.Random; import java.util.Iterator; import java.util.HashMap; import java.util.HashSet; import java.util.Map.Entry; import java.util.Collection; /* * @desc HashMap测试程序 * * @author skywang */ public class HashMapTest { public static void main(String[] args) { testHashMapAPIs(); } private static void testHashMapAPIs() { // 初始化随机种子 Random r = new Random(); // 新建HashMap HashMap map = new HashMap(); // 添加操作 map.put(&quot;one&quot;, r.nextInt(10)); map.put(&quot;two&quot;, r.nextInt(10)); map.put(&quot;three&quot;, r.nextInt(10)); // 打印出map System.out.println(&quot;map:&quot;+map ); // 通过Iterator遍历key-value Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); System.out.println(&quot;next : &quot;+ entry.getKey() +&quot; - &quot;+entry.getValue()); } // HashMap的键值对个数 System.out.println(&quot;size:&quot;+map.size()); // containsKey(Object key) :是否包含键key System.out.println(&quot;contains key two : &quot;+map.containsKey(&quot;two&quot;)); System.out.println(&quot;contains key five : &quot;+map.containsKey(&quot;five&quot;)); // containsValue(Object value) :是否包含值value System.out.println(&quot;contains value 0 : &quot;+map.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 map.remove(&quot;three&quot;); System.out.println(&quot;map:&quot;+map ); // clear() ： 清空HashMap map.clear(); // isEmpty() : HashMap是否为空 System.out.println((map.isEmpty()?&quot;map is empty&quot;:&quot;map is not empty&quot;) ); } } (某一次)运行结果： map:{two=7, one=9, three=6} next : two - 7 next : one - 9 next : three - 6 size:3 contains key two : true contains key five : false contains value 0 : false map:{two=7, one=9} map is empty更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/10/java/collection/2012-02-10-collection-10-hashmap/"},{"title":"Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例","text":"前一章，我们学习了HashMap。这一章，我们对Hashtable进行学习。我们先对Hashtable有个整体认识，然后再学习它的源码，最后再通过实例来学会使用Hashtable。 目录第1部分 Hashtable介绍第2部分 Hashtable数据结构第3部分 Hashtable源码解析(基于JDK1.6.0_45)第4部分 Hashtable遍历方式第5部分 Hashtable示例 第1部分 Hashtable介绍Hashtable 简介 和HashMap一样，Hashtable 也是一个散列表，它存储的内容是键值对(key-value)映射。Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。 Hashtable 的实例有两个参数影响其性能：初始容量 和 加载因子。容量 是哈希表中桶 的数量，初始容量 就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数 Hashtable 操作中，包括 get 和 put 操作，都反映了这一点）。 Hashtable的构造函数 // 默认构造函数。 public Hashtable() // 指定“容量大小”的构造函数 public Hashtable(int initialCapacity) // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) // 包含“子Map”的构造函数 public Hashtable(Map&lt;? extends K, ? extends V&gt; t)Hashtable的API synchronized void clear() synchronized Object clone() boolean contains(Object value) synchronized boolean containsKey(Object key) synchronized boolean containsValue(Object value) synchronized Enumeration&lt;V&gt; elements() synchronized Set&lt;Entry&lt;K, V&gt;&gt; entrySet() synchronized boolean equals(Object object) synchronized V get(Object key) synchronized int hashCode() synchronized boolean isEmpty() synchronized Set&lt;K&gt; keySet() synchronized Enumeration&lt;K&gt; keys() synchronized V put(K key, V value) synchronized void putAll(Map&lt;? extends K, ? extends V&gt; map) synchronized V remove(Object key) synchronized int size() synchronized String toString() synchronized Collection&lt;V&gt; values() 第2部分 Hashtable数据结构Hashtable的继承关系 java.lang.Object ↳ java.util.Dictionary&lt;K, V&gt; ↳ java.util.Hashtable&lt;K, V&gt;Hashtable的声明 public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable { }Hashtable与Map关系如下图： 从图中可以看出：(01) Hashtable继承于Dictionary类，实现了Map接口。Map是”key-value键值对”接口，Dictionary是声明了操作”键值对”函数接口的抽象类。(02) Hashtable是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。&nbsp;&nbsp;table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。&nbsp;&nbsp;count是Hashtable的大小，它是Hashtable保存的键值对的数量。&nbsp;&nbsp;threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。&nbsp;&nbsp;loadFactor就是加载因子。&nbsp;&nbsp;modCount是用来实现fail-fast机制的 第3部分 Hashtable源码解析(基于JDK1.6.0_45)为了更了解Hashtable的原理，下面对Hashtable源码代码作出分析。在阅读源码时，建议参考后面的说明来建立对Hashtable的整体认识，这样更容易理解Hashtable。 package java.util; import java.io.*; public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable { // Hashtable保存key-value的数组。 // Hashtable是采用拉链法实现的，每一个Entry本质上是一个单向链表 private transient Entry[] table; // Hashtable中元素的实际数量 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数 private transient int modCount = 0; // 序列版本号 private static final long serialVersionUID = 1421746759512286392L; // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)(initialCapacity * loadFactor); } // 指定“容量大小”的构造函数 public Hashtable(int initialCapacity) { this(initialCapacity, 0.75f); } // 默认构造函数。 public Hashtable() { // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f); } // 包含“子Map”的构造函数 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) { this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t); } public synchronized int size() { return count; } public synchronized boolean isEmpty() { return count == 0; } // 返回“所有key”的枚举对象 public synchronized Enumeration&lt;K&gt; keys() { return this.&lt;K&gt;getEnumeration(KEYS); } // 返回“所有value”的枚举对象 public synchronized Enumeration&lt;V&gt; elements() { return this.&lt;V&gt;getEnumeration(VALUES); } // 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) { // Hashtable中“键值对”的value不能是null， // 若是null的话，抛出异常! if (value == null) { throw new NullPointerException(); } // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) { if (e.value.equals(value)) { return true; } } } return false; } public boolean containsValue(Object value) { return contains(value); } // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) { Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， // % tab.length 的目的是防止数据越界 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return true; } } return false; } // 返回key对应的value，没有的话返回null public synchronized V get(Object key) { Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return e.value; } } return null; } // 调整Hashtable的长度，将长度变成原来的(2倍+1) // (01) 将“旧的Entry数组”赋值给一个临时变量。 // (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组” // (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中 protected void rehash() { int oldCapacity = table.length; Entry[] oldMap = table; int newCapacity = oldCapacity * 2 + 1; Entry[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)(newCapacity * loadFactor); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) { Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; } } } // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) { // Hashtable中不能插入value为null的元素！！！ if (value == null) { throw new NullPointerException(); } // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { V old = e.value; e.value = value; return old; } } // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) { // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; } // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null; } // 删除Hashtable中键为key的元素 public synchronized V remove(Object key) { Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)” // 然后在链表中找出要删除的节点，并删除该节点。 for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { modCount++; if (prev != null) { prev.next = e.next; } else { tab[index] = e.next; } count--; V oldValue = e.value; e.value = null; return oldValue; } } return null; } // 将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) { for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue()); } // 清空Hashtable // 将Hashtable的table数组的值全部设为null public synchronized void clear() { Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0; } // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() { try { Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) { t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; } t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); } } public synchronized String toString() { int max = size() - 1; if (max == -1) return &quot;{}&quot;; StringBuilder sb = new StringBuilder(); Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator(); sb.append(&apos;{&apos;); for (int i = 0; ; i++) { Map.Entry&lt;K,V&gt; e = it.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? &quot;(this Map)&quot; : key.toString()); sb.append(&apos;=&apos;); sb.append(value == this ? &quot;(this Map)&quot; : value.toString()); if (i == max) return sb.append(&apos;}&apos;).toString(); sb.append(&quot;, &quot;); } } // 获取Hashtable的枚举类对象 // 若Hashtable的实际大小为0,则返回“空枚举类”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) { if (count == 0) { return (Enumeration&lt;T&gt;)emptyEnumerator; } else { return new Enumerator&lt;T&gt;(type, false); } } // 获取Hashtable的迭代器 // 若Hashtable的实际大小为0,则返回“空迭代器”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) { if (count == 0) { return (Iterator&lt;T&gt;) emptyIterator; } else { return new Enumerator&lt;T&gt;(type, true); } } // Hashtable的“key的集合”。它是一个Set，意味着没有重复元素 private transient volatile Set&lt;K&gt; keySet = null; // Hashtable的“key-value的集合”。它是一个Set，意味着没有重复元素 private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // Hashtable的“key-value的集合”。它是一个Collection，意味着可以有重复元素 private transient volatile Collection&lt;V&gt; values = null; // 返回一个被synchronizedSet封装后的KeySet对象 // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;K&gt; keySet() { if (keySet == null) keySet = Collections.synchronizedSet(new KeySet(), this); return keySet; } // Hashtable的Key的Set集合。 // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。 private class KeySet extends AbstractSet&lt;K&gt; { public Iterator&lt;K&gt; iterator() { return getIterator(KEYS); } public int size() { return count; } public boolean contains(Object o) { return containsKey(o); } public boolean remove(Object o) { return Hashtable.this.remove(o) != null; } public void clear() { Hashtable.this.clear(); } } // 返回一个被synchronizedSet封装后的EntrySet对象 // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; } // Hashtable的Entry的Set集合。 // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return getIterator(ENTRIES); } public boolean add(Map.Entry&lt;K,V&gt; o) { return super.add(o); } // 查找EntrySet中是否包含Object(0) // 首先，在table中找到o对应的Entry(Entry是一个单向链表) // 然后，查找Entry链表中是否存在Object public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry)o; Object key = entry.getKey(); Entry[] tab = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) if (e.hash==hash &amp;&amp; e.equals(entry)) return true; return false; } // 删除元素Object(0) // 首先，在table中找到o对应的Entry(Entry是一个单向链表) // 然后，删除链表中的元素Object public boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); Entry[] tab = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) { if (e.hash==hash &amp;&amp; e.equals(entry)) { modCount++; if (prev != null) prev.next = e.next; else tab[index] = e.next; count--; e.value = null; return true; } } return false; } public int size() { return count; } public void clear() { Hashtable.this.clear(); } } // 返回一个被synchronizedCollection封装后的ValueCollection对象 // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步 public Collection&lt;V&gt; values() { if (values==null) values = Collections.synchronizedCollection(new ValueCollection(), this); return values; } // Hashtable的value的Collection集合。 // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。 private class ValueCollection extends AbstractCollection&lt;V&gt; { public Iterator&lt;V&gt; iterator() { return getIterator(VALUES); } public int size() { return count; } public boolean contains(Object o) { return containsValue(o); } public void clear() { Hashtable.this.clear(); } } // 重新equals()函数 // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等 public synchronized boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o; if (t.size() != size()) return false; try { // 通过迭代器依次取出当前Hashtable的key-value键值对 // 并判断该键值对，存在于Hashtable(o)中。 // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) { Map.Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(t.get(key)==null &amp;&amp; t.containsKey(key))) return false; } else { if (!value.equals(t.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } // 计算Hashtable的哈希值 // 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。 // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。 public synchronized int hashCode() { int h = 0; if (count == 0 || loadFactor &lt; 0) return h; // Returns zero loadFactor = -loadFactor; // Mark hashCode computation in progress Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) for (Entry e = tab[i]; e != null; e = e.next) h += e.key.hashCode() ^ e.value.hashCode(); loadFactor = -loadFactor; // Mark hashCode computation complete return h; } // java.io.Serializable的写入函数 // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中 private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException { // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements and then the key/value objects s.writeInt(table.length); s.writeInt(count); for (int index = table.length-1; index &gt;= 0; index--) { Entry entry = table[index]; while (entry != null) { s.writeObject(entry.key); s.writeObject(entry.value); entry = entry.next; } } } // java.io.Serializable的读取函数：根据写入方式读出 // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it&apos;s large enough, this helps distribute the entries. // Guard against the length ending up zero, that&apos;s not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) { K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); } this.table = table; } private void reconstitutionPut(Entry[] tab, K key, V value) throws StreamCorruptedException { if (value == null) { throw new java.io.StreamCorruptedException(); } // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { throw new java.io.StreamCorruptedException(); } } // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); count++; } // Hashtable的Entry节点，它本质上是一个单向链表。 // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表 private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } protected Object clone() { return new Entry&lt;K,V&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); } public K getKey() { return key; } public V getValue() { return value; } // 设置value。若value是null，则抛出异常。 public V setValue(V value) { if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; } // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp; (value==null ? e.getValue()==null : value.equals(e.getValue())); } public int hashCode() { return hash ^ (value==null ? 0 : value.hashCode()); } public String toString() { return key.toString()+&quot;=&quot;+value.toString(); } } private static final int KEYS = 0; private static final int VALUES = 1; private static final int ENTRIES = 2; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。 private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; { // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) { this.type = type; this.iterator = iterator; } // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() { Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) { e = t[--i]; } entry = e; index = i; return e != null; } // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() { Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) { et = t[--i]; } entry = et; index = i; if (et != null) { Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); } throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;); } // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() { return hasMoreElements(); } // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); } // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() { if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException(&quot;Hashtable Enumerator&quot;); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) { Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) { if (e == lastReturned) { modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; } } throw new ConcurrentModificationException(); } } } private static Enumeration emptyEnumerator = new EmptyEnumerator(); private static Iterator emptyIterator = new EmptyIterator(); // 空枚举类 // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。 private static class EmptyEnumerator implements Enumeration&lt;Object&gt; { EmptyEnumerator() { } // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() { return false; } // 空枚举类的nextElement() 抛出异常 public Object nextElement() { throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;); } } // 空迭代器 // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。 private static class EmptyIterator implements Iterator&lt;Object&gt; { EmptyIterator() { } public boolean hasNext() { return false; } public Object next() { throw new NoSuchElementException(&quot;Hashtable Iterator&quot;); } public void remove() { throw new IllegalStateException(&quot;Hashtable Iterator&quot;); } } }说明: 在详细介绍Hashtable的代码之前，我们需要了解：和Hashmap一样，Hashtable也是一个散列表，它也是通过“拉链法”解决哈希冲突的。 第3.1部分 Hashtable的“拉链法”相关内容3.1.1 Hashtable数据存储数组private transient Entry[] table;Hashtable中的key-value都是存储在table数组中的。 3.1.2 数据节点Entry的数据结构private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } protected Object clone() { return new Entry&lt;K,V&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); } public K getKey() { return key; } public V getValue() { return value; } // 设置value。若value是null，则抛出异常。 public V setValue(V value) { if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; } // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp; (value==null ? e.getValue()==null : value.equals(e.getValue())); } public int hashCode() { return hash ^ (value==null ? 0 : value.hashCode()); } public String toString() { return key.toString()+&quot;=&quot;+value.toString(); } }从中，我们可以看出 Entry 实际上就是一个单向链表。这也是为什么我们说Hashtable是通过拉链法解决哈希冲突的。Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。 第3.2部分 Hashtable的构造函数Hashtable共包括4个构造函数 // 默认构造函数。 public Hashtable() { // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f); } // 指定“容量大小”的构造函数 public Hashtable(int initialCapacity) { this(initialCapacity, 0.75f); } // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)(initialCapacity * loadFactor); } // 包含“子Map”的构造函数 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) { this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t); }第3.3部分 Hashtable的主要对外接口3.3.1 clear()clear() 的作用是清空Hashtable。它是将Hashtable的table数组的值全部设为null public synchronized void clear() { Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0; }3.3.2 contains() 和 containsValue()contains() 和 containsValue() 的作用都是判断Hashtable是否包含“值(value)” public boolean containsValue(Object value) { return contains(value);} public synchronized boolean contains(Object value) { // Hashtable中“键值对”的value不能是null， // 若是null的话，抛出异常! if (value == null) { throw new NullPointerException(); } // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) { if (e.value.equals(value)) { return true; } } } return false; }3.3.3 containsKey()containsKey() 的作用是判断Hashtable是否包含key public synchronized boolean containsKey(Object key) { Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， // % tab.length 的目的是防止数据越界 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return true; } } return false; }3.3.4 elements()elements() 的作用是返回“所有value”的枚举对象 public synchronized Enumeration&lt;V&gt; elements() { return this.&lt;V&gt;getEnumeration(VALUES); } // 获取Hashtable的枚举类对象 private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) { if (count == 0) { return (Enumeration&lt;T&gt;)emptyEnumerator; } else { return new Enumerator&lt;T&gt;(type, false); } }从中，我们可以看出：(01) 若Hashtable的实际大小为0,则返回“空枚举类”对象emptyEnumerator；(02) 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) 我们先看看emptyEnumerator对象是如何实现的 private static Enumeration emptyEnumerator = new EmptyEnumerator(); // 空枚举类 // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。 private static class EmptyEnumerator implements Enumeration&lt;Object&gt; { EmptyEnumerator() { } // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() { return false; } // 空枚举类的nextElement() 抛出异常 public Object nextElement() { throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;); } }我们在来看看Enumeration类 Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。 private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; { // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) { this.type = type; this.iterator = iterator; } // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() { Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) { e = t[--i]; } entry = e; index = i; return e != null; } // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() { Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) { et = t[--i]; } entry = et; index = i; if (et != null) { Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); } throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;); } // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() { return hasMoreElements(); } // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); } // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() { if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException(&quot;Hashtable Enumerator&quot;); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) { Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) { if (e == lastReturned) { modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; } } throw new ConcurrentModificationException(); } } }entrySet(), keySet(), keys(), values()的实现方法和elements()差不多，而且源码中已经明确的给出了注释。这里就不再做过多说明了。 3.3.5 get()get() 的作用就是获取key对应的value，没有的话返回null public synchronized V get(Object key) { Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return e.value; } } return null; }3.3.6 put()put() 的作用是对外提供接口，让Hashtable对象可以通过put()将“key-value”添加到Hashtable中。 public synchronized V put(K key, V value) { // Hashtable中不能插入value为null的元素！！！ if (value == null) { throw new NullPointerException(); } // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { V old = e.value; e.value = value; return old; } } // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) { // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; } // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null; }3.3.7 putAll()putAll() 的作用是将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) { for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue()); }3.3.8 remove()remove() 的作用就是删除Hashtable中键为key的元素 public synchronized V remove(Object key) { Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)” // 然后在链表中找出要删除的节点，并删除该节点。 for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { modCount++; if (prev != null) { prev.next = e.next; } else { tab[index] = e.next; } count--; V oldValue = e.value; e.value = null; return oldValue; } } return null; }第3.4部分 Hashtable实现的Cloneable接口Hashtable实现了Cloneable接口，即实现了clone()方法。clone()方法的作用很简单，就是克隆一个Hashtable对象并返回。 // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() { try { Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) { t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; } t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); } }第3.5部分 Hashtable实现的Serializable接口Hashtable实现java.io.Serializable，分别实现了串行读取、写入功能。 串行写入函数就是将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中串行读取函数：根据写入方式读出将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException { // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements and then the key/value objects s.writeInt(table.length); s.writeInt(count); for (int index = table.length-1; index &gt;= 0; index--) { Entry entry = table[index]; while (entry != null) { s.writeObject(entry.key); s.writeObject(entry.value); entry = entry.next; } } } private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it&apos;s large enough, this helps distribute the entries. // Guard against the length ending up zero, that&apos;s not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) { K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); } this.table = table; } 第4部分 Hashtable遍历方式4.1 遍历Hashtable的键值对第一步：根据entrySet()获取Hashtable的“键值对”的Set集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设table是Hashtable对象 // table中的key是String类型，value是Integer类型 Integer integ = null; Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue(); }4.2 通过Iterator遍历Hashtable的键第一步：根据keySet()获取Hashtable的“键”的Set集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设table是Hashtable对象 // table中的key是String类型，value是Integer类型 String key = null; Integer integ = null; Iterator iter = table.keySet().iterator(); while (iter.hasNext()) { // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)table.get(key); }4.3 通过Iterator遍历Hashtable的值第一步：根据value()获取Hashtable的“值”的集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设table是Hashtable对象 // table中的key是String类型，value是Integer类型 Integer value = null; Collection c = table.values(); Iterator iter= c.iterator(); while (iter.hasNext()) { value = (Integer)iter.next(); }4.4 通过Enumeration遍历Hashtable的键第一步：根据keys()获取Hashtable的集合。 第二步：通过Enumeration遍历“第一步”得到的集合。 Enumeration enu = table.keys(); while(enu.hasMoreElements()) { System.out.println(enu.nextElement()); } 4.5 通过Enumeration遍历Hashtable的值第一步：根据elements()获取Hashtable的集合。 第二步：通过Enumeration遍历“第一步”得到的集合。 Enumeration enu = table.elements(); while(enu.hasMoreElements()) { System.out.println(enu.nextElement()); }遍历测试程序如下： import java.util.*; /* * @desc 遍历Hashtable的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorHashtableByEntryset() * (02) 通过keySet()去遍历key，参考实现函数： * iteratorHashtableByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorHashtableJustValues() * (04) 通过Enumeration去遍历key，参考实现函数： * enumHashtableKey() * (05) 通过Enumeration去遍历value，参考实现函数： * enumHashtableValue() * * @author skywang */ public class HashtableIteratorTest { public static void main(String[] args) { int val = 0; String key = null; Integer value = null; Random r = new Random(); Hashtable table = new Hashtable(); for (int i=0; i&lt;12; i++) { // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到Hashtable中 table.put(key, value); System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value); } // 通过entrySet()遍历Hashtable的key-value iteratorHashtableByEntryset(table) ; // 通过keySet()遍历Hashtable的key-value iteratorHashtableByKeyset(table) ; // 单单遍历Hashtable的value iteratorHashtableJustValues(table); // 遍历Hashtable的Enumeration的key enumHashtableKey(table); // 遍历Hashtable的Enumeration的value //enumHashtableValue(table); } /* * 通过Enumeration遍历Hashtable的key * 效率高! */ private static void enumHashtableKey(Hashtable table) { if (table == null) return ; System.out.println(&quot;\\nenumeration Hashtable&quot;); Enumeration enu = table.keys(); while(enu.hasMoreElements()) { System.out.println(enu.nextElement()); } } /* * 通过Enumeration遍历Hashtable的value * 效率高! */ private static void enumHashtableValue(Hashtable table) { if (table == null) return ; System.out.println(&quot;\\nenumeration Hashtable&quot;); Enumeration enu = table.elements(); while(enu.hasMoreElements()) { System.out.println(enu.nextElement()); } } /* * 通过entry set遍历Hashtable * 效率高! */ private static void iteratorHashtableByEntryset(Hashtable table) { if (table == null) return ; System.out.println(&quot;\\niterator Hashtable By entryset&quot;); String key = null; Integer integ = null; Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+&quot; -- &quot;+integ.intValue()); } } /* * 通过keyset来遍历Hashtable * 效率低! */ private static void iteratorHashtableByKeyset(Hashtable table) { if (table == null) return ; System.out.println(&quot;\\niterator Hashtable By keyset&quot;); String key = null; Integer integ = null; Iterator iter = table.keySet().iterator(); while (iter.hasNext()) { key = (String)iter.next(); integ = (Integer)table.get(key); System.out.println(key+&quot; -- &quot;+integ.intValue()); } } /* * 遍历Hashtable的values */ private static void iteratorHashtableJustValues(Hashtable table) { if (table == null) return ; Collection c = table.values(); Iterator iter= c.iterator(); while (iter.hasNext()) { System.out.println(iter.next()); } } } 第5部分 Hashtable示例下面通过一个实例来学习如何使用Hashtable。 import java.util.*; /* * @desc Hashtable的测试程序。 * * @author skywang */ public class HashtableTest { public static void main(String[] args) { testHashtableAPIs(); } private static void testHashtableAPIs() { // 初始化随机种子 Random r = new Random(); // 新建Hashtable Hashtable table = new Hashtable(); // 添加操作 table.put(&quot;one&quot;, r.nextInt(10)); table.put(&quot;two&quot;, r.nextInt(10)); table.put(&quot;three&quot;, r.nextInt(10)); // 打印出table System.out.println(&quot;table:&quot;+table ); // 通过Iterator遍历key-value Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); System.out.println(&quot;next : &quot;+ entry.getKey() +&quot; - &quot;+entry.getValue()); } // Hashtable的键值对个数 System.out.println(&quot;size:&quot;+table.size()); // containsKey(Object key) :是否包含键key System.out.println(&quot;contains key two : &quot;+table.containsKey(&quot;two&quot;)); System.out.println(&quot;contains key five : &quot;+table.containsKey(&quot;five&quot;)); // containsValue(Object value) :是否包含值value System.out.println(&quot;contains value 0 : &quot;+table.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 table.remove(&quot;three&quot;); System.out.println(&quot;table:&quot;+table ); // clear() ： 清空Hashtable table.clear(); // isEmpty() : Hashtable是否为空 System.out.println((table.isEmpty()?&quot;table is empty&quot;:&quot;table is not empty&quot;) ); } }(某一次)运行结果： table:{two=5, one=0, three=6} next : two - 5 next : one - 0 next : three - 6 size:3 contains key two : true contains key five : false contains value 0 : true table:{two=5, one=0} table is empty更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较","link":"/2012/02/11/java/collection/2012-02-11-collection-11-hashtable/"},{"title":"Android Binder机制(五) addService详解01之 请求的发送","text":"终于要开始讲解Client-Server交互了，若标题所示，本文要讲解的是addService请求，即添加服务请求。本文选取的题材是MediaPlayerService服务通过addService请求注册到ServiceManager中。在这个addService请求中，MediaPlayerService是Client，而ServiceManager是Server。由于涉及到的过程比较复杂，这里会将addService请求分为3篇进行说明，这3篇的主题分别是：请求的发送，请求的处理，以及请求的反馈。和以往一样，在讲解详细的代码之前，先做个整体介绍。 注意：本文是基于Android 4.4.2版本进行介绍的！ 1. addService流程的时序图 上面是addService流程的时序图。理解这个图的前提是理解图中的三种角色之间的关系：(01) MediaPlayerService和ServiceManager是两个不同的进程。它们都位于用户空间，都有各自的内存单元，两者之间不能直接进行通信；因此，需要Binder驱动的帮助才能通信。(02) Binder驱动位于内核空间，它映射到节点”/dev/binder”上。MediaPlayerService和ServiceManager都有通过open(“/dev/binder”)打开该节点，并通过mmap()将内存映射到各自所在的进程中；这也就是说MediaPlayerService能和Binder驱动通信，而且ServiceManager也能和Binder驱动通信。而在Binder驱动中，有一个全局变量，依靠这个全局变量，就能实现MediaPlayerService和ServiceManager之间的通信。 依靠的这个全局变量，就是Android Binder机制(三) ServiceManager守护进程中介绍过的binder_context_mgr_node变量，它是ServiceManager的Binder实体。 搞清楚它们三者之间的关系之后，再回到上面的时序图中。 WAIT这表示ServiceManager进入了中断等待状态。它进入等待状态的详细流程，在Android Binder机制(三) ServiceManager守护进程有介绍过。 BC_TRANSACTION这是MediaPlayerService向ServiceManager发送addService请求对应的事务。这个事务是请求，而不是回复；因此是BC开发，B代表Binder，而C代表Command。如果是回复，则会以BR开发，R表示Reply。Binder驱动在收到BC_TRANSACTION之后，会将分配内存，将请求数据保存到所分配的内存中。 WAKE_UPMediaPlayerService通过BC_TRANSACTION提交一个请求，该请求是交给ServiceManager来处理的。因此，Binder驱动在收到该请求后，会将其发送到ServiceManager的待处理事务队列中，并将ServiceManager唤醒。 BR_TRANSACTION_COMPLETEMediaPlayerService在发起了一个请求之后，它需要知道该请求是否发送成功。因此，Binder驱动在将该请求提交给ServiceManager之后，会反馈一个BR_TRANSACTION_COMPLETE给MediaPlayerService，表示MediaPlayerService发送的请求已经被Binder驱动收到了。 WAITMediaPlayerService在知道自己的请求已经发送成功之后，就进入等待状态，等待请求的反馈结果。 BR_NOOP和BR_TRANSACTIONServiceManager被唤醒之后，收到Binder驱动的BR_NOOP和BR_TRANSACTION指令。BR_NOOP指令什么也不会做；而对于BR_TRANSACTION指令时，ServiceManager在解析出该事务是添加服务请求，会将MediaPlayerService的相关信息保存到一个链表中。 BC_FREE_BUFFER和BC_REPLYServiceManager在保存了MediaPlayerService的相关信息之后，便处理完毕了MediaPlayerService的请求。此时，它便反馈BC_FREE_BUFFER和BC_REPLY给Binder驱动。Binder驱动在收到BC_FREE_BUFFER之后，会释放保存请求数据所申请的内存；收到BC_REPLY之后，Binder驱动则知道ServiceManager已经处理完了MediaPlayerService的请求。接着，Binder驱动便会唤醒MediaPlayerService，并发送BR_NOOP和BR_REPLY给MediaPlayerService，告诉MediaPlayerService请求已经处理完毕。同时，它还会发送一个BR_TRANSACTION_COMPLETE给ServiceManager，告诉ServiceManager该事务已经处理完毕。 MediaPlayerService在收到BR_REPLY反馈之后，知道addService请求已经成功处理；接着，它会再次进入等待状态，等待Client的请求。最后，ServiceManager处理MediaPlayerService的请求之后，没有其他事务可处理，也再次进入了等待状态。 2. IMediaPlayerService的类图本文是以MediaPlayerService为例，对addService进行解析。下面看看MediaPlayerService相关联的类图。 IMediaPlayerService的类图和”Android Binder机制(四) defaultServiceManager()的实现“中IServiceManager的类图类似。这里就不再逐一对每个类进行介绍了。 需要知道的是，对于一个MediaPlayerService而言，它存在一个”远程BpBinder对象”和”本地BBinder对象”。(01) 远程BpBinder对象的作用，是和Binder驱动进行交互。例如，当本文所讲到的addService请求，就是通过defaultServiceManager()调用到远程BpBinder对象的transact()方法，而该方法又会调用到IPCThreadState::transact()接口，通过IPCThreadState类来和Binder驱动交互。(02) MediaPlayerService是”本地BBinder的子类”。当Client向MediaPlayerService发起请求时，会调用BBinder的onTransact()方法，而BnServiceManager又重写了该方法，从而调用onTransact()完成对请求的处理。 addService请求发送的代码解析下面通过代码来查看addService请求的发送流程。 1. MediaPlayerService的main()函数先看看MediaPlayerService的main()函数代码。 int main(int argc, char** argv) { signal(SIGPIPE, SIG_IGN); char value[PROPERTY_VALUE_MAX]; bool doLog = (property_get(&quot;ro.test_harness&quot;, value, &quot;0&quot;) &gt; 0) &amp;&amp; (atoi(value) == 1); pid_t childPid; if (doLog &amp;&amp; (childPid = fork()) != 0) { ... } else { // all other services ... sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ... MediaPlayerService::instantiate(); ... ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); } }说明：该代码在frameworks/av/media/mediaserver/main_mediaserver.cpp中。(01) property_get(“ro.test_harness”, value, “0”)是获取”ro.test_harness”属性，为false。(02) ProcessState:self()是获取ProcessState对象，并赋值给proc。ProcessState::self()在Android Binder机制(四) defaultServiceManager()的实现中已经介绍过了。(03) defaultServiceManager()是获取IServiceManager对象，它的实现在Android Binder机制(四) defaultServiceManager()的实现中也有详细介绍。(04) MediaPlayerService::instantiate()是初始化MediaPlayerService服务。 2. MediaPlayerService::instantiate()void MediaPlayerService::instantiate() { defaultServiceManager()-&gt;addService( String16(&quot;media.player&quot;), new MediaPlayerService()); }说明：该代码在frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp中。它会新建MediaPlayerService对象；然后调用defaultServiceManager()获取到的BpServiceManager的实例；最后，调用BpServiceManager的addService()方法，将MediaPlayerService对象添加到Service Manager中。MediaPlayerService服务的名称是”media.player”。 3. MediaPlayerService::MediaPlayerService()MediaPlayerService::MediaPlayerService() { ALOGV(&quot;MediaPlayerService created&quot;); mNextConnId = 1; mBatteryAudio.refCount = 0; for (int i = 0; i &lt; NUM_AUDIO_DEVICES; i++) { mBatteryAudio.deviceOn[i] = 0; mBatteryAudio.lastTime[i] = 0; mBatteryAudio.totalTime[i] = 0; } // speaker is on by default mBatteryAudio.deviceOn[SPEAKER] = 1; mOOMKilling = false; MediaPlayerFactory::registerBuiltinFactories(); }说明：MediaPlayerService的构造函数比较简单，就是进行一些变量的初始化。 4. BpServiceManager::addService()class BpServiceManager : public BpInterface&lt;IServiceManager&gt; { public: ... virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service, bool allowIsolated) { Parcel data, reply; data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); data.writeStrongBinder(service); data.writeInt32(allowIsolated ? 1 : 0); status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); return err == NO_ERROR ? reply.readExceptionCode() : err; } ... }说明：该代码在frameworks/native/libs/binder/IServiceManager.cpp中。addService()会现将MediaPlayerService服务的名称(“media.player”)以及它的实例等参数保存到data(Parcel对象)中，然后再调用remote()返回的BpBinder对象的transact()与Binder驱动进行交互。(01) 先看看addService()的各个参数。name=”media.player”，即MediaPlayerService服务的名称；service就是MediaPlayerService对象，而IBinder是MediaPlayerService的父类；allowIsolated这个值默认为false，默认值的定义在frameworks/native/include/binder/IServiceManager.h的addService()函数声明中。(02) Parcel是Binder通信的数据存储结构，它的各个成员和函数在Android Binder机制(二) Binder中的数据结构中有详细说明。在向data中写入数据时，先通过writeInterfaceToken()写入数据头，这里的数据头是：int32的整形数+字符串(字符串是”android.os.IServiceManager”)。writeString16(name)写入的是服务的名称，即”media.player”。writeStrongBinder(service)是将MediaPlayerService封装到flat_binder_object结构体中。最后的writeInt32()暂时不用关心。下面，我们逐个对data的赋值进行介绍。 5. Parcel::Parcel()先看看Parcel的构造函数。 Parcel::Parcel() { initState(); } 说明：该代码在frameworks/native/libs/binder/Parcel.cpp中。 6. Parcel::initState()void Parcel::initState() { mError = NO_ERROR; mData = 0; // 数据的地址指针 mDataSize = 0; // 数据的大小 mDataCapacity = 0; // 数据的容量 mDataPos = 0; // 数据的位置 mObjects = NULL; // 保存对象的地址指针 mObjectsSize = 0; // 对象的个数 mObjectsCapacity = 0; // 对象的容量 mNextObjectHint = 0; mHasFds = false; mFdsKnown = true; mAllowFds = true; mOwner = NULL; }说明：该函数对Parcel的成员进行了初始化。 7. Parcel::writeInterfaceToken()下面看看data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor())的实现。getInterfaceDescriptor()是通过宏IMPLEMENT_META_INTERFACE()实现的，该宏已经在[Android Binder机制(四) defaultServiceManager()的实现][link_binder_04_defaultServiceManager]中介绍过了；getInterfaceDescriptor()的返回值是&quot;android.os.IServiceManager&quot;。 即data.writeInterfaceToken(&quot;android.os.IServiceManager&quot;)。下面看看writeInterfaceToken()的实现。 status_t Parcel::writeInterfaceToken(const String16&amp; interface) { writeInt32(IPCThreadState::self()-&gt;getStrictModePolicy() | STRICT_MODE_PENALTY_GATHER); // currently the interface identification token is just its name as a string return writeString16(interface); } 说明：该函数先通过writeInt32()写入一个32位的int数到Parcel中，然后再通过writeString16()将字符串写入到Parcel中。它所写入的是数据头，ServiceManager中收到该数据之后，会先获取数据头，并根据数据头来判断数据的有效性！(01) IPCThreadState::self()返回IPCThreadState对象；然后，调用IPCThreadState::getStrictModePolicy()，返回的是mStrictModePolicy，mStrictModePolicy的初始值是0。因此，writeInt32()就可以简化为writeInt32(STRICT_MODE_PENALTY_GATHER)。(02) writeString16(interface)是writeString16(“android.os.IServiceManager”)。 8. Parcel::writeInt32()status_t Parcel::writeInt32(int32_t val) { return writeAligned(val); } 说明：该函数调用writeAligned()。 9. Parcel::writeAligned()template&lt;class T&gt; status_t Parcel::writeAligned(T val) { COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T)); if ((mDataPos+sizeof(val)) &lt;= mDataCapacity) { restart_write: *reinterpret_cast&lt;T*&gt;(mData+mDataPos) = val; return finishWrite(sizeof(val)); } status_t err = growData(sizeof(val)); if (err == NO_ERROR) goto restart_write; return err; }说明：writeAligned()的作用是是写入数据，比同步相应的变量。(01) mDataPos的初始值=0，sizeof(val)=4，mDataCapacity的初始值=0。因此，if((mDataPos+sizeof(val)) &lt;= mDataCapacity)为false。(02) 接下来，会先调用growData(sizeof(val))来增加容量，然后再将数据写入到mData中。 10. Parcel::growData()status_t Parcel::growData(size_t len) { size_t newSize = ((mDataSize+len)*3)/2; return (newSize &lt;= mDataSize) ? (status_t) NO_MEMORY : continueWrite(newSize); }说明：Parcel增加容量时，是按1.5倍进行增长。mDataSize=0，而len=4；因此会执行continueWrite(6)。 11. Parcel::continueWrite()status_t Parcel::continueWrite(size_t desired) { size_t objectsSize = mObjectsSize; ... if (mOwner) { ... } else if (mData) { ... // We own the data, so we can just do a realloc(). if (desired &gt; mDataCapacity) { uint8_t* data = (uint8_t*)realloc(mData, desired); if (data) { mData = data; mDataCapacity = desired; } else if (desired &gt; mDataCapacity) { ... } } else { ... } } else { ... } return NO_ERROR; }说明：mObjectsSize的初始值为0，mOwner的初始值为NULL，mData非空；并且，desired=6，mDataCapacity=0。因此，会调用realloc()给mData重新分配内存大小为6字节。分配成功后，更新”数据地址mData”和”数据容量mDataCapacity=6”。 接下来，回到writeAligned()中，它会跳转到restart_write标签处。先将int32_t的整形数保存到mData中，然后再调用finishWrite()进行同步。 12. Parcel::finishWrite()status_t Parcel::finishWrite(size_t len) { mDataPos += len; if (mDataPos &gt; mDataSize) { mDataSize = mDataPos; ... } return NO_ERROR; }说明：前面已经将数据写入到mData中，现在就通过finishWrite()来改变数据的当前指针位置(方便下一次写入)和数据的大小。(01) len是int32_t的大小，很显然是4个字节，len=4。所以，mDataPos=4。(02) mDataPos=4，mDataSize=0；因此if(mDataPos&gt;mDataSize)为true，所以，mDataSize=4。 此时，就分析完了writeInterfaceToken()中的writeInt32()就分析完毕了.mData：它的第0~3个字节保存了int32_t类型的数据STRICT_MODE_PENALTY_GATHER。mDataPos：值为4，即下一个写入mData中的数据从第4个字节开始。mDataSize：值为4，即mData中数据的大小。mDataCapacity：值为6，即mData的数据容量为6字节。此时，mData的数据如下图所示： 接下来，看看再writeString16(“android.os.IServiceManager”)如何将字符串写入到Parcel中。 13. Parcel::writeString16()status_t Parcel::writeString16(const String16&amp; str) { return writeString16(str.string(), str.size()); } status_t Parcel::writeString16(const char16_t* str, size_t len) { if (str == NULL) return writeInt32(-1); // 将字符串长度写入到Parcel中 status_t err = writeInt32(len); if (err == NO_ERROR) { len *= sizeof(char16_t); // 在将字符串写入之前，增加mData的容量 uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t)); if (data) { // 将字符串拷贝到mData中 memcpy(data, str, len); // 字符串结束符 *reinterpret_cast&lt;char16_t*&gt;(data+len) = 0; return NO_ERROR; } err = mError; } return err; }说明：writeString16()是重载函数。(01) writeString16(str, len)中，str=”android.os.IServiceManager”；len是由str.size()得来，虽然这里的字符串是String16类型(即每个字符占2个字节)，但是str.size()是获取str中有效数据的个数(不包含字符串结束符)，因此，len=26。(02) 首先调用writeInt32(len)将字符串的长度写入到Parcel中，writeInt32()在前面已经介绍过了。当再次写入int32_t类型的数据时，数据容量不够，会再次增长为12，即mDataCapacity=12；而写入int32_t类型的数据之后，mDataPos和mDataSize都增长为8。 此时，mData的数据如下图所示： 在通过writeInt32(len)写入数据长度之后，再重新计算len=52；接着，通过writeInplace()写入数据。 14. Parcel::writeInplace()#define PAD_SIZE(s) (((s)+3)&amp;~3) void* Parcel::writeInplace(size_t len) { // 4字节对齐 const size_t padded = PAD_SIZE(len); ... if ((mDataPos+padded) &lt;= mDataCapacity) { restart_write: uint8_t* const data = mData+mDataPos; // 如果padded!=len，则根据大端法还是小端法进行地址对齐设置。 if (padded != len) { ... } finishWrite(padded); return data; } status_t err = growData(padded); if (err == NO_ERROR) goto restart_write; return NULL; }说明：参数len=54。(01) PAD_SIZE()是4字节对齐的宏，PAD_SIZE(54)=56。(02) 函数的初始值为padded=56，mDataPos=8，mDataCapacity=12。因此，会先调用growData(padded)来增加数据容量。growData()在前面已经介绍过；此时，它会将容量mDataCapacity增加至96。(03) 接着会跳转到restart_write标签处，然后调用finishWrite(padded)来更新mDataPos和mDataSize。 至此，writeInplace()就分析完了，它的作用就是增加mData的容量，并返回即将写入数据的地址。接着，回到writeString16()中，执行mmap(data, str, len)将数据拷贝到mData中；拷贝完毕之后，设置字符串的结束符为0。 status_t Parcel::writeString16(const char16_t* str, size_t len) { if (str == NULL) return writeInt32(-1); // 将字符串长度写入到Parcel中 status_t err = writeInt32(len); if (err == NO_ERROR) { len *= sizeof(char16_t); // 在将字符串写入之前，增加mData的容量 uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t)); if (data) { // 将字符串拷贝到mData中 memcpy(data, str, len); // 字符串结束符 *reinterpret_cast&lt;char16_t*&gt;(data+len) = 0; return NO_ERROR; } err = mError; } return err; } 这样，data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor())就分析完了。此时，mData中数据如下图所示： 15. Parcel::writeString16()继续回到addService()中，接着会通过data.writeString16(name)将MediaPlayerService服务的名称写入到data中，此处的name=”media.player”。在前面已经详细介绍过writeString16()，这里执行完该语句后，mData中的数据如下： 接着，addService()会调用data.writeStrongBinder(service)将MediaPlayerService对象写入到data中。这个数据最重要，下面分析下writeStrongBinder()的实现。 16. Parcel::writeStrongBinder()status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val) { return flatten_binder(ProcessState::self(), val, this); }说明：该函数调用flatten_binder()将数据打包。 17. Parcel::flatten_binder()status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; proc, const sp&lt;IBinder&gt;&amp; binder, Parcel* out) { flat_binder_object obj; obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS; if (binder != NULL) { IBinder *local = binder-&gt;localBinder(); if (!local) { ... } else { obj.type = BINDER_TYPE_BINDER; obj.binder = local-&gt;getWeakRefs(); obj.cookie = local; } } else { ... } return finish_flatten_binder(binder, obj, out); }说明：该函数是将MediaPlayerService对象封装到结构体flat_binder_object中。Binder驱动认识flat_binder_object结构体类型的数据，在C++层将数据发送给Binder驱动后，Binder驱动能够解析该结构体。(01) 先看看参数，proc是ProcessState对象，binder是MediaPlayerService对象，out是Parcel自己。(02) binder不为NULL，因此，执行if(binder!=NULL)中的语句。binder-&gt;localBinder()返回的BBinder对象，即本地Binder对象。(BBinder是MediaPlayerService的父类，localBinder()函数在frameworks/native/libs/binder/Binder.cpp中实现)。因此，local不为NULL。 obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS; // 标记 obj.type = BINDER_TYPE_BINDER; // 类型 obj.binder = local-&gt;getWeakRefs(); // MediaPlayerService的弱引用 obj.cookie = local; // MediaPlayerService自身注意：从这里就可以看出，MediaPlayerService添加服务时，发送给驱动的数据是MediaPlayerService的本地Binder对象，即BBinder实例。准确的来说，该数据是保存在obj.cookie中的，该数据的类型是BINDER_TYPE_BINDER。 (03) 调用finish_flatten_binder()将数据写入到Parcel中。 18. Parcel::finish_flatten_binder()inline static status_t finish_flatten_binder( const sp&lt;IBinder&gt;&amp; binder, const flat_binder_object&amp; flat, Parcel* out) { return out-&gt;writeObject(flat, false); } 说明：该函数是flat_binder_object对象写入到Parcel中。 19. Parcel::writeObject()status_t Parcel::writeObject(const flat_binder_object&amp; val, bool nullMetaData) { const bool enoughData = (mDataPos+sizeof(val)) &lt;= mDataCapacity; const bool enoughObjects = mObjectsSize &lt; mObjectsCapacity; if (enoughData &amp;&amp; enoughObjects) { restart_write: *reinterpret_cast&lt;flat_binder_object*&gt;(mData+mDataPos) = val; // val.binder非空 if (nullMetaData || val.binder != NULL) { // 将地址偏移位置保存到mObjects[0]中 mObjects[mObjectsSize] = mDataPos; acquire_object(ProcessState::self(), val, this); // 增加mObjectsSize的值 mObjectsSize++; } ... return finishWrite(sizeof(flat_binder_object)); } if (!enoughData) { const status_t err = growData(sizeof(val)); if (err != NO_ERROR) return err; } if (!enoughObjects) { // 增加容量 size_t newSize = ((mObjectsSize+2)*3)/2; // 分配内存 size_t* objects = (size_t*)realloc(mObjects, newSize*sizeof(size_t)); if (objects == NULL) return NO_MEMORY; // 设置mObjects的内存地址起始地址 mObjects = objects; // 设置mObjects对象的容量 mObjectsCapacity = newSize; } goto restart_write; }说明：(01) 此时，mDataPos=96, sizeof(val)=32, mDataCapacity=96；因此，enoughData=false。mObjectsSize和mObjectsCapacity的初始值=0，因此，enoughObjects=false。(02) 首先，执行if(!enoughData)部分，通过growData()将数据的容量增加至192。即，mDataCapacity=192。(03) 接着，执行if(!enoughObjects)部分，该部分的目的是分配对象空间，并修改mObjects和mObjectsCapacity的值。增加之后的容量mObjectsCapacity=3。(04) 然后，跳转到restart_write标签处。 reinterpret_cast&lt;flat_binder_object&gt;(mData+mDataPos) = val是保存val对象到mDataPos+mDataPos所指的地址中。(04) mObjects[mObjectsSize]=mDataPos，此处的mObjectsSize=0；这里是将对象的地址偏移mDataPos保存到mObjects[0]中。随后执行mObjectsSize++增加mObjectsSize的值为1。(05) 最后，调用finishWrite()更新mDataPos和mDataSize的值。 至此，data.writeStrongBinder()就分析完了。将MediaPlayerService写入data之后，它的数据如下图所示： 最后，调用data.writeInt32(allowIsolated ? 1 : 0)。allowIsolated为false，因此，data.writeInt32(0)。执行该函数之后，data的数据如下图所示： 以上就是addService()中的data的数据。接下来执行remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply)。前面已经说过，remote()返回的是BpBinder对象，该BpBinder对象是在Android Binder机制(四) defaultServiceManager()的实现中调用defaultServiceManager()时初始化的。下面查看BpBinder的transact()。 20. BpBinder::transact()status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) { // mAlive的初始值为1 if (mAlive) { status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; } return DEAD_OBJECT; }说明：该代码在frameworks/native/libs/binder/BpBinder.cpp中。由于mAlive的初始值为1，因此该函数会调用IPCThreadState::self()-&gt;transact()。我们知道，IPCThreadState::self()是获取全局IPCThreadState对象，因此最终会调用IPCThreadState::transact()。 21. IPCThreadState::transact()status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) { status_t err = data.errorCheck(); flags |= TF_ACCEPT_FDS; ... if (err == NO_ERROR) { ... err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); } ... if ((flags &amp; TF_ONE_WAY) == 0) { if (reply) { err = waitForResponse(reply); } else { ... } } else { ... } return err; }说明：该代码在frameworks/native/libs/binder/IPCThreadState.cpp中。(01) 先看看函数的参数。handle是BpBinder中的mHandle对象，BpBinder中的mHandle是ServiceManager的句柄，值为0。code=ADD_SERVICE_TRANSACTION。data就是在addService中设置的Parcel对象。reply是用来接收Binder驱动反馈数据的Parcel对象。flags是默认值0。(02) 该函数会先通过writeTransactionData()将数据打包。(03) flags的初始化为0，并且reply非空。因此，将数据打包号之后，会调用waitForResponse()将数据发送给Binder驱动，然后等待Binder驱动反馈。 22. IPCThreadState::writeTransactionData()status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer) { binder_transaction_data tr; tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) { tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t); tr.data.ptr.offsets = data.ipcObjects(); } else if (statusBuffer) { .. } else { ... } mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR; }说明：该函数会读取Parcel中的数据，然后将其打包到binder_transaction_data结构体中。binder_transaction_data结构体是Binder驱动能够识别并对之进行解析的数据结构。 ipcDataSize()是返回mDataSize，ipcData()是返回mData，ipcObjectsCount()是返回mObjectsSize，而ipcObjects则是返回mObjects。这些数据就是前面我们在addService中分析的Parcel对象的数据。下面给出初始化之后tr的值。 tr.target.handle = handle; // 0，即Service Manager的句柄 tr.code = code; // ADD_SERVICE_TRANSACTION tr.flags = binderFlags; // TF_ACCEPT_FDS tr.cookie = 0; tr.sender_pid = 0; tr.data_size = data.ipcDataSize(); // 数据大小(对应mDataSize) tr.data.ptr.buffer = data.ipcData(); // 数据的起始地址(对应mData) tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t); // data中保存的对象个数(对应mObjectsSize) tr.data.ptr.offsets = data.ipcObjects(); // data中保存的对象的偏移地址数组(对应mObjects)初始化tr之后，将cmd=BC_TRANSACTION和tr重新打包到mOut中。mOut中的数据将来会被以请求的方式发送给Binder驱动。重新打包后的数据如下图所示： 在上图中，mOut包含了”事务指令”+”binder_transaction_data”结构体对象。而具体的MediaPlayerService对象，则包含在binder_transaction_data的data数据区域；它是被封装在flat_binder_object结构体中的。 23. IPCThreadState::waitForResponse()writeTransactionData()分析完毕之后，再看看waitForResponse()的代码。 status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult) { int32_t cmd; int32_t err; while (1) { // 先通过talkWithDriver()和Binder驱动交互 if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... if (mIn.dataAvail() == 0) continue; // 然后读取返回结果，再根据结果进行处理 cmd = mIn.readInt32(); switch (cmd) { case BR_TRANSACTION_COMPLETE: ... case BR_DEAD_REPLY: ... case BR_FAILED_REPLY: ... case BR_ACQUIRE_RESULT: ... case BR_REPLY: ... default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; } } finish: ... return err; }说明：waitForResponse()会先调用talkWithDriver()和Binder驱动交互，然后根据反馈结果来进行处理。 24. IPCThreadState::talkWithDriver()status_t IPCThreadState::talkWithDriver(bool doReceive) { ... binder_write_read bwr; // Is the read buffer empty? const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (long unsigned int)mOut.data(); // This is what we&apos;ll read. if (doReceive &amp;&amp; needRead) { bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (long unsigned int)mIn.data(); } else { bwr.read_size = 0; bwr.read_buffer = 0; } ... if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do { ... if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else ... ... } while (err == -EINTR); ... if (err &gt;= NO_ERROR) { // 清空已写的数据 if (bwr.write_consumed &gt; 0) { if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); } // 设置已读数据 if (bwr.read_consumed &gt; 0) { mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); } ... return NO_ERROR; } return err; }说明：talkWithDriver()会先初始化bwr(binder_write_read类型的变量)，然后将bwr变量通过ioctl()发送给Binder驱动。该函数的参数doReceive的默认值为true。(01) 现在，mIn中还没有被写入数据，因此它的值都是初始值。那么，mIn.dataPosition()返回mDataPos，它的值为0；mIn.dataSize()返回mDataSize，它的初始值也为0。因此，needRead=true。(02) doReceive=true，但是needRead=true；因此，outAvail=mOut.dataSize，outAvail不为0。接下来，就对bwr进行初始化，关于bwr的介绍，请参考Android Binder机制(二) Binder中的数据结构。bwr初始化完毕之后，各个成员的值如下： bwr.write_size = outAvail; // mOut中数据大小，大于0 bwr.write_buffer = (long unsigned int)mOut.data(); // mOut中数据的地址 bwr.write_consumed = 0; bwr.read_size = mIn.dataCapacity(); // 256 bwr.read_buffer = (long unsigned int)mIn.data(); // mIn.mData，实际上为空 bwr.read_consumed = 0;(03) bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。 通过binder_write_read再次打包后的数据如下图所示： 如上图所示，ioctl()传输的数据包含”BINDER_WRITE_READ”+”binder_write_read结构体对象”。在binder_write_read的write_buffer中包含了事务数据；而在数据数据的data中又包含了flat_binder_object等数据。在flat_binder_object中就包含了需要传输的MediaPlayerService对象。总体来看，数据经过了三次封装。下面看看在Binder驱动中是如何一层层将它们剖析开来的。 25. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // 中断等待函数。 // 1. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。 // 2. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。 // 当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时； // 则继续执行；否则，再进入等待状态。 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); binder_lock(__func__); // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。 thread = binder_get_thread(proc); ... switch (cmd) { case BINDER_WRITE_READ: { struct binder_write_read bwr; ... // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot; if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) { ... } // 如果write_size&gt;0，则进行写操作 if (bwr.write_size &gt; 0) { ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... } // 如果read_size&gt;0，则进行读操作 if (bwr.read_size &gt; 0) { ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... } ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) { ret = -EFAULT; goto err; } break; } ... } ret = 0; ... return ret; }说明：关于该函数在Android Binder机制(三) ServiceManager守护进程中已经介绍过了。这里将binder_write_read从用户空间拷贝到内核空间之后，读取bwr.write_size和bwr.read_size都&gt;0，因此先写后读。 26. Binder驱动中binder_thread_write()的源码int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed) { uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) { // 从用户空间读取32bit到内核中，并赋值给cmd。 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) { ... case BC_TRANSACTION: case BC_REPLY: { struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; } ... } // 更新bwr.write_consumed的值 *consumed = ptr - buffer; } return 0; }说明：读取出来的交易码是BC_TRANSACTION。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。 27. Binder驱动中binder_transaction()的源码static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply) { struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) { ... } else { if (tr-&gt;target.handle) { ... } else { // 事务目标对象是ServiceManager的binder实体 // 即，该事务是交给Service Manager来处理的。 target_node = binder_context_mgr_node; ... } ... // 设置处理事务的目标进程 target_proc = target_node-&gt;proc; ... } if (target_thread) { ... } else { target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; } ... // 分配一个待处理的事务t，t是binder事务(binder_transaction对象) t = kzalloc(sizeof(*t), GFP_KERNEL); ... // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。 tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); ... t-&gt;debug_id = ++binder_last_id; ... // 设置from，表示该事务是MediaPlayerService发起的 if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 下面的一些赋值是初始化事务t t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; // 事务将交给target_proc进程进行处理 t-&gt;to_proc = target_proc; // 事务将交给target_thread线程进行处理 t-&gt;to_thread = target_thread; // 事务编码 t-&gt;code = tr-&gt;code; // 事务标志 t-&gt;flags = tr-&gt;flags; // 事务优先级 t-&gt;priority = task_nice(current); ... // 分配空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); ... t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; // 保存事务 t-&gt;buffer-&gt;transaction = t; // 保存事务的目标对象(即处理该事务的binder对象) t-&gt;buffer-&gt;target_node = target_node; trace_binder_transaction_alloc_buf(t-&gt;buffer); if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 将&quot;用户空间的数据&quot;拷贝到内核中 // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小 if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) { ... } // 将&quot;用户空间的数据中所含对象的偏移地址&quot;拷贝到内核中 // tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数 // 拷贝之后，offp就是flat_binder_object对象数组在内核空间的偏移数组的起始地址 if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) { ... } ... // off_end就是flat_binder_object对象数组在内核空间的偏移地址的结束地址 off_end = (void *)offp + tr-&gt;offsets_size; // 将所有的flat_binder_object对象读取出来 // 对MediaPlayerService而言，只有一个flat_binder_object对象。 for (; offp &lt; off_end; offp++) { struct flat_binder_object *fp; ... fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); switch (fp-&gt;type) { case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: { struct binder_ref *ref; // 在proc中查找binder实体对应的binder_node struct binder_node *node = binder_get_node(proc, fp-&gt;binder); // 若找不到，则新建一个binder_node；下次就可以直接使用了。 if (node == NULL) { node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); if (node == NULL) { ... } node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK; node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS); } ... // 在target_proc(即，ServiceManager的进程上下文)中查找是否包行&quot;该Binder实体的引用&quot;， // 如果没有找到的话，则将&quot;该binder实体的引用&quot;添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该 Binder实体进行管理了。 ref = binder_get_ref_for_node(target_proc, node); if (ref == NULL) { ... } // 修改type if (fp-&gt;type == BINDER_TYPE_BINDER) fp-&gt;type = BINDER_TYPE_HANDLE; else fp-&gt;type = BINDER_TYPE_WEAK_HANDLE; // 修改handle。handle和binder是联合体，这里将handle设为引用的描述。 // 根据该handle可以找到&quot;该binder实体在target_proc中的binder引用&quot;； // 即，可以根据该handle，可以从Service Manager找到对应的Binder实体的引用，从而获取Binder实体。 fp-&gt;handle = ref-&gt;desc; // 增加引用计数，防止&quot;该binder实体&quot;在使用过程中被销毁。 binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); trace_binder_transaction_node_to_ref(t, node, ref); ... } break; ... } } if (reply) { .. } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) { BUG_ON(t-&gt;buffer-&gt;async_transaction != 0); t-&gt;need_reply = 1; t-&gt;from_parent = thread-&gt;transaction_stack; // 将当前事务添加到当前线程的事务栈中 thread-&gt;transaction_stack = t; } else { ... } // 设置事务的类型为BINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // 将事务添加到target_list队列中，即target_list的待处理事务中 list_add_tail(&amp;t-&gt;work.entry, target_list); // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。 list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // 唤醒目标进程 if (target_wait) wake_up_interruptible(target_wait); return; ... }说明：这里的tr-&gt;target.handle=0，因此，会设置target_node为ServiceManager对应的Binder实体。下面是target_node,target_proc等值初始化之后的值。 target_node = binder_context_mgr_node; // 目标节点为Service Manager对应的Binder实体 target_proc = target_node-&gt;proc; // 目标进程为Service Manager对应的binder_proc进程上下文信息 target_list = &amp;target_thread-&gt;todo; // 待处理事务队列 target_wait = &amp;target_thread-&gt;wait; // 等待队列目标节点是Service Manager对应的Binder实体。这是指MediaPlayerService的addService()这个指令是来提交给Service Manager进行处理的，它最终会发送给Service Manager进行处理。。 在初始化完target_node等目标节点之后，会新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。待处理事务t会被提交给目标(即ServiceManager对应的Binder实体)进行处理；而待完成的工作tcomplete则是为了反馈给MediaPlayerService服务，告诉MediaPlayerService它的请求Binder驱动已经收到了。注意，这里仅仅是告诉MediaPlayerService该请求已经被收到，而不是处理完毕！待ServiceManager处理完毕该请求之后，Binder驱动会再次反馈相应的消息给MediaPlayerService。 // 分配一个待处理的事务t，t是binder事务(binder_transaction对象) t = kzalloc(sizeof(*t), GFP_KERNEL); ... // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。 tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); ... t-&gt;debug_id = ++binder_last_id; ... if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 下面的一些赋值是初始化事务t t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; // 事务将交给target_proc进程进行处理 t-&gt;to_proc = target_proc; // 事务将交给target_thread线程进行处理 t-&gt;to_thread = target_thread; // 事务编码 t-&gt;code = tr-&gt;code; // 事务标志 t-&gt;flags = tr-&gt;flags; // 事务优先级 t-&gt;priority = task_nice(current); ... // 分配空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); ... t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; // 保存事务 t-&gt;buffer-&gt;transaction = t; // 保存事务的目标对象(即处理该事务的binder对象) t-&gt;buffer-&gt;target_node = target_node; trace_binder_transaction_alloc_buf(t-&gt;buffer); if (target_node) binder_inc_node(target_node, 1, 0, NULL);在初始化完待处理事务t之后，接着将MediaPlayerService请求的数据拷贝到内核空间并解析出来。从数据中解析出MediaPlayerService请求数据中的flat_binder_object对象，只有一个flat_binder_object对象。该flat_binder_object对象的类型是BINDER_TYPE_BINDER，然后调用binder_get_node()在当前进程的上下文环境proc中查找fp-&gt;binder对应的Binder实体，fp-&gt;binder是Android的flatten_binder()中赋值的，它是MediaPlayerService对象的本地引用的描述(即MediaPlayerService对应的BBinder对象的描述)；此外，在MediaPlayerService是初次与Binder驱动通信，因此肯定找不到该对象fp-&gt;binder对应的Binder实体；因此node=NULL。 接下来，就调用binder_new_node()新建fp-&gt;binder对应的Binder实体，这也就是MediaPlayerService对应的Binder实体。然后，调用binder_get_ref_for_node(target_proc, node)获取该Binder实体在target_proc(即ServiceManager的进程上下文环境)中的Binder引用，此时，在target_proc中肯定也找不到该Binder实体对应的引用；那么，就新建Binder实体的引用，并将其添加到target_proc-&gt;refs_by_node红黑树 和 target_proc-&gt;refs_by_desc红黑树中。 这样，Service Manager的进程上下文中就存在MediaPlayerService的Binder引用，Service Manager也就可以对MediaPlayerService进行管理了！ 然后，修改fp-&gt;type=BINDER_TYPE_HANDLE，并使fp-&gt;handle = ref-&gt;desc。 这样，就将MediaPlayerService的请求数据解析出来，并且在Binder驱动中创建了MediaPlayerService对应的Binder实体，而且将该Binder实体添加到MediaPlayerService的进程上下文proc中。更重要的是，在ServiceManager的refs_by_node和refs_by_desc这两颗红黑树中创建了”MediaPlayerService对应的Binder实体的Binder引用”。这意味着，在Binder驱动中，已经能在ServiceManager的进程上下文中找到MediaPlayerService。 // 将&quot;用户空间的数据&quot;拷贝到内核中 // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小 if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) { ... } // 将&quot;用户空间的数据中所含对象的偏移地址&quot;拷贝到内核中 // tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数 // 拷贝之后，offp就是flat_binder_object对象数组在内核空间的起始地址 if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) { ... } ... // off_end就是flat_binder_object对象数组在内核空间的结束地址 off_end = (void *)offp + tr-&gt;offsets_size; // 将所有的flat_binder_object对象读取出来 // 对MediaPlayerService而言，只有一个flat_binder_object对象。 for (; offp &lt; off_end; offp++) { struct flat_binder_object *fp; ... fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); switch (fp-&gt;type) { case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: { struct binder_ref *ref; // 在proc中查找binder实体对应的binder_node struct binder_node *node = binder_get_node(proc, fp-&gt;binder); // 若找不到，则新建一个binder_node；下次就可以直接使用了。 if (node == NULL) { node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); if (node == NULL) { ... } node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK; node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS); } ... // 在target_proc(即，Service Manager的进程上下文)中查找是否包行&quot;该binder实体的引用&quot;， // 如果没有找到的话，则将&quot;该binder实体的引用&quot;添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该 Binder实体进行管理了。 ref = binder_get_ref_for_node(target_proc, node); if (ref == NULL) { ... } // 修改type if (fp-&gt;type == BINDER_TYPE_BINDER) fp-&gt;type = BINDER_TYPE_HANDLE; else fp-&gt;type = BINDER_TYPE_WEAK_HANDLE; // 修改handle。handle和binder是联合体，这里将handle设为引用的描述。 // 根据该handle可以找到&quot;该binder实体在target_proc中的binder引用&quot;； // 即，可以根据该handle，可以从Service Manager找到对应的binder实体的引用，从而获取binder实体。 fp-&gt;handle = ref-&gt;desc; // 增加引用计数，防止&quot;该binder实体&quot;在使用过程中被销毁。 binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); trace_binder_transaction_node_to_ref(t, node, ref); ... } break; ... } }然后，设置待处理事务的类型为BINDER_WORK_TRANSACTION，并将其添加到target_list中。即，添加事务到Service Manager对应的待处理事务队列中。设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE，并将其添加到当前线程的待完成工作中。此时，Binder驱动已经收到了MediaPlayerService的请求，这个所谓的待完成工作，就是用来让Binder驱动告诉MediaPlayerService，它的请求已经被处理了。最后，target_wait是ServiceManager的等待队列，肯定不为空(因为前面刚刚将BINDER_WORK_TRANSACTION事务添加到待处理事务中)。因此，便会执行wake_up_interruptible(target_wait)唤醒Service Manager进程。注意，此时都是运行在MediaPlayerService的进程中的！ // 设置事务的类型为BINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // 将事务添加到target_list队列中，即target_list的待处理事务中 list_add_tail(&amp;t-&gt;work.entry, target_list); // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。 list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // 唤醒目标进程 if (target_wait) wake_up_interruptible(target_wait); return;此时，MediaPlayerService进程还会继续运行，而且它也通过wake_up_interruptible()唤醒了ServiceManager进程。ServiceManager被唤醒后，所做的工作就是将MediaPlayerService注册到它的服务队列中进行管理；它的具体流程稍候再分析，现在还是先分析完MediaPlayerService进程。 至此，binder_transaction()就分析完了。在binder_transaction()中，我们主要进行了以下工作：(01) 解析出来MediaPlayerService的请求数据。(02) 新建MediaPlayerService对应的Binder实体和Binder引用，并将ServiceManager的进程上下文中存在MediaPlayerService的Binder引用。(03) 新建了待处理事务，并将该事务添加到了ServiceManager的待处理事务队列中。然后，唤醒ServiceManager来处理该事务。(04) 新建了待完成工作，并将待完成工作添加到了当前线程的待完成工作队列中。 28. Binder驱动中binder_thread_write()的源码接着分析MediaPlayerService进程的工作。binder_thread_write()中执行binder_transaction()后，会更新*consumed的值，即bwr.write_consumed的值。意味着，Binder驱动已经驱动完成MediaPlayerService的请求数据。 int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed) { uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 读取binder_write_read.write_buffer中的内容。 // 每次读取32bit(即4个字节) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) { // 从用户空间读取32bit到内核中，并赋值给cmd。 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) { ... case BC_TRANSACTION: case BC_REPLY: { struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; } ... } // 更新bwr.write_consumed的值 *consumed = ptr - buffer; } return 0; } 29. Binder驱动中binder_thread_read()的源码接下来，ioctl()会执行binder_thread_read()来设置反馈数据给MediaPlayerService进程。 static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) { void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区 if (*consumed == 0) { if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); } retry: // 等待proc进程的事务标记。 // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。 wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); ... if (wait_for_proc_work) { ... } else { if (non_block) { ... } else ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread)); } ... while (1) { uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... else { if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */ goto retry; break; } ... switch (w-&gt;type) { ... case BINDER_WORK_TRANSACTION_COMPLETE: { cmd = BR_TRANSACTION_COMPLETE; // 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); binder_stat_br(proc, thread, cmd); ... // 待完成事务已经处理完毕，将其从待完成事务队列中删除。 list_del(&amp;w-&gt;entry); kfree(w); binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE); } break; ... } if (!t) continue; ... } ... // 更新bwr.read_consumed的值 *consumed = ptr - buffer; ... return 0; }说明：(01) 先看看函数的参数，buffer是bwr.read_buffer，是反馈数据缓冲区。size是bwr.read_size，是缓冲区大小，为256字节；而consumed是指向bwr.read_consumed的，它的值是0，表示反馈数据还没有被MediaPlayerService读取过。non_block为0。(02) consumed=0，因此会先将BR_NOOP从内核空间拷贝到用户空间，即拷贝到bwr.read_buffer中。(03) 在binder_transaction()中，我们有添加待完成工作到thread的待完成工作队列中。因此，wait_for_proc_work是false。(04) binder_has_thread_work(thread)为ture，因此wait_event_interruptible()不会进入中断等待状态，而是继续往下运行。(05) 接着，进入while循环。list_empty(&amp;thread-&gt;todo)为flase，执行list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry)从thread的待完成工作队列中取出待完成的工作t。(06) 根据binder_transaction()中的分析可知，t-&gt;type的值为BINDER_WORK_TRANSACTION_COMPLETE。执行对应的case分支，会将数据cmd=BR_TRANSACTION_COMPLETE拷贝到用户空间，即bwr.read_buffer中。拷贝之后，即代表该工作已完成，然后从当前线程的工作队列中将该工作删除，并释放所分配的空间。(07) 由于t=null，因此，会再次从头开始执行while循环。而此时，list_empty(&amp;thread-&gt;todo)为true，并且list_empty(&amp;proc-&gt;todo)也为true；因此会执行break跳出while循环。(08) 在跳出while循环之后，会更新consumed的值。即，更新bwr.read_consumed的值。此时，由于写入了BR_NOOP和BR_TRANSACTION_COMPLETE两个指令，bwr.read_consumed=8。 接下来，回到binder_ioctl()中。将bwr数据拷贝到用户空间后返回。此时，bwr中各个参数的值如下： bwr.write_size = outAvail; bwr.write_buffer = (long unsigned int)mOut.data(); bwr.write_consumed = outAvail; // 等于write_size bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (long unsigned int)mIn.data(); // 存储了BR_NOOP和BR_TRANSACTION_COMPLETE两个返回指令 bwr.read_consumed = 8; // 等于write_sizebwr中的write_参数是保存”MediaPlayerService发送给Binder驱动的请求内容的”，而read_则是保存”Binder驱动反馈给MediaPlayerService的内容的”。此时，write_consumed和write_size相同，意味着”Binder驱动已经将请求的内容都处理完毕了”；而read_consumed&gt;0，则意味着”Binder驱动有反馈内容给MediaPlayerService”。回到talkWithDriver()中，看看ioctl()之后做了些什么？ 30. IPCThreadState::talkWithDriver()status_t IPCThreadState::talkWithDriver(bool doReceive) { ... do { ... if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else ... ... } while (err == -EINTR); ... if (err &gt;= NO_ERROR) { // 清空已写的数据 if (bwr.write_consumed &gt; 0) { if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize()) ... else mOut.setDataSize(0); } // 设置已读数据 if (bwr.read_consumed &gt; 0) { mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); } ... return NO_ERROR; } return err; }说明：ioctl()返回值为0，err=NO_ERROR，退出while循环。(01) bwr.write_consumed&gt;0，并且bwr.write_consumed=mOut.dataSize。因此，调用mOut.setDataSize(0)将释放mOut的内存，并且将mOut的mDataSize和mObjectsSize设为0。(02) bwr.read_consumed&gt;0，因此调用mIn.setDataSize()为mIn分配空间，并将mIn的mDataSize设为=bwr.read_consumed。然后，将位置mDataPos初始化为0。之后，跳出talkWithDriver()，返回到waitForResponse()中。 31. IPCThreadState::waitForResponse()status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult) { int32_t cmd; int32_t err; while (1) { // 先通过talkWithDriver()和Binder驱动交互 if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; if (mIn.dataAvail() == 0) continue; // 然后读取返回结果，再根据结果进行处理 cmd = mIn.readInt32(); switch (cmd) { case BR_TRANSACTION_COMPLETE: ... case BR_DEAD_REPLY: ... case BR_FAILED_REPLY: ... case BR_ACQUIRE_RESULT: ... case BR_REPLY: ... default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; } } finish: ... return err; }说明：从talkWithDriver()正常返回之后，会读取mIn中的数据。而mIn中的数据就是Binder驱动返回的”BR_NOOP和BR_TRANSACTION_COMPLETE两个指令”。先读出的指令是BR_NOOP，因此这里执行executeCommand(cmd)。 32. IPCThreadState::executeCommand()status_t IPCThreadState::executeCommand(int32_t cmd) { BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch (cmd) { case BR_ERROR: ... case BR_OK: ... case BR_NOOP: break; default: ... } if (result != NO_ERROR) { mLastError = result; } return result; }说明：BR_NOOP没有进行任何操作，直接返回。继续回到waitForResponse()中，重新开始while循环，执行talkWithDriver()。 33. IPCThreadState::talkWithDriver()status_t IPCThreadState::talkWithDriver(bool doReceive) { ... binder_write_read bwr; // Is the read buffer empty? const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (long unsigned int)mOut.data(); // This is what we&apos;ll read. if (doReceive &amp;&amp; needRead) { bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (long unsigned int)mIn.data(); } else { bwr.read_size = 0; bwr.read_buffer = 0; } ... if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do { ... if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else ... ... } while (err == -EINTR); ... if (err &gt;= NO_ERROR) { // 清空已写的数据 if (bwr.write_consumed &gt; 0) { if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); } // 设置已读数据 if (bwr.read_consumed &gt; 0) { mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); } ... return NO_ERROR; } return err; }说明：(01) 此时，因为在waitForResponse()中已经通过mIn.readInt32()读取了4个字节，因此mIn.dataPosition()=4，而mIn.dataSize()=8；因此，needRead=false。(02) needRead=false，而doReceive=true；因此，outAvail=0。最终，由于 bwr.write_size和bwr.read_size都为0，因此直接返回NO_ERROR。 再次回到waitForResponse()中，此时读出的cmd为BR_TRANSACTION_COMPLETE。此时，由于reply不为NULL，因此再次重新执行while循环，调用talkWithDriver()。 (01) 此时，已经读取了mIn中的全部数据，因此mIn.dataPosition()=8，而mIn.dataSize()=8；因此，needRead=true。(02) outAvail=mOut.dataSize()，前面已经将mOut清空，因此outAvail=0。bwr初始化完毕之后，各个成员的值如下： bwr.write_size = 0; bwr.write_buffer = (long unsigned int)mOut.data(); bwr.write_consumed = 0; bwr.read_size = mIn.dataCapacity(); // 256字节 bwr.read_buffer = (long unsigned int)mIn.data(); bwr.read_consumed = 0;其实，此时MediaPlayerService已经处理完”addService()这个请求，包括已经处理完了该请求的反馈”。对MediaPlayerService而言，它已经成功的注册到Service Manager中；接下来，就是等待Client的请求了。那么如何去等待Client的请求呢？这和前面分析Service Manager服务启动之后等待Client的请求类似。MediaPlayerService服务，会通过ioctl()给Binder驱动发送读写请求，而此时的bwr.write_size=0，意味着不会进行写；bwr.read_size&gt;0，意味着会进行读。这样，Binder驱动就会执行读取动作，进而去查看”MediaPlayerService在Binder驱动中的待处理事务队列”是否有事务需要处理，有的话，就进行事务处理；否则，就进入中断等待状态，等待Client的请求。 下面，看看它到底是如何做到的。 static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; ... switch (cmd) { case BINDER_WRITE_READ: { struct binder_write_read bwr; ... // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot; if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) { ... } // 如果write_size&gt;0，则进行写操作 if (bwr.write_size &gt; 0) { ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... } // 如果read_size&gt;0，则进行读操作 if (bwr.read_size &gt; 0) { ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... } ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) { ret = -EFAULT; goto err; } break; } ... } ret = 0; ... return ret; }此时，bwr.write_size=0，因此不会执行binder_thread_write()。而bwr.read_size&gt;0，因此会调用binder_thread_read()进行读取动作。 34. Binder驱动中binder_thread_read()的源码static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block) { void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区 if (*consumed == 0) { if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; // 修改指针位置 ptr += sizeof(uint32_t); } retry: // 等待proc进程的事务标记。 // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。 wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); ... if (wait_for_proc_work) { ... // 设置当前线程的优先级=proc-&gt;default_priority。 // 即，当前线程要处理proc的事务，所以设置优先级和proc一样。 binder_set_nice(proc-&gt;default_priority); if (non_block) { ... } else // 阻塞式的读取，则阻塞等待事务的发生。 ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); } else { ... } ... }(01) 此时，bwr.read_consumed=0，意味着*consumed=0。因此，还是会先将BR_NOOP写入到bwr.read_buffer中。(02) 此时，当前线程的事务栈和待处理事务队列都是空，因此wait_for_proc_work=true。(03) 在调用binder_set_nice()设置当前线程的优先级之后，就会调用wait_event_interruptible()。而此时binder_has_proc_work()为false，因此当前线程会进入中断等待状态。当Service Manager处理完MediaPlayerService的请求之后，就会将其唤醒。 至此，MediaPlayerService进程的addService的请求发送部分就讲解完了。在继续了解请求的处理之前，先回顾一下本部分的内容。 如上图所示，MediaPlayerService发送一个BC_TRANSACTION事务给Binder驱动。Binder驱动收到该事务之后，对请求数据进行解析，在Kernel中新建了MediaPlayerService对应的Binder实体，并将在ServiceManager的进程上下文中添加了该Binder实体的Binder引用。解析完数据之后，新增一个待处理事务并提交到ServiceManager的待处理事务列表中；接着，就唤醒了ServiceManager。与此同时，Binder驱动还反馈了一个BR_TRANSACTION_COMPLETE给MediaPlayerService，告诉MediaPlayerService它的addService请求已经发送成功；MediaPlayerService在解析完BR_TRANSACTION_COMPLETE之后，就进入等待状态，等待ServiceManager的处理完请求之后反馈结果给它。 下面一篇文章，就看看ServiceManager被唤醒之后，具体都做了些什么工作！","link":"/2014/09/05/android/os/binder/2014-09-05-BinderCommunication-AddService01/"},{"title":"Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例","text":"这一章，我们对TreeMap进行学习。我们先对TreeMap有个整体认识，然后再学习它的源码，最后再通过实例来学会使用TreeMap。内容包括 目录第1部分 TreeMap介绍第2部分 TreeMap数据结构第3部分 TreeMap源码解析(基于JDK1.6.0_45)第4部分 TreeMap遍历方式第5部分 TreeMap示例 第1部分 TreeMap介绍TreeMap 简介 TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。TreeMap 实现了Cloneable接口，意味着它能被克隆。TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。 TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。 TreeMap的构造函数 // 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。 TreeMap() // 创建的TreeMap包含Map TreeMap(Map&lt;? extends K, ? extends V&gt; copyFrom) // 指定Tree的比较器 TreeMap(Comparator&lt;? super K&gt; comparator) // 创建的TreeSet包含copyFrom TreeMap(SortedMap&lt;K, ? extends V&gt; copyFrom)TreeMap的API Entry&lt;K, V&gt; ceilingEntry(K key) K ceilingKey(K key) void clear() Object clone() Comparator&lt;? super K&gt; comparator() boolean containsKey(Object key) NavigableSet&lt;K&gt; descendingKeySet() NavigableMap&lt;K, V&gt; descendingMap() Set&lt;Entry&lt;K, V&gt;&gt; entrySet() Entry&lt;K, V&gt; firstEntry() K firstKey() Entry&lt;K, V&gt; floorEntry(K key) K floorKey(K key) V get(Object key) NavigableMap&lt;K, V&gt; headMap(K to, boolean inclusive) SortedMap&lt;K, V&gt; headMap(K toExclusive) Entry&lt;K, V&gt; higherEntry(K key) K higherKey(K key) boolean isEmpty() Set&lt;K&gt; keySet() Entry&lt;K, V&gt; lastEntry() K lastKey() Entry&lt;K, V&gt; lowerEntry(K key) K lowerKey(K key) NavigableSet&lt;K&gt; navigableKeySet() Entry&lt;K, V&gt; pollFirstEntry() Entry&lt;K, V&gt; pollLastEntry() V put(K key, V value) V remove(Object key) int size() SortedMap&lt;K, V&gt; subMap(K fromInclusive, K toExclusive) NavigableMap&lt;K, V&gt; subMap(K from, boolean fromInclusive, K to, boolean toInclusive) NavigableMap&lt;K, V&gt; tailMap(K from, boolean inclusive) SortedMap&lt;K, V&gt; tailMap(K fromInclusive) 第2部分 TreeMap数据结构TreeMap的继承关系 java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.TreeMap&lt;K, V&gt;TreeMap的声明 public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable {}TreeMap与Map关系如下图： 从图中可以看出：(01) TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。(02) TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。&nbsp;&nbsp;root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。&nbsp;&nbsp;红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。&nbsp;&nbsp;size是红黑数中节点的个数。 关于红黑数的具体算法，请参考”[红黑树(一) 原理和算法详细介绍][link_rdtree_introduce]”。 第3部分 TreeMap源码解析(基于JDK1.6.0_45)为了更了解TreeMap的原理，下面对TreeMap源码代码作出分析。我们先给出源码内容，后面再对源码进行详细说明，当然，源码内容中也包含了详细的代码注释。读者阅读的时候，建议先看后面的说明，先建立一个整体印象；之后再阅读源码。 package java.util; public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable { // 比较器。用来给TreeMap排序 private final Comparator&lt;? super K&gt; comparator; // TreeMap是红黑树实现的，root是红黑书的根节点 private transient Entry&lt;K,V&gt; root = null; // 红黑树的节点总数 private transient int size = 0; // 记录红黑树的修改次数 private transient int modCount = 0; // 默认构造函数 public TreeMap() { comparator = null; } // 带比较器的构造函数 public TreeMap(Comparator&lt;? super K&gt; comparator) { this.comparator = comparator; } // 带Map的构造函数，Map会成为TreeMap的子集 public TreeMap(Map&lt;? extends K, ? extends V&gt; m) { comparator = null; putAll(m); } // 带SortedMap的构造函数，SortedMap会成为TreeMap的子集 public TreeMap(SortedMap&lt;K, ? extends V&gt; m) { comparator = m.comparator(); try { buildFromSorted(m.size(), m.entrySet().iterator(), null, null); } catch (java.io.IOException cannotHappen) { } catch (ClassNotFoundException cannotHappen) { } } public int size() { return size; } // 返回TreeMap中是否保护“键(key)” public boolean containsKey(Object key) { return getEntry(key) != null; } // 返回TreeMap中是否保护&quot;值(value)&quot; public boolean containsValue(Object value) { // getFirstEntry() 是返回红黑树的第一个节点 // successor(e) 是获取节点e的后继节点 for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) if (valEquals(value, e.value)) return true; return false; } // 获取“键(key)”对应的“值(value)” public V get(Object key) { // 获取“键”为key的节点(p) Entry&lt;K,V&gt; p = getEntry(key); // 若节点(p)为null，返回null；否则，返回节点对应的值 return (p==null ? null : p.value); } public Comparator&lt;? super K&gt; comparator() { return comparator; } // 获取第一个节点对应的key public K firstKey() { return key(getFirstEntry()); } // 获取最后一个节点对应的key public K lastKey() { return key(getLastEntry()); } // 将map中的全部节点添加到TreeMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; map) { // 获取map的大小 int mapSize = map.size(); // 如果TreeMap的大小是0,且map的大小不是0,且map是已排序的“key-value对” if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) { Comparator c = ((SortedMap)map).comparator(); // 如果TreeMap和map的比较器相等； // 则将map的元素全部拷贝到TreeMap中，然后返回！ if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) { ++modCount; try { buildFromSorted(mapSize, map.entrySet().iterator(), null, null); } catch (java.io.IOException cannotHappen) { } catch (ClassNotFoundException cannotHappen) { } return; } } // 调用AbstractMap中的putAll(); // AbstractMap中的putAll()又会调用到TreeMap的put() super.putAll(map); } // 获取TreeMap中“键”为key的节点 final Entry&lt;K,V&gt; getEntry(Object key) { // 若“比较器”为null，则通过getEntryUsingComparator()获取“键”为key的节点 if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = k.compareTo(p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的左孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; } return null; } // 获取TreeMap中“键”为key的节点(对应TreeMap的比较器不是null的情况) final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) { K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = cpr.compare(k, p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的左孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; } } return null; } // 获取TreeMap中不小于key的最小的节点； // 若不存在(即TreeMap中所有节点的键都比key大)，就返回null final Entry&lt;K,V&gt; getCeilingEntry(K key) { Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = compare(key, p.key); // 情况一：若“p的key” &gt; key。 // 若 p 存在左孩子，则设 p=“p的左孩子”； // 否则，返回p if (cmp &lt; 0) { if (p.left != null) p = p.left; else return p; // 情况二：若“p的key” &lt; key。 } else if (cmp &gt; 0) { // 若 p 存在右孩子，则设 p=“p的右孩子” if (p.right != null) { p = p.right; } else { // 若 p 不存在右孩子，则找出 p 的后继节点，并返回 // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。 // 理解这一点的核心是，getCeilingEntry是从root开始遍历的。 // 若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。 // 能理解上面所说的，那么就很容易明白，为什么“p的后继节点”又2种可能性了。 Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) { ch = parent; parent = parent.parent; } return parent; } // 情况三：若“p的key” = key。 } else return p; } return null; } // 获取TreeMap中不大于key的最大的节点； // 若不存在(即TreeMap中所有节点的键都比key小)，就返回null // getFloorEntry的原理和getCeilingEntry类似，这里不再多说。 final Entry&lt;K,V&gt; getFloorEntry(K key) { Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = compare(key, p.key); if (cmp &gt; 0) { if (p.right != null) p = p.right; else return p; } else if (cmp &lt; 0) { if (p.left != null) { p = p.left; } else { Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) { ch = parent; parent = parent.parent; } return parent; } } else return p; } return null; } // 获取TreeMap中大于key的最小的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getHigherEntry进行理解。 final Entry&lt;K,V&gt; getHigherEntry(K key) { Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = compare(key, p.key); if (cmp &lt; 0) { if (p.left != null) p = p.left; else return p; } else { if (p.right != null) { p = p.right; } else { Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) { ch = parent; parent = parent.parent; } return parent; } } } return null; } // 获取TreeMap中小于key的最大的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getLowerEntry进行理解。 final Entry&lt;K,V&gt; getLowerEntry(K key) { Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = compare(key, p.key); if (cmp &gt; 0) { if (p.right != null) p = p.right; else return p; } else { if (p.left != null) { p = p.left; } else { Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) { ch = parent; parent = parent.parent; } return parent; } } } return null; } // 将“key, value”添加到TreeMap中 // 理解TreeMap的前提是掌握“红黑树”。 // 若理解“红黑树中添加节点”的算法，则很容易理解put。 public V put(K key, V value) { Entry&lt;K,V&gt; t = root; // 若红黑树为空，则插入根节点 if (t == null) { // TBD: // 5045147: (coll) Adding null to an empty TreeSet should // throw NullPointerException // // compare(key, key); // type check root = new Entry&lt;K,V&gt;(key, value, null); size = 1; modCount++; return null; } int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; // 在二叉树(红黑树是特殊的二叉树)中，找到(key, value)的插入位置。 // 红黑树是以key来进行排序的，所以这里以key来进行查找。 if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } // 新建红黑树的节点(e) Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; // 红黑树插入节点后，不再是一颗红黑树； // 这里通过fixAfterInsertion的处理，来恢复红黑树的特性。 fixAfterInsertion(e); size++; modCount++; return null; } // 删除TreeMap中的键为key的节点，并返回节点的值 public V remove(Object key) { // 找到键为key的节点 Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; // 保存节点的值 V oldValue = p.value; // 删除节点 deleteEntry(p); return oldValue; } // 清空红黑树 public void clear() { modCount++; size = 0; root = null; } // 克隆一个TreeMap，并返回Object对象 public Object clone() { TreeMap&lt;K,V&gt; clone = null; try { clone = (TreeMap&lt;K,V&gt;) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(); } // Put clone into &quot;virgin&quot; state (except for comparator) clone.root = null; clone.size = 0; clone.modCount = 0; clone.entrySet = null; clone.navigableKeySet = null; clone.descendingMap = null; // Initialize clone with our mappings try { clone.buildFromSorted(size, entrySet().iterator(), null, null); } catch (java.io.IOException cannotHappen) { } catch (ClassNotFoundException cannotHappen) { } return clone; } // 获取第一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; firstEntry() { return exportEntry(getFirstEntry()); } // 获取最后一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; lastEntry() { return exportEntry(getLastEntry()); } // 获取第一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollFirstEntry() { // 获取第一个节点 Entry&lt;K,V&gt; p = getFirstEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除第一个节点 if (p != null) deleteEntry(p); return result; } // 获取最后一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollLastEntry() { // 获取最后一个节点 Entry&lt;K,V&gt; p = getLastEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除最后一个节点 if (p != null) deleteEntry(p); return result; } // 返回小于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; lowerEntry(K key) { return exportEntry(getLowerEntry(key)); } // 返回小于key的最大的键值对所对应的KEY，没有的话返回null public K lowerKey(K key) { return keyOrNull(getLowerEntry(key)); } // 返回不大于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; floorEntry(K key) { return exportEntry(getFloorEntry(key)); } // 返回不大于key的最大的键值对所对应的KEY，没有的话返回null public K floorKey(K key) { return keyOrNull(getFloorEntry(key)); } // 返回不小于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; ceilingEntry(K key) { return exportEntry(getCeilingEntry(key)); } // 返回不小于key的最小的键值对所对应的KEY，没有的话返回null public K ceilingKey(K key) { return keyOrNull(getCeilingEntry(key)); } // 返回大于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; higherEntry(K key) { return exportEntry(getHigherEntry(key)); } // 返回大于key的最小的键值对所对应的KEY，没有的话返回null public K higherKey(K key) { return keyOrNull(getHigherEntry(key)); } // TreeMap的红黑树节点对应的集合 private transient EntrySet entrySet = null; // KeySet为KeySet导航类 private transient KeySet&lt;K&gt; navigableKeySet = null; // descendingMap为键值对的倒序“映射” private transient NavigableMap&lt;K,V&gt; descendingMap = null; // 返回TreeMap的“键的集合” public Set&lt;K&gt; keySet() { return navigableKeySet(); } // 获取“可导航”的Key的集合 // 实际上是返回KeySet类的对象。 public NavigableSet&lt;K&gt; navigableKeySet() { KeySet&lt;K&gt; nks = navigableKeySet; return (nks != null) ? nks : (navigableKeySet = new KeySet(this)); } // 返回“TreeMap的值对应的集合” public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs = values; return (vs != null) ? vs : (values = new Values()); } // 获取TreeMap的Entry的集合，实际上是返回EntrySet类的对象。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet()); } // 获取TreeMap的降序Map // 实际上是返回DescendingSubMap类的对象 public NavigableMap&lt;K, V&gt; descendingMap() { NavigableMap&lt;K, V&gt; km = descendingMap; return (km != null) ? km : (descendingMap = new DescendingSubMap(this, true, null, true, true, null, true)); } // 获取TreeMap的子Map // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) { return new AscendingSubMap(this, false, fromKey, fromInclusive, false, toKey, toInclusive); } // 获取“Map的头部” // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) { return new AscendingSubMap(this, true, null, true, false, toKey, inclusive); } // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) { return new AscendingSubMap(this, false, fromKey, inclusive, true, null, true); } // 获取“子Map”。 // 范围是从fromKey(包括) 到 toKey(不包括) public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { return subMap(fromKey, true, toKey, false); } // 获取“Map的头部”。 // 范围从第一个节点 到 toKey(不包括) public SortedMap&lt;K,V&gt; headMap(K toKey) { return headMap(toKey, false); } // 获取“Map的尾部”。 // 范围是从 fromKey(包括) 到 最后一个节点 public SortedMap&lt;K,V&gt; tailMap(K fromKey) { return tailMap(fromKey, true); } // ”TreeMap的值的集合“对应的类，它集成于AbstractCollection class Values extends AbstractCollection&lt;V&gt; { // 返回迭代器 public Iterator&lt;V&gt; iterator() { return new ValueIterator(getFirstEntry()); } // 返回个数 public int size() { return TreeMap.this.size(); } // &quot;TreeMap的值的集合&quot;中是否包含&quot;对象o&quot; public boolean contains(Object o) { return TreeMap.this.containsValue(o); } // 删除&quot;TreeMap的值的集合&quot;中的&quot;对象o&quot; public boolean remove(Object o) { for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) { if (valEquals(e.getValue(), o)) { deleteEntry(e); return true; } } return false; } // 清空删除&quot;TreeMap的值的集合&quot; public void clear() { TreeMap.this.clear(); } } // EntrySet是“TreeMap的所有键值对组成的集合”， // EntrySet集合的单位是单个“键值对”。 class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new EntryIterator(getFirstEntry()); } // EntrySet中是否包含“键值对Object” public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); return p != null &amp;&amp; valEquals(p.getValue(), value); } // 删除EntrySet中的“键值对Object” public boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); if (p != null &amp;&amp; valEquals(p.getValue(), value)) { deleteEntry(p); return true; } return false; } // 返回EntrySet中元素个数 public int size() { return TreeMap.this.size(); } // 清空EntrySet public void clear() { TreeMap.this.clear(); } } // 返回“TreeMap的KEY组成的迭代器(顺序)” Iterator&lt;K&gt; keyIterator() { return new KeyIterator(getFirstEntry()); } // 返回“TreeMap的KEY组成的迭代器(逆序)” Iterator&lt;K&gt; descendingKeyIterator() { return new DescendingKeyIterator(getLastEntry()); } // KeySet是“TreeMap中所有的KEY组成的集合” // KeySet继承于AbstractSet，而且实现了NavigableSet接口。 static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; { // NavigableMap成员，KeySet是通过NavigableMap实现的 private final NavigableMap&lt;E, Object&gt; m; KeySet(NavigableMap&lt;E,Object&gt; map) { m = map; } // 升序迭代器 public Iterator&lt;E&gt; iterator() { // 若是TreeMap对象，则调用TreeMap的迭代器keyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器keyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).keyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).keyIterator()); } // 降序迭代器 public Iterator&lt;E&gt; descendingIterator() { // 若是TreeMap对象，则调用TreeMap的迭代器descendingKeyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器descendingKeyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).descendingKeyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).descendingKeyIterator()); } public int size() { return m.size(); } public boolean isEmpty() { return m.isEmpty(); } public boolean contains(Object o) { return m.containsKey(o); } public void clear() { m.clear(); } public E lower(E e) { return m.lowerKey(e); } public E floor(E e) { return m.floorKey(e); } public E ceiling(E e) { return m.ceilingKey(e); } public E higher(E e) { return m.higherKey(e); } public E first() { return m.firstKey(); } public E last() { return m.lastKey(); } public Comparator&lt;? super E&gt; comparator() { return m.comparator(); } public E pollFirst() { Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry(); return e == null? null : e.getKey(); } public E pollLast() { Map.Entry&lt;E,Object&gt; e = m.pollLastEntry(); return e == null? null : e.getKey(); } public boolean remove(Object o) { int oldSize = size(); m.remove(o); return size() != oldSize; } public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) { return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); } public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) { return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); } public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) { return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); } public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) { return subSet(fromElement, true, toElement, false); } public SortedSet&lt;E&gt; headSet(E toElement) { return headSet(toElement, false); } public SortedSet&lt;E&gt; tailSet(E fromElement) { return tailSet(fromElement, true); } public NavigableSet&lt;E&gt; descendingSet() { return new TreeSet(m.descendingMap()); } } // 它是TreeMap中的一个抽象迭代器，实现了一些通用的接口。 abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; { // 下一个元素 Entry&lt;K,V&gt; next; // 上一次返回元素 Entry&lt;K,V&gt; lastReturned; // 期望的修改次数，用于实现fast-fail机制 int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) { expectedModCount = modCount; lastReturned = null; next = first; } public final boolean hasNext() { return next != null; } // 获取下一个节点 final Entry&lt;K,V&gt; nextEntry() { Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = successor(e); lastReturned = e; return e; } // 获取上一个节点 final Entry&lt;K,V&gt; prevEntry() { Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = predecessor(e); lastReturned = e; return e; } // 删除当前节点 public void remove() { if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，&apos;新的当前节点&apos;实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向&quot;新的当前节点&quot;。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); expectedModCount = modCount; lastReturned = null; } } // TreeMap的Entry对应的迭代器 final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; { EntryIterator(Entry&lt;K,V&gt; first) { super(first); } public Map.Entry&lt;K,V&gt; next() { return nextEntry(); } } // TreeMap的Value对应的迭代器 final class ValueIterator extends PrivateEntryIterator&lt;V&gt; { ValueIterator(Entry&lt;K,V&gt; first) { super(first); } public V next() { return nextEntry().value; } } // reeMap的KEY组成的迭代器(顺序) final class KeyIterator extends PrivateEntryIterator&lt;K&gt; { KeyIterator(Entry&lt;K,V&gt; first) { super(first); } public K next() { return nextEntry().key; } } // TreeMap的KEY组成的迭代器(逆序) final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; { DescendingKeyIterator(Entry&lt;K,V&gt; first) { super(first); } public K next() { return prevEntry().key; } } // 比较两个对象的大小 final int compare(Object k1, Object k2) { return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2); } // 判断两个对象是否相等 final static boolean valEquals(Object o1, Object o2) { return (o1==null ? o2==null : o1.equals(o2)); } // 返回“Key-Value键值对”的一个简单拷贝(AbstractMap.SimpleImmutableEntry&lt;K,V&gt;对象) // 可用来读取“键值对”的值 static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) { return e == null? null : new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e); } // 若“键值对”不为null，则返回KEY；否则，返回null static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) { return e == null? null : e.key; } // 若“键值对”不为null，则返回KEY；否则，抛出异常 static &lt;K&gt; K key(Entry&lt;K,?&gt; e) { if (e==null) throw new NoSuchElementException(); return e.key; } // TreeMap的SubMap，它一个抽象类，实现了公共操作。 // 它包括了&quot;(升序)AscendingSubMap&quot;和&quot;(降序)DescendingSubMap&quot;两个子类。 static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, java.io.Serializable { // TreeMap的拷贝 final TreeMap&lt;K,V&gt; m; // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”； // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记” // fromStart是“表示是否从第一个节点开始计算”， // toEnd是“表示是否计算到最后一个节点 ” final K lo, hi; final boolean fromStart, toEnd; final boolean loInclusive, hiInclusive; // 构造函数 NavigableSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) { if (!fromStart &amp;&amp; !toEnd) { if (m.compare(lo, hi) &gt; 0) throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;); } else { if (!fromStart) // type check m.compare(lo, lo); if (!toEnd) m.compare(hi, hi); } this.m = m; this.fromStart = fromStart; this.lo = lo; this.loInclusive = loInclusive; this.toEnd = toEnd; this.hi = hi; this.hiInclusive = hiInclusive; } // 判断key是否太小 final boolean tooLow(Object key) { // 若该SubMap不包括“起始节点”， // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内” // 则判断key太小。其余情况都不是太小！ if (!fromStart) { int c = m.compare(key, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive)) return true; } return false; } // 判断key是否太大 final boolean tooHigh(Object key) { // 若该SubMap不包括“结束节点”， // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内” // 则判断key太大。其余情况都不是太大！ if (!toEnd) { int c = m.compare(key, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return true; } return false; } // 判断key是否在“lo和hi”开区间范围内 final boolean inRange(Object key) { return !tooLow(key) &amp;&amp; !tooHigh(key); } // 判断key是否在封闭区间内 final boolean inClosedRange(Object key) { return (fromStart || m.compare(key, lo) &gt;= 0) &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0); } // 判断key是否在区间内, inclusive是区间开关标志 final boolean inRange(Object key, boolean inclusive) { return inclusive ? inRange(key) : inClosedRange(key); } // 返回最低的Entry final TreeMap.Entry&lt;K,V&gt; absLowest() { // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点 // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry; // 否则，调用getHigherEntry(lo)获取大于lo的最小Entry TreeMap.Entry&lt;K,V&gt; e = (fromStart ? m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo))); return (e == null || tooHigh(e.key)) ? null : e; } // 返回最高的Entry final TreeMap.Entry&lt;K,V&gt; absHighest() { // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点 // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry; // 否则，调用getLowerEntry(hi)获取大于hi的最大Entry TreeMap.Entry&lt;K,V&gt; e = TreeMap.Entry&lt;K,V&gt; e = (toEnd ? m.getLastEntry() : (hiInclusive ? m.getFloorEntry(hi) : m.getLowerEntry(hi))); return (e == null || tooLow(e.key)) ? null : e; } // 返回&quot;大于/等于key的最小的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) { // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！ if (tooLow(key)) return absLowest(); // 获取“大于/等于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key); return (e == null || tooHigh(e.key)) ? null : e; } // 返回&quot;大于key的最小的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absHigher(K key) { // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！ if (tooLow(key)) return absLowest(); // 获取“大于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key); return (e == null || tooHigh(e.key)) ? null : e; } // 返回&quot;小于/等于key的最大的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absFloor(K key) { // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！ if (tooHigh(key)) return absHighest(); // 获取&quot;小于/等于key的最大的Entry&quot; TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key); return (e == null || tooLow(e.key)) ? null : e; } // 返回&quot;小于key的最大的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absLower(K key) { // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！ if (tooHigh(key)) return absHighest(); // 获取&quot;小于key的最大的Entry&quot; TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key); return (e == null || tooLow(e.key)) ? null : e; } // 返回“大于最大节点中的最小节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absHighFence() { return (toEnd ? null : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi))); } // 返回“小于最小节点中的最大节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absLowFence() { return (fromStart ? null : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo))); } // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法 abstract TreeMap.Entry&lt;K,V&gt; subLowest(); abstract TreeMap.Entry&lt;K,V&gt; subHighest(); abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key); abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key); abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key); abstract TreeMap.Entry&lt;K,V&gt; subLower(K key); // 返回“顺序”的键迭代器 abstract Iterator&lt;K&gt; keyIterator(); // 返回“逆序”的键迭代器 abstract Iterator&lt;K&gt; descendingKeyIterator(); // 返回SubMap是否为空。空的话，返回true，否则返回false public boolean isEmpty() { return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty(); } // 返回SubMap的大小 public int size() { return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size(); } // 返回SubMap是否包含键key public final boolean containsKey(Object key) { return inRange(key) &amp;&amp; m.containsKey(key); } // 将key-value 插入SubMap中 public final V put(K key, V value) { if (!inRange(key)) throw new IllegalArgumentException(&quot;key out of range&quot;); return m.put(key, value); } // 获取key对应值 public final V get(Object key) { return !inRange(key)? null : m.get(key); } // 删除key对应的键值对 public final V remove(Object key) { return !inRange(key)? null : m.remove(key); } // 获取“大于/等于key的最小键值对” public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) { return exportEntry(subCeiling(key)); } // 获取“大于/等于key的最小键” public final K ceilingKey(K key) { return keyOrNull(subCeiling(key)); } // 获取“大于key的最小键值对” public final Map.Entry&lt;K,V&gt; higherEntry(K key) { return exportEntry(subHigher(key)); } // 获取“大于key的最小键” public final K higherKey(K key) { return keyOrNull(subHigher(key)); } // 获取“小于/等于key的最大键值对” public final Map.Entry&lt;K,V&gt; floorEntry(K key) { return exportEntry(subFloor(key)); } // 获取“小于/等于key的最大键” public final K floorKey(K key) { return keyOrNull(subFloor(key)); } // 获取“小于key的最大键值对” public final Map.Entry&lt;K,V&gt; lowerEntry(K key) { return exportEntry(subLower(key)); } // 获取“小于key的最大键” public final K lowerKey(K key) { return keyOrNull(subLower(key)); } // 获取&quot;SubMap的第一个键&quot; public final K firstKey() { return key(subLowest()); } // 获取&quot;SubMap的最后一个键&quot; public final K lastKey() { return key(subHighest()); } // 获取&quot;SubMap的第一个键值对&quot; public final Map.Entry&lt;K,V&gt; firstEntry() { return exportEntry(subLowest()); } // 获取&quot;SubMap的最后一个键值对&quot; public final Map.Entry&lt;K,V&gt; lastEntry() { return exportEntry(subHighest()); } // 返回&quot;SubMap的第一个键值对&quot;，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollFirstEntry() { TreeMap.Entry&lt;K,V&gt; e = subLowest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; } // 返回&quot;SubMap的最后一个键值对&quot;，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollLastEntry() { TreeMap.Entry&lt;K,V&gt; e = subHighest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; } // Views transient NavigableMap&lt;K,V&gt; descendingMapView = null; transient EntrySetView entrySetView = null; transient KeySet&lt;K&gt; navigableKeySetView = null; // 返回NavigableSet对象，实际上返回的是当前对象的&quot;Key集合&quot;。 public final NavigableSet&lt;K&gt; navigableKeySet() { KeySet&lt;K&gt; nksv = navigableKeySetView; return (nksv != null) ? nksv : (navigableKeySetView = new TreeMap.KeySet(this)); } // 返回&quot;Key集合&quot;对象 public final Set&lt;K&gt; keySet() { return navigableKeySet(); } // 返回“逆序”的Key集合 public NavigableSet&lt;K&gt; descendingKeySet() { return descendingMap().navigableKeySet(); } // 排列fromKey(包含) 到 toKey(不包含) 的子map public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { return subMap(fromKey, true, toKey, false); } // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey) public final SortedMap&lt;K,V&gt; headMap(K toKey) { return headMap(toKey, false); } // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点] public final SortedMap&lt;K,V&gt; tailMap(K fromKey) { return tailMap(fromKey, true); } // Map的Entry的集合 abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { private transient int size = -1, sizeModCount; // 获取EntrySet的大小 public int size() { // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小 if (fromStart &amp;&amp; toEnd) return m.size(); // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素 if (size == -1 || sizeModCount != m.modCount) { sizeModCount = m.modCount; size = 0; Iterator i = iterator(); while (i.hasNext()) { size++; i.next(); } } return size; } // 判断EntrySetView是否为空 public boolean isEmpty() { TreeMap.Entry&lt;K,V&gt; n = absLowest(); return n == null || tooHigh(n.key); } // 判断EntrySetView是否包含Object public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry node = m.getEntry(key); return node != null &amp;&amp; valEquals(node.getValue(), entry.getValue()); } // 从EntrySetView中删除Object public boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key); if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue())){ m.deleteEntry(node); return true; } return false; } } // SubMap的迭代器 abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; { // 上一次被返回的Entry TreeMap.Entry&lt;K,V&gt; lastReturned; // 指向下一个Entry TreeMap.Entry&lt;K,V&gt; next; // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义 final K fenceKey; int expectedModCount; // 构造函数 SubMapIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) { // 每创建一个SubMapIterator时，保存修改次数 // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。 // 这就是所说的fast-fail机制的原理！ expectedModCount = m.modCount; lastReturned = null; next = first; fenceKey = fence == null ? null : fence.key; } // 是否存在下一个Entry public final boolean hasNext() { return next != null &amp;&amp; next.key != fenceKey; } // 返回下一个Entry final TreeMap.Entry&lt;K,V&gt; nextEntry() { TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的后继节点 next = successor(e); lastReturned = e; return e; } // 返回上一个Entry final TreeMap.Entry&lt;K,V&gt; prevEntry() { TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的前继节点 next = predecessor(e); lastReturned = e; return e; } // 删除当前节点(用于“升序的SubMap”)。 // 删除之后，可以继续升序遍历；红黑树特性没变。 final void removeAscending() { if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，&apos;新的当前节点&apos;实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向&quot;新的当前节点&quot;。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; } // 删除当前节点(用于“降序的SubMap”)。 // 删除之后，可以继续降序遍历；红黑树特性没变。 final void removeDescending() { if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; } } // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; { SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) { super(first, fence); } // 获取下一个节点(升序) public Map.Entry&lt;K,V&gt; next() { return nextEntry(); } // 删除当前节点(升序) public void remove() { removeAscending(); } } // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; { SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) { super(first, fence); } // 获取下一个节点(升序) public K next() { return nextEntry().key; } // 删除当前节点(升序) public void remove() { removeAscending(); } } // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; { DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) { super(last, fence); } // 获取下一个节点(降序) public Map.Entry&lt;K,V&gt; next() { return prevEntry(); } // 删除当前节点(降序) public void remove() { removeDescending(); } } // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; { DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) { super(last, fence); } // 获取下一个节点(降序) public K next() { return prevEntry().key; } // 删除当前节点(降序) public void remove() { removeDescending(); } } } // 升序的SubMap，继承于NavigableSubMap static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; { private static final long serialVersionUID = 912986545866124060L; // 构造函数 AscendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) { super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); } // 比较器 public Comparator&lt;? super K&gt; comparator() { return m.comparator(); } // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) { if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new AscendingSubMap(m, false, fromKey, fromInclusive, false, toKey, toInclusive); } // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) { if (!inRange(toKey, inclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new AscendingSubMap(m, fromStart, lo, loInclusive, false, toKey, inclusive); } // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive){ if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); return new AscendingSubMap(m, false, fromKey, inclusive, toEnd, hi, hiInclusive); } // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() { NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new DescendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); } // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() { return new SubMapKeyIterator(absLowest(), absHighFence()); } // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() { return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); } // “升序EntrySet集合”类 // 实现了iterator() final class AscendingEntrySetView extends EntrySetView { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new SubMapEntryIterator(absLowest(), absHighFence()); } } // 返回“升序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { EntrySetView es = entrySetView; return (es != null) ? es : new AscendingEntrySetView(); } TreeMap.Entry&lt;K,V&gt; subLowest() { return absLowest(); } TreeMap.Entry&lt;K,V&gt; subHighest() { return absHighest(); } TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absCeiling(key); } TreeMap.Entry&lt;K,V&gt; subHigher(K key) { return absHigher(key); } TreeMap.Entry&lt;K,V&gt; subFloor(K key) { return absFloor(key); } TreeMap.Entry&lt;K,V&gt; subLower(K key) { return absLower(key); } } // 降序的SubMap，继承于NavigableSubMap // 相比于升序SubMap，它的实现机制是将“SubMap的比较器反转”！ static final class DescendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; { private static final long serialVersionUID = 912986545866120460L; DescendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) { super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); } // 反转的比较器：是将原始比较器反转得到的。 private final Comparator&lt;? super K&gt; reverseComparator = Collections.reverseOrder(m.comparator); // 获取反转比较器 public Comparator&lt;? super K&gt; comparator() { return reverseComparator; } // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) { if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new DescendingSubMap(m, false, toKey, toInclusive, false, fromKey, fromInclusive); } // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) { if (!inRange(toKey, inclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new DescendingSubMap(m, false, toKey, inclusive, toEnd, hi, hiInclusive); } // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive){ if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); return new DescendingSubMap(m, fromStart, lo, loInclusive, false, fromKey, inclusive); } // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() { NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new AscendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); } // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() { return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); } // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() { return new SubMapKeyIterator(absLowest(), absHighFence()); } // “降序EntrySet集合”类 // 实现了iterator() final class DescendingEntrySetView extends EntrySetView { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new DescendingSubMapEntryIterator(absHighest(), absLowFence()); } } // 返回“降序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { EntrySetView es = entrySetView; return (es != null) ? es : new DescendingEntrySetView(); } TreeMap.Entry&lt;K,V&gt; subLowest() { return absHighest(); } TreeMap.Entry&lt;K,V&gt; subHighest() { return absLowest(); } TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absFloor(key); } TreeMap.Entry&lt;K,V&gt; subHigher(K key) { return absLower(key); } TreeMap.Entry&lt;K,V&gt; subFloor(K key) { return absCeiling(key); } TreeMap.Entry&lt;K,V&gt; subLower(K key) { return absHigher(key); } } // SubMap是旧版本的类，新的Java中没有用到。 private class SubMap extends AbstractMap&lt;K,V&gt; implements SortedMap&lt;K,V&gt;, java.io.Serializable { private static final long serialVersionUID = -6520786458950516097L; private boolean fromStart = false, toEnd = false; private K fromKey, toKey; private Object readResolve() { return new AscendingSubMap(TreeMap.this, fromStart, fromKey, true, toEnd, toKey, false); } public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { throw new InternalError(); } public K lastKey() { throw new InternalError(); } public K firstKey() { throw new InternalError(); } public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { throw new InternalError(); } public SortedMap&lt;K,V&gt; headMap(K toKey) { throw new InternalError(); } public SortedMap&lt;K,V&gt; tailMap(K fromKey) { throw new InternalError(); } public Comparator&lt;? super K&gt; comparator() { throw new InternalError(); } } // 红黑树的节点颜色--红色 private static final boolean RED = false; // 红黑树的节点颜色--黑色 private static final boolean BLACK = true; // “红黑树的节点”对应的类。 // 包含了 key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色) static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { // 键 K key; // 值 V value; // 左孩子 Entry&lt;K,V&gt; left = null; // 右孩子 Entry&lt;K,V&gt; right = null; // 父节点 Entry&lt;K,V&gt; parent; // 当前节点颜色 boolean color = BLACK; // 构造函数 Entry(K key, V value, Entry&lt;K,V&gt; parent) { this.key = key; this.value = value; this.parent = parent; } // 返回“键” public K getKey() { return key; } // 返回“值” public V getValue() { return value; } // 更新“值”，返回旧的值 public V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } // 判断两个节点是否相等的函数，覆盖equals()函数。 // 若两个节点的“key相等”并且“value相等”，则两个节点相等 public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); } // 覆盖hashCode函数。 public int hashCode() { int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; } // 覆盖toString()函数。 public String toString() { return key + &quot;=&quot; + value; } } // 返回“红黑树的第一个节点” final Entry&lt;K,V&gt; getFirstEntry() { Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p; } // 返回“红黑树的最后一个节点” final Entry&lt;K,V&gt; getLastEntry() { Entry&lt;K,V&gt; p = root; if (p != null) while (p.right != null) p = p.right; return p; } // 返回“节点t的后继节点” static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) { if (t == null) return null; else if (t.right != null) { Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; } else { Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) { ch = p; p = p.parent; } return p; } } // 返回“节点t的前继节点” static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) { if (t == null) return null; else if (t.left != null) { Entry&lt;K,V&gt; p = t.left; while (p.right != null) p = p.right; return p; } else { Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.left) { ch = p; p = p.parent; } return p; } } // 返回“节点p的颜色” // 根据“红黑树的特性”可知：空节点颜色是黑色。 private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) { return (p == null ? BLACK : p.color); } // 返回“节点p的父节点” private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) { return (p == null ? null: p.parent); } // 设置“节点p的颜色为c” private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) { if (p != null) p.color = c; } // 设置“节点p的左孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) { return (p == null) ? null: p.left; } // 设置“节点p的右孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) { return (p == null) ? null: p.right; } // 对节点p执行“左旋”操作 private void rotateLeft(Entry&lt;K,V&gt; p) { if (p != null) { Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; } } // 对节点p执行“右旋”操作 private void rotateRight(Entry&lt;K,V&gt; p) { if (p != null) { Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; } } // 插入之后的修正操作。 // 目的是保证：红黑树插入节点之后，仍然是一颗红黑树 private void fixAfterInsertion(Entry&lt;K,V&gt; x) { x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) { if (parentOf(x) == leftOf(parentOf(parentOf(x)))) { Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) { setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } else { if (x == rightOf(parentOf(x))) { x = parentOf(x); rotateLeft(x); } setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); } } else { Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) { setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } else { if (x == leftOf(parentOf(x))) { x = parentOf(x); rotateRight(x); } setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); } } } root.color = BLACK; } // 删除“红黑树的节点p” private void deleteEntry(Entry&lt;K,V&gt; p) { modCount++; size--; // If strictly internal, copy successor&apos;s element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) { Entry&lt;K,V&gt; s = successor (p); p.key = s.key; p.value = s.value; p = s; } // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) { // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); } else if (p.parent == null) { // return if we are the only node. root = null; } else { // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) { if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; } } } // 删除之后的修正操作。 // 目的是保证：红黑树删除节点之后，仍然是一颗红黑树 private void fixAfterDeletion(Entry&lt;K,V&gt; x) { while (x != root &amp;&amp; colorOf(x) == BLACK) { if (x == leftOf(parentOf(x))) { Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); } if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) { setColor(sib, RED); x = parentOf(x); } else { if (colorOf(rightOf(sib)) == BLACK) { setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); } setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; } } else { // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); } if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) { setColor(sib, RED); x = parentOf(x); } else { if (colorOf(leftOf(sib)) == BLACK) { setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); } setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; } } } setColor(x, BLACK); } private static final long serialVersionUID = 919286545866124006L; // java.io.Serializable的写入函数 // 将TreeMap的“容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); } } // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeMap的“容量、所有的Entry”依次读出 private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in the Comparator and any hidden stuff s.defaultReadObject(); // Read in size int size = s.readInt(); buildFromSorted(size, null, s, null); } // 根据已经一个排好序的map创建一个TreeMap private void buildFromSorted(int size, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException { this.size = size; root = buildFromSorted(0, 0, size-1, computeRedLevel(size), it, str, defaultVal); } // 根据已经一个排好序的map创建一个TreeMap // 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。 private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi, int redLevel, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException { if (hi &lt; lo) return null; // 获取中间元素 int mid = (lo + hi) / 2; Entry&lt;K,V&gt; left = null; // 若lo小于mid，则递归调用获取(middel的)左孩子。 if (lo &lt; mid) left = buildFromSorted(level+1, lo, mid - 1, redLevel, it, str, defaultVal); // 获取middle节点对应的key和value K key; V value; if (it != null) { if (defaultVal==null) { Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next(); key = entry.getKey(); value = entry.getValue(); } else { key = (K)it.next(); value = defaultVal; } } else { // use stream key = (K) str.readObject(); value = (defaultVal != null ? defaultVal : (V) str.readObject()); } // 创建middle节点 Entry&lt;K,V&gt; middle = new Entry&lt;K,V&gt;(key, value, null); // 若当前节点的深度=红色节点的深度，则将节点着色为红色。 if (level == redLevel) middle.color = RED; // 设置middle为left的父亲，left为middle的左孩子 if (left != null) { middle.left = left; left.parent = middle; } if (mid &lt; hi) { // 递归调用获取(middel的)右孩子。 Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel, it, str, defaultVal); // 设置middle为left的父亲，left为middle的左孩子 middle.right = right; right.parent = middle; } return middle; } // 计算节点树为sz的最大深度，也是红色节点的深度值。 private static int computeRedLevel(int sz) { int level = 0; for (int m = sz - 1; m &gt;= 0; m = m / 2 - 1) level++; return level; } }说明: 在详细介绍TreeMap的代码之前，我们先建立一个整体概念。TreeMap是通过红黑树实现的，TreeMap存储的是key-value键值对，TreeMap的排序是基于对key的排序。TreeMap提供了操作“key”、“key-value”、“value”等方法，也提供了对TreeMap这颗树进行整体操作的方法，如获取子树、反向树。后面的解说内容分为几部分,&nbsp;&nbsp;首先，介绍TreeMap的核心，即红黑树相关部分；&nbsp;&nbsp;然后，介绍TreeMap的主要函数；&nbsp;&nbsp;再次，介绍TreeMap实现的几个接口；&nbsp;&nbsp;最后，补充介绍TreeMap的其它内容。 TreeMap本质上是一颗红黑树。要彻底理解TreeMap，建议读者先理解红黑树。关于红黑树的原理，可以参考：[红黑树(一) 原理和算法详细介绍][link_rdtree_introduce] 第3.1部分 TreeMap的红黑树相关内容TreeMap中于红黑树相关的主要函数有: 1 数据结构1.1 红黑树的节点颜色–红色 private static final boolean RED = false;1.2 红黑树的节点颜色–黑色 private static final boolean BLACK = true;1.3 “红黑树的节点”对应的类 static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { ... }Entry包含了6个部分内容：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)Entry节点根据key进行排序，Entry节点包含的内容为value。 2 相关操作2.1 左旋 private void rotateLeft(Entry&lt;K,V&gt; p) { ... }2.2 右旋 private void rotateRight(Entry&lt;K,V&gt; p) { ... }2.3 插入操作 public V put(K key, V value) { ... }2.4 插入修正操作 红黑树执行插入操作之后，要执行“插入修正操作”。目的是：保红黑树在进行插入节点之后，仍然是一颗红黑树 private void fixAfterInsertion(Entry&lt;K,V&gt; x) { ... }2.5 删除操作 private void deleteEntry(Entry&lt;K,V&gt; p) { ... }2.6 删除修正操作 红黑树执行删除之后，要执行“删除修正操作”。目的是保证：红黑树删除节点之后，仍然是一颗红黑树 private void fixAfterDeletion(Entry&lt;K,V&gt; x) { ... }关于红黑树部分，这里主要是指出了TreeMap中那些是红黑树的主要相关内容。具体的红黑树相关操作API，这里没有详细说明，因为它们仅仅只是将算法翻译成代码。读者可以参考“[红黑树(一) 原理和算法详细介绍][link_rdtree_introduce]”进行了解。 第3.2部分 TreeMap的构造函数1 默认构造函数使用默认构造函数构造TreeMap时，使用java的默认的比较器比较Key的大小，从而对TreeMap进行排序。 public TreeMap() { comparator = null; }2 带比较器的构造函数public TreeMap(Comparator&lt;? super K&gt; comparator) { this.comparator = comparator; }3 带Map的构造函数，Map会成为TreeMap的子集public TreeMap(Map&lt;? extends K, ? extends V&gt; m) { comparator = null; putAll(m); }该构造函数会调用putAll()将m中的所有元素添加到TreeMap中。putAll()源码如下： public void putAll(Map&lt;? extends K, ? extends V&gt; m) { for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); }从中，我们可以看出putAll()就是将m中的key-value逐个的添加到TreeMap中。 4 带SortedMap的构造函数，SortedMap会成为TreeMap的子集public TreeMap(SortedMap&lt;K, ? extends V&gt; m) { comparator = m.comparator(); try { buildFromSorted(m.size(), m.entrySet().iterator(), null, null); } catch (java.io.IOException cannotHappen) { } catch (ClassNotFoundException cannotHappen) { } }该构造函数不同于上一个构造函数，在上一个构造函数中传入的参数是Map，Map不是有序的，所以要逐个添加。而该构造函数的参数是SortedMap是一个有序的Map，我们通过buildFromSorted()来创建对应的Map。buildFromSorted涉及到的代码如下： // 根据已经一个排好序的map创建一个TreeMap // 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。 private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi, int redLevel, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException { if (hi &lt; lo) return null; // 获取中间元素 int mid = (lo + hi) / 2; Entry&lt;K,V&gt; left = null; // 若lo小于mid，则递归调用获取(middel的)左孩子。 if (lo &lt; mid) left = buildFromSorted(level+1, lo, mid - 1, redLevel, it, str, defaultVal); // 获取middle节点对应的key和value K key; V value; if (it != null) { if (defaultVal==null) { Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next(); key = entry.getKey(); value = entry.getValue(); } else { key = (K)it.next(); value = defaultVal; } } else { // use stream key = (K) str.readObject(); value = (defaultVal != null ? defaultVal : (V) str.readObject()); } // 创建middle节点 Entry&lt;K,V&gt; middle = new Entry&lt;K,V&gt;(key, value, null); // 若当前节点的深度=红色节点的深度，则将节点着色为红色。 if (level == redLevel) middle.color = RED; // 设置middle为left的父亲，left为middle的左孩子 if (left != null) { middle.left = left; left.parent = middle; } if (mid &lt; hi) { // 递归调用获取(middel的)右孩子。 Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel, it, str, defaultVal); // 设置middle为left的父亲，left为middle的左孩子 middle.right = right; right.parent = middle; } return middle; }要理解buildFromSorted，重点说明以下几点： 第一，buildFromSorted是通过递归将SortedMap中的元素逐个关联。第二，buildFromSorted返回middle节点(中间节点)作为root。第三，buildFromSorted添加到红黑树中时，只将level == redLevel的节点设为红色。第level级节点，实际上是buildFromSorted转换成红黑树后的最底端(假设根节点在最上方)的节点；只将红黑树最底端的阶段着色为红色，其余都是黑色。 第3.3部分 TreeMap的Entry相关函数TreeMap的 firstEntry()、 lastEntry()、 lowerEntry()、 higherEntry()、 floorEntry()、 ceilingEntry()、 pollFirstEntry() 、 pollLastEntry() 原理都是类似的；下面以firstEntry()来进行详细说明 我们先看看firstEntry()和getFirstEntry()的代码： public Map.Entry&lt;K,V&gt; firstEntry() { return exportEntry(getFirstEntry()); } final Entry&lt;K,V&gt; getFirstEntry() { Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p; }从中，我们可以看出 firstEntry() 和 getFirstEntry() 都是用于获取第一个节点。但是，firstEntry() 是对外接口； getFirstEntry() 是内部接口。而且，firstEntry() 是通过 getFirstEntry() 来实现的。那为什么外界不能直接调用 getFirstEntry()，而需要多此一举的调用 firstEntry() 呢?先告诉大家原因，再进行详细说明。这么做的目的是：防止用户修改返回的Entry。getFirstEntry()返回的Entry是可以被修改的，但是经过firstEntry()返回的Entry不能被修改，只可以读取Entry的key值和value值。下面我们看看到底是如何实现的。(01) getFirstEntry()返回的是Entry节点，而Entry是红黑树的节点，它的源码如下： // 返回“红黑树的第一个节点” final Entry&lt;K,V&gt; getFirstEntry() { Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p; }从中，我们可以调用Entry的getKey()、getValue()来获取key和value值，以及调用setValue()来修改value的值。 (02) firstEntry()返回的是exportEntry(getFirstEntry())。下面我们看看exportEntry()干了些什么？ static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) { return e == null? null : new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e); }实际上，exportEntry() 是新建一个AbstractMap.SimpleImmutableEntry类型的对象，并返回。 SimpleImmutableEntry的实现在AbstractMap.java中，下面我们看看AbstractMap.SimpleImmutableEntry是如何实现的，代码如下： public static class SimpleImmutableEntry&lt;K,V&gt; implements Entry&lt;K,V&gt;, java.io.Serializable { private static final long serialVersionUID = 7138329143949025153L; private final K key; private final V value; public SimpleImmutableEntry(K key, V value) { this.key = key; this.value = value; } public SimpleImmutableEntry(Entry&lt;? extends K, ? extends V&gt; entry) { this.key = entry.getKey(); this.value = entry.getValue(); } public K getKey() { return key; } public V getValue() { return value; } public V setValue(V value) { throw new UnsupportedOperationException(); } public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue()); } public int hashCode() { return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); } public String toString() { return key + &quot;=&quot; + value; } }从中，我们可以看出SimpleImmutableEntry实际上是简化的key-value节点。它只提供了getKey()、getValue()方法类获取节点的值；但不能修改value的值，因为调用 setValue() 会抛出异常UnsupportedOperationException(); 再回到我们之前的问题：那为什么外界不能直接调用 getFirstEntry()，而需要多此一举的调用 firstEntry() 呢?现在我们清晰的了解到：(01) firstEntry()是对外接口，而getFirstEntry()是内部接口。(02) 对firstEntry()返回的Entry对象只能进行getKey()、getValue()等读取操作；而对getFirstEntry()返回的对象除了可以进行读取操作之后，还可以通过setValue()修改值。 第3.4部分 TreeMap的key相关函数TreeMap的firstKey()、lastKey()、lowerKey()、higherKey()、floorKey()、ceilingKey()原理都是类似的；下面以ceilingKey()来进行详细说明 ceilingKey(K key)的作用是“返回大于/等于key的最小的键值对所对应的KEY，没有的话返回null”，它的代码如下： public K ceilingKey(K key) { return keyOrNull(getCeilingEntry(key)); }ceilingKey()是通过getCeilingEntry()实现的。keyOrNull()的代码很简单，它是获取节点的key，没有的话，返回null。 static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) { return e == null? null : e.key; }getCeilingEntry(K key)的作用是“获取TreeMap中大于/等于key的最小的节点，若不存在(即TreeMap中所有节点的键都比key大)，就返回null”。它的实现代码如下： final Entry&lt;K,V&gt; getCeilingEntry(K key) { Entry&lt;K,V&gt; p = root; while (p != null) { int cmp = compare(key, p.key); // 情况一：若“p的key” &gt; key。 // 若 p 存在左孩子，则设 p=“p的左孩子”； // 否则，返回p if (cmp &lt; 0) { if (p.left != null) p = p.left; else return p; // 情况二：若“p的key” &lt; key。 } else if (cmp &gt; 0) { // 若 p 存在右孩子，则设 p=“p的右孩子” if (p.right != null) { p = p.right; } else { // 若 p 不存在右孩子，则找出 p 的后继节点，并返回 // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。 // 理解这一点的核心是，getCeilingEntry是从root开始遍历的。 // 若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。 // 能理解上面所说的，那么就很容易明白，为什么“p的后继节点”有2种可能性了。 Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) { ch = parent; parent = parent.parent; } return parent; } // 情况三：若“p的key” = key。 } else return p; } return null; }第3.5部分 TreeMap的values()函数values() 返回“TreeMap中值的集合” values()的实现代码如下： public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs = values; return (vs != null) ? vs : (values = new Values()); }说明：从中，我们可以发现values()是通过 new Values() 来实现 “返回TreeMap中值的集合”。 那么Values()是如何实现的呢？ 没错！由于返回的是值的集合，那么Values()肯定返回一个集合；而Values()正好是集合类Value的构造函数。Values继承于AbstractCollection，它的代码如下： // ”TreeMap的值的集合“对应的类，它集成于AbstractCollection class Values extends AbstractCollection&lt;V&gt; { // 返回迭代器 public Iterator&lt;V&gt; iterator() { return new ValueIterator(getFirstEntry()); } // 返回个数 public int size() { return TreeMap.this.size(); } // &quot;TreeMap的值的集合&quot;中是否包含&quot;对象o&quot; public boolean contains(Object o) { return TreeMap.this.containsValue(o); } // 删除&quot;TreeMap的值的集合&quot;中的&quot;对象o&quot; public boolean remove(Object o) { for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) { if (valEquals(e.getValue(), o)) { deleteEntry(e); return true; } } return false; } // 清空删除&quot;TreeMap的值的集合&quot; public void clear() { TreeMap.this.clear(); } }说明：从中，我们可以知道Values类就是一个集合。而 AbstractCollection 实现了除 size() 和 iterator() 之外的其它函数，因此只需要在Values类中实现这两个函数即可。size() 的实现非常简单，Values集合中元素的个数=该TreeMap的元素个数。(TreeMap每一个元素都有一个值嘛！)iterator() 则返回一个迭代器，用于遍历Values。下面，我们一起可以看看iterator()的实现： public Iterator&lt;V&gt; iterator() { return new ValueIterator(getFirstEntry()); }说明： iterator() 是通过ValueIterator() 返回迭代器的，ValueIterator是一个类。代码如下： final class ValueIterator extends PrivateEntryIterator&lt;V&gt; { ValueIterator(Entry&lt;K,V&gt; first) { super(first); } public V next() { return nextEntry().value; } }说明：ValueIterator的代码很简单，它的主要实现应该在它的父类PrivateEntryIterator中。下面我们一起看看PrivateEntryIterator的代码： abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; { // 下一节点 Entry&lt;K,V&gt; next; // 上一次返回的节点 Entry&lt;K,V&gt; lastReturned; // 修改次数统计数 int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) { expectedModCount = modCount; lastReturned = null; next = first; } // 是否存在下一个节点 public final boolean hasNext() { return next != null; } // 返回下一个节点 final Entry&lt;K,V&gt; nextEntry() { Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = successor(e); lastReturned = e; return e; } // 返回上一节点 final Entry&lt;K,V&gt; prevEntry() { Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = predecessor(e); lastReturned = e; return e; } // 删除当前节点 public void remove() { if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // deleted entries are replaced by their successors if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); expectedModCount = modCount; lastReturned = null; } }说明：PrivateEntryIterator是一个抽象类，它的实现很简单，只只实现了Iterator的remove()和hasNext()接口，没有实现next()接口。而我们在ValueIterator中已经实现的next()接口。至此，我们就了解了iterator()的完整实现了。 第3.6部分 TreeMap的entrySet()函数entrySet() 返回“键值对集合”。顾名思义，它返回的是一个集合，集合的元素是“键值对”。 下面，我们看看它是如何实现的？entrySet() 的实现代码如下： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet()); }说明：entrySet()返回的是一个EntrySet对象。 下面我们看看EntrySet的代码： // EntrySet是“TreeMap的所有键值对组成的集合”，// EntrySet集合的单位是单个“键值对”。 class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new EntryIterator(getFirstEntry()); } // EntrySet中是否包含“键值对Object” public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); return p != null &amp;&amp; valEquals(p.getValue(), value); } // 删除EntrySet中的“键值对Object” public boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); if (p != null &amp;&amp; valEquals(p.getValue(), value)) { deleteEntry(p); return true; } return false; } // 返回EntrySet中元素个数 public int size() { return TreeMap.this.size(); } // 清空EntrySet public void clear() { TreeMap.this.clear(); } }说明：EntrySet是“TreeMap的所有键值对组成的集合”，而且它单位是单个“键值对”。EntrySet是一个集合，它继承于AbstractSet。而AbstractSet实现了除size() 和 iterator() 之外的其它函数，因此，我们重点了解一下EntrySet的size() 和 iterator() 函数 size() 的实现非常简单，AbstractSet集合中元素的个数=该TreeMap的元素个数。iterator() 则返回一个迭代器，用于遍历AbstractSet。从上面的源码中，我们可以发现iterator() 是通过EntryIterator实现的；下面我们看看EntryIterator的源码： final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; { EntryIterator(Entry&lt;K,V&gt; first) { super(first); } public Map.Entry&lt;K,V&gt; next() { return nextEntry(); } }说明：和Values类一样，EntryIterator也继承于PrivateEntryIterator类。 第3.7部分 TreeMap实现的Cloneable接口TreeMap实现了Cloneable接口，即实现了clone()方法。clone()方法的作用很简单，就是克隆一个TreeMap对象并返回。 // 克隆一个TreeMap，并返回Object对象 public Object clone() { TreeMap&lt;K,V&gt; clone = null; try { clone = (TreeMap&lt;K,V&gt;) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(); } // Put clone into &quot;virgin&quot; state (except for comparator) clone.root = null; clone.size = 0; clone.modCount = 0; clone.entrySet = null; clone.navigableKeySet = null; clone.descendingMap = null; // Initialize clone with our mappings try { clone.buildFromSorted(size, entrySet().iterator(), null, null); } catch (java.io.IOException cannotHappen) { } catch (ClassNotFoundException cannotHappen) { } return clone; }第3.8部分 TreeMap实现的Serializable接口TreeMap实现java.io.Serializable，分别实现了串行读取、写入功能。串行写入函数是writeObject()，它的作用是将TreeMap的“容量，所有的Entry”都写入到输出流中。而串行读取函数是readObject()，它的作用是将TreeMap的“容量、所有的Entry”依次读出。readObject() 和 writeObject() 正好是一对，通过它们，我能实现TreeMap的串行传输。 // java.io.Serializable的写入函数 // 将TreeMap的“容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); } } // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeMap的“容量、所有的Entry”依次读出 private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in the Comparator and any hidden stuff s.defaultReadObject(); // Read in size int size = s.readInt(); buildFromSorted(size, null, s, null); }说到这里，就顺便说一下“关键字transient”的作用 transient是Java语言的关键字，它被用来表示一个域不是该对象串行化的一部分。Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 第3.9部分 TreeMap实现的NavigableMap接口firstKey()、lastKey()、lowerKey()、higherKey()、ceilingKey()、floorKey();firstEntry()、 lastEntry()、 lowerEntry()、 higherEntry()、 floorEntry()、 ceilingEntry()、 pollFirstEntry() 、 pollLastEntry();上面已经讲解过这些API了，下面对其它的API进行说明。 1 反向TreeMapdescendingMap() 的作用是返回当前TreeMap的反向的TreeMap。所谓反向，就是排序顺序和原始的顺序相反。 我们已经知道TreeMap是一颗红黑树，而红黑树是有序的。TreeMap的排序方式是通过比较器，在创建TreeMap的时候，若指定了比较器，则使用该比较器；否则，就使用Java的默认比较器。而获取TreeMap的反向TreeMap的原理就是将比较器反向即可！ 理解了descendingMap()的反向原理之后，再讲解一下descendingMap()的代码。 // 获取TreeMap的降序Map public NavigableMap&lt;K, V&gt; descendingMap() { NavigableMap&lt;K, V&gt; km = descendingMap; return (km != null) ? km : (descendingMap = new DescendingSubMap(this, true, null, true, true, null, true)); }从中，我们看出descendingMap()实际上是返回DescendingSubMap类的对象。下面，看看DescendingSubMap的源码： static final class DescendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; { private static final long serialVersionUID = 912986545866120460L; DescendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) { super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); } // 反转的比较器：是将原始比较器反转得到的。 private final Comparator&lt;? super K&gt; reverseComparator = Collections.reverseOrder(m.comparator); // 获取反转比较器 public Comparator&lt;? super K&gt; comparator() { return reverseComparator; } // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) { if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new DescendingSubMap(m, false, toKey, toInclusive, false, fromKey, fromInclusive); } // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) { if (!inRange(toKey, inclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new DescendingSubMap(m, false, toKey, inclusive, toEnd, hi, hiInclusive); } // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive){ if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); return new DescendingSubMap(m, fromStart, lo, loInclusive, false, fromKey, inclusive); } // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() { NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new AscendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); } // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() { return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); } // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() { return new SubMapKeyIterator(absLowest(), absHighFence()); } // “降序EntrySet集合”类 // 实现了iterator() final class DescendingEntrySetView extends EntrySetView { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new DescendingSubMapEntryIterator(absHighest(), absLowFence()); } } // 返回“降序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { EntrySetView es = entrySetView; return (es != null) ? es : new DescendingEntrySetView(); } TreeMap.Entry&lt;K,V&gt; subLowest() { return absHighest(); } TreeMap.Entry&lt;K,V&gt; subHighest() { return absLowest(); } TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absFloor(key); } TreeMap.Entry&lt;K,V&gt; subHigher(K key) { return absLower(key); } TreeMap.Entry&lt;K,V&gt; subFloor(K key) { return absCeiling(key); } TreeMap.Entry&lt;K,V&gt; subLower(K key) { return absHigher(key); } }从中，我们看出DescendingSubMap是降序的SubMap，它的实现机制是将“SubMap的比较器反转”。 它继承于NavigableSubMap。而NavigableSubMap是一个继承于AbstractMap的抽象类；它包括2个子类——“(升序)AscendingSubMap”和”(降序)DescendingSubMap”。NavigableSubMap为它的两个子类实现了许多公共API。下面看看NavigableSubMap的源码。 static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, java.io.Serializable { // TreeMap的拷贝 final TreeMap&lt;K,V&gt; m; // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”； // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记” // fromStart是“表示是否从第一个节点开始计算”， // toEnd是“表示是否计算到最后一个节点 ” final K lo, hi; final boolean fromStart, toEnd; final boolean loInclusive, hiInclusive; // 构造函数 NavigableSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) { if (!fromStart &amp;&amp; !toEnd) { if (m.compare(lo, hi) &gt; 0) throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;); } else { if (!fromStart) // type check m.compare(lo, lo); if (!toEnd) m.compare(hi, hi); } this.m = m; this.fromStart = fromStart; this.lo = lo; this.loInclusive = loInclusive; this.toEnd = toEnd; this.hi = hi; this.hiInclusive = hiInclusive; } // 判断key是否太小 final boolean tooLow(Object key) { // 若该SubMap不包括“起始节点”， // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内” // 则判断key太小。其余情况都不是太小！ if (!fromStart) { int c = m.compare(key, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive)) return true; } return false; } // 判断key是否太大 final boolean tooHigh(Object key) { // 若该SubMap不包括“结束节点”， // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内” // 则判断key太大。其余情况都不是太大！ if (!toEnd) { int c = m.compare(key, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return true; } return false; } // 判断key是否在“lo和hi”开区间范围内 final boolean inRange(Object key) { return !tooLow(key) &amp;&amp; !tooHigh(key); } // 判断key是否在封闭区间内 final boolean inClosedRange(Object key) { return (fromStart || m.compare(key, lo) &gt;= 0) &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0); } // 判断key是否在区间内, inclusive是区间开关标志 final boolean inRange(Object key, boolean inclusive) { return inclusive ? inRange(key) : inClosedRange(key); } // 返回最低的Entry final TreeMap.Entry&lt;K,V&gt; absLowest() { // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点 // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry; // 否则，调用getHigherEntry(lo)获取大于lo的最小Entry TreeMap.Entry&lt;K,V&gt; e = (fromStart ? m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo))); return (e == null || tooHigh(e.key)) ? null : e; } // 返回最高的Entry final TreeMap.Entry&lt;K,V&gt; absHighest() { // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点 // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry; // 否则，调用getLowerEntry(hi)获取大于hi的最大Entry TreeMap.Entry&lt;K,V&gt; e = TreeMap.Entry&lt;K,V&gt; e = (toEnd ? m.getLastEntry() : (hiInclusive ? m.getFloorEntry(hi) : m.getLowerEntry(hi))); return (e == null || tooLow(e.key)) ? null : e; } // 返回&quot;大于/等于key的最小的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) { // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！ if (tooLow(key)) return absLowest(); // 获取“大于/等于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key); return (e == null || tooHigh(e.key)) ? null : e; } // 返回&quot;大于key的最小的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absHigher(K key) { // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！ if (tooLow(key)) return absLowest(); // 获取“大于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key); return (e == null || tooHigh(e.key)) ? null : e; } // 返回&quot;小于/等于key的最大的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absFloor(K key) { // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！ if (tooHigh(key)) return absHighest(); // 获取&quot;小于/等于key的最大的Entry&quot; TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key); return (e == null || tooLow(e.key)) ? null : e; } // 返回&quot;小于key的最大的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absLower(K key) { // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！ if (tooHigh(key)) return absHighest(); // 获取&quot;小于key的最大的Entry&quot; TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key); return (e == null || tooLow(e.key)) ? null : e; } // 返回“大于最大节点中的最小节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absHighFence() { return (toEnd ? null : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi))); } // 返回“小于最小节点中的最大节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absLowFence() { return (fromStart ? null : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo))); } // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法 abstract TreeMap.Entry&lt;K,V&gt; subLowest(); abstract TreeMap.Entry&lt;K,V&gt; subHighest(); abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key); abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key); abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key); abstract TreeMap.Entry&lt;K,V&gt; subLower(K key); // 返回“顺序”的键迭代器 abstract Iterator&lt;K&gt; keyIterator(); // 返回“逆序”的键迭代器 abstract Iterator&lt;K&gt; descendingKeyIterator(); // 返回SubMap是否为空。空的话，返回true，否则返回false public boolean isEmpty() { return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty(); } // 返回SubMap的大小 public int size() { return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size(); } // 返回SubMap是否包含键key public final boolean containsKey(Object key) { return inRange(key) &amp;&amp; m.containsKey(key); } // 将key-value 插入SubMap中 public final V put(K key, V value) { if (!inRange(key)) throw new IllegalArgumentException(&quot;key out of range&quot;); return m.put(key, value); } // 获取key对应值 public final V get(Object key) { return !inRange(key)? null : m.get(key); } // 删除key对应的键值对 public final V remove(Object key) { return !inRange(key)? null : m.remove(key); } // 获取“大于/等于key的最小键值对” public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) { return exportEntry(subCeiling(key)); } // 获取“大于/等于key的最小键” public final K ceilingKey(K key) { return keyOrNull(subCeiling(key)); } // 获取“大于key的最小键值对” public final Map.Entry&lt;K,V&gt; higherEntry(K key) { return exportEntry(subHigher(key)); } // 获取“大于key的最小键” public final K higherKey(K key) { return keyOrNull(subHigher(key)); } // 获取“小于/等于key的最大键值对” public final Map.Entry&lt;K,V&gt; floorEntry(K key) { return exportEntry(subFloor(key)); } // 获取“小于/等于key的最大键” public final K floorKey(K key) { return keyOrNull(subFloor(key)); } // 获取“小于key的最大键值对” public final Map.Entry&lt;K,V&gt; lowerEntry(K key) { return exportEntry(subLower(key)); } // 获取“小于key的最大键” public final K lowerKey(K key) { return keyOrNull(subLower(key)); } // 获取&quot;SubMap的第一个键&quot; public final K firstKey() { return key(subLowest()); } // 获取&quot;SubMap的最后一个键&quot; public final K lastKey() { return key(subHighest()); } // 获取&quot;SubMap的第一个键值对&quot; public final Map.Entry&lt;K,V&gt; firstEntry() { return exportEntry(subLowest()); } // 获取&quot;SubMap的最后一个键值对&quot; public final Map.Entry&lt;K,V&gt; lastEntry() { return exportEntry(subHighest()); } // 返回&quot;SubMap的第一个键值对&quot;，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollFirstEntry() { TreeMap.Entry&lt;K,V&gt; e = subLowest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; } // 返回&quot;SubMap的最后一个键值对&quot;，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollLastEntry() { TreeMap.Entry&lt;K,V&gt; e = subHighest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; } // Views transient NavigableMap&lt;K,V&gt; descendingMapView = null; transient EntrySetView entrySetView = null; transient KeySet&lt;K&gt; navigableKeySetView = null; // 返回NavigableSet对象，实际上返回的是当前对象的&quot;Key集合&quot;。 public final NavigableSet&lt;K&gt; navigableKeySet() { KeySet&lt;K&gt; nksv = navigableKeySetView; return (nksv != null) ? nksv : (navigableKeySetView = new TreeMap.KeySet(this)); } // 返回&quot;Key集合&quot;对象 public final Set&lt;K&gt; keySet() { return navigableKeySet(); } // 返回“逆序”的Key集合 public NavigableSet&lt;K&gt; descendingKeySet() { return descendingMap().navigableKeySet(); } // 排列fromKey(包含) 到 toKey(不包含) 的子map public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { return subMap(fromKey, true, toKey, false); } // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey) public final SortedMap&lt;K,V&gt; headMap(K toKey) { return headMap(toKey, false); } // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点] public final SortedMap&lt;K,V&gt; tailMap(K fromKey) { return tailMap(fromKey, true); } // Map的Entry的集合 abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { private transient int size = -1, sizeModCount; // 获取EntrySet的大小 public int size() { // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小 if (fromStart &amp;&amp; toEnd) return m.size(); // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素 if (size == -1 || sizeModCount != m.modCount) { sizeModCount = m.modCount; size = 0; Iterator i = iterator(); while (i.hasNext()) { size++; i.next(); } } return size; } // 判断EntrySetView是否为空 public boolean isEmpty() { TreeMap.Entry&lt;K,V&gt; n = absLowest(); return n == null || tooHigh(n.key); } // 判断EntrySetView是否包含Object public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry node = m.getEntry(key); return node != null &amp;&amp; valEquals(node.getValue(), entry.getValue()); } // 从EntrySetView中删除Object public boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key); if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue())){ m.deleteEntry(node); return true; } return false; } } // SubMap的迭代器 abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; { // 上一次被返回的Entry TreeMap.Entry&lt;K,V&gt; lastReturned; // 指向下一个Entry TreeMap.Entry&lt;K,V&gt; next; // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义 final K fenceKey; int expectedModCount; // 构造函数 SubMapIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) { // 每创建一个SubMapIterator时，保存修改次数 // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。 // 这就是所说的fast-fail机制的原理！ expectedModCount = m.modCount; lastReturned = null; next = first; fenceKey = fence == null ? null : fence.key; } // 是否存在下一个Entry public final boolean hasNext() { return next != null &amp;&amp; next.key != fenceKey; } // 返回下一个Entry final TreeMap.Entry&lt;K,V&gt; nextEntry() { TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的后继节点 next = successor(e); lastReturned = e; return e; } // 返回上一个Entry final TreeMap.Entry&lt;K,V&gt; prevEntry() { TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的前继节点 next = predecessor(e); lastReturned = e; return e; } // 删除当前节点(用于“升序的SubMap”)。 // 删除之后，可以继续升序遍历；红黑树特性没变。 final void removeAscending() { if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，&apos;新的当前节点&apos;实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向&quot;新的当前节点&quot;。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; } // 删除当前节点(用于“降序的SubMap”)。 // 删除之后，可以继续降序遍历；红黑树特性没变。 final void removeDescending() { if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; } } // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; { SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) { super(first, fence); } // 获取下一个节点(升序) public Map.Entry&lt;K,V&gt; next() { return nextEntry(); } // 删除当前节点(升序) public void remove() { removeAscending(); } } // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; { SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) { super(first, fence); } // 获取下一个节点(升序) public K next() { return nextEntry().key; } // 删除当前节点(升序) public void remove() { removeAscending(); } } // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; { DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) { super(last, fence); } // 获取下一个节点(降序) public Map.Entry&lt;K,V&gt; next() { return prevEntry(); } // 删除当前节点(降序) public void remove() { removeDescending(); } } // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; { DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) { super(last, fence); } // 获取下一个节点(降序) public K next() { return prevEntry().key; } // 删除当前节点(降序) public void remove() { removeDescending(); } } }NavigableSubMap源码很多，但不难理解；读者可以通过源码和注释进行理解。 其实，读完NavigableSubMap的源码后，我们可以得出它的核心思想是：它是一个抽象集合类，为2个子类——“(升序)AscendingSubMap”和”(降序)DescendingSubMap”而服务；因为NavigableSubMap实现了许多公共API。它的最终目的是实现下面的一系列函数： headMap(K toKey, boolean inclusive) headMap(K toKey) subMap(K fromKey, K toKey) subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) tailMap(K fromKey) tailMap(K fromKey, boolean inclusive) navigableKeySet() descendingKeySet()第3.10部分 TreeMap其它函数1 顺序遍历和逆序遍历TreeMap的顺序遍历和逆序遍历原理非常简单。由于TreeMap中的元素是从小到大的顺序排列的。因此，顺序遍历，就是从第一个元素开始，逐个向后遍历；而倒序遍历则恰恰相反，它是从最后一个元素开始，逐个往前遍历。 我们可以通过 keyIterator() 和 descendingKeyIterator()来说明！keyIterator()的作用是返回顺序的KEY的集合，descendingKeyIterator()的作用是返回逆序的KEY的集合。 keyIterator() 的代码如下： Iterator&lt;K&gt; keyIterator() { return new KeyIterator(getFirstEntry()); }说明：从中我们可以看出keyIterator() 是返回以“第一个节点(getFirstEntry)” 为其实元素的迭代器。 KeyIterator的代码如下： final class KeyIterator extends PrivateEntryIterator&lt;K&gt; { KeyIterator(Entry&lt;K,V&gt; first) { super(first); } public K next() { return nextEntry().key; } }说明：KeyIterator继承于PrivateEntryIterator。当我们通过next()不断获取下一个元素的时候，就是执行的顺序遍历了。 descendingKeyIterator()的代码如下： Iterator&lt;K&gt; descendingKeyIterator() { return new DescendingKeyIterator(getLastEntry()); }说明：从中我们可以看出descendingKeyIterator() 是返回以“最后一个节点(getLastEntry)” 为其实元素的迭代器。再看看DescendingKeyIterator的代码： final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; { DescendingKeyIterator(Entry&lt;K,V&gt; first) { super(first); } public K next() { return prevEntry().key; } }说明：DescendingKeyIterator继承于PrivateEntryIterator。当我们通过next()不断获取下一个元素的时候，实际上调用的是prevEntry()获取的上一个节点，这样它实际上执行的是逆序遍历了。 至此，TreeMap的相关内容就全部介绍完毕了。若有错误或纰漏的地方，欢迎指正！ 第4部分 TreeMap遍历方式4.1 遍历TreeMap的键值对第一步：根据entrySet()获取TreeMap的“键值对”的Set集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是TreeMap对象 // map中的key是String类型，value是Integer类型 Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue(); }4.2 遍历TreeMap的键第一步：根据keySet()获取TreeMap的“键”的Set集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是TreeMap对象 // map中的key是String类型，value是Integer类型 String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key); }4.3 遍历TreeMap的值第一步：根据value()获取TreeMap的“值”的集合。 第二步：通过Iterator迭代器遍历“第一步”得到的集合。 // 假设map是TreeMap对象 // map中的key是String类型，value是Integer类型 Integer value = null; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) { value = (Integer)iter.next(); }TreeMap遍历测试程序如下： import java.util.Map; import java.util.Random; import java.util.Iterator; import java.util.TreeMap; import java.util.HashSet; import java.util.Map.Entry; import java.util.Collection; /* * @desc 遍历TreeMap的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorTreeMapByEntryset() * (02) 通过keySet()去遍历key、value，参考实现函数： * iteratorTreeMapByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorTreeMapJustValues() * * @author skywang */ public class TreeMapIteratorTest { public static void main(String[] args) { int val = 0; String key = null; Integer value = null; Random r = new Random(); TreeMap map = new TreeMap(); for (int i=0; i&lt;12; i++) { // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到TreeMap中 map.put(key, value); System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value); } // 通过entrySet()遍历TreeMap的key-value iteratorTreeMapByEntryset(map) ; // 通过keySet()遍历TreeMap的key-value iteratorTreeMapByKeyset(map) ; // 单单遍历TreeMap的value iteratorTreeMapJustValues(map); } /* * 通过entry set遍历TreeMap * 效率高! */ private static void iteratorTreeMapByEntryset(TreeMap map) { if (map == null) return ; System.out.println(&quot;\\niterator TreeMap By entryset&quot;); String key = null; Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+&quot; -- &quot;+integ.intValue()); } } /* * 通过keyset来遍历TreeMap * 效率低! */ private static void iteratorTreeMapByKeyset(TreeMap map) { if (map == null) return ; System.out.println(&quot;\\niterator TreeMap By keyset&quot;); String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { key = (String)iter.next(); integ = (Integer)map.get(key); System.out.println(key+&quot; -- &quot;+integ.intValue()); } } /* * 遍历TreeMap的values */ private static void iteratorTreeMapJustValues(TreeMap map) { if (map == null) return ; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) { System.out.println(iter.next()); } } } 第5部分 TreeMap示例下面通过实例来学习如何使用TreeMap import java.util.*; /** * @desc TreeMap测试程序 * * @author skywang */ public class TreeMapTest { public static void main(String[] args) { // 测试常用的API testTreeMapOridinaryAPIs(); // 测试TreeMap的导航函数 //testNavigableMapAPIs(); // 测试TreeMap的子Map函数 //testSubMapAPIs(); } /** * 测试常用的API */ private static void testTreeMapOridinaryAPIs() { // 初始化随机种子 Random r = new Random(); // 新建TreeMap TreeMap tmap = new TreeMap(); // 添加操作 tmap.put(&quot;one&quot;, r.nextInt(10)); tmap.put(&quot;two&quot;, r.nextInt(10)); tmap.put(&quot;three&quot;, r.nextInt(10)); System.out.printf(&quot;\\n ---- testTreeMapOridinaryAPIs ----\\n&quot;); // 打印出TreeMap System.out.printf(&quot;%s\\n&quot;,tmap ); // 通过Iterator遍历key-value Iterator iter = tmap.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); System.out.printf(&quot;next : %s - %s\\n&quot;, entry.getKey(), entry.getValue()); } // TreeMap的键值对个数 System.out.printf(&quot;size: %s\\n&quot;, tmap.size()); // containsKey(Object key) :是否包含键key System.out.printf(&quot;contains key two : %s\\n&quot;,tmap.containsKey(&quot;two&quot;)); System.out.printf(&quot;contains key five : %s\\n&quot;,tmap.containsKey(&quot;five&quot;)); // containsValue(Object value) :是否包含值value System.out.printf(&quot;contains value 0 : %s\\n&quot;,tmap.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 tmap.remove(&quot;three&quot;); System.out.printf(&quot;tmap:%s\\n&quot;,tmap ); // clear() ： 清空TreeMap tmap.clear(); // isEmpty() : TreeMap是否为空 System.out.printf(&quot;%s\\n&quot;, (tmap.isEmpty()?&quot;tmap is empty&quot;:&quot;tmap is not empty&quot;) ); } /** * 测试TreeMap的子Map函数 */ public static void testSubMapAPIs() { // 新建TreeMap TreeMap tmap = new TreeMap(); // 添加“键值对” tmap.put(&quot;a&quot;, 101); tmap.put(&quot;b&quot;, 102); tmap.put(&quot;c&quot;, 103); tmap.put(&quot;d&quot;, 104); tmap.put(&quot;e&quot;, 105); System.out.printf(&quot;\\n ---- testSubMapAPIs ----\\n&quot;); // 打印出TreeMap System.out.printf(&quot;tmap:\\n\\t%s\\n&quot;, tmap); // 测试 headMap(K toKey) System.out.printf(&quot;tmap.headMap(\\&quot;c\\&quot;):\\n\\t%s\\n&quot;, tmap.headMap(&quot;c&quot;)); // 测试 headMap(K toKey, boolean inclusive) System.out.printf(&quot;tmap.headMap(\\&quot;c\\&quot;, true):\\n\\t%s\\n&quot;, tmap.headMap(&quot;c&quot;, true)); System.out.printf(&quot;tmap.headMap(\\&quot;c\\&quot;, false):\\n\\t%s\\n&quot;, tmap.headMap(&quot;c&quot;, false)); // 测试 tailMap(K fromKey) System.out.printf(&quot;tmap.tailMap(\\&quot;c\\&quot;):\\n\\t%s\\n&quot;, tmap.tailMap(&quot;c&quot;)); // 测试 tailMap(K fromKey, boolean inclusive) System.out.printf(&quot;tmap.tailMap(\\&quot;c\\&quot;, true):\\n\\t%s\\n&quot;, tmap.tailMap(&quot;c&quot;, true)); System.out.printf(&quot;tmap.tailMap(\\&quot;c\\&quot;, false):\\n\\t%s\\n&quot;, tmap.tailMap(&quot;c&quot;, false)); // 测试 subMap(K fromKey, K toKey) System.out.printf(&quot;tmap.subMap(\\&quot;a\\&quot;, \\&quot;c\\&quot;):\\n\\t%s\\n&quot;, tmap.subMap(&quot;a&quot;, &quot;c&quot;)); // 测试 System.out.printf(&quot;tmap.subMap(\\&quot;a\\&quot;, true, \\&quot;c\\&quot;, true):\\n\\t%s\\n&quot;, tmap.subMap(&quot;a&quot;, true, &quot;c&quot;, true)); System.out.printf(&quot;tmap.subMap(\\&quot;a\\&quot;, true, \\&quot;c\\&quot;, false):\\n\\t%s\\n&quot;, tmap.subMap(&quot;a&quot;, true, &quot;c&quot;, false)); System.out.printf(&quot;tmap.subMap(\\&quot;a\\&quot;, false, \\&quot;c\\&quot;, true):\\n\\t%s\\n&quot;, tmap.subMap(&quot;a&quot;, false, &quot;c&quot;, true)); System.out.printf(&quot;tmap.subMap(\\&quot;a\\&quot;, false, \\&quot;c\\&quot;, false):\\n\\t%s\\n&quot;, tmap.subMap(&quot;a&quot;, false, &quot;c&quot;, false)); // 测试 navigableKeySet() System.out.printf(&quot;tmap.navigableKeySet():\\n\\t%s\\n&quot;, tmap.navigableKeySet()); // 测试 descendingKeySet() System.out.printf(&quot;tmap.descendingKeySet():\\n\\t%s\\n&quot;, tmap.descendingKeySet()); } /** * 测试TreeMap的导航函数 */ public static void testNavigableMapAPIs() { // 新建TreeMap NavigableMap nav = new TreeMap(); // 添加“键值对” nav.put(&quot;aaa&quot;, 111); nav.put(&quot;bbb&quot;, 222); nav.put(&quot;eee&quot;, 333); nav.put(&quot;ccc&quot;, 555); nav.put(&quot;ddd&quot;, 444); System.out.printf(&quot;\\n ---- testNavigableMapAPIs ----\\n&quot;); // 打印出TreeMap System.out.printf(&quot;Whole list:%s%n&quot;, nav); // 获取第一个key、第一个Entry System.out.printf(&quot;First key: %s\\tFirst entry: %s%n&quot;,nav.firstKey(), nav.firstEntry()); // 获取最后一个key、最后一个Entry System.out.printf(&quot;Last key: %s\\tLast entry: %s%n&quot;,nav.lastKey(), nav.lastEntry()); // 获取“小于/等于bbb”的最大键值对 System.out.printf(&quot;Key floor before bbb: %s%n&quot;,nav.floorKey(&quot;bbb&quot;)); // 获取“小于bbb”的最大键值对 System.out.printf(&quot;Key lower before bbb: %s%n&quot;, nav.lowerKey(&quot;bbb&quot;)); // 获取“大于/等于bbb”的最小键值对 System.out.printf(&quot;Key ceiling after ccc: %s%n&quot;,nav.ceilingKey(&quot;ccc&quot;)); // 获取“大于bbb”的最小键值对 System.out.printf(&quot;Key higher after ccc: %s%n\\n&quot;,nav.higherKey(&quot;ccc&quot;)); } }运行结果： {one=8, three=4, two=2} next : one - 8 next : three - 4 next : two - 2 size: 3 contains key two : true contains key five : false contains value 0 : false tmap:{one=8, two=2} tmap is empty更多内容00. Java 集合系列目录(Category)01. Java 集合系列01之 总体框架02. Java 集合系列02之 Collection架构03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)09. Java 集合系列09之 Map架构10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)15. Java 集合系列15之 Set架构16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例18. Java 集合系列18之 Iterator和Enumeration比较 [link_rdtree_introduce]:","link":"/2012/02/12/java/collection/2012-02-12-collection-12-treemap/"}],"tags":[{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"kotlin","slug":"kotlin","link":"/tags/kotlin/"},{"name":"uml","slug":"uml","link":"/tags/uml/"},{"name":"pattern","slug":"pattern","link":"/tags/pattern/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"}],"categories":[{"name":"android","slug":"android","link":"/categories/android/"},{"name":"pattern","slug":"pattern","link":"/categories/pattern/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"gradle","slug":"gradle","link":"/categories/gradle/"}]}