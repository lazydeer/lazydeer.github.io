<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Category: android - PillBlog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta property="og:type" content="website">
<meta property="og:title" content="PillBlog">
<meta property="og:url" content="https://apppills.com/categories/android/index.html">
<meta property="og:site_name" content="PillBlog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PillBlog">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">归档</a>
            
            <a class="navbar-item " href="/about">关于</a>
            
            <a class="navbar-item " href="https://everything.apppills.com">Everything</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5><i class="far fa-folder"></i>android</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/06/09/Flutter 开发桌面应用初步体验——Go Flutter还是Flutter Desktop Embedding/" itemprop="url">Flutter 开发桌面应用对比</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-06-08T16:01:00.000Z" itemprop="datePublished">6月 9 2019</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            12 分钟 read (About 1763 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近用flutter做了一款App，已经发布了Android和iOS的版本，因为有计划支持全部平台。所以开始尝试flutter desktop的解决方案。在github上我们能发现两个方案，一个是flutter官方的方案<a href="https://github.com/google/flutter-desktop-embedding" target="_blank" rel="noopener">flutter-desktop-embedding</a>还有一个是使用go和glfw开发的<a href="https://github.com/go-flutter-desktop/go-flutter" target="_blank" rel="noopener">go-flutter</a></p>
<h3 id="两种方案对比"><a href="#两种方案对比" class="headerlink" title="两种方案对比"></a>两种方案对比</h3><p>在选择使用flutter-desktop还是go-flutter之前，我们先对两种方案做一些介绍和对比。</p>
<p><img src="/media/typora-user-images/image-20190609214047338.png" alt="image-20190609214047338"></p>
<h3 id="两种方式的项目结构："><a href="#两种方式的项目结构：" class="headerlink" title="两种方式的项目结构："></a>两种方式的项目结构：</h3><p><img src="/media/typora-user-images/image-20190609213521705.png" alt="image-20190609213521705"></p>
<h4 id="Flutter-Desktop-Embedding"><a href="#Flutter-Desktop-Embedding" class="headerlink" title="Flutter Desktop Embedding:"></a>Flutter Desktop Embedding:</h4><p>在flutter desktop中我们可以看到目录结构和flutter开发手机App的结构是类似的，一个主项目下有各个平台的壳工程(这里面也可以包含Android和iOS)，然后由壳工程集成flutter的渲染引擎。flutter的代码写在lib目录中。</p>
<p>如果我们懂一些macOS开发或者windows开发，可以直接在项目中修改原生代码，比如你想修改整个程序的window的样式直接在原工程中就能修改，又比如macOS你要集成苹果的IAP，可以直接在原生项目中实现即可。</p>
<p>它的缺点就是三个平台的开发你最好都得懂一些</p>
<h4 id="Go-Flutter"><a href="#Go-Flutter" class="headerlink" title="Go Flutter:"></a>Go Flutter:</h4><p>Go Flutter由于本身Go语言就是跨平台的，所有它只有一个desktop目录，表示桌面版，相比于flutter desktop它让开发者完全不需要去关心macOS或者windows开发了，desktop中全是go语言编写的内容，最后desktop可以编译成三中平台的可执行文件。开发者只需要会Go语言即可。</p>
<p>它的缺点就是如果win或者mac或者linux你要在不同的平台做一些特殊的功能或者界面，会特别麻烦，不像在Flutter desktop中直接在宿主项目中实现即可。</p>
<h3 id="对比结果如何选择"><a href="#对比结果如何选择" class="headerlink" title="对比结果如何选择"></a>对比结果如何选择</h3><p>首先我们要明确，两种方案都不太成熟，但是如果要用来开发，也不是用不了。大家选择的时候可以根据自身技术栈，以及产品的特性来选择。</p>
<p>如果你懂Go语言，同时你的程序是阅读类，或者偏业务类，基本不需要和本身Native交互的，选 Go Flutter真的很爽。</p>
<p>如果你懂一点macOS或者windows开发，同时你的程序经常三个桌面端各有特色，而且需要修改本身整个window的一些样式，那么选择Flutter desktop embedding。</p>
<h3 id="Go-Flutter实际使用"><a href="#Go-Flutter实际使用" class="headerlink" title="Go Flutter实际使用"></a>Go Flutter实际使用</h3><p>上面说了这么多，我们来实际体验一下Go flutter。先说一下背景，我已经使用flutter开发了一款App，现在我要把App变成可以运行到桌面的版本。我写的软件叫做Everything是一款记录类软件，在这里可以下载到<a href="https://everything.apppills.com" target="_blank" rel="noopener">https://everything.apppills.com</a>大家可以先看一下效果。</p>
<ol>
<li>安装Go ，由于Go flutter使用Go编写，所以需要安装Go工具包。大家可以在<a href="https://golang.org/doc/install" target="_blank" rel="noopener">官网下载安装</a></li>
</ol>
<ol start="2">
<li><p>安装hover，hover是 Go Flutter的一个命令行工具，简化了项目初始化以及运行等步骤。</p>
<p>使用下面命令安装</p>
<p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">go</span> get -u github.com/<span class="hljs-keyword">go</span>-flutter-desktop/hover</span><br></pre></td></tr></table></figure></p>
<p>注意如果上面的命令卡住下载不下来，大家可以设置一下代理，设置命令行代理可以开启ss或者v2ray，然后在命令行输入命令设置</p>
<p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=<span class="hljs-string">"http://127.0.0.1:8001"</span>; export HTTP_PROXY=<span class="hljs-string">"http://127.0.0.1:8001"</span>; export https_proxy=<span class="hljs-string">"http://127.0.0.1:8001"</span>; export HTTPS_PROXY=<span class="hljs-string">"http://127.0.0.1:8001"</span></span><br><span class="line"><span class="hljs-comment">//8001改成你的ss或者v2ray监听的端口</span></span><br></pre></td></tr></table></figure></p>
<p>⚠️ 注意：安装好hover之后，官网上说就可以使用hover命令了，但是可能你在命令行里敲hover可能还是得到的是command not found。 这里我用的是mac系统，在安装好之后，在home目录多了一个go的目录，需要在你的环境变量里加入一下go的包路径。</p>
<p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/<span class="hljs-keyword">go</span>/bin</span><br><span class="line">export PATH=$PATH:/Users/&#123;你的用户名&#125;/<span class="hljs-keyword">go</span>/bin</span><br><span class="line"><span class="hljs-comment">//可以检查一下你的home目录是否有了go的目录，里面有个bin，将那个目录加入到环境变量即可</span></span><br></pre></td></tr></table></figure></p>
</li>
<li><p>进入你以前开发App的flutter项目，执行命令初始化项目</p>
<p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hover init github.com/my-organization/simpleApplication</span><br><span class="line"><span class="hljs-comment">//后面这个github.com xxxx就是你的项目仓库地址。没有的话随便写也行</span></span><br></pre></td></tr></table></figure></p>
<p>初始化项目完成后，你会在你的项目中发现一个desktop目录，和以前的iOS和Android是平级的。这个desktop目录就是桌面版的项目。</p>
</li>
<li><p>把你的main.dart复制一份名字改为main_desktop.dart，Go flutter有个特别的地方，就是程序的入口不是用的main.dart，而是用的main_desktop.dart。</p>
<p>修改main_desktop.dart为使用桌面版运行</p>
<p><figure class="highlight dart hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">void</span> main() &#123;</span><br><span class="line">  <span class="hljs-comment">// 关键是下面这一句</span></span><br><span class="line">  debugDefaultTargetPlatformOverride = TargetPlatform.fuchsia;</span><br><span class="line">  runApp(<span class="hljs-keyword">new</span> MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>大功告成，运行项目吧。</p>
<p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hover run</span><br><span class="line"><span class="hljs-comment">//执行 hover run 可以运行项目</span></span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>我们先来看一下运行效果下面是App的运行效果和桌面版的运行效果。</p>
<p><strong>手机版本身效果：</strong></p>
<p><img src="/media/flutter-image/16b3cb3588b93eac.gif" alt="phone"></p>
<p><strong>Go Flutter运行的桌面版效果：</strong></p>
<p><img src="/media/flutter-image/16b3cd31cee0dfbc.gif" alt="desktop"></p>
<h3 id="FAQ："><a href="#FAQ：" class="headerlink" title="FAQ："></a>FAQ：</h3><h5 id="1-程序按照上面那样迁移完成就能跑？"><a href="#1-程序按照上面那样迁移完成就能跑？" class="headerlink" title="1.程序按照上面那样迁移完成就能跑？"></a>1.程序按照上面那样迁移完成就能跑？</h5><p>当然不是，我们都知道我们用了很多插件，其实是只支持Android或者iOS的，如果你用得比较多的这种插件，那么你可能迁移到桌面端过来会比较麻烦。我的整体迁移的时间大概只用了2-3个小时，我用到了sqflite和shared preference，这两个插件Go flutter已有实现，所以很容易替换。</p>
<h5 id="2-如何使用Go-flutter的插件"><a href="#2-如何使用Go-flutter的插件" class="headerlink" title="2.如何使用Go flutter的插件"></a>2.如何使用Go flutter的插件</h5><p>我们知道我们所有和原生通信都是通过定义一个method channel来通信的。如果你用到的插件只支持Android或者iOS，那么你就需要在desktop中去实现这个插件的method channel的所有方法。目前Go flutter只有三个插件可以用，在这里可以找到。<a href="https://github.com/go-flutter-desktop/plugins" target="_blank" rel="noopener">https://github.com/go-flutter-desktop/plugins</a> 点击某个插件，就可以看到使用方法，就是把对应代码贴到，desktop里面的option文件中即可，不要找错地方了，官网没说得太清楚。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>感谢大家的阅读，我们用flutter开发了个小App也欢迎大家试用：</p>
<p>Everything 把记账本日记本，行程，待办等等都装进一个App里。</p>
<h4 id="https-everything-apppills-com"><a href="#https-everything-apppills-com" class="headerlink" title="https://everything.apppills.com/"></a><a href="https://everything.apppills.com/" target="_blank" rel="noopener">https://everything.apppills.com/</a></h4><p><img src="/media/typora-user-images/image-20190609223616844.png" alt="image-20190609223616844"></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/06/09/现有项目集成flutter混合开发和踩过的坑/" itemprop="url">原生App项目集成flutter混合开发详细指南</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-06-08T16:01:00.000Z" itemprop="datePublished">6月 9 2019</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            21 分钟 read (About 3082 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>记得去年9月份的时候谷歌在上海有一次开发者大会，去参加的时候关注到了flutter，随后没过多久就发布了1.0版本。18年底的时候用flutter做了个小项目，发现flutter确实挺好用的。于是尝试在公司找个小项目上马，进行混合开发试试。</p>
<h3 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h3><p>目前主流的混合开发方案有两种集成方式：</p>
<p><strong>源码集成：</strong>也就是谷歌官方提供的方案[<a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps]" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps]</a></p>
<p><strong>产物集成：</strong>Flutter项目单独开发，开发完成后发布成aar包或者iOS的framework形式，原生项目依赖flutter输出的制品即可。具体可以参考闲鱼的文章</p>
<p><img src="/media/typora-user-images/image-20190221145655505.png" alt="image-20190221145655505"></p>
<p>两种方式各有优劣，其实产物集成更好一些，不过即使是进行产物集成，也需要弄懂源码集成的方式，因为当有很多和原生交互的功能进行开发的时候，源码集成的方式可以直接调试会方便很多。</p>
<p>根据目前我们的情况：</p>
<p>1.参与人员都要进行flutter开发、</p>
<p>2.持续发布和构建我可以修改控制</p>
<p>我们现在这个项目选择了<strong>源码集成</strong>的方式。</p>
<h3 id="为原生项目集成flutter"><a href="#为原生项目集成flutter" class="headerlink" title="为原生项目集成flutter"></a>为原生项目集成flutter</h3><p>整个的集成方案是参考谷歌方法：[<a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps]，但是有一些不一样，我是创建了一个flutter项目后，在原生的项目中使用`git" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps]，但是有一些不一样，我是创建了一个flutter项目后，在原生的项目中使用`git</a> submodule`的形式进行管理的。</p>
<h4 id="1-创建flutter-module-project"><a href="#1-创建flutter-module-project" class="headerlink" title="1.创建flutter module project"></a>1.创建flutter module project</h4><p>我们假定已经有了原生的项目<code>Native-iOS</code>和<code>Native-Android</code>；现在我们需要创建我们的flutter项目。</p>
<ol>
<li><p>把我们的flutter的channel切换到master(master分支下是flutter的preview版本)</p>
<p><code>flutter channel master</code></p>
</li>
<li><p>创建flutter模块的项目</p>
<p><code>flutter create -t module {moduleName}</code></p>
<p>我这里创建一个flutter的模块项目叫<code>flutter_module</code></p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ flutter create -t module flutter_module</span><br><span class="line">Creating project flutter_module...</span><br><span class="line">  flutter_module/test/widget_test.dart (created)</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  flutter_module/.idea/workspace.xml (created)</span><br><span class="line">Running &quot;flutter packages get&quot; in flutter_module...                 7.2s</span><br><span class="line">Wrote 12 files.</span><br><span class="line"></span><br><span class="line">All done!</span><br><span class="line">Your module code is in flutter_module/lib/main.dart.</span><br></pre></td></tr></table></figure></p>
<p>创建成功后我们可以看一下目录结构</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  flutter_module git:(master) ✗ tree -L 2 -a</span><br><span class="line">.</span><br><span class="line">├── .android</span><br><span class="line">│   ├── Flutter</span><br><span class="line">│   ├── app</span><br><span class="line">│   ├── ...</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .ios</span><br><span class="line">│   ├── Config</span><br><span class="line">│   ├── Flutter</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── Runner.xcworkspace</span><br><span class="line">├── lib</span><br><span class="line">│   └── main.dart</span><br><span class="line">├── pubspec.lock</span><br><span class="line">├── pubspec.yaml</span><br><span class="line">└── test</span><br><span class="line">    └── widget_test.dart</span><br></pre></td></tr></table></figure></p>
<p>在flutter的模块项目中包含有一个隐藏的<code>.android</code>和<code>.ios</code>目录这个目录下是可运行的Android和iOS项目，我们的flutter代码还是在<code>lib</code>下编写，注意在<code>.android</code>和<code>.ios</code>目录下都有一个Flutter目录，这个是我们flutter的库项目了。也就是Android用来生成aar，iOS用来生产framework的库。如果我们用<code>flutter create xxx</code> 生成的纯flutter项目是没有这个Flutter目录的。</p>
</li>
<li><p>把该项目使用git管理起来，稍后我们要在native项目中以子模块的形式添加进去。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="hljs-built_in">cd</span> flutter_module</span><br><span class="line">➜  git init</span><br><span class="line">Initialized empty Git repository <span class="hljs-keyword">in</span> /Users/zhiqiangdeng/Documents/ProjectSource/FlutterProject/flutter_module/.git/</span><br><span class="line">➜  flutter_module git:(master) ✗</span><br></pre></td></tr></table></figure></p>
<p>初始化git仓库后我们先编辑一下项目下的<code>.gitignore</code>文件，当前这个文件是把项目下的<code>.ios</code>和<code>.android</code>忽略掉的。这个两个项目我们需要跟踪一下，大家可以去github上找一下iOS和Android的gitignore模版文件，然后添加到这个两个目录中，然后把顶层目录的文件作出如下修改，删除<code>.android和.ios</code>添加<code>.ios/Flutter/Generated.xcconfig</code></p>
<p>.gitignore文件：</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-.android/</span><br><span class="line">-.ios/</span><br><span class="line">+.ios/Flutter/Generated.xcconfig</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>提交你的flutter模块项目到你的git服务器(我提交到github上了[<a href="https://github.com/zakiso/flutter-module-demo.git]大家可以参考" target="_blank" rel="noopener">https://github.com/zakiso/flutter-module-demo.git]大家可以参考</a>)</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &#123;你的flutter module的仓库地址&#125;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<h4 id="2-给iOS项目集成flutter"><a href="#2-给iOS项目集成flutter" class="headerlink" title="2.给iOS项目集成flutter"></a>2.给iOS项目集成flutter</h4><p>1.进入我们原生的iOS项目根目录中，为它添加一个git submodule，把我们的flutter项目拉取下来.</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &#123;你的flutter module的仓库地址&#125;</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure></p>
<p>2.在项目的<code>Podfile</code>文件中添加下面的代码，在每次执行pod install会运行podhelper.rb</p>
<p><figure class="highlight ruby hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="hljs-symbol">:ios</span>, <span class="hljs-string">'8.0'</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="hljs-string">'MyApp'</span> <span class="hljs-keyword">do</span></span><br><span class="line">  pod <span class="hljs-string">'AFNetworking'</span>, <span class="hljs-string">'~&gt; 2.6'</span></span><br><span class="line">  xxxx</span><br><span class="line"><span class="hljs-keyword">end</span></span><br><span class="line"><span class="hljs-comment">#添加如下两行代码，路径修改为我们的fluter module的路径</span></span><br><span class="line">flutter_application_path = <span class="hljs-string">'./flutter-module-demo'</span></span><br><span class="line">  eval(File.read(File.join(flutter_application_path, <span class="hljs-string">'.ios'</span>, <span class="hljs-string">'Flutter'</span>, <span class="hljs-string">'podhelper.rb'</span>)), binding)</span><br></pre></td></tr></table></figure></p>
<p>3.打开Xcode关闭bitcode配置<code>Build Settings-&gt;Build Options-&gt;Enable Bitcode</code></p>
<p>4.添加编译脚本，打开Xcode在 Build Phases中添加<code>New Run Script Phase</code>在里面填入如下脚本</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"<span class="hljs-variable">$FLUTTER_ROOT</span>/packages/flutter_tools/bin/xcode_backend.sh"</span> build</span><br><span class="line"><span class="hljs-string">"<span class="hljs-variable">$FLUTTER_ROOT</span>/packages/flutter_tools/bin/xcode_backend.sh"</span> embed</span><br></pre></td></tr></table></figure></p>
<p><img src="/media/typora-user-images/image-20190221164146532.png" alt="image-20190221164146532"></p>
<p>5.项目的配置完成现在需要生成一些配置文件</p>
<p>​    a. 进入原生项目的flutter模块目录中执行<code>flutter packages get</code>命令</p>
<p>​    b. 回到原生项目根目录执行<code>pod install</code></p>
<p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  cd flutter-module-demo</span><br><span class="line">➜  flutter-module-demo git:(master) flutter packages get</span><br><span class="line">Running "flutter packages get" in flutter-module-demo...            0.4s</span><br><span class="line">➜  flutter-module-demo git:(master) cd ..</span><br><span class="line">➜  FlutterNativeiOS git:(master) ✗ pod install</span><br><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec for `Flutter` from `./flutter-module-demo/.ios/Flutter/engine`</span><br><span class="line">Fetching podspec for `FlutterPluginRegistrant` from `./flutter-module-demo/.ios/Flutter/FlutterPluginRegistrant`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Using AFNetworking (2.6.3)</span><br><span class="line">Installing Flutter (1.0.0)</span><br><span class="line">Installing FlutterPluginRegistrant (0.0.1)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line">Sending stats</span><br><span class="line">Pod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed.</span><br></pre></td></tr></table></figure></p>
<p>到此为止我们的原生项目就已经集成好了flutter项目了。</p>
<p>5.在原生项目中使用flutter，下面以swift项目为例</p>
<p>修改AppDelegate.swift:注意AppDelegate是集成自FlutterAppDelegate</p>
<p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> UIKit</span><br><span class="line"><span class="hljs-keyword">import</span> Flutter</span><br><span class="line"><span class="hljs-keyword">import</span> FlutterPluginRegistrant <span class="hljs-comment">// Only if you have Flutter Plugins.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@UIApplicationMain</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>: <span class="hljs-title">FlutterAppDelegate</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> flutterEngine : <span class="hljs-type">FlutterEngine?</span>;</span><br><span class="line">  <span class="hljs-comment">// Only if you have Flutter plugins.</span></span><br><span class="line">  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">application</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="hljs-keyword">Any</span>]?)</span></span> -&gt; <span class="hljs-type">Bool</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span>.flutterEngine = <span class="hljs-type">FlutterEngine</span>(name: <span class="hljs-string">"io.flutter"</span>, project: <span class="hljs-literal">nil</span>);</span><br><span class="line">    <span class="hljs-keyword">self</span>.flutterEngine?.run(withEntrypoint: <span class="hljs-literal">nil</span>);</span><br><span class="line">    <span class="hljs-type">GeneratedPluginRegistrant</span>.register(with: <span class="hljs-keyword">self</span>.flutterEngine);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.application(application, didFinishLaunchingWithOptions: launchOptions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改Controller代码</p>
<p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> UIKit</span><br><span class="line"><span class="hljs-keyword">import</span> Flutter</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="hljs-keyword">let</span> button = <span class="hljs-type">UIButton</span>(type:<span class="hljs-type">UIButtonType</span>.custom)</span><br><span class="line">	...</span><br><span class="line">    <span class="hljs-keyword">self</span>.view.addSubview(button)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleButtonAction</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> flutterEngine = (<span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as</span>? <span class="hljs-type">AppDelegate</span>)?.flutterEngine;</span><br><span class="line">    <span class="hljs-keyword">let</span> flutterViewController = <span class="hljs-type">FlutterViewController</span>(engine: flutterEngine, nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)!;</span><br><span class="line">    <span class="hljs-keyword">self</span>.present(flutterViewController, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="6">
<li>RUN….</li>
</ol>
<h4 id="3-iOS项目集成过程梳理"><a href="#3-iOS项目集成过程梳理" class="headerlink" title="3.iOS项目集成过程梳理"></a>3.iOS项目集成过程梳理</h4><p>整个的集成过程其实总得来说是如下三个步骤：</p>
<p>1.将flutter项目放入原生项目的文件夹下</p>
<p>2.在podfile中添加<code>podhelper.rb</code>配置</p>
<p>3.在Xcode的build phases添加<code>&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot;</code>iOS编译脚本。</p>
<p>其中podhelper.rb文件位于我们flutter模块项目的<code>.ios/Flutter/podhelper.rb</code>下，大家查看它的源码可以发现，它有下面几个作用：</p>
<p>1.把Flutter（flutterEngine）和FlutterPluginRegistrant两个库用pod给原生项目导入进入</p>
<p>2.如果flutter项目有用到flutter plugin插件，把插件用pod导入</p>
<p>3.导入<code>Generated.xcconfig</code>的相关配置信息，在<code>podhelper.rb</code>同级别的目录下还有一个<code>Generated.xcconfig</code>文件，这个文件在使用<code>flutter create xx、flutter run xxx、flutter packages get</code>命令的时候如果该文件不存在则会生成这个文件。这个文件内容如下：</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// This is a generated file; do not edit or check into version control.</span><br><span class="line">FLUTTER_ROOT=/Users/zhiqiangdeng/.flutter_wrapper/1.2.2-pre.43</span><br><span class="line">FLUTTER_APPLICATION_PATH=/Users/zhiqiangdeng/Documents/ProjectSource/XcodeProject/lianhua-order-iOS/order-check-module-flutter</span><br><span class="line">FLUTTER_TARGET=lib/main.dart</span><br><span class="line">FLUTTER_BUILD_DIR=build</span><br><span class="line">SYMROOT=$&#123;SOURCE_ROOT&#125;/../build/ios</span><br><span class="line">FLUTTER_BUILD_NAME=1.0.0</span><br><span class="line">FLUTTER_BUILD_NUMBER=1</span><br></pre></td></tr></table></figure></p>
<p>他记录了当前flutter sdk的目录位置，以及版本号，还有项目模块的目录位置。这个文件的内容在执行<code>pod install</code>的时候会被写入到xcode build setting中，在执行完pod install之后，可以在原生项目根目录使用<code>xcodebuild -showBuildSettings|grep flutter</code> 查看相关的信息。</p>
<p><img src="/media/typora-user-images/image-20190221183656596.png" alt="image-20190221183656596"></p>
<p>最后一步就是运行程序，运行程序的时候在Build phase添加了<code>xcode_backend.sh</code>该脚本会使用到上面pod install给xcode build setting设置的那些环境变量，然后找到项目目录生成AppFramework。</p>
<h4 id="4-给原生Android项目集成Flutter"><a href="#4-给原生Android项目集成Flutter" class="headerlink" title="4.给原生Android项目集成Flutter"></a>4.给原生Android项目集成Flutter</h4><p>Android的文章很多，这里不再详细描述了</p>
<p>1.在原生Android项目中添加子模块，将上面创建的flutter module项目拉取到原生安卓项目中</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &#123;你的flutter module的仓库地址&#125;</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure></p>
<p>2.在根目录的<code>settings.gradle</code>中添加如下配置</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setBinding(new Binding([gradle: this]))                                 </span><br><span class="line">evaluate(new File(                                                                 </span><br><span class="line">  &apos;&#123;xxxxx你的flutter module目录&#125;/.android/include_flutter.groovy&apos;                    </span><br><span class="line">))</span><br></pre></td></tr></table></figure></p>
<p>3.在原生项目的app目录下的build.gradle文件中添加Flutter库的依赖</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation project(&apos;:flutter&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.在原生代码中集成flutter跳转到flutter页面</p>
<p>我使用了一个新的Activity进行跳转。具体可以参看源码</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Button open = findViewById(R.id.openBtn);</span><br><span class="line">open.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="hljs-keyword">new</span> Intent();</span><br><span class="line">        intent.setClass(MainActivity.<span class="hljs-keyword">this</span>, MyFlutterActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFlutterActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_flutter);</span><br><span class="line">        <span class="hljs-keyword">final</span> FlutterView flutterView = Flutter.createView(</span><br><span class="line">                <span class="hljs-keyword">this</span>,</span><br><span class="line">                getLifecycle(),</span><br><span class="line">                <span class="hljs-string">"route1"</span></span><br><span class="line">        );</span><br><span class="line">        <span class="hljs-keyword">final</span> FrameLayout layout = findViewById(R.id.flutter_container);</span><br><span class="line">        layout.addView(flutterView);</span><br><span class="line">        <span class="hljs-keyword">final</span> FlutterView.FirstFrameListener[] listeners = <span class="hljs-keyword">new</span> FlutterView.FirstFrameListener[<span class="hljs-number">1</span>];</span><br><span class="line">        listeners[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> FlutterView.FirstFrameListener() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFirstFrame</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                layout.setVisibility(View.VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        flutterView.addFirstFrameListener(listeners[<span class="hljs-number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Android从原生跳到Flutter模块的黑屏问题</strong>，在网上看到很多说设置透明主题的但是没有用，后来看到一种先隐藏显示，等待渲染好第一帧后才显示flutter页面的方法。这里要注意一点要在布局中先把flutter的Container布局设置为InVisible状态，不要使用Gone，用gone的话是不显示也不渲染，用InVisible不显示但是会渲染界面占位置，等待渲染完成后再设置为Visible即可。</p>
<p>项目demo我已经传到github中：有遇到问题的可以参考项目源码</p>
<ul>
<li><p>原生Android集成Flutter项目：<a href="https://github.com/zakiso/flutter-native-android.git" target="_blank" rel="noopener">https://github.com/zakiso/flutter-native-android.git</a></p>
</li>
<li><p>原生iOS集成Flutter项目：<a href="https://github.com/zakiso/flutter-native-ios.git" target="_blank" rel="noopener">https://github.com/zakiso/flutter-native-ios.git</a></p>
</li>
<li><p>Flutter模块项目：<a href="https://github.com/zakiso/flutter-module-demo.git" target="_blank" rel="noopener">https://github.com/zakiso/flutter-module-demo.git</a></p>
</li>
</ul>
<h4 id="5-flutter的版本管理"><a href="#5-flutter的版本管理" class="headerlink" title="5.flutter的版本管理"></a>5.flutter的版本管理</h4><p>在我们的开发过程中遇到了一个问题，就是各个开发者使用的flutter sdk版本不一致，导致一些库无法运行，在网上也遇到有相同问题的人，提出了模仿gradle wrapper来做一个flutter_wrapper的思路。于是我根据自己的需要写了一个flutter_wrapper的小工具。它的主要作用是统一开发人员的本地flutter环境。</p>
<p>项目仓库地址：<a href>https://github.com/zakiso/flutterw.git</a></p>
<p><strong>使用说明</strong></p>
<ol>
<li>在你的项目根目录中执行命令下载脚本<br><code>curl -O https://raw.githubusercontent.com/zakiso/flutterw/master/flutterw &amp;&amp; chmod 755 flutterw</code></li>
<li>下载好脚本后在根目录中使用<br><code>./flutterw init</code><br>该命令会收集你当前系统中的flutter版本，并将相关信息写入<code>flutter_wrapper.properties</code>文件中，团队中所有成员都会以该版本号做为该项目的标准版本  </li>
<li>将flutterw文件和flutter_wrapper.properties文件添加到git中提交到仓库里</li>
<li>其他成员拉取代码后在项目中使用<code>flutter</code>命令的地方使用<code>./flutterw</code>代替，如果使用ide请选择home目录下对应版本的sdk包</li>
</ol>
<p><strong>flutterw做了什么？</strong></p>
<ol>
<li>使用flutterw的时候会获取当前目录下的flutter_wrapper.properties文件中的版本号</li>
<li>去用户的<code>${HOME}/flutter_wrapper/{版本号}/</code> 目录下查找是否有该版本sdk</li>
<li>如果没有该版本sdk会下载下来，然后使用该目录下的sdk执行命令</li>
</ol>
<p><strong>注意事项</strong></p>
<p>如果flutter版本是preview的版本是直接使用master的最新代码来管理的。大家可以查看源码很简单，根据自己的需要定制。</p>
<h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>我们整个项目都是使用git进行管理的，虽然每个开发者都需要安装flutter环境，但是对于小团队来说成本并不高，加上flutter_wrapper也保证了版本的一致性。iOS开发者可以在原来的iOS项目中开发flutter的项目，Android开发者可以在原android项目中开发flutter，flutter开发者也可以自己单独开发flutter项目，这种方式其实对于开发者来说也是很方便的。</p>
<p><img src="/media/typora-user-images/image-20190221223543845.png" alt="image-20190221223543845"></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/05/07/优化使用kotlin开发Android app的编译速度/" itemprop="url">优化使用kotlin开发Android app的编译速度</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-05-06T16:01:00.000Z" itemprop="datePublished">5月 7 2019</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            6 分钟 read (About 830 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>团队使用kotlin挺长时间了，一直以来都不太满意kotlin的编译速度，但是也能忍受。最近开了一个新项目，有不少同事从java过来的，他们就实在是受不了，优化编译速度就变得很重要了。</p>
<h3 id="优化之前和之后的对比"><a href="#优化之前和之后的对比" class="headerlink" title="优化之前和之后的对比"></a>优化之前和之后的对比</h3><p><strong>在优化之前我们的一次完整编译时间是2分21秒</strong></p>
<p><img src="/media/typora-user-images/image-20190507140625016.png" alt="image-20190507140625016"></p>
<p>具体的耗时任务在Run Tasks中：</p>
<p><img src="/media/typora-user-images/image-20190507140746857.png" alt="image-20190507140746857"></p>
<p>可以看到具体的耗时任务如上，主要是kapt相关的编译和编译kotlin代码，以及最后的transformClassedWithXXX。</p>
<p><strong>优化之后的完整编译时间31s</strong></p>
<p><img src="/media/typora-user-images/image-20190507151442005.png" alt="image-20190507151442005"></p>
<p><strong>优化之后的增量编译时间15s</strong></p>
<p><img src="/media/typora-user-images/image-20190507151649144.png" alt="image-20190507151649144"></p>
<p><img src="/media/ypora-user-images/image-20190507151800539.png" alt="image-20190507151800539"></p>
<h3 id="优化步骤："><a href="#优化步骤：" class="headerlink" title="优化步骤："></a>优化步骤：</h3><h5 id="1-优化gradle配置："><a href="#1-优化gradle配置：" class="headerlink" title="1.优化gradle配置："></a>1.优化gradle配置：</h5><p>在项目根目录创建一个gradle.properties文件</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//开启gradle并行编译，开启daemon，调整jvm内存大小</span><br><span class="line">org.gradle.daemon=true</span><br><span class="line">org.gradle.configureondemand=true</span><br><span class="line">org.gradle.parallel=true</span><br><span class="line">org.gradle.jvmargs=-Xmx4096m -XX:MaxPermSize=1024m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8</span><br><span class="line"></span><br><span class="line">//开启gradle缓存</span><br><span class="line">org.gradle.caching=true</span><br><span class="line">android.enableBuildCache=true</span><br><span class="line"></span><br><span class="line">//开启kotlin的增量和并行编译</span><br><span class="line">kotlin.incremental=true</span><br><span class="line">kotlin.incremental.java=true</span><br><span class="line">kotlin.incremental.js=true</span><br><span class="line">kotlin.caching.enabled=true</span><br><span class="line">kotlin.parallel.tasks.in.project=true //开启kotlin并行编译</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//优化kapt</span><br><span class="line">kapt.use.worker.api=true  //并行运行kapt1.2.60版本以上支持</span><br><span class="line">kapt.incremental.apt=true  //增量编译 kapt1.3.30版本以上支持</span><br><span class="line">kapt.include.compile.classpath=false  //kapt avoiding 如果用kapt依赖的内容没有变化，会完全重用编译内容，省掉最上图中的:app:kaptGenerateStubsDebugKotlin的时间</span><br></pre></td></tr></table></figure></p>
<p>在上面的配置中，我们首先调整了gradle的配置，然后开启了缓存和kotlin和kapt的增量编译。</p>
<p>如果项目中使用了kapt请使用最新版本的kapt，当前写该文章时kapt的最新版本为<code>1.3.31</code></p>
<h5 id="2-优化app的build-gradle"><a href="#2-优化app的build-gradle" class="headerlink" title="2.优化app的build.gradle"></a>2.优化app的build.gradle</h5><p>1.在项目的app目录中的build.gradle文件中修改：</p>
<p><figure class="highlight groovy hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//如果有用到kapt添加如下配置</span></span><br><span class="line">kapt &#123;</span><br><span class="line">    useBuildCache = <span class="hljs-literal">true</span></span><br><span class="line">    javacOptions &#123;</span><br><span class="line">        option(<span class="hljs-string">"-Xmaxerrs"</span>, <span class="hljs-number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//在Android代码块中添加如下配置：（可优化最上图中transformClassDexBuilderForDebug的时间）</span></span><br><span class="line">android &#123;</span><br><span class="line">    dexOptions &#123;</span><br><span class="line">        preDexLibraries <span class="hljs-literal">true</span></span><br><span class="line">        maxProcessCount <span class="hljs-number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.其他不太重要的优化，好像对时间影响不算特别大</p>
<p>优化版本号的配置，如果是debug版本不要使用动态版本号</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//原配置</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">	...</span><br><span class="line">    minSdkVersion 19</span><br><span class="line">    targetSdkVersion 28</span><br><span class="line">    versionCode gitVersionCode()</span><br><span class="line">    versionName currentName()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">//修改为</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">	...</span><br><span class="line">    minSdkVersion 19</span><br><span class="line">    targetSdkVersion 28</span><br><span class="line">    versionCode 1</span><br><span class="line">    versionName &quot;1.0.0&quot;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    ...</span><br><span class="line">    if (variant.buildType.name == &quot;release&quot;) &#123;</span><br><span class="line">        versionName = currentName()</span><br><span class="line">        versionCode = gitVersionCode()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以前我们的配置上versionCode是使用的git的提交次数作为版本号的，在本地debug状态的时候其实最好是写死版本号，如果版本号变化会导致需要重新生成Manifest文件以及完整的编译应用，导致InstantRun无法使用(PS其实我们一直没用InstantRun)。所以修改为写死版本号，然后在applicationVariants中判断如果是release才使用正常的版本号。然后还有一个就是使用依赖版本的时候，尽量不要使用+号的版本依赖，使用固定版本号速度会更快。</p>
<p>希望大家省下的编译时间，能够好好陪陪家人。 enjoy～</p>
<p>参考资料：</p>
<p><a href="https://developer.android.com/studio/build/optimize-your-build" target="_blank" rel="noopener">https://developer.android.com/studio/build/optimize-your-build</a></p>
<p><a href="https://www.kotlincn.net/docs/reference/kapt.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/kapt.html</a></p>
<p><a href="https://blog.jetbrains.com/kotlin/2019/01/kotlin-1-3-20-released/" target="_blank" rel="noopener">https://blog.jetbrains.com/kotlin/2019/01/kotlin-1-3-20-released/</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/03/29/使用Appium进行App自动化测试体验/" itemprop="url">使用Appium进行App自动化测试体验</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-03-28T16:01:00.000Z" itemprop="datePublished">3月 29 2019</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            6 分钟 read (About 906 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h4 id="1-为什么选择Appium"><a href="#1-为什么选择Appium" class="headerlink" title="1.为什么选择Appium"></a>1.为什么选择Appium</h4><ul>
<li>脚本编写支持多种语言方便测试人员使用自己喜欢的语言维护脚本</li>
<li>跨平台同事支持Android和iOS的测试、并且支持应用内嵌RN或者webview等的测试</li>
<li>纯黑盒，不需要依赖项目源码，可以完全由测试人员控制和维护脚本</li>
<li>基于seleium如果有做过web自动化测试经验会很容易上手</li>
</ul>
<h4 id="2-Appium简介"><a href="#2-Appium简介" class="headerlink" title="2.Appium简介"></a>2.Appium简介</h4><p><a href="http://appium.io/" target="_blank" rel="noopener">Appium</a>是一款基于seleium采用C/S架构的测试工具。有多种语言的客户端比如python和java还有javascript等等，客户端使用rest接口与server端进行通信。server端根据rest请求使用对应的driver和Android真机或者iOS模拟器等设备进行交互。</p>
<p>目前Appium支持如下驱动：</p>
<ul>
<li><p>XCUITest (iOS)</p>
</li>
<li><p>XCUITest Real Devices(iOS)</p>
</li>
<li><p>UIAutomation (iOS)</p>
</li>
<li><p>UIAutomation Safari Launcher(iOS)</p>
</li>
<li><p>UIAutomatar（Android）</p>
</li>
<li><p>Espresso </p>
</li>
<li><p>…等等</p>
</li>
</ul>
<h4 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3.环境搭建"></a>3.环境搭建</h4><p>要使用appium进行自动化测试首先需要安装AppiumServer，然后配置对应的开发环境，安装对应的client客户端以及配置环境，最后编写用咧脚本，然后运行测试。下面我们采用python做为客户端语言，使用Appium Desktop做为server为Android编写测试用例。</p>
<h5 id="1-安装Appium-Server-Desktop"><a href="#1-安装Appium-Server-Desktop" class="headerlink" title="1.安装Appium Server Desktop"></a>1.安装Appium Server Desktop</h5><p><a href="https://github.com/appium/appium-desktop/releases/tag/v1.12.0" target="_blank" rel="noopener">选择适合自己系统的最新版本进行下载</a></p>
<p>下载好后双击打开后点击startServer即可启动该服务</p>
<h5 id="2-安装Android-Studio和Java-SDK-如果以及配置好这些环境可跳过该步骤"><a href="#2-安装Android-Studio和Java-SDK-如果以及配置好这些环境可跳过该步骤" class="headerlink" title="2.安装Android Studio和Java SDK(如果以及配置好这些环境可跳过该步骤)"></a>2.安装Android Studio和Java SDK(如果以及配置好这些环境可跳过该步骤)</h5><ul>
<li><p>下载Android Studio，包含有Android SDK以及可以方便的使用Layout Inspector查找界面id</p>
<p><a href="https://www.androiddevtools.cn/" target="_blank" rel="noopener">https://www.androiddevtools.cn/</a>选择适合自己电脑的最新版本，旧版本没有Layout Inspector</p>
<p>安装好后配置一下Android Home环境变量</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># Android Home</span></span><br><span class="line"><span class="hljs-built_in">export</span> ANDROID_HOME=/Users/zhiqiangdeng/Library/Android/sdk</span><br><span class="line"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$ANDROID_HOME</span>/tools:<span class="hljs-variable">$ANDROID_HOME</span>/platform-tools</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<ul>
<li><p>下载JDK并配置Java Home环境变变量</p>
<p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># Java Home</span></span><br><span class="line"><span class="hljs-built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home</span><br><span class="line"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<h5 id="3-安装Appium-Client"><a href="#3-安装Appium-Client" class="headerlink" title="3.安装Appium Client"></a>3.安装Appium Client</h5><p>这里我们使用python版本的client<a href="https://github.com/appium/python-client" target="_blank" rel="noopener">https://github.com/appium/python-client</a></p>
<p>在使用pip安装appium python client之前，建议先安装pyenv用于管理python的版本。使用pyenv-virtualenv管理python的虚拟环境。如果嫌麻烦可跳过。</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Appium-Python-Client</span><br></pre></td></tr></table></figure></p>
<h4 id="4-开发测试脚本"><a href="#4-开发测试脚本" class="headerlink" title="4.开发测试脚本"></a>4.开发测试脚本</h4><p>安装好后创建一个目录作为我们的项目目录<code>mkdir project-test</code></p>
<p>使用你喜欢的编辑器打开，这里我使用pycharm。</p>
<p>编写脚本：</p>
<p>下面我们以一个登录模块的脚本为例子：</p>
<p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#python </span></span><br><span class="line"><span class="hljs-comment"># Android environment</span></span><br><span class="line"><span class="hljs-keyword">import</span> unittest</span><br><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginTests</span><span class="hljs-params">(unittest.TestCase)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setUp</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># 配置appium需要哪些能力，以及设备信息等基础资料，详细字段可以参考</span></span><br><span class="line">        <span class="hljs-comment"># http://appium.io/docs/en/writing-running-appium/caps/</span></span><br><span class="line">        desired_caps = &#123;&#125;</span><br><span class="line">        desired_caps[<span class="hljs-string">'platformName'</span>] = <span class="hljs-string">'Android'</span></span><br><span class="line">        desired_caps[<span class="hljs-string">'automationName'</span>] = <span class="hljs-string">'uiautomator2'</span></span><br><span class="line">        desired_caps[<span class="hljs-string">'deviceName'</span>] = <span class="hljs-string">'emulator-5556 (9)'</span></span><br><span class="line">        desired_caps[<span class="hljs-string">'appPackage'</span>] = <span class="hljs-string">'com.hd123.apos.ui.debug'</span></span><br><span class="line">        desired_caps[<span class="hljs-string">'appActivity'</span>] = <span class="hljs-string">'com.hd123.apos.ui.view.welcome.SplashActivity'</span></span><br><span class="line">        desired_caps[<span class="hljs-string">"autoGrantPermissions"</span>] = <span class="hljs-literal">True</span></span><br><span class="line">        desired_caps[<span class="hljs-string">"noReset"</span>] = <span class="hljs-literal">True</span></span><br><span class="line">        self.driver = webdriver.Remote(<span class="hljs-string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment"># </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testIsLoginPageAndStoreIdCorrected</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#执行一个测试，执行UI测试最重要的三点</span></span><br><span class="line">        <span class="hljs-comment"># 1. 查找元素 </span></span><br><span class="line">        <span class="hljs-comment"># 2. 执行动作 </span></span><br><span class="line">        <span class="hljs-comment"># 3. 判断结果 </span></span><br><span class="line">        sleep(<span class="hljs-number">2</span>)</span><br><span class="line">        <span class="hljs-comment"># appium支持通过findbyid以及xpath等进行元素的定位</span></span><br><span class="line">        loginBtn = self.driver.find_element_by_id(<span class="hljs-string">"login_tv"</span>)</span><br><span class="line">        self.assertIsNotNone(loginBtn)</span><br><span class="line">        el = self.driver.find_element_by_xpath(<span class="hljs-string">"//android.widget.TextView[contains(@text,'AP1001')]"</span>)</span><br><span class="line">        self.assertIsNotNone(el)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testStoreNumberCorrected</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        username = self.driver.find_element_by_id(<span class="hljs-string">"code_et"</span>)</span><br><span class="line">        username.set_value(<span class="hljs-string">"5551"</span>)</span><br><span class="line">        password = self.driver.find_element_by_id(<span class="hljs-string">"pwd_et"</span>)</span><br><span class="line">        password.set_value(<span class="hljs-string">"0"</span>)</span><br><span class="line">        loginBtn = self.driver.find_element_by_id(<span class="hljs-string">"login_tv"</span>)</span><br><span class="line">        loginBtn.click()</span><br><span class="line">    <span class="hljs-comment"># def test</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">    suite = unittest.TestLoader().loadTestsFromTestCase(LoginTests)</span><br><span class="line">    unittest.TextTestRunner(verbosity=<span class="hljs-number">2</span>).run(suite)</span><br></pre></td></tr></table></figure></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2019/02/21/Flutter快速入门文档/" itemprop="url">Futter快速入门学习指南</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-02-20T16:01:00.000Z" itemprop="datePublished">2月 21 2019</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 分钟 read (About 444 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>flutter是什么？</p>
<p>flutter是google退出的一款跨平台app开发框架，他采用自己绘制界面的方式，采用了Android的skia绘制引擎，性能较高，同时不是像react native一样渲染成原生组件，所以跨平台兼容性较好，不需要依赖原生实现。</p>
<p><img src="https://cdn-images-1.medium.com/max/1440/1*5MY5yRErZcv46mN3er8JIA.png" alt="img"></p>
<h4 id="（一）flutter基础"><a href="#（一）flutter基础" class="headerlink" title="（一）flutter基础"></a>（一）flutter基础</h4><p>flutter项目目录介绍</p>
<ul>
<li>项目结构</li>
<li>常用命令<ul>
<li>flutter doctor、flutter build、flutter —version</li>
<li>flutter packages get</li>
<li>hot reload如何进行的</li>
<li>flutter —help演示</li>
</ul>
</li>
</ul>
<p>程序是如何运行的</p>
<ul>
<li>main函数 入口</li>
<li>演示demo的布局讲解<ul>
<li>flutter inspector使用</li>
</ul>
</li>
</ul>
<h4 id="（二）flutter布局介绍"><a href="#（二）flutter布局介绍" class="headerlink" title="（二）flutter布局介绍"></a>（二）flutter布局介绍</h4><p>Text  Textfield. Container</p>
<p>Column Row</p>
<p>Stack</p>
<p>ListView</p>
<p>Scofford</p>
<p>页面传值与原生交互</p>
<p>Flutter平台特定的API支持不依赖于代码生成，而是依赖于灵活的消息传递的方式：</p>
<p>应用的Flutter部分通过平台通道（platform channel）将消息发送到其应用程序的所在的宿主（iOS或Android）。</p>
<p>宿主监听的平台通道，并接收该消息。然后它会调用特定于该平台的API（使用原生编程语言） - 并将响应发送回客户端，即应用程序的Flutter部分。</p>
<p>用平台通道在客户端（Flutter UI）和宿主（平台）之间传递消息，如下图所示：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fqi6oy9kj6j30g40hzmxi.jpg" alt="img"></p>
<h3 id="界面绘制："><a href="#界面绘制：" class="headerlink" title="界面绘制："></a>界面绘制：</h3><p><img src="https://cdn-images-1.medium.com/max/1440/1*NEMl_CrH4mAKeVCgxXRhiA.png" alt="img"></p>
<p><img src="https://cdn-images-1.medium.com/max/1440/1*h3CuR6jpaGAel6HyVpv8RA.png" alt="img"></p>
<p><img src="https://cdn-images-1.medium.com/max/1440/1*2NGvaOqMyGwX7Cp1k0JTxg.png" alt="img"></p>
<p><img src="https://cdn-images-1.medium.com/max/1440/1*d-Q8fAT5YjedMOXfpATtlw.png" alt="img"></p>
<p><img src="https://cdn-images-1.medium.com/max/1440/1*Kvjwl5DpKmYOGyNE5ytYbA.png" alt="img"></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-05-ViewGroup/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例5--ViewGroup没拦截但是却消费了触摸事件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T05:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            5 分钟 read (About 759 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>本文的示例是在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>的基础上修改的。与<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>相比，本文的示例对MyViewGroup中的onTouchEvent()进行了修改。修改后的onTouchEvent()代码如下：</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {
    String actionName = Utils.getActionName(event);
    Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
    // boolean ret = super.onTouchEvent(event);
    boolean ret = true;
    Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
    return ret;
}   </code></pre><p>说明：修改后的MyViewGroup没有拦截触摸事件，但是消费了触摸事件。</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>MyViewGroup没有拦截却消费了ACTION_DOWN。由于MyViewGroup没有拦截ACTION_DOWN，因此，该事件会继续分发给MyViewGroup的子类MyView。由于MyViewGroup消费了ACTION_DOWN，因此该事件不会分发给MyActivity的onTouchEvent()。</strong><br>(02) <strong>MyViewGroup没有拦截却消费了ACTION_DOWN。那么，MyViewGroup仍然可以接受到ACTION_MOVE和ACTION_UP这两种触摸触事件。但是对于MyView而言，由于MyView没有接受该事件；因此，MyView不会收到ACTION_MOVE和ACTION_UP。</strong><br>   试想想，如果MyView接受了ACTION_DOWN事件的话；它是否会收到ACTION_MOVE和ACTION_UP事件呢？答案是：会。感兴趣的读者可以自行验证。</p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event05.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event05.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/05_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例5的源码</a></p>
<p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 2950): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2950): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2950): onInterceptTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 2950): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyView( 2950): onTouchEvent(start) :DOWN<br>D/##skywang-MyView( 2950): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 2950): dispatchTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyViewGroup( 2950): onTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2950): onTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyActivity( 2950): dispatchTouchEvent( end ) :DOWN, ret=true</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 2950): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2950): onTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2950): onTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyActivity( 2950): dispatchTouchEvent( end ) :MOVE, ret=true</p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 2950): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2950): onTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2950): onTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyActivity( 2950): dispatchTouchEvent( end ) :UP, ret=true</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-04-ViewGroup/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例4--ViewGroup拦截并消费触摸事件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T04:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 read (About 1169 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/03_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例(三)</a>中，MyViewGroup只是拦截了触摸事件，但是并没有消费触摸事件。<br>而在本文的示例中，MyViewGroup将在拦截触摸事件的基础上，同时消费触摸事件。</p>
<p>本文的示例仍然是在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/03_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例(三)</a>的基础上修改的。与<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/03_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例(三)</a>相比，本文的示例对MyViewGroup中的onTouchEvent()进行了修改。修改后的onTouchEvent()代码如下：</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {
    String actionName = Utils.getActionName(event);
    Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
    // boolean ret = super.onTouchEvent(event);
    boolean ret = true;
    Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
    return ret;
}   </code></pre><p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>MyViewGroup拦截并消费了ACTION_DOWN。那么，该事件就不会分发给MyViewGroup的子类，也不会调用MyActivity的onTouchEvent()。</strong><br>(02) <strong>MyViewGroup拦截并消费了ACTION_DOWN。那么，MyViewGroup就会接受到ACTION_MOVE和ACTION_UP这两种触摸触事件。而且对于ACTION_MOVE和ACTION_UP事件，不会再执行拦截操作，即不会调用MyViewGroup.onInterceptTouchEvent()；而是直接调用MyViewGroup.onTouchEvent()对事件进行处理。</strong><br>  为什么在ACTION_MOVE和ACTION_UP中，没有执行MyViewGroup.onInterceptTouchEvent()呢？查看[ViewGroup中的dispatchTouchEvent()源码]即可得到答案，MyViewGroup在分发ACTION_MOVE时，没有执行”第3步”和”第5步”，而是直接执行”第6步”；进而调用View.dispatchTouchEvent()进行的处理。</p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event04.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event04.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/04_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例4的源码</a></p>
<p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 2465): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2465): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2465): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2465): onInterceptTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2465): onTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2465): onTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2465): dispatchTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyActivity( 2465): dispatchTouchEvent( end ) :DOWN, ret=true</p>
<p>说明：很显然，ACTION_DOWN的流程如下：<br>(01) MyActivity收到ACTION_DOWN，<strong>进入MyActivity.dispatchTouchEvent()</strong>。<br>(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，<strong>进入MyViewGroup.dispatchTouchEvent()</strong>。<br>(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先<strong>进入MyViewGroup.onInterceptTouchEvent()</strong>。<br>(04) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onInterceptTouchEvent()</strong>。此时，MyViewGroup.onInterceptTouchEvent()返回true。表示MyViewGroup拦截了该触摸事件。<br>(05) MyViewGroup在得知自己拦截了触摸事件之后，将触摸事件交给自己的onTouchEvent()进行处理，即<strong>进入MyViewGroup.onTouchEvent()</strong>。<br>(06) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onTouchEvent()</strong>，并返回true。表示MyViewGroup消费了该事件。<br>(07) 随后，MyViewGroup会<strong>退出MyViewGroup.dispatchTouchEvent()</strong>，并返回true。表示MyViewGroup接受了该触摸事件。<br>(08) MyActivity得知MyViewGroup接受了该触摸事件之后，就会<strong>退出MyActivity.dispatchTouchEvent()</strong>，并返回true。表示此次触摸事件被消费了。</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 2465): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2465): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2465): onTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2465): onTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyViewGroup( 2465): dispatchTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyActivity( 2465): dispatchTouchEvent( end ) :MOVE, ret=true</p>
<p>说明：由于MyViewGroup接受了ACTION_DOWN；因此，ACTION_MOVE事件会继续分发给MyViewGroup。不过此时，是直接调用onTouchEvent()进行消息处理，而不再需要执行onInterceptTouchEvent()来拦截消息。<br>为什么没有执行MyViewGroup.onInterceptTouchEvent()呢？查看[ViewGroup中的dispatchTouchEvent()源码]即可得到答案，MyViewGroup在分发ACTION_MOVE时，没有执行”第3步”和”第5步”，而是直接执行”第6步”；进而调用View.dispatchTouchEvent()进行的处理。  </p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 2595): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2595): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2595): onTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2595): onTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyViewGroup( 2595): dispatchTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyActivity( 2595): dispatchTouchEvent( end ) :UP, ret=true</p>
<p>说明：ACTION_UP的路径和ACTION_MOVE的路径一样！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-03-ViewGroup/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例3--ViewGroup拦截但不消费触摸事件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T03:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            9 分钟 read (About 1304 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/02_event_view/EventTest" target="_blank" rel="noopener">触摸事件示例(二)</a>中，MyView接受了触摸事件。<br>可是，在有的时候，我们希望MyViewGroup对触摸事件进行拦截；而不希望这个事件发送给MyView进行处理。此时，就需要重载GroupView的onInterceptTouchEvent()来拦截触摸事件。这就是本文要讲到的示例。</p>
<p>本文的示例仍然是在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>的基础上修改的。与<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/02_event_view/EventTest" target="_blank" rel="noopener">触摸事件示例(二)</a>不同，本文的示例仅仅只对MyViewGroup中的onInterceptTouchEvent()进行了修改。修改后的onInterceptTouchEvent()代码如下：</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    String actionName = Utils.getActionName(event);
    Log.d(TAG, &quot;onInterceptTouchEvent(start) :&quot;+actionName);
    // boolean ret = super.onInterceptTouchEvent(event);
    boolean ret = true;
    Log.d(TAG, &quot;onInterceptTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
    return ret;
}   </code></pre><p>这里的onTouchEvent()直接返回true，表示MyView消费了触摸事件。</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>MyViewGroup拦截了ACTION_DOWN，并没有消费该ACTION_DOWN。既然MyViewGroup拦截了ACTION_DOWN，那就意味着该事件就不会分发给MyViewGroup的子类。但是由于MyViewGroup没有消费该事件，即它并没有接受该事件；那么，ACTION_DOWN会继续查找其他对象来消费它自己，这也意味着该触摸事件仍然会发送MyActivity的onTouchEvent()。</strong><br>  如果MyActivity中有和MyViewGroup同级别的GroupView的话，在得知MyViewGroup拦截了ACTION_DOWN，却没有消费该ACTION_DOWN之后；MyActivity仍然能够向这个同级的GroupView分发消息。<br>(02) <strong>MyViewGroup并没有消费ACTION_DOWN，那么，MyViewGroup就不能接受到ACTION_MOVE和ACTION_UP这两种触摸触事件。至于MyViewGroup的子类MyView，就更加不可能接受到ACTION_MOVE和ACTION_UP了。</strong></p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event03.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event03.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/03_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例3的源码</a></p>
<p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 2371): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2371): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2371): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2371): onInterceptTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2371): onTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2371): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyViewGroup( 2371): dispatchTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyActivity( 2371): onTouchEvent(start) :DOWN<br>D/##skywang-MyActivity( 2371): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyActivity( 2371): dispatchTouchEvent( end ) :DOWN, ret=false</p>
<p>说明：很显然，ACTION_DOWN的流程如下：<br>(01) MyActivity收到ACTION_DOWN，<strong>进入MyActivity.dispatchTouchEvent()</strong>。<br>(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，<strong>进入MyViewGroup.dispatchTouchEvent()</strong>。<br>(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先<strong>进入MyViewGroup.onInterceptTouchEvent()</strong>。<br>(04) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onInterceptTouchEvent()</strong>。此时，MyViewGroup.onInterceptTouchEvent()返回true。表示MyViewGroup拦截了该触摸事件。<br>(05) MyViewGroup在得知自己拦截了触摸事件之后，将触摸事件交给自己的onTouchEvent()进行处理，即<strong>进入MyViewGroup.onTouchEvent()</strong>。<br>(06) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onTouchEvent()</strong>。而MyViewGroup自身并没有消费该事件，因此MyViewGroup.onTouchEvent()返回false。<br>(07) 随后，<strong>退出MyViewGroup.dispatchTouchEvent()</strong>，并返回false。表示MyViewGroup没有接受该触摸事件。<br>(08) MyActivity得知MyViewGroup没有接受该触摸事件之后，就会调用<strong>进入MyActivity.onTouchEvent()</strong>。<br>(09) 紧接着，MyActivity会<strong>退出MyActivity.onTouchEvent()</strong>，并返回false。表示MyActivity也没有消费触摸事件。<br>(10) 最后，MyActivity会<strong>退出MyActivity.dispatchTouchEvent()</strong>，并返回false。表示此次触摸事件没有被消费。</p>
<p>对比，<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>中的ACTION_DOWN路径。在本示例中，MyViewGroup拦截了ACTION_DOWN，但是没有消费ACTION_DOWN事件。 (01) MyViewGroup拦截了ACTION_DOWN事件，意味着该事件不会继续往下分发。 (02) MyViewGroup没有消费该事件，意味着该事件就继续往上分发。</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 2371): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyActivity( 2371): onTouchEvent(start) :MOVE<br>D/##skywang-MyActivity( 2371): onTouchEvent( end ) :MOVE, ret=false<br>D/##skywang-MyActivity( 2371): dispatchTouchEvent( end ) :MOVE, ret=false</p>
<p>说明：由于MyViewGroup拦截了ACTION_DOWN，却没有消费给ACTION_DOWN；导致ACTION_MOVE不会分发给MyViewGroup。既然没有分发给MyViewGroup，就更加谈不上分发给MyView了。</p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 2371): dispatchTouchEvent(start) :UP<br>D/##skywang-MyActivity( 2371): onTouchEvent(start) :UP<br>D/##skywang-MyActivity( 2371): onTouchEvent( end ) :UP, ret=false<br>D/##skywang-MyActivity( 2371): dispatchTouchEvent( end ) :UP, ret=false</p>
<p>说明：ACTION_UP的路径和ACTION_MOVE的路径一样！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-02-View/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例2--View接受触摸事件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T02:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 read (About 1226 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>本文的示例是在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>的基础上修改的。即本文的示例仍然是：自定义一个Activity，该Activity中的显示内容是包含一个自定义的ViewGroup，该ViewGroup中包含一个自定义的View。</p>
<p>相比<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>，本示例对MyView中的onTouchEvent()进行了修改。修改后的onTouchEvent()代码如下：</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {
    String actionName = Utils.getActionName(event);
    Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
    // boolean ret = super.onTouchEvent(event);
    boolean ret = true;
    Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
    return ret;
}   </code></pre><p>这里的onTouchEvent()直接返回true，表示MyView消费了触摸事件。</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>如果MyView接受了ACTION_DOWN，那么就不会再再执行其他对象的onTouchEvent()函数的。即，不会执行MyViewGroup的onTouchEvent()和MyActivity的onTouchEvent()。因为MyView接受了ACTION_DOWN，意味着这个事件已经被消费了；就无须其他对象再来消费ACTION_DOWN了。</strong><br>(02) <strong>如果MyView接受了ACTION_DOWN，那么MyView能继续收到ACTION_MOVE和ACTION_UP这两种触摸触事件。并且ACTION_MOVE和ACTION_UP的处理流程和ACTION_DOWN的流程基本一样。</strong></p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event02.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/02_event_view/EventTest" target="_blank" rel="noopener">触摸事件示例2的源码</a></p>
<p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 2273): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 2273): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyView( 2273): onTouchEvent(start) :DOWN<br>D/##skywang-MyView( 2273): onTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyView( 2273): dispatchTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyActivity( 2273): dispatchTouchEvent( end ) :DOWN, ret=true</p>
<p>说明：很显然，ACTION_DOWN的流程如下：<br>(01) MyActivity收到ACTION_DOWN，<strong>进入MyActivity.dispatchTouchEvent()</strong>。<br>(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，<strong>进入MyViewGroup.dispatchTouchEvent()</strong>。<br>(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先<strong>进入MyViewGroup.onInterceptTouchEvent()</strong>。<br>(04) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onInterceptTouchEvent()</strong>。因为MyViewGroup没有对触摸事件进行拦截，MyViewGroup会继续分发事件。<br>(05) MyViewGroup将触摸事件分发给MyView，即<strong>进入MyView.dispatchTouchEvent()</strong>。<br>(06) MyView会调用onTouchEvent()对触摸事件进行处理，即<strong>进入MyView.onTouchEvent()</strong>  。<br>(07) 紧接着，MyView会<strong>退出MyView.onTouchEvent()</strong>。此时的，MyView.onTouchEvent()返回的是true；表示MyView消费了此次触摸事件。<br>(08) MyView.dispatchTouchEvent()得知MyView.onTouchEvent()消费此次触摸事件之后；也就返回true，表示MyView接受该此次触摸事件。<br>(09) MyViewGroup则得知MyView接受了该触摸事件之后，就<strong>退出MyViewGroup.dispatchTouchEvent()</strong>，并返回true。<br>(10) MyActivity得知MyViewGroup接受了该触摸事件之后，就会调用<strong>退出MyActivity.dispatchTouchEvent()</strong>，并返回true。</p>
<p>对比，<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>中的ACTION_DOWN路径。在本示例中，MyView消费了ACTION_DOWN事件之后；触摸事件就没有再发送给MyViewGroup.onTouchEvent()以及MyActivity.onTouchEvent()。</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 2273): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent( end ) :MOVE, ret=false<br>D/##skywang-MyView( 2273): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyView( 2273): onTouchEvent(start) :MOVE<br>D/##skywang-MyView( 2273): onTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyView( 2273): dispatchTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyActivity( 2273): dispatchTouchEvent( end ) :MOVE, ret=true</p>
<p>说明：由于MyView接受了ACTION_DOWN；因此，ACTION_MOVE事件会继续分发给MyView。ACTION_MOVE的分发路径和ACTION_DOWN的路径基本上一样！</p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 2273): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent( end ) :UP, ret=false<br>D/##skywang-MyView( 2273): dispatchTouchEvent(start) :UP<br>D/##skywang-MyView( 2273): onTouchEvent(start) :UP<br>D/##skywang-MyView( 2273): onTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyView( 2273): dispatchTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyActivity( 2273): dispatchTouchEvent( end ) :UP, ret=true</p>
<p>说明：由于MyView接受了ACTION_DOWN；因此，ACTION_UP事件会继续分发给MyView。ACTION_UP的分发路径和ACTION_DOWN的路径基本上一样！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-01-default/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例1--默认处理方式</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T01:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 read (About 1914 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>2.1</strong>. <a href="#anchor2_1">MyActivity的源码</a><br><strong>2.2</strong>. <a href="#anchor2_2">MyViewGroup的源码</a><br><strong>2.3</strong>. <a href="#anchor2_3">MyView的源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>本文的示例：自定义一个Activity，该Activity中的显示内容是包含一个自定义的ViewGroup，该ViewGroup中包含一个自定义的View。</p>
<p>(01) 自定义的Activity是MyActivity<br>public boolean dispatchTouchEvent(MotionEvent ev): 调用系统默认的dispatchTouchEvent()<br>public boolean onTouchEvent(MotionEvent ev): 调用系统默认的onTouchEvent()</p>
<p>(02) 自定义ViewGroup是MyViewGroup<br>public boolean dispatchTouchEvent(MotionEvent ev): 调用系统默认的dispatchTouchEvent()<br>public boolean onTouchEvent(MotionEvent ev): 调用系统默认的onTouchEvent()<br>public boolean onInterceptTouchEvent(MotionEvent ev):: 调用系统默认的onInterceptTouchEvent() </p>
<p>(03) 自定义View是MyView<br>public boolean dispatchTouchEvent(MotionEvent ev): 调用系统默认的dispatchTouchEvent()<br>public boolean onTouchEvent(MotionEvent ev): 调用系统默认的onTouchEvent()</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>MyActivity, ViewGroup和View的触摸事件相关API默认都返回false。即，上面列出的API的默认返回值都是false。</strong><br>(02) <strong>触摸事件的分发顺序是经过MyActivity –&gt; MyViewGroup –&gt; MyView。</strong><br>    它们的触摸事件的入口都是dispatchTouchEvent()，即MyActivity将事件分发给MyViewGroup时，是通过MyActivity.dispatchTouchEvent()去调用MyViewGroup.dispatchTouchEvent()；同样的，MyViewGroup将事件分发给MyView时，也是通过MyViewGroup.dispatchTouchEvent()去调用MyView.dispatchTouchEvent()。<br>    它们的对触摸事件的处理都是在onTouchEvent()中完成的。也就是说，会在它们的dispatchTouchEvent()中，皆会调用(它们各自的)onTouchEvent()来对事件进行处理。onTouchEvent()返回true，就表示消费了个事件，或者说接受了个事件。<br>    前面说过消息的分发顺序是MyActivity –&gt; MyViewGroup –&gt; MyView。如果想在MyActivity中进行消息拦截(即，MyActivity不想将消息分发给它包含的视图)，则需要重载dispatchTouchEvent()。如果想在MyViewGroup中进行消息拦截(即，MyViewGroup收到触摸事件之后，不想分发给它的子视图)，则一般都会通过覆盖onInterceptTouchEvent()，并在onInterceptTouchEvent()返回true来拦截消息。<br>(03) <strong>MyViewGroup和MyView都没有接受ACTION_DOWN事件的话；那么，ACTION_MOVE和ACTION_UP等触摸事件也就不会发送给它们。</strong>  </p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event01.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例1的源码</a></p>
<p><a name="anchor2_1"></a></p>
<h2 id="2-1-MyActivity的源码"><a href="#2-1-MyActivity的源码" class="headerlink" title="2.1 MyActivity的源码"></a>2.1 MyActivity的源码</h2><pre><code>public class MyActivity extends Activity {
    private static final String TAG = &quot;##skywang-MyActivity&quot;;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }   

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;dispatchTouchEvent(start) :&quot;+actionName);
        boolean ret = super.dispatchTouchEvent(event);
        Log.d(TAG, &quot;dispatchTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }   

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
        boolean ret = super.onTouchEvent(event);
        Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }
}</code></pre><p>说明：MyActivity的layout是main.xml。虽然它覆盖了dispatchTouchEvent()和onTouchEvent()方法；但它们都是在调用父类的对应的方法的基础之上，添加了打印信息而已。</p>
<h3 id="2-1-1-getActionName的源码"><a href="#2-1-1-getActionName的源码" class="headerlink" title="2.1.1 getActionName的源码"></a>2.1.1 getActionName的源码</h3><pre><code>public static String getActionName(MotionEvent event) {
    final int action = event.getAction(); 
    if (action == MotionEvent.ACTION_DOWN) {
        return &quot;DOWN&quot;;     
    } else if (action == MotionEvent.ACTION_MOVE) {
        return &quot;MOVE&quot;;     
    } else if (action == MotionEvent.ACTION_UP) {
        return &quot;UP&quot;;       
    } else if (action == MotionEvent.ACTION_CANCEL) { 
        return &quot;CANCEL&quot;;   
    } else {               
        return &quot;NULL&quot;;     
    }
}</code></pre><h3 id="2-1-2-main-xml的源码"><a href="#2-1-2-main-xml的源码" class="headerlink" title="2.1.2 main.xml的源码"></a>2.1.2 main.xml的源码</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;fill_parent&quot; &gt;

    &lt;TextView                  
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Hello World, EventTest-Default&quot; /&gt;

    &lt;com.skw.eventtest.MyViewGroup  
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;400dp&quot;
        android:background=&quot;#cccccc&quot;
        android:layout_gravity=&quot;center&quot;
        android:gravity=&quot;center&quot; &gt;

        &lt;com.skw.eventtest.MyView       
            android:layout_width=&quot;200dp&quot;
            android:layout_height=&quot;100dp&quot;
            android:background=&quot;#451c0a&quot; /&gt;

    &lt;/com.skw.eventtest.MyViewGroup&gt;
&lt;/LinearLayout&gt;</code></pre><p>说明：main.xml中包含了MyViewGroup，而MyViewGroup中又包含了MyView。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-MyViewGroup的源码"><a href="#2-2-MyViewGroup的源码" class="headerlink" title="2.2 MyViewGroup的源码"></a>2.2 MyViewGroup的源码</h2><pre><code>public class MyViewGroup extends LinearLayout {
    private static final String TAG = &quot;##skywang-MyViewGroup&quot;;

    public MyViewGroup(Context context){
        super(context);        
    } 

    public MyViewGroup(Context context, AttributeSet attrs) {
        super(context, attrs); 
    }     

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;dispatchTouchEvent(start) :&quot;+actionName);
        boolean ret = super.dispatchTouchEvent(event);
        Log.d(TAG, &quot;dispatchTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
        boolean ret = super.onTouchEvent(event);
        Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;onInterceptTouchEvent(start) :&quot;+actionName);
        boolean ret = super.onInterceptTouchEvent(event);
        Log.d(TAG, &quot;onInterceptTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }
}</code></pre><p>说明：MyViewGroup继承于ViewGroup。虽然它覆盖了dispatchTouchEvent(), onTouchEvent()和onInterceptTouchEvent()方法；但它们都是在调用父类的对应的方法的基础之上，添加了打印信息而已。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="2-3-MyView的源码"><a href="#2-3-MyView的源码" class="headerlink" title="2.3 MyView的源码"></a>2.3 MyView的源码</h2><pre><code>public class MyView extends View {
    private static final String TAG = &quot;##skywang-MyView&quot;;

    public MyView(Context context) {
        super(context);        
    }

    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs); 
    } 

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;dispatchTouchEvent(start) :&quot;+actionName);
        boolean ret = super.dispatchTouchEvent(event);
        Log.d(TAG, &quot;dispatchTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
        boolean ret = super.onTouchEvent(event);
        Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }
}</code></pre><p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 1935): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 1935): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 1935): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 1935): onInterceptTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 1935): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyView( 1935): onTouchEvent(start) :DOWN<br>D/##skywang-MyView( 1935): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 1935): dispatchTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyViewGroup( 1935): onTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 1935): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyViewGroup( 1935): dispatchTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyActivity( 1935): onTouchEvent(start) :DOWN<br>D/##skywang-MyActivity( 1935): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyActivity( 1935): dispatchTouchEvent( end ) :DOWN, ret=false</p>
<p>说明：很显然，ACTION_DOWN的流程如下：<br>(01) MyActivity收到ACTION_DOWN，<strong>进入MyActivity.dispatchTouchEvent()</strong>。<br>(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，<strong>进入MyViewGroup.dispatchTouchEvent()</strong>。<br>(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先<strong>进入MyViewGroup.onInterceptTouchEvent()</strong>。<br>(04) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onInterceptTouchEvent()</strong>。因为MyViewGroup没有对触摸事件进行拦截，MyViewGroup会继续分发事件。<br>(05) MyViewGroup将触摸事件分发给MyView，即<strong>进入MyView.dispatchTouchEvent()</strong>。<br>(06) MyView会调用onTouchEvent()对触摸事件进行处理，即<strong>进入MyView.onTouchEvent()</strong>  。<br>(07) 紧接着，MyView会<strong>退出MyView.onTouchEvent()</strong>。返回false给MyView.dispatchTouchEvent()。<br>(08) MyView收到MyView.onTouchEvent()的返回值之后，<strong>退出MyView.dispatchTouchEvent()</strong>。返回false给MyViewGroup的MyViewGroup.dispatchTouchEvent()，表示MyView没有接受该触摸事件。<br>(09) MyViewGroup则得知MyView没有接受该触摸事件之后，将自己当作一个View，调用View.dispatchTouchEvent()；View.dispatchTouchEvent()接着就会<strong>进入MyViewGroup.onTouchEvent()</strong>。<br>(10) 紧接着，就会<strong>退出MyViewGroup.onTouchEvent()</strong>。MyViewGroup.onTouchEvent()没有消费该触摸事件，因此返回false。<br>(11) 然后，View.dispatchTouchEvent()就会结束，并返回false。接着，MyViewGroup就会<strong>退出MyViewGroup.dispatchTouchEvent()</strong>。并返回false。<br>(12) MyActivity在得知MyViewGroup没有接受该触摸事件之后，就会调用<strong>进入MyActivity.onTouchEvent</strong>。<br>(13) 紧接着，就会<strong>退出MyActivity.onTouchEvent</strong>，并返回false。<br>(14) 至此，MyActivity.dispatchTouchEvent()才结束。因此，会<strong>退出MyActivity.dispatchTouchEvent()</strong>，并返回false。</p>
<p>说明：触摸事件的分发顺序是经过MyActivity –&gt; MyViewGroup –&gt; MyView。</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 1935): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyActivity( 1935): onTouchEvent(start) :MOVE<br>D/##skywang-MyActivity( 1935): onTouchEvent( end ) :MOVE, ret=false<br>D/##skywang-MyActivity( 1935): dispatchTouchEvent( end ) :MOVE, ret=false</p>
<p>说明：由于MyViewGroup和MyView都没有接受ACTION_DOWN事件，因此ACTION_MOVE事件就不会再分发给它们。</p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 1935): dispatchTouchEvent(start) :UP<br>D/##skywang-MyActivity( 1935): onTouchEvent(start) :UP<br>D/##skywang-MyActivity( 1935): onTouchEvent( end ) :UP, ret=false<br>D/##skywang-MyActivity( 1935): dispatchTouchEvent( end ) :UP, ret=false</p>
<p>说明：由于MyViewGroup和MyView都没有接受ACTION_DOWN事件，因此ACTION_UP事件就不会再分发给它们。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/04/android/os/event/2015-01-04-TouchEvent-ViewGroup/" itemprop="url">Android 触摸事件机制(四) ViewGroup中触摸事件详解</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-04T01:01:00.000Z" itemprop="datePublished">1月 4 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            26 分钟 read (About 3837 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将对ViewGroup中触摸事件相关的内容进行介绍。ViewGroup继承于View，所以说，ViewGroup中对触摸事件的处理，很多都继承于View。但是，ViewGroup又有自己对触摸事件的特定处理。本文重点介绍的是dispatchTouchEvent()；理解ViewGroup的dispatchTouchEvent()接口是理解Android触摸事件传递机制的关机。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">ViewGroup中触摸事件的概述</a><br><strong>2</strong>. <a href="#anchor2">ViewGroup中触摸事件的源码解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">ViewGroup中的dispatchTouchEvent</a><br><strong>2.2</strong>. <a href="#anchor2_2">ViewGroup中的onTouchEvent</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-ViewGroup中触摸事件的概述"><a href="#1-ViewGroup中触摸事件的概述" class="headerlink" title="1. ViewGroup中触摸事件的概述"></a>1. ViewGroup中触摸事件的概述</h1><p>ViewGroup继承于View，它中对触摸事件的处理，很多都继承于View。但是，ViewGroup又有自己对触摸事件的特定处理。<br>(01) ViewGroup重载了dispatchTouchEvent()接口。<br>(02) ViewGroup新增了onInterceptTouchEvent()接口。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-ViewGroup中触摸事件的源码解析"><a href="#2-ViewGroup中触摸事件的源码解析" class="headerlink" title="2. ViewGroup中触摸事件的源码解析"></a>2. ViewGroup中触摸事件的源码解析</h1><p><a name="anchor2_1"></a></p>
<h2 id="2-1-ViewGroup中的dispatchTouchEvent"><a href="#2-1-ViewGroup中的dispatchTouchEvent" class="headerlink" title="2.1 ViewGroup中的dispatchTouchEvent"></a>2.1 ViewGroup中的dispatchTouchEvent</h2><pre><code>@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    // mInputEventConsistencyVerifier是调试用的，不会理会
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }

    // 第1步：是否要分发该触摸事件
    //
    // onFilterTouchEventForSecurity()表示是否要分发该触摸事件。 
    // 如果该View不是位于顶部，并且有设置属性使该View不在顶部时不响应触摸事件，则不分发该触摸事件，即返回false。
    // 否则，则对触摸事件进行分发，即返回true。
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

        // 第2步：检测是否需要清空目标和状态
        //
        // 如果是ACTION_DOWN(即按下事件)，则清空之前的触摸事件处理目标和状态。
        // 这里的情况状态包括：
        // (01) 清空mFirstTouchTarget链表，并设置mFirstTouchTarget为null。
        //      mFirstTouchTarget是&quot;接受触摸事件的View&quot;所组成的单链表
        // (02) 清空mGroupFlags的FLAG_DISALLOW_INTERCEPT标记
        //      如果设置了FLAG_DISALLOW_INTERCEPT，则不允许ViewGroup对触摸事件进行拦截。
        // (03) 清空mPrivateFlags的PFLAG_CANCEL_NEXT_UP_EVEN标记
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }    

        // 第3步：检查当前ViewGroup是否想要拦截触摸事件
        // 
        // 是的话，设置intercepted为true；否则intercepted为false。
        // 如果是&quot;按下事件(ACTION_DOWN)&quot; 或者 mFirstTouchTarget不为null；就执行if代码块里面的内容。
        // 否则的话，设置intercepted为true。
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            // 检查禁止拦截标记：FLAG_DISALLOW_INTERCEPT
            // 如果调用了requestDisallowInterceptTouchEvent()标记的话，则FLAG_DISALLOW_INTERCEPT会为true。
            // 例如，ViewPager在处理触摸事件的时候，就会调用requestDisallowInterceptTouchEvent()
            //     ，禁止它的父类对触摸事件进行拦截
            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                // 如果禁止拦截标记为false的话，则调用onInterceptTouchEvent()；并返回拦截状态。
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else {
                intercepted = false;
            }    
        } else {
            intercepted = true;
        }    

        // 第4步：检查当前的触摸事件是否被取消
        // 
        // (01) 对于ACTION_DOWN而言，mPrivateFlags的PFLAG_CANCEL_NEXT_UP_EVENT位肯定是0；因此，canceled=false。
        // (02) 当前的View或ViewGroup要被从父View中detach时，PFLAG_CANCEL_NEXT_UP_EVENT就会被设为true；
        //      此时，它就不再接受触摸事情。
        final boolean canceled = resetCancelNextUpFlag(this)
                || actionMasked == MotionEvent.ACTION_CANCEL;

        // 第5步：将触摸事件分发给&quot;当前ViewGroup的子View和子ViewGroup&quot;
        // 
        // 如果触摸&quot;没有被取消&quot;，同时也&quot;没有被拦截&quot;的话，则将触摸事件分发给它的子View和子ViewGroup。  
        //     如果当前ViewGroup的孩子有接受触摸事件的话，则将该孩子添加到mFirstTouchTarget链表中。
        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled &amp;&amp; !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // 这是获取触摸事件的序号 以及 触摸事件的id信息。
                // (01) 对于ACTION_DOWN，actionIndex肯定是0
                // (02) 而getPointerId()是获取的该触摸事件的id，并将该id信息保存到idBitsToAssign中。
                //    这个触摸事件的id是为多指触摸而添加的；对于单指触摸，getActionIndex()返回的肯定是0；
                //    而对于多指触摸，第一个手指的id是0，第二个手指的id是1，第三个手指的id是2，...依次类推。
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                        : TouchTarget.ALL_POINTER_IDS;

                // 清空这个手指之前的TouchTarget链表。
                // 一个TouchTarget，相当于一个可以被触摸的对象；它中记录了接受触摸事件的View
                removePointersFromTouchTargets(idBitsToAssign);

                // 获取该ViewGroup包含的View和ViewGroup的数目，
                // 然后递归遍历ViewGroup的孩子，对触摸事件进行分发。
                // 递归遍历ViewGroup的孩子：是指对于当前ViewGroup的所有孩子，都会逐个遍历，并分发触摸事件；
                //   对于逐个遍历到的每一个孩子，若该孩子是ViewGroup类型的话，则会递归到调用该孩子的孩子，...
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    final View[] children = mChildren;

                    final boolean customOrder = isChildrenDrawingOrderEnabled();
                    for (int i = childrenCount - 1; i &gt;= 0; i--) {
                        final int childIndex = customOrder ?
                                getChildDrawingOrder(childrenCount, i) : i;
                        final View child = children[childIndex];
                        // 如果child可以接受触摸事件，
                        // 并且触摸坐标(x,y)在child的可视范围之内的话；
                        // 则继续往下执行。否则，调用continue。
                        // child可接受触摸事件：是指child的是可见的(VISIBLE)；或者虽然不可见，但是位于动画状态。
                        if (!canViewReceivePointerEvents(child)
                                || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }

                        // getTouchTarget()的作用是查找child是否存在于mFirstTouchTarget的单链表中。
                        // 是的话，返回对应的TouchTarget对象；否则，返回null。
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }

                        // 重置child的mPrivateFlags变量中的PFLAG_CANCEL_NEXT_UP_EVENT位。
                        resetCancelNextUpFlag(child);

                        // 调用dispatchTransformedTouchEvent()将触摸事件分发给child。
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // 如果child能够接受该触摸事件，即child消费或者拦截了该触摸事件的话；
                            // 则调用addTouchTarget()将child添加到mFirstTouchTarget链表的表头，并返回表头对应的TouchTarget
                            // 同时还设置alreadyDispatchedToNewTouchTarget为true。
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = childIndex;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }

                // 如果newTouchTarget为null，并且mFirstTouchTarget不为null；
                // 则设置newTouchTarget为mFirstTouchTarget链表中第一个不为空的节点。
                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }

        // 第6步：进一步的对触摸事件进行分发
        // 
        // (01) 如果mFirstTouchTarget为null，意味着还没有任何View来接受该触摸事件；
        //   此时，将当前ViewGroup看作一个View；
        //   将会调用&quot;当前的ViewGroup的父类View的dispatchTouchEvent()&quot;对触摸事件进行分发处理。
        //   即，会将触摸事件交给当前ViewGroup的onTouch(), onTouchEvent()进行处理。
        // (02) 如果mFirstTouchTarget不为null，意味着有ViewGroup的子View或子ViewGroup中，
        //   有可以接受触摸事件的。那么，就将触摸事件分发给这些可以接受触摸事件的子View或子ViewGroup。
        if (mFirstTouchTarget == null) {
            // 注意：这里的第3个参数是null
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                            || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                            target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }

        // 第7步：再次检查取消标记，并进行相应的处理
        // 
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled
                || actionMasked == MotionEvent.ACTION_UP
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }

    // mInputEventConsistencyVerifier是调试用的，不会理会
    if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}</code></pre><p>说明：该代码定义在frameworks/base/core/java/android/view/ViewGroup.java中。流程比较复杂，但文章已经给出了非常详细的注释，相信根据注释应该能读懂。遇到不懂或有疑惑的地方，还需阅读源码才是！  </p>
<p>注意：<strong>第5步，即ViewGroup尝试将触摸事件分发给它的孩子。这只有在ACTION_DOWN的时候才发生。如果它的孩子接受了触摸事件，则会调用addTouchTarget()将该孩子添加到mFirstTouchTarget链表中。  在ACTION_DOWN之后，传递ACTION_MOVE或ACTION_UP时，ViewGroup不会再执行第5步；而是在第6步中，直接遍历mFirstTouchTarget链表，查找之前接受ACTION_DOWN的孩子，并将触摸事件分配给这些孩子。</strong><br><strong>也就是说，如果ViewGroup的某个孩子没有接受ACTION_DOWN事件；那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！</strong></p>
<h3 id="2-1-1-ViewGroup中的dispatchTransformedTouchEvent"><a href="#2-1-1-ViewGroup中的dispatchTransformedTouchEvent" class="headerlink" title="2.1.1 ViewGroup中的dispatchTransformedTouchEvent()"></a>2.1.1 ViewGroup中的dispatchTransformedTouchEvent()</h3><pre><code>private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {
    final boolean handled;

    // 检测是否需要发送ACTION_CANCEL。
    // 如果cancel为true 或者 action是ACTION_CANCEL;
    // 则设置消息为ACTION_CANCEL，并将ACTION_CANCEL消息分发给对应的对象，并返回。
    // (01) 如果child是空，则将ACTION_CANCEL消息分发给当前ViewGroup；
    //      只不过会将ViewGroup看作它的父类View，调用View的dispatchTouchEvent()接口。
    // (02) 如果child不是空，调用child的dispatchTouchEvent()。
    final int oldAction = event.getAction();
    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL);
        if (child == null) {
            handled = super.dispatchTouchEvent(event);
        } else {
            handled = child.dispatchTouchEvent(event);
        }
        event.setAction(oldAction);
        return handled;
    }

    // 计算触摸事件的id信息
    final int oldPointerIdBits = event.getPointerIdBits();
    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;

    // 如果新的id信息为0，则返回false。
    if (newPointerIdBits == 0) {
        return false;
    }


    // 如果计算得到的前后触摸事件id信息相同，则执行不需要重新计算MotionEvent，直接执行if语句块进行消费分发；
    // 否则，就重新计算MotionEvent之后，再进行消息分发。
    final MotionEvent transformedEvent;
    if (newPointerIdBits == oldPointerIdBits) {
        if (child == null || child.hasIdentityMatrix()) {
            // (01) 如果child是空，则将ViewGroup看作它的父类View，调用View的dispatchTouchEvent()接口。
            // (02) 如果child不是空，调用child的dispatchTouchEvent()。
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                final float offsetX = mScrollX - child.mLeft;
                final float offsetY = mScrollY - child.mTop;
                event.offsetLocation(offsetX, offsetY);

                handled = child.dispatchTouchEvent(event);

                event.offsetLocation(-offsetX, -offsetY);
            }
            return handled;
        }
        transformedEvent = MotionEvent.obtain(event);
    } else {
        transformedEvent = event.split(newPointerIdBits);
    }

    // (01) 如果child是空，则将ViewGroup看作它的父类View，调用View的dispatchTouchEvent()接口。
    // (02) 如果child不是空，调用child的dispatchTouchEvent()。
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        if (! child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }

        handled = child.dispatchTouchEvent(transformedEvent);
    }

    // Done.
    transformedEvent.recycle();
    return handled;
}</code></pre><p>说明：dispatchTransformedTouchEvent()会对触摸事件进行重新打包后再分发。<br>如果它的第三个参数child是null，则会将触摸消息分发给ViewGroup自己，只不过此时是将ViewGroup看作一个View，即调用View的dispatchTouchEvent()进行消息分发。而View的dispatchTouchEvent()在前面一篇文章中已经消息介绍过了，它会触摸事件分发给onTouch(), onTouchEvent()进行处理。<br>如果它的第三个参数child不是null，则会调用child.dispatchTouchEvent()进行消息分发。而如果这个child是ViewGroup对象的话，它则又会递归的将消息分发给它的孩子。</p>
<h3 id="2-1-2-ViewGroup中的cancelAndClearTouchTargets"><a href="#2-1-2-ViewGroup中的cancelAndClearTouchTargets" class="headerlink" title="2.1.2 ViewGroup中的cancelAndClearTouchTargets()"></a>2.1.2 ViewGroup中的cancelAndClearTouchTargets()</h3><pre><code>private TouchTarget mFirstTouchTarget;

private void cancelAndClearTouchTargets(MotionEvent event) {
    // 如果mFirstTouchTarget链表不为空，则清空该链表
    if (mFirstTouchTarget != null) {
        ...

        // 遍历mFirstTouchTarget链表，请清空每一个TouchTarget中View的PFLAG_CANCEL_NEXT_UP_EVENT位
        for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {
            resetCancelNextUpFlag(target.child);
            ...
        }
        // 清空TouchTarget链表本身，并设置mFirstTouchTarget为null
        clearTouchTargets();

        ...
    }
}

private static boolean resetCancelNextUpFlag(View view) {
    // 清空mPrivateFlags中的PFLAG_CANCEL_NEXT_UP_EVENT位
    if ((view.mPrivateFlags &amp; PFLAG_CANCEL_NEXT_UP_EVENT) != 0) {
        view.mPrivateFlags &amp;= ~PFLAG_CANCEL_NEXT_UP_EVENT;
        return true;
    }
    return false;
}

private void clearTouchTargets() {
    TouchTarget target = mFirstTouchTarget;
    // 清空mFirstTouchTarget链表，并设置mFirstTouchTarget为null
    if (target != null) {
        do {
            TouchTarget next = target.next;
            target.recycle();
            target = next;
        } while (target != null);
        mFirstTouchTarget = null;
    }
}</code></pre><p>说明：cancelAndClearTouchTargets()的作用和明显。就是清空mFirstTouchTarget链表中每一个View的PFLAG_CANCEL_NEXT_UP_EVENT标记；然后清空mFirstTouchTarget链表，并设置mFirstTouchTarget为null。<br>mFirstTouchTarget是TouchTarget类的成员。TouchTarget是ViewGroup的内部类，一个TouchTarget对象可以视为一个被触摸对象；即，在ViewGroup中，就通过TouchTarget表示一个可以接受触摸事件的对象。</p>
<pre><code>private static final class TouchTarget {
    ...

    // 被触摸的View
    public View child;

    // pointerIdBits是记录触摸事件的id信息(对于多指触摸而言)
    public int pointerIdBits;

    // TouchTarget指向的下一个节点
    public TouchTarget next;


    private TouchTarget() {
    }

    ...
}</code></pre><h3 id="2-1-3-ViewGroup中的resetTouchState"><a href="#2-1-3-ViewGroup中的resetTouchState" class="headerlink" title="2.1.3 ViewGroup中的resetTouchState()"></a>2.1.3 ViewGroup中的resetTouchState()</h3><pre><code>private void resetTouchState() {
    clearTouchTargets();
    resetCancelNextUpFlag(this);
    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
}</code></pre><p>说明：resetTouchState()是清空当前ViewGroup的点击状态。</p>
<h3 id="2-1-4-ViewGroup中的removePointersFromTouchTargets"><a href="#2-1-4-ViewGroup中的removePointersFromTouchTargets" class="headerlink" title="2.1.4 ViewGroup中的removePointersFromTouchTargets()"></a>2.1.4 ViewGroup中的removePointersFromTouchTargets()</h3><pre><code>private void removePointersFromTouchTargets(int pointerIdBits) {
    TouchTarget predecessor = null;
    TouchTarget target = mFirstTouchTarget;
    while (target != null) {
        final TouchTarget next = target.next;
        if ((target.pointerIdBits &amp; pointerIdBits) != 0) {
            target.pointerIdBits &amp;= ~pointerIdBits;
            if (target.pointerIdBits == 0) {
                if (predecessor == null) {
                    mFirstTouchTarget = next;
                } else {
                    predecessor.next = next;
                }
                target.recycle();
                target = next;
                continue;
            }
        }
        predecessor = target;
        target = next;
    }
}</code></pre><p>说明：理解removePointersFromTouchTargets()的关机，是理解ev.getPointerId()。而getPointerId()是获取的该触摸事件的id。对于多指触摸，第一个手指的id是0，第二个手指的id是1，第三个手指的id是2，…依次类推。<br>而pointerIdBits就是记录的id信息的。第一个手指的pointerIdBits是0x0，第二个手指的的pointerIdBits是0x1，第三个手指的pointerIdBits是0x2，第四个手指的pointerIdBits是0x4，…所有手指的pointerIdBits是0xffffffff。<br>理解了触摸id之后，再看看removePointersFromTouchTargets()就非常容易理解了。它是从mFirstTouchTarget链表中逐个遍历，清空pointerIdBits；如果清空pointerIdBits之后，TouchTarget的pointerIdBits为0，则将该节点从链表中删除。</p>
<h3 id="2-1-5-ViewGroup中的canViewReceivePointerEvents"><a href="#2-1-5-ViewGroup中的canViewReceivePointerEvents" class="headerlink" title="2.1.5 ViewGroup中的canViewReceivePointerEvents()"></a>2.1.5 ViewGroup中的canViewReceivePointerEvents()</h3><pre><code>private static boolean canViewReceivePointerEvents(View child) {
    return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE
            || child.getAnimation() != null;
}</code></pre><p>说明：canViewReceivePointerEvents()是判断child是否可以接受触摸事件。如果child是VISIBLE；或者child是非VISIBLE，但是它处于动画状态；这两种状态都可以接受触摸事件。</p>
<h3 id="2-1-6-ViewGroup中的isTransformedTouchPointInView"><a href="#2-1-6-ViewGroup中的isTransformedTouchPointInView" class="headerlink" title="2.1.6 ViewGroup中的isTransformedTouchPointInView()"></a>2.1.6 ViewGroup中的isTransformedTouchPointInView()</h3><pre><code>protected boolean isTransformedTouchPointInView(float x, float y, View child,
        PointF outLocalPoint) {
    float localX = x + mScrollX - child.mLeft;
    float localY = y + mScrollY - child.mTop;
    if (! child.hasIdentityMatrix() &amp;&amp; mAttachInfo != null) {
        final float[] localXY = mAttachInfo.mTmpTransformLocation;
        localXY[0] = localX;
        localXY[1] = localY;
        child.getInverseMatrix().mapPoints(localXY);
        localX = localXY[0];
        localY = localXY[1];
    }
    final boolean isInView = child.pointInView(localX, localY);
    ...
    return isInView;
}</code></pre><p>说明：isTransformedTouchPointInView()是判断(x,y)是否在child中。</p>
<h3 id="2-1-7-ViewGroup中的getTouchTarget"><a href="#2-1-7-ViewGroup中的getTouchTarget" class="headerlink" title="2.1.7 ViewGroup中的getTouchTarget()"></a>2.1.7 ViewGroup中的getTouchTarget()</h3><pre><code>private TouchTarget getTouchTarget(View child) {
    for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {
        if (target.child == child) {
            return target;
        }
    }
    return null;
}</code></pre><p>说明：getTouchTarget()的作用是查找child是否存在于mFirstTouchTarget的单链表中。是的话，返回对应的TouchTarget对象；否则，返回null。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-ViewGroup中的onTouchEvent"><a href="#2-2-ViewGroup中的onTouchEvent" class="headerlink" title="2.2 ViewGroup中的onTouchEvent"></a>2.2 ViewGroup中的onTouchEvent</h2><p>ViewGroup没有覆盖onTouchEvent()。因此，调用ViewGroup的onTouchEvent()的话；实际上调用的是它的父类View的onTouchEvent()。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="2-3-ViewGroup中的onInterceptTouchEvent"><a href="#2-3-ViewGroup中的onInterceptTouchEvent" class="headerlink" title="2.3 ViewGroup中的onInterceptTouchEvent"></a>2.3 ViewGroup中的onInterceptTouchEvent</h2><pre><code>public boolean onInterceptTouchEvent(MotionEvent ev) {
    return false;
}   </code></pre><p>说明：ViewGroup的onInterceptTouchEvent()默认返回false。而且什么都不会执行！<br>一般来说，若我们自定义ViewGroup时，需要拦截触摸消息；就可以覆盖onInterceptTouchEvent()来进行。</p>
<p>ViewGroup中关于触摸事件的代码就分析至此。总的来说：<br>(01) <strong>ViewGroup中的dispatchTouchEvent()会将触摸事件进行递归遍历传递。ViewGroup会遍历它的所有孩子，对每个孩子都递归的调用dispatchTouchEvent()来分发触摸事件。</strong><br>(02) <strong>如果ViewGroup的某个孩子没有接受(消费或者拦截)ACTION_DOWN事件；那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！</strong><br>(03) <strong>ViewGroup的onInterceptTouchEvent()默认返回false。</strong></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/03/android/os/event/2015-01-03-TouchEvent-View/" itemprop="url">Android 触摸事件机制(三) View中触摸事件详解</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-03T01:01:00.000Z" itemprop="datePublished">1月 3 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            14 分钟 read (About 2054 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将对View中触摸事件相关的内容进行介绍。重点介绍的是dispatchTouchEvent(), onTouchEvent()这两个API以及OnTouchListener接口。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">View中触摸事件的概述</a><br><strong>2</strong>. <a href="#anchor2">View中触摸事件的源码解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">View中的dispatchTouchEvent</a><br><strong>2.2</strong>. <a href="#anchor2_2">View中的onTouchEvent</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-View中触摸事件的概述"><a href="#1-View中触摸事件的概述" class="headerlink" title="1. View中触摸事件的概述"></a>1. View中触摸事件的概述</h1><p>  View中与触摸事件相关的内容可以分为两部分。</p>
<p><strong>第一部分</strong> dispatchTouchEvent()和onTouchEvent()这两个API</p>
<p>dispatchTouchEvent()是传递触摸事件的API，而onTouchEvent()则是View处理触摸事件的API。<br>View中dispatchTouchEvent()将事件传递给”自己的onTouch()”, “自己的onTouchEvent()”进行处理。 onTouch()是OnTouchListener接口中API，属于View提供的，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统提供的，用于处理触摸事件的接口；在onTouchEvent()中会进行一系列的动作，例如获取焦点、设置按下状态，调用onClick()等。</p>
<p><strong>第二部分</strong> OnTouchListener, OnClickListener, OnLongClickListener等接口</p>
<p>这部分主要是接口。但本文主要介绍的是OnTouchListener接口中的onTouch()。为什么呢？<br>这是因为，onTouch()与onTouchEvent()都是用户处理触摸事件的API。<br>但不同的是：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。  如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。</p>
<pre><code>public interface OnTouchListener {
    boolean onTouch(View v, MotionEvent event);
}</code></pre><p><a name="anchor2"></a></p>
<h1 id="2-View中触摸事件的源码解析"><a href="#2-View中触摸事件的源码解析" class="headerlink" title="2. View中触摸事件的源码解析"></a>2. View中触摸事件的源码解析</h1><p><a name="anchor2_1"></a></p>
<h2 id="2-1-View中的dispatchTouchEvent"><a href="#2-1-View中的dispatchTouchEvent" class="headerlink" title="2.1 View中的dispatchTouchEvent"></a>2.1 View中的dispatchTouchEvent</h2><pre><code>public boolean dispatchTouchEvent(MotionEvent event) {
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    // 如果该View被遮蔽，并且该View在被遮蔽时不响应点击事件；
    // 此时，返回false；不会执行onTouch()或onTouchEvent()，即过滤调用该点击事件。
    // 否则，返回true。
    // 被遮蔽的意思是：该View不是位于顶部，有其他的View在它之上。
    if (onFilterTouchEventForSecurity(event)) {
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            return true;
        }

        if (onTouchEvent(event)) {
            return true;
        }
    }

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}</code></pre><p>说明：该代码定义在frameworks/base/core/java/android/view/View.java中。<br>(01) mInputEventConsistencyVerifier是调试用的，这里不用理会。重点看onFilterTouchEventForSecurity()部分。<br>(02) onFilterTouchEventForSecurity()表示是否要分发该触摸事件；如果该View不是位于顶部，并且有设置属性使该View不在顶部时不响应触摸事件，则不分发该触摸事件，即不会执行onTouch()与onTouchEvent()。 否则的话，则将事件分发给onTouch(), onTouchEvent()进行处理。<br>(03) 如果将事件进行分发的话，会先尝试分发给onTouch()；然后才分发给onTouchEvent()。</p>
<h3 id="2-1-1-View中的onFilterTouchEventForSecurity"><a href="#2-1-1-View中的onFilterTouchEventForSecurity" class="headerlink" title="2.1.1 View中的onFilterTouchEventForSecurity()"></a>2.1.1 View中的onFilterTouchEventForSecurity()</h3><pre><code>public boolean onFilterTouchEventForSecurity(MotionEvent event) {
    //noinspection RedundantIfStatement
    if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0
            &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {
        // Window is obscured, drop this touch.
        return false;
    }
    return true;
}</code></pre><p>说明：onFilterTouchEventForSecurity()返回true，表示可以分发该触摸事件；否则，不能分发该触摸事件。不能分发事件的情况，只有mViewFlags&amp;FILTER_TOUCHES_WHEN_OBSCURED!=0，并且event.getFlags()&amp;MotionEvent.FLAG_WINDOW_IS_OBSCURED!=0同时成立。<br>(01) FILTER_TOUCHES_WHEN_OBSCURED是android:filterTouchesWhenObscured属性所对应的位。android:filterTouchesWhenObscured是true的话，则表示其他视图在该视图之上，导致该视图被隐藏时，该视图就不再响应触摸事件。<br>(02) MotionEvent.FLAG_WINDOW_IS_OBSCURED为true的话，则表示该视图的窗口是被隐藏的。  </p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-View中的onTouchEvent"><a href="#2-2-View中的onTouchEvent" class="headerlink" title="2.2 View中的onTouchEvent"></a>2.2 View中的onTouchEvent</h2><pre><code>public boolean onTouchEvent(MotionEvent event) {
    final int viewFlags = mViewFlags;

    // 如果View被禁用的话，则返回它是否可以点击。
    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));
    }

    // 如果该View的mTouchDelegate不为null的话，将触摸消息分发给mTouchDelegate。
    // mTouchDelegate的默认值是null。
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    // 如果View可以被点击的话，则执行if里面的内容。
    // 这其中涉及到的主要是获取焦点，设置按下状态，触发onClick(), onLongClick()事件等等。
    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don&apos;t have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true);
                   }


                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;

            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true);
                    checkForLongClick(0);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                break;

            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();

                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }

    return false;
}</code></pre><p>说明：onTouchEvent()是Android系统实现的View对触摸事件的处理。<br>(01) 如果View被禁用的话，则返回它是否可以点击。当我们调用了setEnabled(false)时，View就被禁用了；默认情况下，View是可用的。当调用setClickable(true)或者android:clickable为true时，View就是可点击状态；默认情况下，View是不可点击的。<br>(02) 如果该View的mTouchDelegate不为null的话，将触摸消息分发给mTouchDelegate。例如，假设有两个视图v1和v2，它们的布局相互之间不重叠；如果设置了v1.setTouchDelegate(v2)的话，v1的触摸事件就会分发给v2。 注意：mTouchDelegate的默认值是null。<br>(03) 如果View可以被点击的话，则执行if里面的内容。if里面涉及的内容很多，这里与本文的主题关联不大，暂且不表；如果要细将的话，估计得好几篇文章。例如，setPressed()是设置View的按下状态，如果用户有设置View在不同状态的图片时，setPressed()时会导致View的图片的更新。</p>
<p>View中关于触摸事件的代码就分析至此。总的来说：<br>(01) <strong>View中的dispatchTouchEvent()会将事件传递给”自己的onTouch()”, “自己的onTouchEvent()”进行处理。而且onTouch()的优先级比onTouchEvent()的优先级要高。</strong><br>(02) <strong>onTouch()与onTouchEvent()都是View中用户处理触摸事件的API。onTouch是OnTouchListener接口中的函数，OnTouchListener接口需要用户自己实现。onTouchEvent()是View自带的接口，Android系统提供了默认的实现；当然，用户可以重载该API。</strong><br>(03) <strong>onTouch()与onTouchEvent()有两个不同之处：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。  如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。</strong></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/02/android/os/event/2015-01-02-TouchEvent-Activity/" itemprop="url">Android 触摸事件机制(二) Activity中触摸事件详解</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-02T01:01:00.000Z" itemprop="datePublished">1月 2 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 read (About 1997 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将对Activity中触摸事件相关的内容进行介绍，重点介绍的是Activity中与触摸事件相关的两个API：dispatchTouchEvent()和onTouchEvent()。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Activity中触摸事件的概述</a><br><strong>2</strong>. <a href="#anchor2">Activity中触摸事件的源码解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">Activity中的dispatchTouchEvent</a><br><strong>2.2</strong>. <a href="#anchor2_2">Activity中的onTouchEvent</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Activity中触摸事件的概述"><a href="#1-Activity中触摸事件的概述" class="headerlink" title="1. Activity中触摸事件的概述"></a>1. Activity中触摸事件的概述</h1><p>  Activity中与触摸事件相关API主要是dispatchTouchEvent()和onTouchEvent()。dispatchTouchEvent()是传递触摸事件的API，而onTouchEvent()则是Activity处理触摸事件的API。</p>
<p>  Activity就是dispatchTouchEvent()将触摸事件传递给它所包含的根视图，从而实现将触摸事件传递给View或ViewGroup进行处理。<br>  而在onTouchEvent()在是Activity自己对触摸事件的处理。例如，如果Activity是一个Dialog主题，即Activity相当于一个对话框；那么当onTouchEvent()收到点击事件，并且该点击事件的坐标在Activity之外的时候，onTouchEvent()就会结束Activity。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-Activity中触摸事件的源码解析"><a href="#2-Activity中触摸事件的源码解析" class="headerlink" title="2. Activity中触摸事件的源码解析"></a>2. Activity中触摸事件的源码解析</h1><p><a name="anchor2_1"></a></p>
<h2 id="2-1-Activity中的dispatchTouchEvent"><a href="#2-1-Activity中的dispatchTouchEvent" class="headerlink" title="2.1 Activity中的dispatchTouchEvent"></a>2.1 Activity中的dispatchTouchEvent</h2><pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    // onUserInteraction默认不执行任何动作。
    // 它是提供给客户的接口。
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    // 这里会调用到ViewGroup的dispatchTouchEvent()，
    // 即会调用Activity包含的根视图的dispatchTouchEvent()。
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    // 如果superDispatchTouchEvent()返回false，
    // 即Activity的根视图以及根视图的子视图都没有拦截该事件的话，则调用Activity的onTouchEvent()
    return onTouchEvent(ev);
}</code></pre><p>说明：该代码定义在frameworks/base/core/java/android/app/Activity.java中。<br>Activity通过调用dispatchTouchEvent()将触摸事件分发给Activity所包含的视图；如果Activity中的视图都没有对触摸事件进行拦截的话，则调用Activity的onTouchEvent()对触摸事件进行处理。<br>下面，先看看Activity是如何通过superDispatchTouchEvent()将事件分发给它所包含的View的。</p>
<h3 id="2-1-1-Activity中的getWindow"><a href="#2-1-1-Activity中的getWindow" class="headerlink" title="2.1.1 Activity中的getWindow()"></a>2.1.1 Activity中的getWindow()</h3><pre><code>private Window mWindow;

public Window getWindow() {
    return mWindow;
}

final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config) {

    ...

    mWindow = PolicyManager.makeNewWindow(this);

    ...
}</code></pre><p>说明：getWindow()返回的是mWindow对象，而mWindow是在attach()中初始化的。attach()是Activity被加载时调用的，具体是如何attact()的，不是我们关心的重点；这里只需要了解，Activity被加载时，attach()会被执行即可。<br>接着，我们就看看PolicyManager.makeNewWindow()是如何实现的。</p>
<h3 id="2-1-2-PolicyManager中的makeNewWindow"><a href="#2-1-2-PolicyManager中的makeNewWindow" class="headerlink" title="2.1.2 PolicyManager中的makeNewWindow()"></a>2.1.2 PolicyManager中的makeNewWindow()</h3><pre><code>public static Window makeNewWindow(Context context) {
    return sPolicy.makeNewWindow(context);
}   

private static final String POLICY_IMPL_CLASS_NAME =
    &quot;com.android.internal.policy.impl.Policy&quot;;

private static final IPolicy sPolicy;

static {
    // Pull in the actual implementation of the policy at run-time
    try {
        Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME);
        sPolicy = (IPolicy)policyClass.newInstance();
    } catch (ClassNotFoundException ex) {
        throw new RuntimeException(
                POLICY_IMPL_CLASS_NAME + &quot; could not be loaded&quot;, ex);
    } catch (InstantiationException ex) {
        throw new RuntimeException(
                POLICY_IMPL_CLASS_NAME + &quot; could not be instantiated&quot;, ex);
    } catch (IllegalAccessException ex) {
        throw new RuntimeException(
                POLICY_IMPL_CLASS_NAME + &quot; could not be instantiated&quot;, ex);
    }
}   </code></pre><p>说明：该代码定义在frameworks/base/core/java/com/android/internal/policy/PolicyManager.java中。<br>makeNewWindow()是调用的sPolicy.makeNewWindow()，而sPolicy是个静态变量，它的实现也是在静态代码块中。因此，在PolicyManager.java加载的时候，sPolicy就会被初始化为policyClass.newInstance()。而policyClass是通过Class得到的Policy对象。<br>也就是说，PolicyManager中的makeNewWindow()会调用Policy中的makeNewWindow()。</p>
<h3 id="2-1-3-Policy中的makeNewWindow"><a href="#2-1-3-Policy中的makeNewWindow" class="headerlink" title="2.1.3 Policy中的makeNewWindow"></a>2.1.3 Policy中的makeNewWindow</h3><pre><code>public Window makeNewWindow(Context context) {
    return new PhoneWindow(context);
}   </code></pre><p>说明：该代码定义在frameworks/base/policy/src/com/android/internal/policy/impl/Policy.java中。makeNewWindow()会返回PhoneWindow对象。<br>回到Activity的dispatchTouchEvent()中，也就是说getWindow()返回的是PhoneWindow对象。接着，就看看superDispatchTouchEvent()的实现。</p>
<h3 id="2-1-4-PhoneWindow中的superDispatchTouchEvent"><a href="#2-1-4-PhoneWindow中的superDispatchTouchEvent" class="headerlink" title="2.1.4 PhoneWindow中的superDispatchTouchEvent"></a>2.1.4 PhoneWindow中的superDispatchTouchEvent</h3><pre><code>@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
    return mDecor.superDispatchTouchEvent(event);
}    

private DecorView mDecor;

private void installDecor() {
    if (mDecor == null) {
        mDecor = generateDecor();
        ...
    }

    ...
}

protected DecorView generateDecor() {
    return new DecorView(getContext(), -1); 
}    </code></pre><p>说明：该代码定义在frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java中。<br>superDispatchTouchEvent()会调用mDecor.superDispatchTouchEvent()；而mDecor是DecorView对象。mDecor是在installDecor()中被创建的。总之，PhoneWindow中的superDispatchTouchEvent()会调用DecorView中的superDispatchTouchEvent()。DecorView是PhoneWindow中的内部类，下面看看它的实现。</p>
<h3 id="2-1-5-DecorView中的superDispatchTouchEvent"><a href="#2-1-5-DecorView中的superDispatchTouchEvent" class="headerlink" title="2.1.5 DecorView中的superDispatchTouchEvent"></a>2.1.5 DecorView中的superDispatchTouchEvent</h3><pre><code>private final class DecorView extends FrameLayout implements RootViewSurfaceTaker {
    ...

    public boolean superDispatchTouchEvent(MotionEvent event) {
        return super.dispatchTouchEvent(event);
    }

    ...
}</code></pre><p>说明：DecorView中的superDispatchTouchEvent()会调用父类的dispatchTouchEvent()。而DecorView的父类是FrameLayout，FrameLayout的父类又是GroupView；因此superDispatchTouchEvent()最终会调用到GroupView的dispatchTouchEvent()。</p>
<p>关于GroupView中的dispatchTouchEvent()的流程，在后面的文章中再来详细介绍！这里重点需要了解：<strong>Activity在通过dispatchTouchEvent()传递触摸事件的时候，会调用到ViewGroup的dispatchTouchEvent()。从而实现，将Activity中的触摸事件传递给它所包含的View或ViewGroup。</strong></p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-Activity中的onTouchEvent"><a href="#2-2-Activity中的onTouchEvent" class="headerlink" title="2.2 Activity中的onTouchEvent"></a>2.2 Activity中的onTouchEvent</h2><p>回顾一下Activity中dispatchTouchEvent()的内容。</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    // onUserInteraction默认不执行任何动作。
    // 它是提供给客户的接口。
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    // 这里会调用到ViewGroup的dispatchTouchEvent()，
    // 即会调用Activity包含的根视图的dispatchTouchEvent()。
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    // 如果superDispatchTouchEvent()返回false，
    // 即Activity的根视图以及根视图的子视图都没有拦截该事件的话，则调用Activity的onTouchEvent()
    return onTouchEvent(ev);
}</code></pre><p>(01) 如果superDispatchTouchEvent()返回true的话，dispatchTouchEvent()就直接返回true了，不会执行onTouchEvent()。也就是说，如果Activity将触摸事件分发给它所包含的视图的时候，如果有视图拦截或消费了该事件，就不会轮到Activity来处理该事件了；即，不会执行Activity的onTouchEvent()了。<br>(02) 如果superDispatchTouchEvent()返回false的话，意味着，Activity所包含的视图都没有拦截或消费该触摸事件；那么，就会调用Activity的onTouchEvent()来处理触摸事件。</p>
<p>下面就看看onTouchEvent()的代码。</p>
<pre><code>public boolean onTouchEvent(MotionEvent event) {
    if (mWindow.shouldCloseOnTouch(this, event)) {
        finish();
        return true;
    }    

    return false;
}    </code></pre><p>说明：代码很简单。它会先调用mWindow.shouldCloseOnTouch()，如果shouldCloseOnTouch()返回true，则意味着该触摸事件会触发”结束Activity”的动作。那么接下来，就调用finish()来结束Activity，并返回true，表示Activity消费了这个触摸事件。否则的话，就返回false。</p>
<h3 id="2-2-1-Window的shouldCloseOnTouch"><a href="#2-2-1-Window的shouldCloseOnTouch" class="headerlink" title="2.2.1 Window的shouldCloseOnTouch()"></a>2.2.1 Window的shouldCloseOnTouch()</h3><p>前面分析过，mWindow是PhoneWindow对象，而PhoneWindow继承于Window。则mWindow.shouldCloseOnTouch()实际上会调用Window中的shouldCloseOnTouch()。</p>
<pre><code>public boolean shouldCloseOnTouch(Context context, MotionEvent event) {
    if (mCloseOnTouchOutside &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN
            &amp;&amp; isOutOfBounds(context, event) &amp;&amp; peekDecorView() != null) {
        return true;
    }    
    return false;
}    </code></pre><p>说明：该代码定义在frameworks/base/core/java/android/view/Window.java中。<br>(01) mCloseOnTouchOutside是一个boolean变量，它是由Window的android:windowCloseOnTouchOutside属性值决定。<br>(02) isOutOfBounds(context, event)是判断该event的坐标是否在context(对于本文来说就是当前的Activity)之外。是的话，返回true；否则，返回false。<br>(03) peekDecorView()则是返回PhoneWindow的mDecor。<br>也就是说，如果设置了android:windowCloseOnTouchOutside属性为true，并且当前事件是ACTION_DOWN，而且点击发生在Activity之外，同时Activity还包含视图的话，则返回true；表示该点击事件会导致Activity的结束。</p>
<p>至此，Activity中关于触摸事件的代码就分析完毕了。总结来说：<br>(01) <strong>Activity中的dispatchTouchEvent会将触摸事件传递给Activity所包含的视图。具体的实现方式在通过调用到Activity所属Window的superDispatchTouchEvent，进而调用到Window的DecorView的superDispatchTouchEvent，进一步的又调用到ViewGroup的dispatchTouchEvent()。</strong><br> 如果Activity所包含的视图拦截或者消费了该触摸事件的话，就不会再执行Activity的onTouchEvent()；<br> 如果Activity所包含的视图没有拦截或者消费该触摸事件的话，则会执行Activity的onTouchEvent()。<br>(02) <strong>Activity中的onTouchEvent是Activity自身对触摸事件的处理。如果该Activity的android:windowCloseOnTouchOutside属性为true，并且当前触摸事件是ACTION_DOWN，而且该触摸事件的坐标在Activity之外，同时Activity还包含了视图的话；就会导致Activity被结束。</strong></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/01/android/os/event/2015-01-01-TouchEvent-Introduce/" itemprop="url">Android 触摸事件机制(一) 简介</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-01T01:01:00.000Z" itemprop="datePublished">1月 1 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 read (About 1007 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本系列文章将介绍Android中触摸事件，即Touch Event的传递机制。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">触摸事件概述</a><br><strong>2</strong>. <a href="#anchor2">Activity, ViewGroup, View中的触摸事件API</a><br><strong>3</strong>. <a href="#anchor3">OnTouchListener接口</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-触摸事件概述"><a href="#1-触摸事件概述" class="headerlink" title="1. 触摸事件概述"></a>1. 触摸事件概述</h1><p>本文介绍的触摸事件API和接口主要是：dispatchTouchEvent(), onTouchEvent(), onInterceptTouchEvent()和OnTouchListener接口。这些内容中，最复杂的莫过于dispatchTouchEvent(), onTouchEvent()和onInterceptTouchEvent()这三者之间的关系。如果你能认真读完本系列文章，相信对它们之间的关系，它们的原理和用法，很有很清晰的认识。</p>
<p>本文先对这些接口做个大致介绍，建立一个整体概念。后续再通过阅读Activity, View和ViewGroup中触摸事件API的源码，来对认识这些API；最后，再通过几个示例来进一步了解它们，同时也了解它们的用法。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-Activity-ViewGroup-View中的触摸事件API"><a href="#2-Activity-ViewGroup-View中的触摸事件API" class="headerlink" title="2. Activity, ViewGroup, View中的触摸事件API"></a>2. Activity, ViewGroup, View中的触摸事件API</h1><p><strong>1. Activity中的触摸事件API</strong><br>public boolean dispatchTouchEvent(MotionEvent ev)；<br>public boolean onTouchEvent(MotionEvent ev); </p>
<p><strong>2. ViewGroup中的触摸事件API</strong><br>public boolean dispatchTouchEvent(MotionEvent ev)；<br>public boolean onTouchEvent(MotionEvent ev);<br>public boolean onInterceptTouchEvent(MotionEvent ev);</p>
<p><strong>3. View中的触摸事件API</strong><br>public boolean dispatchTouchEvent(MotionEvent ev)；<br>public boolean onTouchEvent(MotionEvent ev); </p>
<p>下面简单的说明一下涉及到的三个API的作用。</p>
<p><strong>dispatchTouchEvent</strong>：它是传递触摸事件的接口。<br>(01) Activity将触摸事件传递给ViewGroup，ViewGroup将触摸事件传递给另一个ViewGroup，以及ViewGroup将触摸事件传递给View；这些都是通过dispatchTouchEvent()来传递的。<br>(02) dispatchTouchEvent(), onInterceptTouchEvent(), onTouchEvent()以及onTouch()它们之间的联系，都是通过dispatchTouchEvent()体现的。它们都是在dispatchTouchEvent()中调度的！因此，理解dispatchTouchEvent()是理解Android事件机制的关机；而其中，最关机的就是ViewGroup中的dispatchTouchEvent()<br>(03) 返回值：true，表示触摸事件被消费了；false，则表示触摸事件没有被消费。<br><strong>onTouchEvent</strong>：它是处理触摸事件的接口。<br>(01) 无论是Activity, ViewGroup还是View，对触摸事件的处理，基本上都是在onTouchEvent()中进行的。因此，我们说它是处理触摸事件的接口。<br>(02) 返回值：返回true，表示触摸事件被它处理过了；或者，换句话说，表示它消费了触摸事件。否则，表示它没有消费该触摸事件。<br><strong>onInterceptTouchEvent</strong>：它是拦截触摸事件的接口。<br>(01) 只有ViewGroup中才有该接口。如果ViewGroup不想将触摸事件传递给它的子View，则可以在onInterceptTouchEvent中进行拦截。<br>(02) 返回值：true，表示ViewGroup拦截了该触摸事件；那么，该事件就不会分发给它的子View或者子ViewGroup。否则，表示ViewGroup没有拦截该事件，该事件就会分发给它的子View和子ViewGroup。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-OnTouchListener接口"><a href="#3-OnTouchListener接口" class="headerlink" title="3. OnTouchListener接口"></a>3. OnTouchListener接口</h1><p>OnTouchListener一个interface接口，它是在View中声明的。OnTouchListener中只包含了onTouch()函数。<br>那么，onTouch()和onTouchEvent()有什么相同和不同点呢？</p>
<p><strong>相同点</strong><br>onTouch()与onTouchEvent()都是用户处理触摸事件的API。</p>
<p><strong>不同点</strong><br>(01)，onTouch()是View专门提供给用户的接口，目的是为了方便用户自己处理触摸事件。而onTouchEvent()是Android系统自己实现的接口。<br>(02)，onTouch()的优先级比onTouchEvent()的优先级更高。<br>    dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。  如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。</p>
<p>关于它们之间的内容，在讲解View的dispatchTouchEvent()时，会详细说明。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/08/android/os/binder/2014-09-08-Binder-Java/" itemprop="url">Android Binder机制(十二) Binder机制的Java调用流程</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-08T01:01:00.000Z" itemprop="datePublished">9月 8 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            23 分钟 read (About 3468 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面几篇文章，是基于Binder驱动和C/C++层对Binder机制进行了介绍。本文将从Java引用开始，逐步的分析Client是如何与Server进行交互的。本文的例子还是选取MediaPlayer。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">MediaPlayer的使用示例</a><br><strong>2</strong>. <a href="#anchor2">MediaPlayer示例分析</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-MediaPlayer的使用示例"><a href="#1-MediaPlayer的使用示例" class="headerlink" title="1. MediaPlayer的使用示例"></a>1. MediaPlayer的使用示例</h1><p>下面是一个调用MediaPlayer播放音乐(test.mp3)的示例代码。</p>
<pre><code>public class MainActivity extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.main);
        testMediaPlayer();
    }   

    private void testMediaPlayer() {
        try {
            MediaPlayer mp = new MediaPlayer();
            mp.setDataSource(&quot;/sdcard/test.mp3&quot;);
            mp.setAudioStreamType(AudioManager.STREAM_MUSIC);
            mp.prepare();
            mp.start();
        } catch (Exception e) {
            e.printStackTrace();
        }   
    }   
}</code></pre><p>说明：源码很简单，只需要关注testMediaPlayer()部分即可。首先，新建一个MediaPlayer对象。接着，设置数据源和音频流类型。最后，调用prepare()进行准备之后，再通过start()进行播放。</p>
<p>下面，我们就对该过程进行分析，看看该Binder机制是如何参与其中的。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-MediaPlayer示例分析"><a href="#2-MediaPlayer示例分析" class="headerlink" title="2. MediaPlayer示例分析"></a>2. MediaPlayer示例分析</h1><p>我们将MediaPlayer示例就看作一个MediaPlayer进程，接下来，就看看这个MediaPlayer进程是如何通过Binder机制来和MediaPlayerService通信的。重点需要关注的是mp.setDataSource()的实现。</p>
<p><a name="anchor2_1"></a></p>
<h2 id="2-1-MediaPlayer的构造函数"><a href="#2-1-MediaPlayer的构造函数" class="headerlink" title="2.1 MediaPlayer的构造函数"></a>2.1 MediaPlayer的构造函数</h2><p>先看看MediaPlayer的构造函数。</p>
<pre><code>public MediaPlayer() {

    ...
    native_setup(new WeakReference&lt;MediaPlayer&gt;(this));
}

private static native final void native_init();
private native final void native_setup(Object mediaplayer_this);</code></pre><p>说明：该代码在frameworks/base/media/java/android/media/MediaPlayer.java中。在MediaPlayer中，会调用本地方法native_setup()；而且在native_setup()之前，会调用静态方法native_init()进行初始化。下面就看看native_init()和native_setup()各自的代码。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-native-init-和native-setup-的注册信息"><a href="#2-2-native-init-和native-setup-的注册信息" class="headerlink" title="2.2 native_init()和native_setup()的注册信息"></a>2.2 native_init()和native_setup()的注册信息</h2><pre><code>static JNINativeMethod gMethods[] = {
    ...
    {&quot;_setDataSource&quot;,       &quot;(Ljava/io/FileDescriptor;JJ)V&quot;,    (void *)android_media_MediaPlayer_setDataSourceFD},
    ...
    {&quot;_start&quot;,              &quot;()V&quot;,                              (void *)android_media_MediaPlayer_start},
    ...
    {&quot;native_init&quot;,         &quot;()V&quot;,                              (void *)android_media_MediaPlayer_native_init},
    {&quot;native_setup&quot;,        &quot;(Ljava/lang/Object;)V&quot;,            (void *)android_media_MediaPlayer_native_setup},
    ...
};

static int register_android_media_MediaPlayer(JNIEnv *env)
{
    return AndroidRuntime::registerNativeMethods(env,
                &quot;android/media/MediaPlayer&quot;, gMethods, NELEM(gMethods));
}

jint JNI_OnLoad(JavaVM* vm, void* reserved)
{
    ...
    if (register_android_media_MediaPlayer(env) &lt; 0) {
        ...
    }
    ...
}</code></pre><p>说明：该代码在frameworks/base/media/jni/android_media_MediaPlayer.cpp中。gMethods是JNI本地方法的注册表；在Dalvik虚拟机启动之后，会调用JNI_OnLoad()；进而将上面的方法注册到系统中。<br>这里，我们只需要了解native_init()与android_media_MediaPlayer_native_init()对应，而native_setup()和android_media_MediaPlayer_native_setup()对应即可。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="2-3-native-init-的实现"><a href="#2-3-native-init-的实现" class="headerlink" title="2.3 native_init()的实现"></a>2.3 native_init()的实现</h2><p>由于native_init()与android_media_MediaPlayer_native_init()对应，下面就看看native_init()的实现。</p>
<pre><code>static void
android_media_MediaPlayer_native_init(JNIEnv *env)
{
    jclass clazz;

    clazz = env-&gt;FindClass(&quot;android/media/MediaPlayer&quot;);
    ..

    fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;, &quot;I&quot;);
    ...
}</code></pre><p>说明：该代码在frameworks/base/media/jni/android_media_MediaPlayer.cpp中。<br>env-&gt;FindClass(“android/media/MediaPlayer”)会加载Java层的MediaPlayer类；进而将fields.context初始化为MediaPlayer类中的mNativeContext成员。</p>
<p><a name="anchor2_4"></a></p>
<h2 id="2-4-native-setup-的实现"><a href="#2-4-native-setup-的实现" class="headerlink" title="2.4 native_setup()的实现"></a>2.4 native_setup()的实现</h2><p>由于native_setup()和android_media_MediaPlayer_native_setup()对应，下面就看看native_setup()的实现。</p>
<pre><code>static void
android_media_MediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this)
{
    sp&lt;MediaPlayer&gt; mp = new MediaPlayer();
    ...

    setMediaPlayer(env, thiz, mp);
}</code></pre><p>说明：该函数会新建一个MediaPlayer对象，然后调用setMediaPlayer()来保存该MediaPlayer对象。下面看看setMediaPlayer()是如何保存MediaPlayer对象的。</p>
<p><a name="anchor2_5"></a></p>
<h2 id="2-5-setMediaPlayer"><a href="#2-5-setMediaPlayer" class="headerlink" title="2.5 setMediaPlayer()"></a>2.5 setMediaPlayer()</h2><pre><code>static sp&lt;MediaPlayer&gt; setMediaPlayer(JNIEnv* env, jobject thiz, const sp&lt;MediaPlayer&gt;&amp; player)
{
    sp&lt;MediaPlayer&gt; old = (MediaPlayer*)env-&gt;GetIntField(thiz, fields.context);
    ...
    env-&gt;SetIntField(thiz, fields.context, (int)player.get());
    return old;
}</code></pre><p>说明：通过SetIntField()会将MediaPlayer对象保存到fields.context中。而在前面的，我们将fields.context初始化为MediaPlayer类(Java层)中的mNativeContext成员。这也就意味着，设置了Java层的MediaPlayer中的mNativeContext成员的值为C++层MediaPlayer对象。</p>
<br>
至此，就分析完了MediaPlayer的构造函数。下面继续看Java示例代码中的mp.setDataSource("/sdcard/test.mp3")。


<p><a name="anchor2_6"></a></p>
<h2 id="2-6-setDataSource"><a href="#2-6-setDataSource" class="headerlink" title="2.6 setDataSource()"></a>2.6 setDataSource()</h2><pre><code>public void setDataSource(String path)
        throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
    setDataSource(path, null, null);
}

private void setDataSource(String path, String[] keys, String[] values)
        throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {

    ...
    final File file = new File(path);
    if (file.exists()) {
        FileInputStream is = new FileInputStream(file);
        FileDescriptor fd = is.getFD();
        setDataSource(fd);
        is.close();
    } else {
        ...
    }
    ...
}

public void setDataSource(FileDescriptor fd)
        throws IOException, IllegalArgumentException, IllegalStateException {
    setDataSource(fd, 0, 0x7ffffffffffffffL);
}

public void setDataSource(FileDescriptor fd, long offset, long length)
        throws IOException, IllegalArgumentException, IllegalStateException {
    ...
    _setDataSource(fd, offset, length);
}

private native void _setDataSource(FileDescriptor fd, long offset, long length)
        throws IOException, IllegalArgumentException, IllegalStateException;</code></pre><p>说明：该代码在frameworks/base/media/java/android/media/MediaPlayer.java中。setDataSource()最终会调用到本地方法_setDataSource()。在前面的gMethods本地方法注册表中，将_setDataSource()和android_media_MediaPlayer_setDataSourceFD()匹配。下面，看看_setDataSource()的实现。</p>
<p><a name="anchor2_7"></a></p>
<h2 id="2-7-android-media-MediaPlayer-setDataSourceFD"><a href="#2-7-android-media-MediaPlayer-setDataSourceFD" class="headerlink" title="2.7 android_media_MediaPlayer_setDataSourceFD()"></a>2.7 android_media_MediaPlayer_setDataSourceFD()</h2><pre><code>static void
android_media_MediaPlayer_setDataSourceFD(JNIEnv *env, jobject thiz, jobject fileDescriptor, jlong offset, jlong length)
{
    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);
    ...

    int fd = jniGetFDFromFileDescriptor(env, fileDescriptor);
    ...
    process_media_player_call( env, thiz, mp-&gt;setDataSource(fd, offset, length), &quot;java/io/IOException&quot;, &quot;setDataSourceFD failed.&quot; );
}</code></pre><p>说明：该代码在frameworks/base/media/jni/android_media_MediaPlayer.cpp中。该函数会先通过getMediaPlayer()获取MediaPlayer对象，然后在执行mp-&gt;setDataSource()时会调用MediaPlayer的setDataSource()方法。</p>
<p><a name="anchor2_8"></a></p>
<h2 id="2-8-getMediaPlayer"><a href="#2-8-getMediaPlayer" class="headerlink" title="2.8 getMediaPlayer()"></a>2.8 getMediaPlayer()</h2><pre><code>static sp&lt;MediaPlayer&gt; getMediaPlayer(JNIEnv* env, jobject thiz)
{
    ...
    MediaPlayer* const p = (MediaPlayer*)env-&gt;GetIntField(thiz, fields.context);
    return sp&lt;MediaPlayer&gt;(p);
}</code></pre><p>说明：前面在native_setup()中，将fields.context设置为MediaPlayer对象。这里就是返回fields.context中保存的MediaPlayer对象。</p>
<p><a name="anchor2_9"></a></p>
<h2 id="2-9-MediaPlayer-setDataSource"><a href="#2-9-MediaPlayer-setDataSource" class="headerlink" title="2.9 MediaPlayer::setDataSource"></a>2.9 MediaPlayer::setDataSource</h2><pre><code>status_t MediaPlayer::setDataSource(
        const char *url, const KeyedVector&lt;String8, String8&gt; *headers)
{
    ...
    status_t err = BAD_VALUE;
    if (url != NULL) {
        // 通过getMediaPlayerService()的代理BpMediaPlayerService。
        const sp&lt;IMediaPlayerService&gt;&amp; service(getMediaPlayerService());
        if (service != 0) {
            // 通过BpMediaPlayerService创建一个IMediaPlayer客户端
            sp&lt;IMediaPlayer&gt; player(service-&gt;create(this, mAudioSessionId));
            ...
            // 保存player
            err = attachNewPlayer(player);
        }
    }
    return err;
}</code></pre><p>说明：该代码在frameworks/av/media/libmedia/mediaplayer.cpp中。<br>(01) 它会新建一个service对象，而service是通过getMediaPlayerService()获取到的。getMediaPlayerService()已经在”<a href="/2014/09/07/BinderCommunication-GetService01/">介绍getService请求</a>“时，详细分析过了。它会返回IMediaPlayerService的代理，即BpMediaPlayerService对象。<br>(02) 接着，会调用service-&gt;create()返回一个IMediaPlayer对象。下面看看这个MediaPlayer进程是如何通过BpMediaPlayerService这个远程代理来获取IMediaPlayer对象的。</p>
<p><a name="anchor2_10"></a></p>
<h2 id="2-10-BpMediaPlayerService-create"><a href="#2-10-BpMediaPlayerService-create" class="headerlink" title="2.10 BpMediaPlayerService::create()"></a>2.10 BpMediaPlayerService::create()</h2><pre><code>class BpMediaPlayerService: public BpInterface&lt;IMediaPlayerService&gt;
{
    ...
    virtual sp&lt;IMediaPlayer&gt; create(
            const sp&lt;IMediaPlayerClient&gt;&amp; client, int audioSessionId) {
        Parcel data, reply;
        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());
        data.writeStrongBinder(client-&gt;asBinder());
        data.writeInt32(audioSessionId);

        remote()-&gt;transact(CREATE, data, &amp;reply);
        return interface_cast&lt;IMediaPlayer&gt;(reply.readStrongBinder());
    }
    ...
}</code></pre><p>说明：该代码在frameworks/av/media/libmedia/IMediaPlayerService.cpp中。<br>这里无非是CREATE请求数据打包之后发送给Binder驱动，再由Binder驱动转发给MediaPlayerService进程。数据的发送和解析，在前面介绍”addService”和”getService”时已经多次介绍过了；这里就不再展开说明了。</p>
<p>Binder驱动在收到MediaPlayer的数据之后，会将添加一个事务到MediaPlayerService的待处理事务列表中，然后唤醒MediaPlayerService。下面就从MediaPlayerService被唤醒之后开始说明。</p>
<p><a name="anchor2_11"></a></p>
<h2 id="2-11-Binder驱动中binder-thread-read-的源码"><a href="#2-11-Binder驱动中binder-thread-read-的源码" class="headerlink" title="2.11 Binder驱动中binder_thread_read()的源码"></a>2.11 Binder驱动中binder_thread_read()的源码</h2><p>又回到了熟悉的binder_thread_read()中。</p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是目标节点。
        // 这里，MediaPlayer的CREATE请求的目标是MediaPlayerService，因此target_node是MediaPlayerService对应的节点；
        if (t-&gt;buffer-&gt;target_node) {
            // 事务目标对应的Binder实体(即，MediaPlayerService对应的Binder实体)
            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;
            // Binder实体在用户空间的地址。
            // MediaPlayerService的ptr为本地Binder的弱引用，即BBinder的弱引用
            tr.target.ptr = target_node-&gt;ptr;
            // Binder实体在用户空间的其它数据
            // MediaPlayerService的cookie为本地Binder本身，即BBinder对象
            tr.cookie =  target_node-&gt;cookie;
            t-&gt;saved_priority = task_nice(current);
            if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;
                !(t-&gt;flags &amp; TF_ONE_WAY))
                binder_set_nice(t-&gt;priority);
            else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||
                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)
                binder_set_nice(target_node-&gt;min_priority);
            cmd = BR_TRANSACTION;
        } else {
            ...
        }
        // 交易码，即CREATE
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            tr.sender_pid = 0;
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd(即BR_TRANSACTION)指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        // 设置回复信息
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            t-&gt;to_parent = thread-&gt;transaction_stack;
            t-&gt;to_thread = thread;
            thread-&gt;transaction_stack = t;
        } else {
            ...
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：MediaPlayerService被唤醒之后，binder_has_thread_work()为true。因为MediaPlayerService的待处理事务队列中有个待处理事务(即，MediaPlayer添加的CREATE请求)。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让MediaPlayerService读取后进行处理。  </p>
<p>这里，共添加了两个指令到bwr.read_consumed中：BR_NOOP和BR_TRANSACTION。其中，BR_TRANSACTION指令对应的数据中包含了CREATE请求的数据。</p>
<p>接下来，binder_thread_read()返回到binder_ioctl()中；binder_ioctl()将数据拷贝到用户空间之后，便返回到用户空间继续执行。<br>而在<a href="/2014/09/06/BinderCommunication-ThreadPool/">Android Binder机制(八) MediaPlayerService服务的消息循环</a>中介绍过，MediaPlayerService是通过调用IPCThreadState::joinThreadPool()进入消息循环的，而joinThreadPool()又会通过getAndExecuteCommand()调用到talkWithDriver()来和Binder驱动交互的。因此，Binder驱动返回到用户空间之后，会进入talkWithDriver()。</p>
<p><a name="anchor2_12"></a></p>
<h2 id="2-12-IPCThreadState-talkWithDriver"><a href="#2-12-IPCThreadState-talkWithDriver" class="headerlink" title="2.12 IPCThreadState::talkWithDriver()"></a>2.12 IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：ioctl()返回之后，talkWithDriver()会清除已经发送的数据。然后，便返回到getAndExecuteCommand()中。</p>
<p><a name="anchor2_13"></a></p>
<h2 id="13-IPCThreadState-getAndExecuteCommand"><a href="#13-IPCThreadState-getAndExecuteCommand" class="headerlink" title="13. IPCThreadState::getAndExecuteCommand()"></a>13. IPCThreadState::getAndExecuteCommand()</h2><pre><code>status_t IPCThreadState::getAndExecuteCommand()
{
    status_t result;
    int32_t cmd;

    // 和Binder驱动交互
    result = talkWithDriver();
    if (result &gt;= NO_ERROR) {
        ...
        // 读取mIn中的数据
        cmd = mIn.readInt32();
        ...

        // 调用executeCommand()对数据进行处理。
        result = executeCommand(cmd);
        ...
    }

    return result;
}</code></pre><p>说明：getAndExecuteCommand()会取出Binder反馈的指令，然后再调用executeCommand()根据指令进行解析。前面说过，Binder驱动共反馈了BR_NOOP和BR_TRANSACTION两个指令。而BR_NOOP指令什么也不会做。因此，我们直接分析BR_TRANSACTION指令。</p>
<p><a name="anchor2_14"></a></p>
<h2 id="14-IPCThreadState-executeCommand"><a href="#14-IPCThreadState-executeCommand" class="headerlink" title="14. IPCThreadState::executeCommand()"></a>14. IPCThreadState::executeCommand()</h2><pre><code>status_t IPCThreadState::executeCommand(int32_t cmd) 
{
    BBinder* obj; 
    RefBase::weakref_type* refs;
    status_t result = NO_ERROR;

    switch (cmd) {
        ...
        case BR_TRANSACTION:
        {
            binder_transaction_data tr;
            result = mIn.read(&amp;tr, sizeof(tr));
            ...

            Parcel buffer;
            buffer.ipcSetDataReference(
                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                tr.data_size,
                reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(size_t), freeBuffer, this);

            ...

            Parcel reply;
            ...
            if (tr.target.ptr) {
                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);
                const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
                if (error &lt; NO_ERROR) reply.setError(error);

            } else {
                ...
            }

            if ((tr.flags &amp; TF_ONE_WAY) == 0) {
                sendReply(reply, 0);
            } else {
                ...
            }
            ...

        }
        break;

        ...
    }

    ...
    return result;
}</code></pre><p>说明：进入BR_TRANSACTION分支后，首先通过mIn.read()读取事务数据。接着，调用ipcSetDataReference()将事务数据解析出来。很显然，tr.target.ptr不为空，它的值是”MediaPlayerService的BBinder的弱引用”。然后，就将tr.cookie转换为BBinder*对象b；而b实际上是MediaPlayerService的本地Binder实例，即BnMediaPlayerService的实例。最终，通过b-&gt;transact()进行事务处理。</p>
<p>下面看看BBinder的transact()代码。</p>
<pre><code>status_t BBinder::transact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    data.setDataPosition(0);

    status_t err = NO_ERROR;
    switch (code) {
        case PING_TRANSACTION:
            reply-&gt;writeInt32(pingBinder());
            break;
        default:
            err = onTransact(code, data, reply, flags);
            break;
    }

    if (reply != NULL) {
        reply-&gt;setDataPosition(0);
    }

    return err;
}</code></pre><p>该代码在frameworks/native/libs/binder/Binder.cpp中。此时的code是CREATE，因此，它会调用onTransact()对事务进行处理。而BnMediaPlayerService重写了onTransact()方法；因此会调用到BnMediaPlayerService的onTransact()方法。在Binder机制中也是根据这种方式来实现不同Server的对各自的的请求进行区分处理的：Server的本地Binder实现类，通过覆盖onTransact()方法来处理事务。</p>
<p>下面看看BnMediaPlayerService的onTransact()方法。</p>
<p><a name="anchor2_15"></a></p>
<h2 id="15-BnMediaPlayerService-onTransact"><a href="#15-BnMediaPlayerService-onTransact" class="headerlink" title="15. BnMediaPlayerService::onTransact()"></a>15. BnMediaPlayerService::onTransact()</h2><pre><code>status_t BnMediaPlayerService::onTransact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    switch (code) {
        case CREATE: {
            ...
            sp&lt;IMediaPlayerClient&gt; client =
                interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder());
            int audioSessionId = data.readInt32();
            sp&lt;IMediaPlayer&gt; player = create(client, audioSessionId);
            reply-&gt;writeStrongBinder(player-&gt;asBinder());
            return NO_ERROR;
        } break;
        ...
    }
    ...
}</code></pre><p>说明：该代码在frameworks/av/media/libmedia/IMediaPlayerService.cpp中。<br>(01) 先通过interface_cast宏获取IMediaPlayerClient对象，该对象是BpMediaPlayerClient实例。BpMediaPlayerClient定义在frameworks/av/media/libmedia/IMediaPlayer.cpp中。<br>(02) 接着，通过create()创建IMediaPlayerService对象。该create()的实现是在BnMediaPlayerService的子类MediaPlayerService.cpp中，即在frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp中实现。在create()中会新建一个Client，并返回。<br>(03) 最后，将这个Client通过Binder返回给MediaPlayer。</p>
<p>后面的流程就不再多说了。本文的核心是Binder机制，而不是MediaPlayer的框架，让我们了解MediaPlayer进程是如何与MediaPlayerService交互即可！而目前，通过CREATE请求，我们已经知道了MediaPlayer是如何和MediaPlayerService进行事务交互的。后面的内容更多的涉及到MediaPlayerService的框架，它不是本章的重点；感兴趣的读者可以自行研究。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/07/android/os/binder/2014-09-07-BinderCommunication-GetService03/" itemprop="url">Android Binder机制(十一) getService详解03之 请求的反馈</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-07T01:03:00.000Z" itemprop="datePublished">9月 7 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 read (About 2012 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面两篇文章分别介绍了getService中”请求的发送”和”请求的处理”这两部分，本文将介绍getService请求的最后一部分–请求的反馈。下面就说说MediaPlayer收到请求反馈之后的处理流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder驱动中binder-thread-read-的源码"><a href="#1-Binder驱动中binder-thread-read-的源码" class="headerlink" title="1. Binder驱动中binder_thread_read()的源码"></a>1. Binder驱动中binder_thread_read()的源码</h1><p>从MediaPlayer开始唤醒开始说起。</p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是目标节点。
        // 这里，MediaPlayer的getService请求的目标是Service Manager，因此target_node是Service Manager对应的节点；
        if (t-&gt;buffer-&gt;target_node) {
            ...
        } else {
            tr.target.ptr = NULL;
            tr.cookie = NULL;
            cmd = BR_REPLY;
        }
        // 交易码
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            ...
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            ...
        } else {
            t-&gt;buffer-&gt;transaction = NULL;
            kfree(t);
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：MediaPlayer进程被唤醒之后，binder_has_thread_work()为true，因为MediaPlayer进程中有个BINDER_WORK_TRANSACTION类型的待处理事务。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction<em>类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让MediaPlayer读取后进行处理。此时的指令为BR_REPLY！<br>(03) 最后，更新</em>consumed的值，即更新bwr.read_consumed的值。</p>
<p>binder_thread_read()执行完毕之后，共反馈了两个指令到用户空间：BR_NOOP和BR_REPLY。</p>
<p>之后的流程应该都比较熟悉了，首先返回到binder_ioctl()中，接着将ServiceManager反馈的数据拷贝到用户空间。接下来的工作就交给MediaPlayer进程进行处理了。<br>从Binder驱动返回后，首先回到talkWithDriver()中，接着便返回到waitForResponse()中。在waitForResponse()会反馈数据进行解析。  </p>
<p><a name="anchor2"></a></p>
<h1 id="2-IPCThreadState-waitForResponse"><a href="#2-IPCThreadState-waitForResponse" class="headerlink" title="2. IPCThreadState::waitForResponse"></a>2. IPCThreadState::waitForResponse</h1><pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) {
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        ...

        cmd = mIn.readInt32();

        switch (cmd) {
            ...
        case BR_REPLY:
            {
                binder_transaction_data tr;
                err = mIn.read(&amp;tr, sizeof(tr));
                ...

                if (reply) {
                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                        reply-&gt;ipcSetDataReference(
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t),
                            freeBuffer, this);
                    } else {
                        ...
                    }
                } else {
                    ...
                }
            }
            goto finish;
            ...
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：在BR_REPLY分支中，先读取出数据，并保存到tr中。由于reply不为null，并且tr.flags &amp; TF_STATUS_CODE为0；因此，会执行reply-&gt;ipcSetDataReference()。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-Parcel-ipcSetDataReference"><a href="#3-Parcel-ipcSetDataReference" class="headerlink" title="3. Parcel::ipcSetDataReference"></a>3. Parcel::ipcSetDataReference</h1><pre><code>void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,
    const size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)     
{
    freeDataNoInit();                   
    mError = NO_ERROR;
    mData = const_cast&lt;uint8_t*&gt;(data); 
    mDataSize = mDataCapacity = dataSize;
    mDataPos = 0;
    mObjects = const_cast&lt;size_t*&gt;(objects);
    mObjectsSize = mObjectsCapacity = objectsCount;
    mNextObjectHint = 0;
    mOwner = relFunc;
    mOwnerCookie = relCookie;           
    scanForFds();
}</code></pre><p>说明： data就是ServiceManager返回来的数据。数据中包含一个flat_binder_object对象(对应ServiceManager中的binder_object)，因此objectsCount则为1。先通过freeDataNoInit()将原始的数据清空，然后再给mData和mObjects赋值，这样就将数据保存到了Parcel中。<br>为什么objectsCount的值是1呢？请返回查看一下Service Manager在执行binder_send_reply()即可知，这里就不再多说。</p>
<p>waitForResponse()执行完BR_REPLY之后，便返回到IPCThreadState::transact()中；然后层层返回，直到退回到checkService()。  </p>
<p><a name="anchor4"></a></p>
<h1 id="4-BpServiceManager-checkService"><a href="#4-BpServiceManager-checkService" class="headerlink" title="4. BpServiceManager::checkService()"></a>4. BpServiceManager::checkService()</h1><pre><code>virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const
{
    Parcel data, reply;             
    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());               
    data.writeString16(name);       
    remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);
    return reply.readStrongBinder();
}     </code></pre><p>说明：到目前为止，通过transact()来获取MediaPlayerService的事务已经执行完毕！MediaPlayerService的接入点已经保存在replay中。接下来的工作就是调用reply.readStrongBinder()来从replay中解析出所需要的数据，即MediaPlayerService在Biner驱动中的Binder引用描述，也就是C++层的句柄。</p>
<p><a name="anchor5"></a></p>
<h1 id="5-Parcel-readStrongBinder"><a href="#5-Parcel-readStrongBinder" class="headerlink" title="5. Parcel::readStrongBinder"></a>5. Parcel::readStrongBinder</h1><pre><code>sp&lt;IBinder&gt; Parcel::readStrongBinder() const
{
    sp&lt;IBinder&gt; val; 
    unflatten_binder(ProcessState::self(), *this, &amp;val);
    return val; 
}</code></pre><p>说明：readStrongBinder()会调用unflatten_binder()来解析Parcel中的数据。</p>
<p><a name="anchor6"></a></p>
<h1 id="6-Parcel-unflatten-binder"><a href="#6-Parcel-unflatten-binder" class="headerlink" title="6. Parcel::unflatten_binder"></a>6. Parcel::unflatten_binder</h1><pre><code>status_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc,
    const Parcel&amp; in, sp&lt;IBinder&gt;* out)
{
    const flat_binder_object* flat = in.readObject(false);

    if (flat) {
        switch (flat-&gt;type) {
            case BINDER_TYPE_BINDER:
                ...
            case BINDER_TYPE_HANDLE:
                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);
                return finish_unflatten_binder(
                    static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);
        }        
    }
    return BAD_TYPE;
}</code></pre><p>说明：readObject()的作用是从Parcel中读取出它所保存的flat_binder_object类型的对象。该对象的类型是BINDER_TYPE_HANDLE，因此会指向BINDER_TYPE_HANDLE对应的switch分支。<br>(01) 这里的proc是ProcessState对象，执行proc-&gt;getStrongProxyForHandle()会将句柄(MediaPlayerService的Binder引用描述)保存到ProcessState的链表中，然后再创建并返回该句柄的BpBinder对象(即Binder的代理)。在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中有getStrongProxyForHandle()的详细说明，下面只给出getStrongProxyForHandle()代码。<br>(02) finish_unflatten_binder()中只有return NO_ERROR。</p>
<pre><code>sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp&lt;IBinder&gt; result;

    AutoMutex _l(mLock);

    // 在矢量数组中查找&quot;句柄值为handle的handle_entry对象&quot;；
    // 找到的话，则直接返回；找不到的话，则新建handle对应的handle_entry。
    handle_entry* e = lookupHandleLocked(handle);

    if (e != NULL) {
        IBinder* b = e-&gt;binder;
        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
            // 当handle==0(即是Service Manager的句柄)时，尝试去ping Binder驱动。
            if (handle == 0) {
                Parcel data;
                status_t status = IPCThreadState::self()-&gt;transact(
                        0, IBinder::PING_TRANSACTION, data, NULL, 0);
                if (status == DEAD_OBJECT)
                   return NULL;
            }

            // 新建BpBinder代理
            b = new BpBinder(handle);
            e-&gt;binder = b;
            if (b) e-&gt;refs = b-&gt;getWeakRefs();
            result = b;
        } else {
            ...
        }
    }

    return result;
}</code></pre><p>这样，getService()的内容就全部执行完毕。getService()的返回结果IBinder=BpBinder对象，该对象包含了”MediaPlayerService(在Binder驱动)中的Binder引用的描述”，该描述在C++层而言就是个整型句柄。之后，若MediaPlayer要向MediaPlayerService发送请求，就根据该IBinder对象和”MediaPlayerService”进行通信。</p>
<p>上面只是执行完了getService()，它返回了IBinder对象。但是，getMediaPlayerService()并没有执行完毕。下面继续回到getMediaPlayerService()中。</p>
<p><a name="anchor7"></a></p>
<h1 id="7-IMediaDeathNotifier-getMediaPlayerService"><a href="#7-IMediaDeathNotifier-getMediaPlayerService" class="headerlink" title="7. IMediaDeathNotifier::getMediaPlayerService()"></a>7. IMediaDeathNotifier::getMediaPlayerService()</h1><pre><code>const sp&lt;IMediaPlayerService&gt;&amp; IMediaDeathNotifier::getMediaPlayerService()
{
    ...
    if (sMediaPlayerService == 0) {
        sp&lt;IServiceManager&gt; sm = defaultServiceManager();
        sp&lt;IBinder&gt; binder;             
        do {
            binder = sm-&gt;getService(String16(&quot;media.player&quot;));
            ...
            usleep(500000); // 0.5 s    
        } while (true);                 

        ...
        sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);
    }     
    ...
    return sMediaPlayerService;         
}</code></pre><p>说明：在成功获取MediaPlayerService对应的IBinder对象(binder)之后，可以通过interface_cast<imediaplayerservice>(binder)获取它的代理。<br>是不是对interface_cast()很熟悉！不错，在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中就是通过该宏获取IServiceManager的代理的。</imediaplayerservice></p>
<p><a name="anchor8"></a></p>
<h1 id="8-IMediaDeathNotifier-getMediaPlayerService"><a href="#8-IMediaDeathNotifier-getMediaPlayerService" class="headerlink" title="8. IMediaDeathNotifier::getMediaPlayerService()"></a>8. IMediaDeathNotifier::getMediaPlayerService()</h1><pre><code>template&lt;typename INTERFACE&gt;
inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)
{
    return INTERFACE::asInterface(obj);
}   </code></pre><p>下面直接给出IMediaPlayerService::asInterface()的代码。</p>
<pre><code>android::sp&lt;IMediaPlayerService&gt; IMediaPlayerService::asInterface(
        const android::sp&lt;android::IBinder&gt;&amp; obj)
{
    android::sp&lt;IMediaPlayerService&gt; intr;
    if (obj != NULL) {
        intr = static_cast&lt;IMediaPlayerService*&gt;(
            obj-&gt;queryLocalInterface(
                    IMediaPlayerService::descriptor).get());
        if (intr == NULL) {
            intr = new BpServiceManager(obj);
        }
    }
    return intr;
}</code></pre><p>说明：asInterface()会调用new BpMediaPlayerService()新建BpServiceManager对象，并返回给对象。</p>
<p>这样，MediaPlayer进程的getService请求就全部介绍完毕了。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/07/android/os/binder/2014-09-07-BinderCommunication-GetService02/" itemprop="url">Android Binder机制(十) getService详解02之 请求的处理</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-07T01:02:00.000Z" itemprop="datePublished">9月 7 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            28 分钟 read (About 4128 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面介绍了getService请求的发送部分，本文接着介绍请求的处理部分。下面看看ServiceManager被唤醒之后，是如何处理getService请求的</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder驱动中binder-thread-read-的源码"><a href="#1-Binder驱动中binder-thread-read-的源码" class="headerlink" title="1. Binder驱动中binder_thread_read()的源码"></a>1. Binder驱动中binder_thread_read()的源码</h1><p>前面说到，MediaPlayer线程在执行binder_transaction()时，会将一个待处理事务添加到”ServiceManager的待处理事务队列”中；然后，再将ServiceManager进程唤醒。<br>下面，我们就接着看看ServiceManager被唤醒之后做了些什么。</p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是目标节点。
        // 这里，MediaPlayer的getService请求的目标是ServiceManager，因此target_node是Service Manager对应的节点；
        if (t-&gt;buffer-&gt;target_node) {
            // 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体)
            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;
            // Binder实体在用户空间的地址(ServiceManager的ptr为NULL)
            tr.target.ptr = target_node-&gt;ptr;
            // Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL)
            tr.cookie =  target_node-&gt;cookie;
            t-&gt;saved_priority = task_nice(current);
            if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;
                !(t-&gt;flags &amp; TF_ONE_WAY))
                binder_set_nice(t-&gt;priority);
            else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||
                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)
                binder_set_nice(target_node-&gt;min_priority);
            cmd = BR_TRANSACTION;
        } else {
            ...
        }
        // 交易码
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            ...
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            // 将事务t添加到当前线程的事务栈transaction_stack中。
            // 这是因为，Binder驱动需要等待Service Manager的反馈。
            t-&gt;to_parent = thread-&gt;transaction_stack;
            t-&gt;to_thread = thread;
            thread-&gt;transaction_stack = t;
        } else {
            ...
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：ServiceManager进程被唤醒之后，binder_has_thread_work()为true，因为ServiceManager中有个待处理事务(即，MediaPlayer的getService求)。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction<em>类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。此时的指令为BR_TRANSACTION！<br>(03) 最后，更新</em>consumed的值，即更新bwr.read_consumed的值。</p>
<p>然后，binder_thread_read()会返回到binder_ioctl()中。binder_ioctl()在将数据bwr拷贝到用户空间之后会返回。这样，就又回到了ServiceManager守护进程中。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-binder-loop"><a href="#2-binder-loop" class="headerlink" title="2. binder_loop"></a>2. binder_loop</h1><pre><code>void binder_loop(struct binder_state *bs, binder_handler func)
{
    ..

    for (;;) {
        ...
        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);

        ...
        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);
        ...
    }
}   </code></pre><p>说明：该代码在frameworks/native/cmds/servicemanager/binder.c中。Binder驱动共反馈了BR_NOOP和BR_TRANSACTION两个指令给Service Manager守护进程。BR_NOOP什么实质性的工作也不会做，我们直接分析BR_TRANSACTION的处理情况。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-binder-parse"><a href="#3-binder-parse" class="headerlink" title="3. binder_parse"></a>3. binder_parse</h1><pre><code>int binder_parse(struct binder_state *bs, struct binder_io *bio,
                 uint32_t *ptr, uint32_t size, binder_handler func)
{
    int r = 1;
    uint32_t *end = ptr + (size / 4);

    while (ptr &lt; end) {
        uint32_t cmd = *ptr++;

        switch(cmd) {
        case BR_NOOP:
            break;
        ...
        case BR_TRANSACTION: {
            struct binder_txn *txn = (void *) ptr;
            ...
            if (func) {
                unsigned rdata[256/4];
                struct binder_io msg;   // 用于保存&quot;Binder驱动反馈的信息&quot;
                struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot;
                int res;

                // 初始化reply
                bio_init(&amp;reply, rdata, sizeof(rdata), 4);
                // 根据txt(Binder驱动反馈的信息)初始化msg
                bio_init_from_txn(&amp;msg, txn);
                // 消息处理
                res = func(bs, txn, &amp;msg, &amp;reply);
                // 反馈消息给Binder驱动。
                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);
            }
            ptr += sizeof(*txn) / sizeof(uint32_t);
            break;
        }
        ...
        }
    }

    return r;
}</code></pre><p>说明：这里只关注BR_TRANSACTION分支。 首先，用bio_init()初始化reply。然后通过bio_init_from_txn()初始化msg。接着，是通过func函数指针对数据进行处理，func指向svcmgr_handler。处理完毕，再通过binder_send_reply()填写反馈信息给Binder驱动。<br>这里的大部分内容在<a href="/2014/09/05/BinderCommunication-AddService02/">Android Binder机制(六) addService详解02之 请求的处理</a>中都介绍过，这里重点关注svcmgr_handler()处理getService请求的流程。</p>
<p><a name="anchor4"></a></p>
<h1 id="4-svcmgr-handler"><a href="#4-svcmgr-handler" class="headerlink" title="4. svcmgr_handler"></a>4. svcmgr_handler</h1><pre><code>int svcmgr_handler(struct binder_state *bs,
                   struct binder_txn *txn,
                   struct binder_io *msg,
                   struct binder_io *reply)
{
    ...
    // 数据有效性检测(数据头)
    strict_policy = bio_get_uint32(msg);
    s = bio_get_string16(msg, &amp;len);
    if ((len != (sizeof(svcmgr_id) / 2)) ||
        memcmp(svcmgr_id, s, sizeof(svcmgr_id))) {
        ...
    }

    switch(txn-&gt;code) {
        case SVC_MGR_GET_SERVICE:
        case SVC_MGR_CHECK_SERVICE:
            s = bio_get_string16(msg, &amp;len);
            ptr = do_find_service(bs, s, len, txn-&gt;sender_euid);
            if (!ptr)
                break;
            bio_put_ref(reply, ptr);
            return 0;
        ...
    }

    bio_put_uint32(reply, 0);
    return 0;
}</code></pre><p>说明：该代码在frameworks/native/cmds/servicemanager/service_manager.c中。svcmgr_handler()首先读取出getService请求的消息头，进行有效性检测。然后，取出请求的编码；这里请求编码对应是SVC_MGR_CHECK_SERVICE。接着，便进入对应的switch分支。<br>(01) 通过bio_get_string16()获取请求的IBinder对象的名称，即s=”media.player”。<br>(02) 然后，通过do_find_service()查找名称为s的IBinder对象。  </p>
<p><a name="anchor5"></a></p>
<h1 id="5-do-find-service"><a href="#5-do-find-service" class="headerlink" title="5. do_find_service"></a>5. do_find_service</h1><pre><code>void *do_find_service(struct binder_state *bs, uint16_t *s, unsigned len, unsigned uid)
{
    struct svcinfo *si;
    si = find_svc(s, len);

    if (si &amp;&amp; si-&gt;ptr) {
        ...
        return si-&gt;ptr;
    } else {
        return 0;
    }
}

struct svcinfo *find_svc(uint16_t *s16, unsigned len)
{
    struct svcinfo *si;

    for (si = svclist; si; si = si-&gt;next) {
        if ((len == si-&gt;len) &amp;&amp;
            !memcmp(s16, si-&gt;name, len * sizeof(uint16_t))) {
            return si;
        }
    }
    return 0;
}</code></pre><p>说明：<br>(01) do_find_service()会调用find_svc()进行查找。在find_svc()中，会在svclist链表中查找是否有名称等于”media.player”的svcinfo对象。很显然，在<a href="/2014/09/05/BinderCommunication-AddService02/">Android Binder机制(六) addService详解02之 请求的处理</a>中，已经将MediaPlayerService注册到svclist中，而MediaPlayerService的名称就是”media.player”。<br>(02) find_svc()找到svcinfo对象后返回到do_find_service()中。此时，if (si &amp;&amp; si-&gt;ptr)为true，返回si-&gt;ptr。这里的si-&gt;ptr就是MediaPlayerService在Binder驱动中的Binder引用的描述。根据该引用描述，就能找到对应的MediaPlayerService对象。</p>
<p>随后，在成功获取Binder引用的描述之后，svcmgr_handler()会调用bio_put_ref()将该引用信息写入到binder_object中。</p>
<p><a name="anchor6"></a></p>
<h1 id="6-bio-put-ref"><a href="#6-bio-put-ref" class="headerlink" title="6. bio_put_ref()"></a>6. bio_put_ref()</h1><pre><code>void bio_put_ref(struct binder_io *bio, void *ptr)
{
    struct binder_object *obj;

    if (ptr) 
        obj = bio_alloc_obj(bio);
    else
        obj = bio_alloc(bio, sizeof(*obj));

    if (!obj)
        return;

    obj-&gt;flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
    // 类型
    obj-&gt;type = BINDER_TYPE_HANDLE;
    // 句柄地址
    obj-&gt;pointer = ptr;
    obj-&gt;cookie = 0;
}</code></pre><p>说明：bio_put_ref()会将获取到的Binder引用描述打包到结构体binder_object中。而binder_object是与flat_binder_object对应的结构体，Binder驱动在收到个数据之后，就能对flat_binder_object进行解析处理。</p>
<p>在bio_put_ref()将数据打包到reply中之后，svcmgr_handle会调用binder_send_reply()将数据和指令整合到一起。</p>
<p><a name="anchor7"></a></p>
<h1 id="7-binder-send-reply"><a href="#7-binder-send-reply" class="headerlink" title="7. binder_send_reply()"></a>7. binder_send_reply()</h1><pre><code>void binder_send_reply(struct binder_state *bs,
                       struct binder_io *reply,
                       void *buffer_to_free,
                       int status)
{
    struct {
        uint32_t cmd_free;
        void *buffer;
        uint32_t cmd_reply;
        struct binder_txn txn;
    } __attribute__((packed)) data;

    data.cmd_free = BC_FREE_BUFFER;
    data.buffer = buffer_to_free;
    data.cmd_reply = BC_REPLY;
    data.txn.target = 0;
    data.txn.cookie = 0;
    data.txn.code = 0;
    if (status) {
        ...
    } else {
        data.txn.flags = 0;
        data.txn.data_size = reply-&gt;data - reply-&gt;data0;
        data.txn.offs_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0);
        data.txn.data = reply-&gt;data0;
        data.txn.offs = reply-&gt;offs0;
    }
    binder_write(bs, &amp;data, sizeof(data));
}</code></pre><p>说明：binder_send_reply()在<a href="/2014/09/05/BinderCommunication-AddService02/">Android Binder机制(六) addService详解02之 请求的处理</a>中已经介绍过。它共打包了两个指令：BC_FREE_BUFFER和BC_REPLY。在函数最后，它调用binder_write()和Binder驱动交互。</p>
<p><a name="anchor8"></a></p>
<h1 id="8-binder-write"><a href="#8-binder-write" class="headerlink" title="8. binder_write()"></a>8. binder_write()</h1><pre><code>int binder_write(struct binder_state *bs, void *data, unsigned len)
{
    struct binder_write_read bwr;
    int res;
    bwr.write_size = len;
    bwr.write_consumed = 0;
    bwr.write_buffer = (unsigned) data;
    bwr.read_size = 0;
    bwr.read_consumed = 0;
    bwr.read_buffer = 0;
    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
    if (res &lt; 0) {
        fprintf(stderr,&quot;binder_write: ioctl failed (%s)\n&quot;,
                strerror(errno));
    }
    return res;
}</code></pre><p>说明：binder_write()会将数据封装到binder_write_read的变量bwr中；其中，bwr.read_size=0，而bwr.write_size&gt;0。接着，便通过ioctl(,BINDER_WRITE_READ,)和Binder驱动交互，将数据反馈给Binder驱动。</p>
<p>再次回到Binder驱动的binder_ioctl()对应的BINDER_WRITE_READ分支中。此时，由于bwr.read_size=0，而bwr.write_size&gt;0；因此，Binder驱动只调用binder_thread_write进行写操作，而不会进行读。</p>
<p><a name="anchor9"></a></p>
<h1 id="9-Binder驱动中binder-thread-write-的源码"><a href="#9-Binder驱动中binder-thread-write-的源码" class="headerlink" title="9. Binder驱动中binder_thread_write()的源码"></a>9. Binder驱动中binder_thread_write()的源码</h1><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
        case BC_FREE_BUFFER: 
        ...
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p>说明：binder_thread_write()会逐个读出”Service Manager反馈的指令”。<br>(01) 第一个指令是BC_FREE_BUFFER。binder_thread_write()进入BC_FREE_BUFFER对应的分支后后，执行的动作主要是释放”保存MediaPlayer请求数据的缓冲”。<br>(02) 第二个指令是BC_REPLY。binder_thread_write()进入BC_REPLY之后，会将数据拷贝到内核空间，然后调用binder_transaction()进行处理</p>
<p><a name="anchor10"></a></p>
<h1 id="10-Binder驱动中binder-transaction-的源码"><a href="#10-Binder驱动中binder-transaction-的源码" class="headerlink" title="10. Binder驱动中binder_transaction()的源码"></a>10. Binder驱动中binder_transaction()的源码</h1><pre><code>static void binder_transaction(struct binder_proc *proc,
                   struct binder_thread *thread,
                   struct binder_transaction_data *tr, int reply)
{
    struct binder_transaction *t;
    struct binder_work *tcomplete;
    size_t *offp, *off_end;
    struct binder_proc *target_proc;
    struct binder_thread *target_thread = NULL;
    struct binder_node *target_node = NULL;
    struct list_head *target_list;
    wait_queue_head_t *target_wait;
    struct binder_transaction *in_reply_to = NULL;
    struct binder_transaction_log_entry *e;
    uint32_t return_error;

    ...

    if (reply) {
        // 事务栈
        in_reply_to = thread-&gt;transaction_stack;
        ...
        // 设置优先级
        binder_set_nice(in_reply_to-&gt;saved_priority);
        ...
        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;
        // 发起请求的线程，即MediaPlayer所在线程。
        // from的值，是MediaPlayer发起请求时在binder_transaction()中赋值的。
        target_thread = in_reply_to-&gt;from;
        ...
        // MediaPlayer对应的进程
        target_proc = target_thread-&gt;proc;
    } else {
        ...
    }
    if (target_thread) {
        e-&gt;to_thread = target_thread-&gt;pid;
        target_list = &amp;target_thread-&gt;todo;
        target_wait = &amp;target_thread-&gt;wait;
    } else {
        ...
    }
    e-&gt;to_proc = target_proc-&gt;pid;

    // 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
    t = kzalloc(sizeof(*t), GFP_KERNEL);
    if (t == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_alloc_t_failed;
    }

    // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
    if (tcomplete == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_alloc_tcomplete_failed;
    }
    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);

    t-&gt;debug_id = ++binder_last_id;
    e-&gt;debug_id = t-&gt;debug_id;

    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
        t-&gt;from = thread;
    else
        t-&gt;from = NULL;
    // 下面的一些赋值是初始化事务t
    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
    // 事务将交给target_proc进程进行处理
    t-&gt;to_proc = target_proc;
    // 事务将交给target_thread线程进行处理
    t-&gt;to_thread = target_thread;
    // 事务编码
    t-&gt;code = tr-&gt;code;
    // 事务标志
    t-&gt;flags = tr-&gt;flags;
    // 事务优先级
    t-&gt;priority = task_nice(current);

    // 分配空间
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    if (t-&gt;buffer == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_binder_alloc_buf_failed;
    }
    t-&gt;buffer-&gt;allow_user_free = 0;
    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
    // 保存事务
    t-&gt;buffer-&gt;transaction = t;
    // target_node为NULL
    t-&gt;buffer-&gt;target_node = target_node;
    trace_binder_transaction_alloc_buf(t-&gt;buffer);
    if (target_node)
        binder_inc_node(target_node, 1, 0, NULL);

    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));

    // 将&quot;用户传入的数据&quot;保存到事务中
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户传入的数据偏移地址&quot;保存到事务中
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }

    ...
    off_end = (void *)offp + tr-&gt;offsets_size;
    // 将flat_binder_object对象读取出来，
    // 这里就是Service Manager中反馈的MediaPlayerService对象。
    for (; offp &lt; off_end; offp++) {
        struct flat_binder_object *fp;
        ...
        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);

        switch (fp-&gt;type) {
            ...
            case BINDER_TYPE_HANDLE:
            case BINDER_TYPE_WEAK_HANDLE: {
                // 根据handle获取对应的Binder引用，即得到MediaPlayerService的Binder引用
                struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);
                if (ref == NULL) {
                    ...
                }
                // ref-&gt;node-&gt;proc是MediaPlayerService的进程上下文环境，
                // 而target_proc是MediaPlayer的进程上下文环境
                if (ref-&gt;node-&gt;proc == target_proc) {
                    ...
                } else {
                    struct binder_ref *new_ref;
                    // 在MediaPlayer进程中引用&quot;MediaPlayerService&quot;。
                    // 表现为，执行binder_get_ref_for_node()会，会先在MediaPlayer进程中查找是否存在MediaPlayerService对应的Binder引用；
                    // 很显然是不存在的。于是，并新建MediaPlayerService对应的Binder引用，并将其添加到MediaPlayer的Binder引用红黑树中。
                    new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);
                    if (new_ref == NULL) {
                        ...
                    }
                    // 将new_ref的引用描述复制给fp-&gt;handle。
                    fp-&gt;handle = new_ref-&gt;desc;
                    binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL);
                    ...
                }
            } break;

        }
    }

    if (reply) {
        binder_pop_transaction(target_thread, in_reply_to);
    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {
        ...
    } else {
        ...
    }
    // 设置事务的类型为BINDER_WORK_TRANSACTION
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    // 将事务添加到target_list队列中，即target_list的待处理事务中
    list_add_tail(&amp;t-&gt;work.entry, target_list);
    // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
    // 唤醒目标进程
    if (target_wait)
        wake_up_interruptible(target_wait);
    return;
    ...
}</code></pre><p>说明：reply=1，这里只关注reply部分。<br>(01) 此反馈最终是要回复给MediaPlayer的。因此，target_thread被赋值为MediaPlayer所在的线程，target_proc则是MediaPlayer对应的进程，target_node为null。<br>(02) 这里，先看看for循环里面的内容，取出BR_REPLY指令所发送的数据，然后获取数据中的flat_binder_object变量fp。因为fp-&gt;type为BINDER_TYPE_HANDLE，因此进入BINDER_TYPE_HANDLE对应的分支。接着，通过binder_get_ref()获取MediaPlayerService对应的Binder引用；很明显，能够正常获取到MediaPlayerService的Binder引用。因为在MediaPlayerService调用addService请求时，已经创建了它的Binder引用。 binder_get_ref_for_node()的作用是在MediaPlayer进程上下文中添加”MediaPlayerService对应的Binder引用”。这样，后面就可以根据该Binder引用一步步的获取MediaPlayerService对象。 最后，将Binder引用的描述赋值给fp-&gt;handle。<br>(03) 此时，Service Manager已经处理了getService请求。便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayer线程的事务栈中删除该事务。<br>(04) 新建的”待处理事务t”的type为设为BINDER_WORK_TRANSACTION后，会被添加到MediaPlayer的待处理事务队列中。<br>(05) 此时，Service Manager已经处理了getService请求，而Binder驱动在等待它的回复。于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”(作为回复)添加到当前线程(即，Service Manager线程)的待处理事务队列中。<br>(06) 最后，调用wake_up_interruptible()唤醒MediaPlayer。MediaPlayer被唤醒后，会对事务BINDER_WORK_TRANSACTION进行处理。</p>
<p>OK，到现在为止，还有两个待处理事务：(01) ServiceManager待处理事务列表中有个BINDER_WORK_TRANSACTION_COMPLETE类型的事务 (02) MediaPlayer待处理事务列表中有个BINDER_WORK_TRANSACTION事务。</p>
<p>关于BINDER_WORK_TRANSACTION_COMPLETE事务，它是用来告诉ServiceManager，ServiceManager的反馈信息已经处理完毕。下一篇文章，就说说MediaPlayer被唤醒后，执行BINDER_WORK_TRANSACTION的流程。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/07/android/os/binder/2014-09-07-BinderCommunication-GetService01/" itemprop="url">Android Binder机制(九) getService详解01之 请求的发送</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-07T01:01:00.000Z" itemprop="datePublished">9月 7 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            27 分钟 read (About 4109 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面，以MediaPlayerService为例，介绍了Server服务是如何通过addService请求添加到ServiceManager中的。本文，将以MediaPlayer获取MediaPlayerService服务为例，介绍Client是如何通过getService请求从ServiceManager中获取到Server接入点的。<br>在本文的getService请求中，MediaPlayer是Client，它要获取的Server接入点是MediaPlayerService。和addService一样，在分析getService时，会将文章分为请求的发送，请求的处理，和请求的反馈这3部分来进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Android消息机制的架构</a>  </p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="getService概述"><a href="#getService概述" class="headerlink" title="getService概述"></a>getService概述</h1><p>先看看getService的时序图</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/getService.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/getService.jpg" alt></a></p>
<p> 仔细观察，你会发现getService的时序图和”addService的时序图(在<a href="/2014/09/05/BinderCommunication-AddService01/">Android Binder机制(五) addService详解01之 请求的发送</a>中)”几乎是一样的。<br> 先是MediaPlayer进程将getService以BC_TRANSACTION事务的方式发给Binder驱动。Binder驱动收到之后，对内容进行解析；然后唤醒ServiceManager，同时反馈一个BR_TRANSACTION_COMPLETE给MediaPlayer。反馈的BR_TRANSACTION_COMPLETE是告诉MediaPlayer，它的getService请求已经被Binder驱动成功收到。接着，MediaPlayer就进入等待状态，等待ServiceManager的反馈。 ServiceManager被唤醒之后，读取Binder驱动传递给它的BR_TRANSACTION事务。在得知是获取MediaPlayerService的请求之后，就从缓冲中取出MediaPlayerService的相关信息；然后和BC_REPLY指令一起反馈给Binder驱动。Binder驱动收到ServiceManager的反馈之后，将内容进一步反馈给MediaPlayer，并将MediaPlayer唤醒。MediaPlayer被唤醒之后，从Binder驱动反馈的BR_REPLY中解析出MediaPlayerService的相关信息；这样，MediaPlayer就成功获取到了MediaPlayerService的接入点。</p>
<p><a name="anchor2"></a></p>
<h1 id="getService的代码解析"><a href="#getService的代码解析" class="headerlink" title="getService的代码解析"></a>getService的代码解析</h1><p><a name="anchor2_1"></a></p>
<h2 id="1-MediaPlayer的getService入口"><a href="#1-MediaPlayer的getService入口" class="headerlink" title="1. MediaPlayer的getService入口"></a>1. MediaPlayer的getService入口</h2><pre><code>sp&lt;IMediaPlayerService&gt; IMediaDeathNotifier::sMediaPlayerService;
...

const sp&lt;IMediaPlayerService&gt;&amp; IMediaDeathNotifier::getMediaPlayerService()
{
    ...
    if (sMediaPlayerService == 0) {
        sp&lt;IServiceManager&gt; sm = defaultServiceManager();
        sp&lt;IBinder&gt; binder;             
        do {
            binder = sm-&gt;getService(String16(&quot;media.player&quot;));
            ...
            usleep(500000); // 0.5 s    
        } while (true);                 

        ...
        sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);                 
    }     
    ...
    return sMediaPlayerService;         
}</code></pre><p>说明：该代码在frameworks/av/media/libmedia/IMediaDeathNotifier.cpp中。<br>(01) sMediaPlayerService是sp<imediaplayerservice>成员，初始化为null。因此if(sMediaPlayerService==0)为true。<br>(02) 调用defaultServiceManager()获取IServiceManager对象，该对象实际上是BpServiceManager类的实例。defaultServiceManager()的详细流程请参考<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>。<br>(03) 接着就是调用sm-&gt;getService(String16(“media.player”))获取MediaPlayerService对象。</imediaplayerservice></p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-BpServiceManager-getService"><a href="#2-BpServiceManager-getService" class="headerlink" title="2. BpServiceManager::getService()"></a>2. BpServiceManager::getService()</h2><pre><code>virtual sp&lt;IBinder&gt; getService(const String16&amp; name) const
{
    unsigned n;
    for (n = 0; n &lt; 5; n++){
        sp&lt;IBinder&gt; svc = checkService(name);
        if (svc != NULL) return svc;
        sleep(1);
    }
    return NULL;
}

virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const
{
    Parcel data, reply;             
    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());               
    data.writeString16(name);       
    remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);
    return reply.readStrongBinder();
}     </code></pre><p>说明：该代码在frameworks/native/libs/binder/IServiceManager.cpp中。<br>(01) getService()是通过调用checkService()来获取IBinder对象的。如果获取失败，它会调用sleep()休眠1ms之后再次尝试；若尝试5次都失败，则返回null。之所以要尝试5次，是由于可能此时MediaPlayerService服务还没有准备好。<br>(02) 下面看看checkService()，它和”<a href="/2014/09/05/BinderCommunication-AddService01/">Android Binder机制(五) addService详解01之 请求的发送</a>中的addService()”很多内容都相似。 checkService()会先调用writeInterfaceToken()写入一个消息头：”4字节的整型数” + “字符串android.os.IServiceManager”。然后，再调用writeString16(name)将服务名”media.player”写入到data中。 最后，调用remote()-&gt;transact()进行事务交互，其中remote()返回的是BpBinder对象。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="3-BpBinder-transact"><a href="#3-BpBinder-transact" class="headerlink" title="3. BpBinder::transact()"></a>3. BpBinder::transact()</h2><pre><code>status_t BpBinder::transact(            
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // mAlive的初始值为1
    if (mAlive) {
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }

    return DEAD_OBJECT;
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/BpBinder.cpp中。它会调用IPCThreadState::transact()。</p>
<p><a name="anchor2_4"></a></p>
<h2 id="4-IPCThreadState-transact"><a href="#4-IPCThreadState-transact" class="headerlink" title="4. IPCThreadState::transact()"></a>4. IPCThreadState::transact()</h2><pre><code>status_t IPCThreadState::transact(int32_t handle,
                                  uint32_t code, const Parcel&amp; data,
                                  Parcel* reply, uint32_t flags)
{
    status_t err = data.errorCheck();

    flags |= TF_ACCEPT_FDS;

    ...
    if (err == NO_ERROR) {
        ...
        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
    }

    ...

    if ((flags &amp; TF_ONE_WAY) == 0) {
        if (reply) {
            err = waitForResponse(reply);
        } else {
            ...
        }
    } else {
        ...
    }

    return err;
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/IPCThreadState.cpp中。它会先通过writeTransactionData()将要发送的指令和数据打包到binder_transaction_data中，然后调用waitForResponse()和Binder驱动进行通信。</p>
<p><a name="anchor2_5"></a></p>
<h2 id="5-IPCThreadState-writeTransactionData"><a href="#5-IPCThreadState-writeTransactionData" class="headerlink" title="5. IPCThreadState::writeTransactionData()"></a>5. IPCThreadState::writeTransactionData()</h2><pre><code>status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,
    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)
{
    binder_transaction_data tr;

    tr.target.handle = handle;
    tr.code = code;
    tr.flags = binderFlags;
    tr.cookie = 0;
    tr.sender_pid = 0;
    tr.sender_euid = 0;

    const status_t err = data.errorCheck();
    if (err == NO_ERROR) {
        tr.data_size = data.ipcDataSize();
        tr.data.ptr.buffer = data.ipcData();
        tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t);
        tr.data.ptr.offsets = data.ipcObjects();
    } else if (statusBuffer) {
        ..
    } else {
        ...
    }

    mOut.writeInt32(cmd);
    mOut.write(&amp;tr, sizeof(tr));

    return NO_ERROR;
}</code></pre><p>说明：该函数会读取Parcel中的数据，然后将其打包到tr中，tr是binder_transaction_data结构体的对象。之后，将”指令”+”数据”写入到mOut中。指令(cmd)=BC_TRANSACTION，数据就是tr。</p>
<p><a name="anchor2_6"></a></p>
<h2 id="6-IPCThreadState-waitForResponse"><a href="#6-IPCThreadState-waitForResponse" class="headerlink" title="6. IPCThreadState::waitForResponse()"></a>6. IPCThreadState::waitForResponse()</h2><pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) {
        // 先通过talkWithDriver()和Binder驱动交互
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        ...
        if (mIn.dataAvail() == 0) continue;

        // 然后读取返回结果，再根据结果进行处理
        cmd = mIn.readInt32();

        switch (cmd) {
        case BR_TRANSACTION_COMPLETE:
            ...
        case BR_DEAD_REPLY:
            ...
        case BR_FAILED_REPLY:
            ...
        case BR_ACQUIRE_RESULT:
            ...
        case BR_REPLY:
            ...
        default:
            err = executeCommand(cmd);
            if (err != NO_ERROR) goto finish;
            break;
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：waitForResponse()会先调用talkWithDriver()和Binder驱动交互，然后根据反馈结果来进行处理。</p>
<p><a name="anchor2_7"></a></p>
<h2 id="7-IPCThreadState-talkWithDriver"><a href="#7-IPCThreadState-talkWithDriver" class="headerlink" title="7. IPCThreadState::talkWithDriver()"></a>7. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    binder_write_read bwr;

    // Is the read buffer empty?
    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();
    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we&apos;ll read.
    if (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
        bwr.read_buffer = 0;
    }

    ...
    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    status_t err;
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：talkWithDriver()会先初始化bwr(binder_write_read类型的变量)，然后将bwr通过ioctl()发送给Binder驱动。初始化之后的bwr各个成员的值如下：  </p>
<pre><code>bwr.write_size = outAvail;                          // mOut中数据大小，大于0
bwr.write_buffer = (long unsigned int)mOut.data();  // mOut中数据的地址
bwr.write_consumed = 0;
bwr.read_size = mIn.dataCapacity();                 // 256
bwr.read_buffer = (long unsigned int)mIn.data();    // mIn.mData，实际上为空
bwr.read_consumed = 0;</code></pre><p>bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。</p>
<p><a name="anchor2_8"></a></p>
<h2 id="8-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#8-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="8. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>8. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h2><pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：首先，会将binder_write_read从用户空间拷贝到内核空间之后。拷贝之后，读取出来的bwr.write_size和bwr.read_size都&gt;0，因此先写后读。即，先执行binder_thread_write()，然后执行binder_thread_read()。</p>
<p><a name="anchor2_9"></a></p>
<h2 id="9-Binder驱动中binder-thread-write-的源码"><a href="#9-Binder驱动中binder-thread-write-的源码" class="headerlink" title="9. Binder驱动中binder_thread_write()的源码"></a>9. Binder驱动中binder_thread_write()的源码</h2><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
      ...
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p>说明：MediaPlayer发送的指令是BC_TRANSACTION，这里只关心与BC_TRANSACTION相关的部分。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。</p>
<p><a name="anchor2_10"></a></p>
<h2 id="10-Binder驱动中binder-transaction-的源码"><a href="#10-Binder驱动中binder-transaction-的源码" class="headerlink" title="10. Binder驱动中binder_transaction()的源码"></a>10. Binder驱动中binder_transaction()的源码</h2><pre><code>static void binder_transaction(struct binder_proc *proc,
                   struct binder_thread *thread,
                   struct binder_transaction_data *tr, int reply)
{
    struct binder_transaction *t;
    struct binder_work *tcomplete;
    size_t *offp, *off_end;
    struct binder_proc *target_proc;
    struct binder_thread *target_thread = NULL;
    struct binder_node *target_node = NULL;
    struct list_head *target_list;
    wait_queue_head_t *target_wait;
    struct binder_transaction *in_reply_to = NULL;
    struct binder_transaction_log_entry *e;
    uint32_t return_error;

    ...

    if (reply) {
        ...
    } else {
        if (tr-&gt;target.handle) {
            ...
        } else {
            // 该getService是从ServiceManager中获取MediaPlayer；
            // 因此事务目标对象是ServiceManager的binder实体。
            target_node = binder_context_mgr_node;
            ...
        }
        ...
        // 设置处理事务的目标进程
        target_proc = target_node-&gt;proc;
        ...
    }

    if (target_thread) {
        ...
    } else {
        target_list = &amp;target_proc-&gt;todo;
        target_wait = &amp;target_proc-&gt;wait;
    }
    ...

    // 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
    t = kzalloc(sizeof(*t), GFP_KERNEL);
    ...

    // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
    ...

    t-&gt;debug_id = ++binder_last_id;
    ...

    // 设置from，表示该事务是MediaPlayer线程发起的
    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
        t-&gt;from = thread;
    else
        t-&gt;from = NULL;
    // 下面的一些赋值是初始化事务t
    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
    // 事务将交给target_proc进程进行处理
    t-&gt;to_proc = target_proc;
    // 事务将交给target_thread线程进行处理
    t-&gt;to_thread = target_thread;
    // 事务编码
    t-&gt;code = tr-&gt;code;
    // 事务标志
    t-&gt;flags = tr-&gt;flags;
    // 事务优先级
    t-&gt;priority = task_nice(current);

    ...

    // 分配空间
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    ...
    t-&gt;buffer-&gt;allow_user_free = 0;
    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
    // 保存事务
    t-&gt;buffer-&gt;transaction = t;
    // 保存事务的目标对象(即处理该事务的binder对象)
    t-&gt;buffer-&gt;target_node = target_node;
    trace_binder_transaction_alloc_buf(t-&gt;buffer);
    if (target_node)
        binder_inc_node(target_node, 1, 0, NULL);

    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));

    // 将&quot;用户空间的数据&quot;拷贝到内核中
    // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户空间的数据中所含对象的偏移地址&quot;拷贝到内核中
    // MediaPlayer中不包含对象, offp=null
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }
    ...
    // MediaPlayer中不包含对象, off_end为null
    off_end = (void *)offp + tr-&gt;offsets_size;
    // MediaPlayer中不包含对象, offp=off_end
    for (; offp &lt; off_end; offp++) {
        ...
    }
    if (reply) {
        ..
    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {
        BUG_ON(t-&gt;buffer-&gt;async_transaction != 0);
        t-&gt;need_reply = 1;
        t-&gt;from_parent = thread-&gt;transaction_stack;
        // 将当前事务添加到当前线程的事务栈中
        thread-&gt;transaction_stack = t;
    } else {
        ...
    }
    // 设置事务的类型为BINDER_WORK_TRANSACTION
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    // 将事务添加到target_list队列中，即target_list的待处理事务中
    list_add_tail(&amp;t-&gt;work.entry, target_list);
    // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
    // 唤醒目标进程
    if (target_wait)
        wake_up_interruptible(target_wait);
    return;

    ...
}</code></pre><p>说明：参数reply=0，表明这是个请求事务，而不是反馈。binder_transaction新建会新建”一个待处理事务t”和”待完成的工作tcomplete”，并根据请求的数据对它们进行初始化。<br>(01) MediaPlayer的getService请求是提交给ServiceManager进行处理的，因此，”待处理事务t”会被添加到ServiceManager的待处理事务队列中。此时的target_thread是ServiceManager对应的线程，而target_proc则是ServiceManager对应的进程上下文环境。<br>(02) 此时，Binder驱动已经收到了MediaPlayer的getService请求；于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”添加到当前线程(即，MediaPlayer线程)的待处理事务队列中。目的是告诉MediaPlayer，Binder驱动已经收到它的getService请求了。<br>(03) 最后，调用wake_up_interruptible(target_wait)将Service Manager唤醒。</p>
<p>接下来，还是先分析完MediaPlayer线程，再看ServiceManager被唤醒后做了些什么。</p>
<p>binder_transaction()执行完毕之后，就会返回到binder_thread_write()中。binder_thread_write()更新bwr.write_consumed的值后，就返回到binder_ioctl()继续执行”读”动作。即执行binder_thread_read()。</p>
<p><a name="anchor2_11"></a></p>
<h2 id="11-Binder驱动中binder-thread-read-的源码"><a href="#11-Binder驱动中binder-thread-read-的源码" class="headerlink" title="11. Binder驱动中binder_thread_read()的源码"></a>11. Binder驱动中binder_thread_read()的源码</h2><pre><code>static int binder_thread_read(struct binder_proc *proc,
                  struct binder_thread *thread,
                  void  __user *buffer, int size,
                  signed long *consumed, int non_block)
{
    void __user *ptr = buffer + *consumed;
    void __user *end = buffer + size;

    int ret = 0;
    int wait_for_proc_work;

    // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区
    if (*consumed == 0) {
        if (put_user(BR_NOOP, (uint32_t __user *)ptr))
            return -EFAULT;
        ptr += sizeof(uint32_t);
    }

retry:
    // 等待proc进程的事务标记。
    // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。
    wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;
                list_empty(&amp;thread-&gt;todo);

    ...

    if (wait_for_proc_work) {
        ...
    } else {
        if (non_block) {
            ...
        } else
            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));
    }

    ...

    while (1) {
        uint32_t cmd;
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */
                goto retry;
            break;
        }

        ...

        switch (w-&gt;type) {
        ...
        case BINDER_WORK_TRANSACTION_COMPLETE: {
            cmd = BR_TRANSACTION_COMPLETE;
            // 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中
            if (put_user(cmd, (uint32_t __user *)ptr))
                return -EFAULT;
            ptr += sizeof(uint32_t);

            ...
            // 待完成事务已经处理完毕，将其从待完成事务队列中删除。
            list_del(&amp;w-&gt;entry);
            kfree(w);
            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
        } break;
        ...
        }

        if (!t)
            continue;

        ...
    }

    ...
    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：<br>(01) bwr.read_consumed=0，即if (*consumed == 0)为true。因此，会将BR_NOOP写入到bwr.read_buffer中。<br>(02) thread-&gt;transaction_stack不为空，thread-&gt;todo也不为空。因为，前面在binder_transaction()中有将一个BINDER_WORK_TRANSACTION_COMPLETE类型的待完成工作添加到thread的待完成工作队列中。因此，wait_for_proc_work为false。<br>(03) binder_has_thread_work(thread)为true。因此，在调用wait_event_interruptible()时，不会进入等待状态，而是继续运行。<br>(04) 进入while循环后，通过list_first_entry()取出待完成工作w。w的类型w-&gt;type=BINDER_WORK_TRANSACTION_COMPLETE，进入到对应的switch分支。随后，将BR_TRANSACTION_COMPLETE写入到bwr.read_buffer中。此时，待处理工作已经完成，将其从当前线程的待处理工作队列中删除。<br>(05) 最后，更新bwr.read_consumed的值。  </p>
<p>经过binder_thread_read()处理之后，bwr.read_buffer中包含了两个指令：BR_NOOP和BR_TRANSACTION_COMPLETE。</p>
<p>再回到binder_ioctl()中，在将bwr拷贝到用户空间之后，binder_ioctl()的工作就完成了。于是就返回到talkWithDriver()中。</p>
<p><a name="anchor2_12"></a></p>
<h2 id="12-IPCThreadState-talkWithDriver"><a href="#12-IPCThreadState-talkWithDriver" class="headerlink" title="12. IPCThreadState::talkWithDriver()"></a>12. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                ...
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：<br>(01) 从Binder驱动返回后，bwr.write_consumed&gt;0，因此调用mOut.setDataSize(0)将mOut中的数据清空。这意味着，MediaPlayer的请求Binder驱动已经收到，并且已经将请求数据读取完毕。<br>(02) bwr.read_consumed也&gt;0，因此会执行if(bwr.read_consumed&gt;0)中的代码，更新mIn中的mDataSize和mDataPos。这意味着，Binder驱动反馈给MediaPlayer的数据不为空。接下来，MediaPlayer线程肯定会读取Binder驱动反馈的数据(BR_NOOP和BR_TRANSACTION_COMPLETE)。在读取完这些数据之后，MediaPlayer线程会再次调用ioctl(,BINDER_WRITE_READ,)进行读动作；而当执行到binder_thread_read()时，由于此时MediaPlayer线程的待处理工作队列为空，因此MediaPlayer线程会进入中断等待状态。待ServiceManager守护进程处理完MediaPlayer的请求之后，就会将MediaPlayer唤醒。</p>
<br>
至此，getService请求的发送部分就介绍完了。下面，就看看ServiceManager被唤醒后是如何获取MediaPlayerService进入点，然后再将该进入点反馈给MediaPlayer的。





    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/06/android/os/binder/2014-09-06-BinderCommunication-ThreadPool/" itemprop="url">Android Binder机制(八) MediaPlayerService服务的消息循环</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-06T01:01:00.000Z" itemprop="datePublished">9月 6 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 read (About 1598 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>在前面的3篇文章中，我们以MediaPlayerService为例，介绍了C-S中的Server服务是如何通过addService请求添加到ServiceManager中的。但是，在<a href="/2014/09/05/BinderCommunication-AddService03/">Android Binder机制(七) addService详解03之 请求的反馈</a>的结尾，我们提到过：MediaPlayerService仅仅只是将自己注册到了ServiceManager中，它还没有进入消息循环等待Client的请求。<br>本文，就接着介绍MediaPlayerService是如何进入消息循环的。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-MediaPlayerService的main-函数"><a href="#1-MediaPlayerService的main-函数" class="headerlink" title="1. MediaPlayerService的main()函数"></a>1. MediaPlayerService的main()函数</h1><pre><code>int main(int argc, char** argv)
{
    ...

    if (doLog &amp;&amp; (childPid = fork()) != 0) {
        ...
    } else {
        ...
        MediaPlayerService::instantiate();
        ...
        ProcessState::self()-&gt;startThreadPool();
        IPCThreadState::self()-&gt;joinThreadPool();
    }
}</code></pre><p>说明：该代码在frameworks/av/media/mediaserver/main_mediaserver.cpp中。对于MediaPlayerService::instantiate()，已经详细介绍过了；它的作用是将MediaPlayerService已经注册到ServiceManager中。下面看看startThreadPool()的流程。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-ProcessState-startThreadPool"><a href="#2-ProcessState-startThreadPool" class="headerlink" title="2. ProcessState::startThreadPool();"></a>2. ProcessState::startThreadPool();</h1><pre><code>void ProcessState::startThreadPool()
{
    AutoMutex _l(mLock);
    if (!mThreadPoolStarted) {
        mThreadPoolStarted = true;
        spawnPooledThread(true);
    }
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中。<br>mThreadPoolStarted的初始值为false，因此这里设置mThreadPoolStarted=true之后，就调用spawnPooledThread()。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-ProcessState-spawnPooledThread"><a href="#2-ProcessState-spawnPooledThread" class="headerlink" title="2. ProcessState::spawnPooledThread()"></a>2. ProcessState::spawnPooledThread()</h1><pre><code>void ProcessState::spawnPooledThread(bool isMain)
{
    if (mThreadPoolStarted) {
        String8 name = makeBinderThreadName();
        ALOGV(&quot;Spawning new pooled thread, name=%s\n&quot;, name.string());
        sp&lt;Thread&gt; t = new PoolThread(isMain);
        t-&gt;run(name.string());
    }
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中。 此时mThreadPoolStarted=true，因此会先调用makeBinderThreadName()为线程取一个名称；然后新建PoolThread线程，并运行。<br>makeBinderThreadName()的代码比较简单，这里就不列出了。线程的名称是”Binder_X”(其实X是16进制数)，每新建一个线程X的值都会+1。下面看看PoolThread。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-ProcessState-spawnPooledThread"><a href="#3-ProcessState-spawnPooledThread" class="headerlink" title="3. ProcessState::spawnPooledThread()"></a>3. ProcessState::spawnPooledThread()</h1><pre><code>class PoolThread : public Thread
{
public:
    PoolThread(bool isMain)
        : mIsMain(isMain)
    {
    }

protected:
    virtual bool threadLoop()
    {
        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);
        return false;
    }

    const bool mIsMain;
};</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中。PoolThread继承于Thread，在线程启动之后，会调用threadLoop()进入消息循环中。 </p>
<p>下面简单说说，当PoolThread启动之后，是如何调用到threadLoop()的。PoolThread继承于Thread，先看看Thread的构造函数，然后再看看run()的代码。</p>
<p><a name="anchor4"></a></p>
<h1 id="4-Thread-Thread"><a href="#4-Thread-Thread" class="headerlink" title="4. Thread::Thread"></a>4. Thread::Thread</h1><pre><code>Thread::Thread(bool canCallJava)
    :   mCanCallJava(canCallJava),
        mThread(thread_id_t(-1)),
        mLock(&quot;Thread::mLock&quot;),
        mStatus(NO_ERROR),
        mExitPending(false), mRunning(false)
        , mTid(-1)
{
}   </code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。新建Thread对象时，会进行一些列初始化。这里设置mCanCallJava=true。</p>
<p><a name="anchor5"></a></p>
<h1 id="5-Thread-run"><a href="#5-Thread-run" class="headerlink" title="5. Thread::run"></a>5. Thread::run</h1><pre><code>status_t Thread::run(const char* name, int32_t priority, size_t stack)
{   
    Mutex::Autolock _l(mLock);

    ...

    // 初始化
    mStatus = NO_ERROR;
    mExitPending = false;
    mThread = thread_id_t(-1);
    mHoldSelf = this;
    mRunning = true;            

    bool res;
    if (mCanCallJava) {
        res = createThreadEtc(_threadLoop,
                this, name, priority, stack, &amp;mThread);
    } else {
        ...
    }

    ...
    return NO_ERROR;
}</code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。<br>(01) 先看看函数参数。name是spawnPooledThread()中创建的Binder线程名称，形式是”Binder_X”。priority是优先级(默认值为PRIORITY_DEFAULT)，stack是线程栈数量(默认是0)；它们都是使用默认值，在system/core/include/utils/Thread.h中定义。<br>(02) 先进行初始化；mCanCallJava的值在构造函数中被初始化为true。因此，会调用createThreadEtc()。</p>
<p><a name="anchor6"></a></p>
<h1 id="6-createThreadEtc"><a href="#6-createThreadEtc" class="headerlink" title="6. createThreadEtc"></a>6. createThreadEtc</h1><pre><code>// Create thread with lots of parameters
inline bool createThreadEtc(thread_func_t entryFunction,
                            void *userData,
                            const char* threadName = &quot;android:unnamed_thread&quot;,             
                            int32_t threadPriority = PRIORITY_DEFAULT,                     
                            size_t threadStackSize = 0,                                    
                            thread_id_t *threadId = 0)
{
    return androidCreateThreadEtc(entryFunction, userData, threadName,
        threadPriority, threadStackSize, threadId) ? true : false;
}</code></pre><p>说明：该代码定义在system/core/include/utils/AndroidThreads.h中。它会调用androidCreateThreadEtc()。</p>
<p><a name="anchor7"></a></p>
<h1 id="7-androidCreateThreadEtc"><a href="#7-androidCreateThreadEtc" class="headerlink" title="7. androidCreateThreadEtc"></a>7. androidCreateThreadEtc</h1><pre><code>static android_create_thread_fn gCreateThreadFn = androidCreateRawThreadEtc;

int androidCreateThreadEtc(android_thread_func_t entryFunction,
                            void *userData,
                            const char* threadName,
                            int32_t threadPriority,
                            size_t threadStackSize,
                            android_thread_id_t *threadId)
{
    return gCreateThreadFn(entryFunction, userData, threadName,
        threadPriority, threadStackSize, threadId);
}

void androidSetCreateThreadFunc(android_create_thread_fn func)
{
    gCreateThreadFn = func;
}</code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。 androidCreateThreadEtc()会调用gCreateThreadFn()。gCreateThreadFn()是个函数指针，它的值是androidCreateRawThreadEtc。</p>
<p><a name="anchor8"></a></p>
<h1 id="8-androidCreateRawThreadEtc"><a href="#8-androidCreateRawThreadEtc" class="headerlink" title="8. androidCreateRawThreadEtc"></a>8. androidCreateRawThreadEtc</h1><pre><code>int androidCreateRawThreadEtc(android_thread_func_t entryFunction,
                               void *userData,
                               const char* threadName,
                               int32_t threadPriority,
                               size_t threadStackSize,
                               android_thread_id_t *threadId)
{
    ...
    int result = pthread_create(&amp;thread, &amp;attr,
                    (android_pthread_entry)entryFunction, userData);

    ...
    return 1;
}</code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。 该函数会调用pthread_create()，而pthread_create()则是我们非常熟悉的Linux的标准接口，它的作用就是创建线程。线程创建成功之后运行时，会以执行entryFunction对应的函数。而entryFunction这个函数指针的值是_threadLoop。因此，当线程启动之后，会执行_threadLoop。</p>
<p><a name="anchor9"></a></p>
<h1 id="9-threadLoop"><a href="#9-threadLoop" class="headerlink" title="9. _threadLoop"></a>9. _threadLoop</h1><pre><code>int Thread::_threadLoop(void* user)
{
    ...

    bool first = true;

    do {
        bool result;
        if (first) {
            first = false;
            self-&gt;mStatus = self-&gt;readyToRun();
            result = (self-&gt;mStatus == NO_ERROR);

            if (result &amp;&amp; !self-&gt;exitPending()) {
                result = self-&gt;threadLoop();
            }
        } else {
            ...
        }

        ...
    } while(strong != 0);

    return 0;
}</code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。first的初始值为true，因此进入到if(first)中。  readyToRun()的实现在Threads.cpp中，返回NO_ERROR。因此result为true，而mExitPending的默认值为false，即self0&gt;exitPending()返回false。因此会执行self-&gt;threadLoop()。由于PoolThread重载了threadLoop()，因此，这里的self-&gt;threadLoop()会调用PoolThread中的threadLoop()。</p>
<p><a name="anchor10"></a></p>
<h1 id="10-PoolThread-threadLoop"><a href="#10-PoolThread-threadLoop" class="headerlink" title="10. PoolThread::threadLoop()"></a>10. PoolThread::threadLoop()</h1><pre><code>virtual bool threadLoop()
{
    IPCThreadState::self()-&gt;joinThreadPool(mIsMain);
    return false;
}</code></pre><p>说明：这是PoolThread中实现的threadLoop()函数。它会先通过IPCThreadState::self()获取IPCThreadState对象，然后调用IPCThreadState::joinThreadPool(mIsMain)，其中mIsMain为true。</p>
<p><a name="anchor11"></a></p>
<h1 id="11-IPCThreadState-joinThreadPool"><a href="#11-IPCThreadState-joinThreadPool" class="headerlink" title="11. IPCThreadState::joinThreadPool()"></a>11. IPCThreadState::joinThreadPool()</h1><pre><code>void IPCThreadState::joinThreadPool(bool isMain)
{
    ...

    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);

    ...
    do {  
        ...
        result = getAndExecuteCommand();

        if (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) {
            ...
            abort();
        } 

        if(result == TIMED_OUT &amp;&amp; !isMain) {
            break;
        } 
    } while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);

    ...

    mOut.writeInt32(BC_EXIT_LOOPER);    
    talkWithDriver(false);              
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/IPCThreadState.cpp中。在该函数中，便进入了消息循环！<br>(01) isMain=true，因此会先将BC_ENTER_LOOPER指令写入到mOut中。<br>(02) 接着调用getAndExecuteCommand()。  </p>
<p><a name="anchor12"></a></p>
<h1 id="12-IPCThreadState-getAndExecuteCommand"><a href="#12-IPCThreadState-getAndExecuteCommand" class="headerlink" title="12. IPCThreadState::getAndExecuteCommand()"></a>12. IPCThreadState::getAndExecuteCommand()</h1><pre><code>status_t IPCThreadState::getAndExecuteCommand()
{
    status_t result;
    int32_t cmd;

    // 和Binder驱动交互
    result = talkWithDriver();
    if (result &gt;= NO_ERROR) {
        ...
        // 读取mIn中的数据
        cmd = mIn.readInt32();
        ...

        // 调用executeCommand()对数据进行处理。
        result = executeCommand(cmd);
        ...
    }

    return result;
}</code></pre><p>说明：该函数会调用talkWithDriver()和Binder驱动进行交互。对于talkWithDriver()，前面已经多次提到。在此，talkWithDriver()会将BC_ENTER_LOOPER指令发送给Binder驱动，告诉Binder驱动，MediaPlayerService进入了消息循环状态。BC_ENTER_LOOPER的流程在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中已经介绍过了。<br>当BC_ENTER_LOOPER处理完毕，MediaPlayerService再次调用ioctl()和Binder驱动通信时，由于MediaPlayerService对应的待处理事务列表为空，因此MediaPlayerService线程会进入中断等待状态。当有Client向MediaPlayerService发送请求时，MediaPlayerService就会被唤醒。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/05/android/os/binder/2014-09-05-BinderCommunication-AddService03/" itemprop="url">Android Binder机制(七) addService详解03之 请求的反馈</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-05T01:03:00.000Z" itemprop="datePublished">9月 5 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            9 分钟 read (About 1331 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面两篇文章分别介绍了addService中”请求的发送”和”请求的处理”这两部分，本文将介绍addService请求的最后一部分–请求的反馈。<br>ServiceManager在处理完addService请求之后，添加了一个待处理事务到MediaPlayerService的事务列表中，并将MediaPlayerService唤醒。我们从上次MediaPlayerService休眠的地方开始，看看它被唤醒之后干了些什么。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder驱动中binder-thread-read-的源码"><a href="#1-Binder驱动中binder-thread-read-的源码" class="headerlink" title="1. Binder驱动中binder_thread_read()的源码"></a>1. Binder驱动中binder_thread_read()的源码</h1><pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是NULL
        if (t-&gt;buffer-&gt;target_node) {
            ...
        } else {
            tr.target.ptr = NULL;
            tr.cookie = NULL;
            cmd = BR_REPLY;
        }
        // 交易码
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            tr.sender_pid = 0;
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        // 设置回复信息
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            ...
        } else {
            t-&gt;buffer-&gt;transaction = NULL;
            kfree(t);
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：MediaPlayerService进程被Service Manager唤醒，同时它的待处理事务队列中有ServiceManager添加的事务；此时，binder_has_thread_work()为true。因此，MediaPlayerService会继续往下执行。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让MediaPlayerService读取后进行处理。此时的指令是BR_REPLY。</p>
<p>binder_thread_read()执行完毕之后，共反馈了两个指令到用户空间：BR_NOOP和BR_REPLY</p>
<p>现在回到MediaPlayerService位于用户空间的进程。它会逐个解析Binder驱动反馈的指令。<br>对于BR_NOOP，MediaPlayerService不会做任何实质性的动作。<br>对于BR_REPLY，看看MediaPlayerService的处理流程。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-IPCThreadState-waitForResponse"><a href="#2-IPCThreadState-waitForResponse" class="headerlink" title="2. IPCThreadState::waitForResponse"></a>2. IPCThreadState::waitForResponse</h1><pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) {
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        ...

        cmd = mIn.readInt32();

        switch (cmd) {
            ...
        case BR_REPLY:
            {
                binder_transaction_data tr;
                err = mIn.read(&amp;tr, sizeof(tr));
                ...

                if (reply) {
                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                        reply-&gt;ipcSetDataReference(
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t),
                            freeBuffer, this);
                    } else {
                        ...
                    }
                } else {
                    ...
                }
            }
            goto finish;
            ...
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：在BR_REPLY分支中，先读取出数据，并保存到tr中。由于reply不为null，并且tr.flags &amp; TF_STATUS_CODE为0；因此，会执行reply-&gt;ipcSetDataReference()。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-Parcel-ipcSetDataReference"><a href="#3-Parcel-ipcSetDataReference" class="headerlink" title="3. Parcel::ipcSetDataReference"></a>3. Parcel::ipcSetDataReference</h1><pre><code>void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,
    const size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)     
{
    freeDataNoInit();                   
    mError = NO_ERROR;
    mData = const_cast&lt;uint8_t*&gt;(data); 
    mDataSize = mDataCapacity = dataSize;
    mDataPos = 0;
    mObjects = const_cast&lt;size_t*&gt;(objects);
    mObjectsSize = mObjectsCapacity = objectsCount;
    mNextObjectHint = 0;
    mOwner = relFunc;
    mOwnerCookie = relCookie;           
    scanForFds();
}</code></pre><p>说明：ipcSetDataReference()是根据参数的值重新初始化Parcel的数据和对象。<br>(01) freeDataNoInit()的目的是释放原有的内存。为接下来保存Binder驱动反馈的数据做准备。<br>(02) 在<a href="/2014/09/05/BinderCommunication-AddService02/">Android Binder机制(六) addService详解02之 请求的处理</a>中，ServiceManager反馈数据时，我们知道它对应的BR_REPLY的数据实际上是空的！因此，这里的mDataSize和mObjectsSize都是0。</p>
<p>实际上，Binder驱动反馈给MediaPlayerService的指令就是告诉它addService已经成功处理完毕！</p>
<p>在MediaPlayerService解析完Binder驱动反馈的数据之后，它会层层向上返回。这样，MediaPlayerService::instantiate()也就正式执行完了！<br>MediaPlayerService::instantiate()执行完毕，但是MediaPlayerService进程似乎还没有进入消息循环中等到Client的请求！那么，它是何时进入消息循环的呢？回到MediaPlayerService进程的main()函数入口中，它后面是通过startThreadPool()进入消息循环的。这部分的内容，我们下一章再来介绍。</p>
<pre><code>int main(int argc, char** argv)
{
    ...

    if (doLog &amp;&amp; (childPid = fork()) != 0) {
        ...
    } else {
        ...
        MediaPlayerService::instantiate();
        ...
        ProcessState::self()-&gt;startThreadPool();
        IPCThreadState::self()-&gt;joinThreadPool();
    }
}</code></pre>
    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous is-invisible is-hidden-mobile">
        <a href="/categories/android/page/0/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/categories/android/page/2/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link is-current" href="/categories/android/">1</a></li>
        
        <li><a class="pagination-link" href="/categories/android/page/2/">2</a></li>
        
        <li><a class="pagination-link" href="/categories/android/page/3/">3</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 炸鸡叔&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>