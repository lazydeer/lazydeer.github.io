<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Category: android - PillBlog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta property="og:type" content="website">
<meta property="og:title" content="PillBlog">
<meta property="og:url" content="https://apppills.com/categories/android/page/2/index.html">
<meta property="og:site_name" content="PillBlog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PillBlog">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">归档</a>
            
            <a class="navbar-item " href="/about">关于</a>
            
            <a class="navbar-item " href="https://everything.apppills.com">Everything</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5><i class="far fa-folder"></i>android</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/05/android/os/binder/2014-09-05-BinderCommunication-AddService02/" itemprop="url">Android Binder机制(六) addService详解02之 请求的处理</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-05T01:02:00.000Z" itemprop="datePublished">9月 5 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            42 分钟 read (About 6341 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p><a href="/2014/09/05/BinderCommunication-AddService01/">前面一文</a>介绍了addService的请求发送部分，Binder驱动在处理addService请求时，将一个待处理事务添加到ServiceManager中，然后将ServiceManager唤醒。在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>的末尾，我们说过ServiceManager启动之后，由于没有事务可处理，就进入了等待状态。这里，从ServiceManager被唤醒后开始讲解。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Android消息机制的架构</a>  </p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder驱动中binder-thread-read-的源码"><a href="#1-Binder驱动中binder-thread-read-的源码" class="headerlink" title="1. Binder驱动中binder_thread_read()的源码"></a>1. Binder驱动中binder_thread_read()的源码</h1><p>下面，就接着<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中的休眠部分进行讲解，看看Service Manager被唤醒后，会干些什么。</p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是目标节点。
        // 这里，addService请求的目标是ServiceManager，因此target_node是ServiceManager对应的节点；
        // 它的值在事务交互时(binder_transaction中)，被赋值为ServiceManager对应的Binder实体。  
        if (t-&gt;buffer-&gt;target_node) {
            // 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体)
            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;
            // Binder实体在用户空间的地址(ServiceManager的ptr为NULL)
            tr.target.ptr = target_node-&gt;ptr;
            // Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL)
            tr.cookie =  target_node-&gt;cookie;
            t-&gt;saved_priority = task_nice(current);
            if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;
                !(t-&gt;flags &amp; TF_ONE_WAY))
                binder_set_nice(t-&gt;priority);
            else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||
                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)
                binder_set_nice(target_node-&gt;min_priority);
            cmd = BR_TRANSACTION;
        } else {
            tr.target.ptr = NULL;
            tr.cookie = NULL;
            cmd = BR_REPLY;
        }
        // 交易码
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            tr.sender_pid = 0;
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        // 设置回复信息
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            // 该事务会发送给Service Manager守护进程进行处理。
            // Service Manager处理之后，还需要给Binder驱动回复处理结果。
            // 这里设置Binder驱动回复信息。
            t-&gt;to_parent = thread-&gt;transaction_stack;
            // to_thread表示Service Manager反馈后，将反馈结果交给当前thread进行处理
            t-&gt;to_thread = thread;
            // transaction_stack交易栈保存当前事务。用于之处反馈是针对哪个事务的。
            thread-&gt;transaction_stack = t;
        } else {
            ...
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：ServiceManager进程在调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))进入等待之后，被MediaPlayerService进程唤醒。唤醒之后，binder_has_thread_work()为true，因为ServiceManager的待处理事务队列中有个待处理事务(即，MediaPlayerService添加服务的请求)。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。<br>下面列举比较重要的几个部分进行说明。</p>
<pre><code>// 数据大小
tr.data_size = t-&gt;buffer-&gt;data_size;
// 数据中对象的偏移数组的大小(即对象的个数)
tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
// 数据
tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
            proc-&gt;user_buffer_offset;
// 数据中对象的偏移数组
tr.data.ptr.offsets = tr.data.ptr.buffer +
            ALIGN(t-&gt;buffer-&gt;data_size,
                    sizeof(void *));</code></pre><p>这里着重强调一下地址的赋值方式，因为它涉及到Binder机制的数据拷贝原理！<br>t-&gt;buffer是在binder_transaction()中，通过binder_alloc_buf()分配的内核空间地址。现在要将数据返回给Service Manager守护进程，需要将内核空间的数据拷贝到用户空间。如果你还记得的话，前面在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>的mmap()中，我们将内核虚拟地址和进程虚拟地址映射到同一个物理存储区；现在，已知内核虚拟地址(即t-&gt;buffer-&gt;data)。那么，只需要将t-&gt;buffer-&gt;data加上proc-&gt;user_buffer_offset(内核虚拟地址和进程虚拟地址的偏移)即可得到在用户空间的地址。  </p>
<p>在tr赋值完毕之后，就将完整数据拷贝到用户空间。此时，该事务已经在Binder驱动中被处理，于是将事务从Service Manager的待处理事务队列中删除。Binder驱动随后会将该事务发送给Service Manager守护进程，Service Manager守护进程在处理完事务之后，需要反馈结果给Binder驱动。因此，接下来会设置t-&gt;to_thread和t-&gt;transaction_stack等成员。最后，修改*consumed的值，即bwr.read_consumed的值，表示待读取内容的大小。<br>执行完binder_thread_read()之后，回到binder_ioctl()中，执行copy_to_user()将数据拷贝到用户空间。接下来，就回到了Service Manager的守护进程当中，即回到binder_loop()中。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-binder-loop"><a href="#2-binder-loop" class="headerlink" title="2. binder_loop()"></a>2. binder_loop()</h1><pre><code>void binder_loop(struct binder_state *bs, binder_handler func)
{
    struct binder_write_read bwr;
    unsigned readbuf[32];
    ...

    for (;;) {
        bwr.read_size = sizeof(readbuf);
        bwr.read_consumed = 0;
        bwr.read_buffer = (unsigned) readbuf;

        bwr.read_buffer = (unsigned) readbuf;

        // 向Kernel中发送消息(先写后读)。
        // 先将消息传递给Kernel，然后再从Kernel读取消息反馈
        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);

        ...

        // 解析读取的消息反馈
        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);
        ...
    }
}</code></pre><p>说明：binder_loop()会将ioctl()反馈的数据发送给binder_parse()进行解析。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-binder-parse"><a href="#3-binder-parse" class="headerlink" title="3. binder_parse()"></a>3. binder_parse()</h1><pre><code>int binder_parse(struct binder_state *bs, struct binder_io *bio,
                 uint32_t *ptr, uint32_t size, binder_handler func)
{
    int r = 1;
    uint32_t *end = ptr + (size / 4);

    while (ptr &lt; end) {
        uint32_t cmd = *ptr++;

        switch(cmd) {
        case BR_NOOP:
            break;
        ...
        case BR_TRANSACTION: {
            struct binder_txn *txn = (void *) ptr;
            ...
            if (func) {
                unsigned rdata[256/4];
                struct binder_io msg;   // 用于保存&quot;Binder驱动反馈的信息&quot;
                struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot;
                int res;

                // 初始化reply
                bio_init(&amp;reply, rdata, sizeof(rdata), 4);
                // 根据txt(Binder驱动反馈的信息)初始化msg
                bio_init_from_txn(&amp;msg, txn);
                // 消息处理
                res = func(bs, txn, &amp;msg, &amp;reply);
                // 反馈消息给Binder驱动。
                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);
            }
            ptr += sizeof(*txn) / sizeof(uint32_t);
            break;
        }
        ...
        }
    }

    return r;
}</code></pre><p>说明：此处里的cmd就是bwr.read_buffer指针。而在Binder驱动的binder_thread_read()中，反馈的第一个指令是BR_NOOP；因此这里的cmd=BR_NOOP，不执行任何动作，继续取出下一个指令cmd=BR_TRANSACTION。在BR_TRANSACTION中，会先取出消息，在对消息处理之后，再将反馈信息发送给Binder驱动。下面是BR_TRANSACTION的详细内容。<br>(01) 首先，将ptr转换成struct binder_txn结构体指针。struct binder_txn是与binder_transaction_datad对应的结构体，在<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>中有它的详细介绍。<br>(02) 此处的func是函数指针svcmgr_handler，不为空；因此，先调用bio_init()初始化reply，再调用bio_init_from_txn()来初始化msg。<br>(03) 初始化完毕之后，就调用svcmgr_handler()对消息进行处理。<br>(04) 消息处理完毕，就通过binder_send_reply()将处理结果反馈给Binder驱动。  </p>
<p><a name="anchor4"></a></p>
<h1 id="4-bio-init"><a href="#4-bio-init" class="headerlink" title="4. bio_init()"></a>4. bio_init()</h1><pre><code>void bio_init(struct binder_io *bio, void *data,
              uint32_t maxdata, uint32_t maxoffs)
{               
    uint32_t n = maxoffs * sizeof(uint32_t);

    if (n &gt; maxdata) {
        bio-&gt;flags = BIO_F_OVERFLOW;
        bio-&gt;data_avail = 0;
        bio-&gt;offs_avail = 0;            
        return;
    }       

    bio-&gt;data = bio-&gt;data0 = (char *) data + n;
    bio-&gt;offs = bio-&gt;offs0 = data;
    bio-&gt;data_avail = maxdata - n;
    bio-&gt;offs_avail = maxoffs;
    bio-&gt;flags = 0;
}</code></pre><p>说明：bio_init()就是对struct binder_io的各个成员赋值。</p>
<p><a name="anchor5"></a></p>
<h1 id="5-bio-init-from-txn"><a href="#5-bio-init-from-txn" class="headerlink" title="5. bio_init_from_txn()"></a>5. bio_init_from_txn()</h1><pre><code>void bio_init_from_txn(struct binder_io *bio, struct binder_txn *txn)
{           
    bio-&gt;data = bio-&gt;data0 = txn-&gt;data;    // 数据起始地址
    bio-&gt;offs = bio-&gt;offs0 = txn-&gt;offs;    // 数据中对象的偏移数组的起始地址
    bio-&gt;data_avail = txn-&gt;data_size;      // 数据大小
    bio-&gt;offs_avail = txn-&gt;offs_size / 4;  // 对象个数
    bio-&gt;flags = BIO_F_SHARED;
}</code></pre><p>说明：bio_init_from_txn()就是根据已有的数据txn初始化struct binder_io的各个成员。 </p>
<p><a name="anchor6"></a></p>
<h1 id="6-svcmgr-handler"><a href="#6-svcmgr-handler" class="headerlink" title="6. svcmgr_handler()"></a>6. svcmgr_handler()</h1><pre><code>int svcmgr_handler(struct binder_state *bs,
                   struct binder_txn *txn,
                   struct binder_io *msg,
                   struct binder_io *reply)
{
    struct svcinfo *si;
    uint16_t *s;
    unsigned len;
    void *ptr;  
    uint32_t strict_policy;
    int allow_isolated;

    if (txn-&gt;target != svcmgr_handle)
        return -1;

    ...
    // 数据有效性检测(数据头)
    strict_policy = bio_get_uint32(msg);
    s = bio_get_string16(msg, &amp;len);
    if ((len != (sizeof(svcmgr_id) / 2)) ||
        memcmp(svcmgr_id, s, sizeof(svcmgr_id))) {
        ...
    }

    switch(txn-&gt;code) {
        case SVC_MGR_GET_SERVICE:
        case SVC_MGR_CHECK_SERVICE:
            ...

        case SVC_MGR_ADD_SERVICE:
            s = bio_get_string16(msg, &amp;len);
            ptr = bio_get_ref(msg);
            allow_isolated = bio_get_uint32(msg) ? 1 : 0;
            if (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated))
                return -1;
            break;
        case SVC_MGR_LIST_SERVICES:
            ...
    }

    bio_put_uint32(reply, 0);
    return 0;
}</code></pre><p>说明：<br>(01) txt-&gt;target对应tr.target.ptr，而tr.target.ptr是Binder驱动的在binder_thread_read()中赋值的，它指向Service Manager的Binder实体在用户空间的句柄，是NULL。而svcmgr_handle=BINDER_SERVICE_MANAGER=((void*) 0)。显然，txt-&gt;target=svcmgr_handler。<br>(02) 接下来，先通过bio_get_uint32(msg)和bio_get_string16(msg, &amp;len)进行有效性检测。通过bio_get_uint32()从msg中取出32位的整型数，就是MediaPlayerService请求数据中的STRICT_MODE_PENALTY_GATHER。然后，通过bio_get_string16(msg, &amp;len)获取数据中字符串，也就是”android.os.IServiceManager”。接着，将该字符串和svcmgr_id进行比较(依次比较长度和内容)；很显然，这里是相当的。<br>(03) 在通过有效性检测之后，就根据相应的事务编码进行处理。这里txt-&gt;code的值是SVC_MGR_ADD_SERVICE。先通过bio_get_string16()获取MediaPlayerService的名称，也就是s=”media.player”，然后就通过bio_get_ref()获取MediaPlayerService对象的引用。  </p>
<p><a name="anchor7"></a></p>
<h1 id="7-svcmgr-handler"><a href="#7-svcmgr-handler" class="headerlink" title="7. svcmgr_handler()"></a>7. svcmgr_handler()</h1><pre><code>void *bio_get_ref(struct binder_io *bio)
{   
    struct binder_object *obj;

    obj = _bio_get_obj(bio);
    if (!obj)
        return 0;

    if (obj-&gt;type == BINDER_TYPE_HANDLE)
        return obj-&gt;pointer;

    return 0;
}       </code></pre><p>说明：binder_object是与flat_binder_object对应的结构体，关于它的详细介绍可以参考<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。<br>(01) _bio_get_obj(bio)的代码就不展开了，它是根据bio创建binder_object对象。实际上，obj就是MediaPlayerService打包成的flat_binder_object对象。<br>(02) obj-&gt;type的值是BINDER_TYPE_HANDLE。原来MediaPlayerService对应的type是BINDER_TYPE_BINDER，但在Binder驱动的binder_transaction()中，将type修改成了BINDER_TYPE_HANDLE。因此，返回obj-&gt;pointer，而obj-&gt;pointer实际上是flat_binder_object中的handle，而该handle在Binder驱动中被赋值为”MediaPlayerService对应的Binder引用的描述，即binder_ref-&gt;desc”。根据该引用描述，可以在Binder驱动中找到MediaPlayerService对应的Binder实体以及MediaPlayerService对应的进程上下文信息，进而可以给MediaPlayerService发送消息。  </p>
<p><a name="anchor8"></a></p>
<h1 id="8-svcmgr-handler"><a href="#8-svcmgr-handler" class="headerlink" title="8. svcmgr_handler()"></a>8. svcmgr_handler()</h1><p>接下来，回到svcmgr_handler()中，继续执行do_add_service()。</p>
<pre><code>int do_add_service(struct binder_state *bs,
                   uint16_t *s, unsigned len,
                   void *ptr, unsigned uid, int allow_isolated)
{
    struct svcinfo *si;
    ...

    if (!svc_can_register(uid, s)) {
        ...
    }

    si = find_svc(s, len);
    if (si) {
        ...
    } else {
        si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t));
        if (!si) { 
            ...
        }
        si-&gt;ptr = ptr;
        si-&gt;len = len;
        memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t));
        si-&gt;name[len] = &apos;\0&apos;;
        si-&gt;death.func = svcinfo_death;
        si-&gt;death.ptr = si;
        si-&gt;allow_isolated = allow_isolated;
        si-&gt;next = svclist;
        svclist = si;
    }

    binder_acquire(bs, ptr);
    binder_link_to_death(bs, ptr, &amp;si-&gt;death);
    return 0;
}</code></pre><p>说明：do_add_service()是将该MediaPlayerService<br>(01) 先看看参数。bs是struct binder_state类型，它在保存了打开”/dev/binder”文件的相关信息。s是IBinder对象的名称，即”media.player”。len是s的长度。ptr是MediaPlayerService在Binder驱动中的引用描述。uid是MediaPlayerService的uid。allow_isolated是flase。<br>(02) svc_can_register()是检测能否将uid线程的信息注册到Service Manager中。这里，返回true。<br>(03) find_svc(s, len)是在Service Manager的服务队列svclist中，查找是否有名称为s的服务。由于之前没有将MediaPlayerService注册到Service Manager中，这里返回的si=null；接下来，就将MediaPlayerService的信息保存到si中，然后再将si注册到svclist中。<br>这样，MediaPlayerService就注册到Service Manager中了。</p>
<p><a name="anchor9"></a></p>
<h1 id="9-svcmgr-handler"><a href="#9-svcmgr-handler" class="headerlink" title="9. svcmgr_handler()"></a>9. svcmgr_handler()</h1><p>接下来，回到svcmgr_handler()中，调用bio_put_uint32(reply, 0)。这里就不对bio_put_uint32()的代码进行展开了，bio_put_uint32(reply, val)的作用是将val写入到reply中。但是，当val=0时，不会写入任何数据；也就是说bio_put_uint32(reply, 0)不会写入任何数据到reply中！</p>
<pre><code>int svcmgr_handler(struct binder_state *bs,
                   struct binder_txn *txn,
                   struct binder_io *msg,
                   struct binder_io *reply)
{
    ...

    switch(txn-&gt;code) {

        case SVC_MGR_ADD_SERVICE:
            s = bio_get_string16(msg, &amp;len);
            ptr = bio_get_ref(msg);
            allow_isolated = bio_get_uint32(msg) ? 1 : 0;
            if (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated))
                return -1;
            break;
            ...
    }

    bio_put_uint32(reply, 0);
    return 0;
}</code></pre><p>接着，回到binder_parse()中，调用binder_send_reply()写入到即将发送Binder的缓冲区中。</p>
<p><a name="anchor10"></a></p>
<h1 id="10-svcmgr-handler"><a href="#10-svcmgr-handler" class="headerlink" title="10. svcmgr_handler()"></a>10. svcmgr_handler()</h1><pre><code>void binder_send_reply(struct binder_state *bs,
                       struct binder_io *reply,
                       void *buffer_to_free,
                       int status)
{   
    struct {
        uint32_t cmd_free;
        void *buffer;
        uint32_t cmd_reply;
        struct binder_txn txn;
    } __attribute__((packed)) data;

    data.cmd_free = BC_FREE_BUFFER;
    data.buffer = buffer_to_free;
    data.cmd_reply = BC_REPLY;
    data.txn.target = 0;
    data.txn.cookie = 0;
    data.txn.code = 0;
    if (status) {
        ...
    } else {
        data.txn.flags = 0;
        data.txn.data_size = reply-&gt;data - reply-&gt;data0;
        data.txn.offs_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0);
        data.txn.data = reply-&gt;data0;
        data.txn.offs = reply-&gt;offs0;
    }
    binder_write(bs, &amp;data, sizeof(data));
}   </code></pre><p>说明：<br>(01) 先看看参数。bs是struct binder_state，它保存了打开”/dev/binder”文件的相关信息。reply没有任何数据。buffer_to_free是对应binder_transaction_data中保存请求数据的buffer缓冲区，它是在Binder驱动的binder_transaction()中分配的。status_t=0。<br>(02) 该函数中的私有结构体struct是用来描述返回给Binder驱动的数据。我们知道，Binder机制的交互数据的格式是”指令+数据”。这里，返回的指令有两个BC_FREE_BUFFER和BC_REPLY，BC_FREE_BUFFER是告诉Binder驱动，请求处理完毕，让Binder驱动释放数据缓冲；而BC_REPLY是告诉Binder驱动，这是回复，回复的内容是data.txt.data，实际上，这里的回复内容是空！<br>(03) 最后，调用binder_write()将数据打包。</p>
<p><a name="anchor11"></a></p>
<h1 id="11-binder-write-的源码"><a href="#11-binder-write-的源码" class="headerlink" title="11. binder_write()的源码"></a>11. binder_write()的源码</h1><pre><code>int binder_write(struct binder_state *bs, void *data, unsigned len)
{
    struct binder_write_read bwr;
    int res;
    bwr.write_size = len;                // 数据长度
    bwr.write_consumed = 0;             
    bwr.write_buffer = (unsigned) data;  // 数据是BINDER_WRITE_READ
    bwr.read_size = 0;
    bwr.read_consumed = 0;
    bwr.read_buffer = 0;
    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
    if (res &lt; 0) {
        fprintf(stderr,&quot;binder_write: ioctl failed (%s)\n&quot;,
                strerror(errno));
    }
    return res;
}</code></pre><p>说明：binder_write()单单只是向Binder驱动发送一个消息，而不会去读取消息反馈。</p>
<p><a name="anchor12"></a></p>
<h2 id="12-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#12-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="12. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>12. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h2><p>下面我们看看Binder驱动部分的对应代码。</p>
<pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：bwr.write_size&gt;0，而bwr.read_size=0；因此，只会执行写动作，而不会进行读取动作。下面看看binder_thread_write()到底写了些什么。</p>
<p><a name="anchor13"></a></p>
<h2 id="13-Binder驱动中binder-thread-write-的源码"><a href="#13-Binder驱动中binder-thread-write-的源码" class="headerlink" title="13. Binder驱动中binder_thread_write()的源码"></a>13. Binder驱动中binder_thread_write()的源码</h2><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
            void __user *buffer, int size, signed long *consumed)
{
    uint32_t cmd; 
    void __user *ptr = buffer + *consumed;
    void __user *end = buffer + size;

    // 读取binder_write_read.write_buffer中的内容。
    // 每次读取32bit(即4个字节)
    while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
        if (get_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        ptr += sizeof(uint32_t);

        ...
        switch (cmd) {

        case BC_FREE_BUFFER: {
            void __user *data_ptr;
            struct binder_buffer *buffer;

            // 获取要释放的内存地址
            if (get_user(data_ptr, (void * __user *)ptr))
                return -EFAULT;
            ptr += sizeof(void *);

            // 根据用户空间地址，得到进程空间地址；
            // 再根据进程空间地址，在proc-&gt;allocated_buffers红黑树中进行查找该地址对应的binder_buffer对象。
            buffer = binder_buffer_lookup(proc, data_ptr);
            ...
            // 释放内存
            trace_binder_transaction_buffer_release(buffer);
            binder_transaction_buffer_release(proc, buffer, NULL);
            binder_free_buf(proc, buffer);
            break;
        }
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
        ...
        }
        // 更新bwr.write_consumed的值
        *consumed = ptr - buffer;
    }
    return 0;
}</code></pre><p>说明：在Service Manager中，反馈给Binder驱动的指令有两个，分别是BC_FREE_BUFFER和BC_REPLY。<br>(01) binder_write_read()先读出BC_FREE_BUFFER指令，然后释放内存。代码中给出了相应的注释，这里就不再详细说明了。<br>(02) 接着，读出BC_REPLY指令，将数据拷贝到内核空间之后，便执行binder_transaction()对数据进行处理。</p>
<p><a name="anchor14"></a></p>
<h2 id="14-Binder驱动中binder-transaction-的源码"><a href="#14-Binder驱动中binder-transaction-的源码" class="headerlink" title="14. Binder驱动中binder_transaction()的源码"></a>14. Binder驱动中binder_transaction()的源码</h2><pre><code>static void binder_transaction(struct binder_proc *proc,
                   struct binder_thread *thread,
                   struct binder_transaction_data *tr, int reply)
{
    struct binder_transaction *t;
    struct binder_work *tcomplete;
    size_t *offp, *off_end;
    struct binder_proc *target_proc;
    struct binder_thread *target_thread = NULL;
    struct binder_node *target_node = NULL;
    struct list_head *target_list;
    wait_queue_head_t *target_wait;
    struct binder_transaction *in_reply_to = NULL;
    struct binder_transaction_log_entry *e;
    uint32_t return_error;

    ...

    if (reply) {
        // 事务栈
        in_reply_to = thread-&gt;transaction_stack;
        ...
        // 设置优先级
        binder_set_nice(in_reply_to-&gt;saved_priority);
        ...
        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;
        // 发起请求的线程，即MediaPlayerService所在线程。
        // from的值，是MediaPlayerService发起请求时在binder_transaction()中赋值的。
        target_thread = in_reply_to-&gt;from;
        ...
        // MediaPlayerService对应的进程
        target_proc = target_thread-&gt;proc;
    } else {
        ...
    }
    if (target_thread) {
        e-&gt;to_thread = target_thread-&gt;pid;
        target_list = &amp;target_thread-&gt;todo;
        target_wait = &amp;target_thread-&gt;wait;
    } else {
        ...
    }
    e-&gt;to_proc = target_proc-&gt;pid;

    // 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
    t = kzalloc(sizeof(*t), GFP_KERNEL);
    if (t == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_alloc_t_failed;
    }

    // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
    if (tcomplete == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_alloc_tcomplete_failed;
    }
    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);

    t-&gt;debug_id = ++binder_last_id;
    e-&gt;debug_id = t-&gt;debug_id;

    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
        t-&gt;from = thread;
    else
        t-&gt;from = NULL;
    // 下面的一些赋值是初始化事务t
    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
    // 事务将交给target_proc进程进行处理
    t-&gt;to_proc = target_proc;
    // 事务将交给target_thread线程进行处理
    t-&gt;to_thread = target_thread;
    // 事务编码
    t-&gt;code = tr-&gt;code;
    // 事务标志
    t-&gt;flags = tr-&gt;flags;
    // 事务优先级
    t-&gt;priority = task_nice(current);

    // 分配空间
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    if (t-&gt;buffer == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_binder_alloc_buf_failed;
    }
    t-&gt;buffer-&gt;allow_user_free = 0;
    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
    // 保存事务
    t-&gt;buffer-&gt;transaction = t;
    // target_node为NULL
    t-&gt;buffer-&gt;target_node = target_node;
    trace_binder_transaction_alloc_buf(t-&gt;buffer);
    if (target_node)
        binder_inc_node(target_node, 1, 0, NULL);

    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));

    // 将&quot;用户传入的数据&quot;保存到事务中
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户传入的数据偏移地址&quot;保存到事务中
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }

    ...
    off_end = (void *)offp + tr-&gt;offsets_size;
    for (; offp &lt; off_end; offp++) {
        ...
    }
    if (reply) {
        binder_pop_transaction(target_thread, in_reply_to);
    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {
        ...
    } else {
        ...
    }
    // 设置事务的类型为BINDER_WORK_TRANSACTION
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    // 将事务添加到target_list队列中，即target_list的待处理事务中
    list_add_tail(&amp;t-&gt;work.entry, target_list);
    // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
    // 唤醒目标进程
    if (target_wait)
        wake_up_interruptible(target_wait);
    return;
    ...
}</code></pre><p>说明：<br>(01) reply=1。这里只关注reply部分。target_thread被赋值为MediaPlayerService所在的线程，而target_proc则是MediaPlayerService对应的进程。<br>(02) 接着，会新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。这部分前面已经介绍过了；这里就不再重复说明了。从Service Manager反馈的信息中，仅仅包含了数据0，而没有flat_binder_object对象；因此，off_end=offp，不会执行for循环。<br>(03) 此时，MediaPlayerService已经成功的添加到了Server Manager守护进程中，接下来便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayerService线程的事务栈中删除该事务。<br>(04) 之后，便是设置事务的类型为BINDER_WORK_TRANSACTION，然后将其添加到target_list队列中。即，将事务添加到MediaPlayerService的待处理事务队列中。<br>(05) 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE，然后将其添加到thread-&gt;todo中。即，将其添加到当前线程(Service Manager守护进程的线程)的待处理事务队列中。<br>(06) 最后，调用wake_up_interruptible()唤醒MediaPlayerService进程。 </p>
<p>此时，Binder驱动就将addService的反馈内容以待处理事务t的方式添加到MediaPlayerService的待处理事务队列当中，并将MediaPlayerService进程唤醒了。而对于待完成工作tcomplete，肯定是告诉ServiceManager进程，它的反馈已经被Binder驱动收到。</p>
<p>下面，还是先说完ServiceManager的流程，然后再来看MediaPlayerService被唤醒后做了什么。</p>
<p>ServiceManager执行完binder_transaction()后，回到binder_thread_write()中；此时，数据已经处理完毕，便返回到binder_ioctl()中。binder_ioctl()将数据拷贝到用户空间后，Binder驱动的工作就结束了。<br>于是，又回到ServiceManager守护进程中，binder_write()执行完ioctl()后，返回到binder_send_reply()中，binder_send_reply()则进一步返回到binder_parse()。binder_parse()已经解析完请求数据，于是进一步返回到binder_loop()中。而binder_loop()会再次开始循环，调用ioctl(,BINDER_WRITE_READ,)到Binder驱动执行读操作。<br>当ServiceManager再次进入到Binder驱动，并通过binder_ioctl()调用到binder_thread_read()时。由于此时的ServiceManager线程中有一个类型为BINDER_WORK_TRANSACTION_COMPLETE的待处理事务；于是，便取出该事务进行执行。执行完毕之后，将该事务从Service Manager的待处理事务队列中删除，并反馈cmd=BR_TRANSACTION_COMPLETE信息给ServiceManager守护进程。ServiceManager守护进程收到Binder驱动的反馈后，解析出BR_TRANSACTION_COMPLETE，该指令什么也不做；它的目的是让ServiceManager知道，此次addService的反馈已经顺利完成！<br>于是，ServiceManager继续它的循环；当它再次调用ioctl()，进而进入到Binder驱动中读取请求时；由于此时的待处理事务队列为空，因此，ServiceManager会再次进入中断等待状态，等待Client的请求。</p>
<br>
至此，MediaPlayerService进程的addService的请求处理部分就讲解完了。在继续了解请求的反馈之前，先回顾一下本部分的内容。

<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService02_deal.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService02_deal.jpg" alt></a></p>
<p>MediaPlayerService将addService请求发送到Binder驱动，Binder驱动将addService转换成一个待处理事务并添加到ServiceManager的事务队列中，并将ServiceManager唤醒。ServiceManager被唤醒后，取出该处理；接着，Binder驱动将BR_TRANSACTION发送到ServiceManager守护进程中。ServiceManager通过BR_TRANSACTION解析出addService请求；在从请求数据中解析出MediaPlayerService的相关信息后，并将这些信息存储在一个链表中。接着，ServiceManager守护进程反馈BC_FREE_BUFFER和BC_REPLY给Binder驱动。Binder驱动收到BC_FREE_BUFFER后，释放保存事务数据的内存；在收到BC_REPLY之后，得知ServiceManager已经处理完addService请求。于是，将一个待处理事务添加到MediaPlayerService的事务队列中；然后将MediaPlayerService唤醒。目的是告诉MediaPlayerService，它已经处理完了addService请求。  最后，Binder驱动还需要反馈一个BR_TRANSACTION_COMPLETE给ServiceManager进程，目的是告诉ServiceManager，Binder驱动已经收到了它的回复。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/05/android/os/binder/2014-09-05-BinderCommunication-AddService01/" itemprop="url">Android Binder机制(五) addService详解01之 请求的发送</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-05T01:01:00.000Z" itemprop="datePublished">9月 5 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 read (About 13173 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>终于要开始讲解Client-Server交互了，若标题所示，本文要讲解的是addService请求，即添加服务请求。本文选取的题材是MediaPlayerService服务通过addService请求注册到ServiceManager中。<br>在这个addService请求中，MediaPlayerService是Client，而ServiceManager是Server。由于涉及到的过程比较复杂，这里会将addService请求分为3篇进行说明，这3篇的主题分别是：请求的发送，请求的处理，以及请求的反馈。和以往一样，在讲解详细的代码之前，先做个整体介绍。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-addService流程的时序图"><a href="#1-addService流程的时序图" class="headerlink" title="1. addService流程的时序图"></a>1. addService流程的时序图</h1><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService_01_flow.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService_01_flow.jpg" alt></a></p>
<p>上面是addService流程的时序图。理解这个图的前提是理解图中的三种角色之间的关系：<br>(01) MediaPlayerService和ServiceManager是两个不同的进程。它们都位于用户空间，都有各自的内存单元，两者之间不能直接进行通信；因此，需要Binder驱动的帮助才能通信。<br>(02) Binder驱动位于内核空间，它映射到节点”/dev/binder”上。MediaPlayerService和ServiceManager都有通过open(“/dev/binder”)打开该节点，并通过mmap()将内存映射到各自所在的进程中；这也就是说MediaPlayerService能和Binder驱动通信，而且ServiceManager也能和Binder驱动通信。而在Binder驱动中，有一个全局变量，依靠这个全局变量，就能实现MediaPlayerService和ServiceManager之间的通信。  依靠的这个全局变量，就是<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中介绍过的binder_context_mgr_node变量，它是ServiceManager的Binder实体。</p>
<p>搞清楚它们三者之间的关系之后，再回到上面的时序图中。  </p>
<ol>
<li><p>WAIT<br>这表示ServiceManager进入了中断等待状态。它进入等待状态的详细流程，在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>有介绍过。  </p>
</li>
<li><p>BC_TRANSACTION<br>这是MediaPlayerService向ServiceManager发送addService请求对应的事务。这个事务是请求，而不是回复；因此是BC开发，B代表Binder，而C代表Command。如果是回复，则会以BR开发，R表示Reply。Binder驱动在收到BC_TRANSACTION之后，会将分配内存，将请求数据保存到所分配的内存中。</p>
</li>
<li><p>WAKE_UP<br>MediaPlayerService通过BC_TRANSACTION提交一个请求，该请求是交给ServiceManager来处理的。因此，Binder驱动在收到该请求后，会将其发送到ServiceManager的待处理事务队列中，并将ServiceManager唤醒。</p>
</li>
<li><p>BR_TRANSACTION_COMPLETE<br>MediaPlayerService在发起了一个请求之后，它需要知道该请求是否发送成功。因此，Binder驱动在将该请求提交给ServiceManager之后，会反馈一个BR_TRANSACTION_COMPLETE给MediaPlayerService，表示MediaPlayerService发送的请求已经被Binder驱动收到了。</p>
</li>
<li><p>WAIT<br>MediaPlayerService在知道自己的请求已经发送成功之后，就进入等待状态，等待请求的反馈结果。</p>
</li>
<li><p>BR_NOOP和BR_TRANSACTION<br>ServiceManager被唤醒之后，收到Binder驱动的BR_NOOP和BR_TRANSACTION指令。BR_NOOP指令什么也不会做；而对于BR_TRANSACTION指令时，ServiceManager在解析出该事务是添加服务请求，会将MediaPlayerService的相关信息保存到一个链表中。</p>
</li>
<li><p>BC_FREE_BUFFER和BC_REPLY<br>ServiceManager在保存了MediaPlayerService的相关信息之后，便处理完毕了MediaPlayerService的请求。此时，它便反馈BC_FREE_BUFFER和BC_REPLY给Binder驱动。Binder驱动在收到BC_FREE_BUFFER之后，会释放保存请求数据所申请的内存；收到BC_REPLY之后，Binder驱动则知道ServiceManager已经处理完了MediaPlayerService的请求。<br>接着，Binder驱动便会唤醒MediaPlayerService，并发送BR_NOOP和BR_REPLY给MediaPlayerService，告诉MediaPlayerService请求已经处理完毕。同时，它还会发送一个BR_TRANSACTION_COMPLETE给ServiceManager，告诉ServiceManager该事务已经处理完毕。 MediaPlayerService在收到BR_REPLY反馈之后，知道addService请求已经成功处理；接着，它会再次进入等待状态，等待Client的请求。<br>最后，ServiceManager处理MediaPlayerService的请求之后，没有其他事务可处理，也再次进入了等待状态。</p>
</li>
</ol>
<p><a name="anchor2"></a></p>
<h1 id="2-IMediaPlayerService的类图"><a href="#2-IMediaPlayerService的类图" class="headerlink" title="2. IMediaPlayerService的类图"></a>2. IMediaPlayerService的类图</h1><p>本文是以MediaPlayerService为例，对addService进行解析。下面看看MediaPlayerService相关联的类图。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/IMediaPlayerService_leitu.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/IMediaPlayerService_leitu.jpg" alt></a></p>
<p>IMediaPlayerService的类图和”<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>“中IServiceManager的类图类似。这里就不再逐一对每个类进行介绍了。</p>
<p>需要知道的是，对于一个MediaPlayerService而言，它存在一个”远程BpBinder对象”和”本地BBinder对象”。<br>(01) 远程BpBinder对象的作用，是和Binder驱动进行交互。例如，当本文所讲到的addService请求，就是通过defaultServiceManager()调用到远程BpBinder对象的transact()方法，而该方法又会调用到IPCThreadState::transact()接口，通过IPCThreadState类来和Binder驱动交互。<br>(02) MediaPlayerService是”本地BBinder的子类”。当Client向MediaPlayerService发起请求时，会调用BBinder的onTransact()方法，而BnServiceManager又重写了该方法，从而调用onTransact()完成对请求的处理。</p>
<p><a name="anchor3"></a></p>
<h1 id="addService请求发送的代码解析"><a href="#addService请求发送的代码解析" class="headerlink" title="addService请求发送的代码解析"></a>addService请求发送的代码解析</h1><p>下面通过代码来查看addService请求的发送流程。</p>
<p><a name="anchor3_1"></a></p>
<h2 id="1-MediaPlayerService的main-函数"><a href="#1-MediaPlayerService的main-函数" class="headerlink" title="1. MediaPlayerService的main()函数"></a>1. MediaPlayerService的main()函数</h2><p>先看看MediaPlayerService的main()函数代码。</p>
<pre><code>int main(int argc, char** argv)
{
    signal(SIGPIPE, SIG_IGN);
    char value[PROPERTY_VALUE_MAX];
    bool doLog = (property_get(&quot;ro.test_harness&quot;, value, &quot;0&quot;) &gt; 0) &amp;&amp; (atoi(value) == 1);
    pid_t childPid;

    if (doLog &amp;&amp; (childPid = fork()) != 0) {
        ...
    } else {
        // all other services
        ...
        sp&lt;ProcessState&gt; proc(ProcessState::self());
        sp&lt;IServiceManager&gt; sm = defaultServiceManager();
        ...
        MediaPlayerService::instantiate();
        ...
        ProcessState::self()-&gt;startThreadPool();
        IPCThreadState::self()-&gt;joinThreadPool();
    }
}</code></pre><p>说明：该代码在frameworks/av/media/mediaserver/main_mediaserver.cpp中。<br>(01) property_get(“ro.test_harness”, value, “0”)是获取”ro.test_harness”属性，为false。<br>(02) ProcessState:self()是获取ProcessState对象，并赋值给proc。ProcessState::self()在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中已经介绍过了。<br>(03) defaultServiceManager()是获取IServiceManager对象，它的实现在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中也有详细介绍。<br>(04) MediaPlayerService::instantiate()是初始化MediaPlayerService服务。  </p>
<p><a name="anchor3_2"></a></p>
<h2 id="2-MediaPlayerService-instantiate"><a href="#2-MediaPlayerService-instantiate" class="headerlink" title="2. MediaPlayerService::instantiate()"></a>2. MediaPlayerService::instantiate()</h2><pre><code>void MediaPlayerService::instantiate() {
    defaultServiceManager()-&gt;addService(
            String16(&quot;media.player&quot;), new MediaPlayerService());
}</code></pre><p>说明：该代码在frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp中。它会新建MediaPlayerService对象；然后调用defaultServiceManager()获取到的BpServiceManager的实例；最后，调用BpServiceManager的addService()方法，将MediaPlayerService对象添加到Service Manager中。MediaPlayerService服务的名称是”media.player”。</p>
<p><a name="anchor3_3"></a></p>
<h2 id="3-MediaPlayerService-MediaPlayerService"><a href="#3-MediaPlayerService-MediaPlayerService" class="headerlink" title="3. MediaPlayerService::MediaPlayerService()"></a>3. MediaPlayerService::MediaPlayerService()</h2><pre><code>MediaPlayerService::MediaPlayerService()
{
    ALOGV(&quot;MediaPlayerService created&quot;);
    mNextConnId = 1; 

    mBatteryAudio.refCount = 0; 
    for (int i = 0; i &lt; NUM_AUDIO_DEVICES; i++) {
        mBatteryAudio.deviceOn[i] = 0; 
        mBatteryAudio.lastTime[i] = 0; 
        mBatteryAudio.totalTime[i] = 0; 
    }    
    // speaker is on by default
    mBatteryAudio.deviceOn[SPEAKER] = 1; 
    mOOMKilling = false;
    MediaPlayerFactory::registerBuiltinFactories();
}</code></pre><p>说明：MediaPlayerService的构造函数比较简单，就是进行一些变量的初始化。</p>
<p><a name="anchor3_4"></a></p>
<h2 id="4-BpServiceManager-addService"><a href="#4-BpServiceManager-addService" class="headerlink" title="4. BpServiceManager::addService()"></a>4. BpServiceManager::addService()</h2><pre><code>class BpServiceManager : public BpInterface&lt;IServiceManager&gt;
{
public:
    ...

    virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service,          
            bool allowIsolated)         
    {     
        Parcel data, reply;             
        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
        data.writeString16(name);       
        data.writeStrongBinder(service);
        data.writeInt32(allowIsolated ? 1 : 0);
        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);          
        return err == NO_ERROR ? reply.readExceptionCode() : err;
    }     

    ...
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/IServiceManager.cpp中。addService()会现将MediaPlayerService服务的名称(“media.player”)以及它的实例等参数保存到data(Parcel对象)中，然后再调用remote()返回的BpBinder对象的transact()与Binder驱动进行交互。<br>(01) 先看看addService()的各个参数。name=”media.player”，即MediaPlayerService服务的名称；service就是MediaPlayerService对象，而IBinder是MediaPlayerService的父类；allowIsolated这个值默认为false，默认值的定义在frameworks/native/include/binder/IServiceManager.h的addService()函数声明中。<br>(02) Parcel是Binder通信的数据存储结构，它的各个成员和函数在<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>中有详细说明。<br>在向data中写入数据时，先通过writeInterfaceToken()写入数据头，这里的数据头是：int32的整形数+字符串(字符串是”android.os.IServiceManager”)。writeString16(name)写入的是服务的名称，即”media.player”。writeStrongBinder(service)是将MediaPlayerService封装到flat_binder_object结构体中。最后的writeInt32()暂时不用关心。<br>下面，我们逐个对data的赋值进行介绍。</p>
<p><a name="anchor3_5"></a></p>
<h2 id="5-Parcel-Parcel"><a href="#5-Parcel-Parcel" class="headerlink" title="5. Parcel::Parcel()"></a>5. Parcel::Parcel()</h2><p>先看看Parcel的构造函数。</p>
<pre><code>Parcel::Parcel()
{   
    initState(); 
}   </code></pre><p>说明：该代码在frameworks/native/libs/binder/Parcel.cpp中。  </p>
<p><a name="anchor3_6"></a></p>
<h2 id="6-Parcel-initState"><a href="#6-Parcel-initState" class="headerlink" title="6. Parcel::initState()"></a>6. Parcel::initState()</h2><pre><code>void Parcel::initState()
{
    mError = NO_ERROR;
    mData = 0;              // 数据的地址指针
    mDataSize = 0;          // 数据的大小
    mDataCapacity = 0;      // 数据的容量
    mDataPos = 0;           // 数据的位置
    mObjects = NULL;        // 保存对象的地址指针
    mObjectsSize = 0;       // 对象的个数
    mObjectsCapacity = 0;   // 对象的容量
    mNextObjectHint = 0;
    mHasFds = false;
    mFdsKnown = true;
    mAllowFds = true;
    mOwner = NULL;
}</code></pre><p>说明：该函数对Parcel的成员进行了初始化。</p>
<p><a name="anchor3_7"></a></p>
<h2 id="7-Parcel-writeInterfaceToken"><a href="#7-Parcel-writeInterfaceToken" class="headerlink" title="7. Parcel::writeInterfaceToken()"></a>7. Parcel::writeInterfaceToken()</h2><pre><code>下面看看data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor())的实现。getInterfaceDescriptor()是通过宏IMPLEMENT_META_INTERFACE()实现的，该宏已经在[Android Binder机制(四) defaultServiceManager()的实现][link_binder_04_defaultServiceManager]中介绍过了；getInterfaceDescriptor()的返回值是&quot;android.os.IServiceManager&quot;。  
即data.writeInterfaceToken(&quot;android.os.IServiceManager&quot;)。下面看看writeInterfaceToken()的实现。

status_t Parcel::writeInterfaceToken(const String16&amp; interface)
{       
    writeInt32(IPCThreadState::self()-&gt;getStrictModePolicy() |
               STRICT_MODE_PENALTY_GATHER);
    // currently the interface identification token is just its name as a string
    return writeString16(interface);
}   </code></pre><p>说明：该函数先通过writeInt32()写入一个32位的int数到Parcel中，然后再通过writeString16()将字符串写入到Parcel中。它所写入的是数据头，ServiceManager中收到该数据之后，会先获取数据头，并根据数据头来判断数据的有效性！<br>(01) IPCThreadState::self()返回IPCThreadState对象；然后，调用IPCThreadState::getStrictModePolicy()，返回的是mStrictModePolicy，mStrictModePolicy的初始值是0。因此，writeInt32()就可以简化为writeInt32(STRICT_MODE_PENALTY_GATHER)。<br>(02) writeString16(interface)是writeString16(“android.os.IServiceManager”)。</p>
<p><a name="anchor3_8"></a></p>
<h2 id="8-Parcel-writeInt32"><a href="#8-Parcel-writeInt32" class="headerlink" title="8. Parcel::writeInt32()"></a>8. Parcel::writeInt32()</h2><pre><code>status_t Parcel::writeInt32(int32_t val)
{   
    return writeAligned(val);
}   </code></pre><p>说明：该函数调用writeAligned()。</p>
<p><a name="anchor3_9"></a></p>
<h2 id="9-Parcel-writeAligned"><a href="#9-Parcel-writeAligned" class="headerlink" title="9. Parcel::writeAligned()"></a>9. Parcel::writeAligned()</h2><pre><code>template&lt;class T&gt;
status_t Parcel::writeAligned(T val) {
    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));

    if ((mDataPos+sizeof(val)) &lt;= mDataCapacity) {
restart_write:
        *reinterpret_cast&lt;T*&gt;(mData+mDataPos) = val;
        return finishWrite(sizeof(val));
    }

    status_t err = growData(sizeof(val));
    if (err == NO_ERROR) goto restart_write;
    return err;
}</code></pre><p>说明：writeAligned()的作用是是写入数据，比同步相应的变量。<br>(01) mDataPos的初始值=0，sizeof(val)=4，mDataCapacity的初始值=0。因此，if((mDataPos+sizeof(val)) &lt;= mDataCapacity)为false。<br>(02) 接下来，会先调用growData(sizeof(val))来增加容量，然后再将数据写入到mData中。  </p>
<p><a name="anchor3_10"></a></p>
<h2 id="10-Parcel-growData"><a href="#10-Parcel-growData" class="headerlink" title="10. Parcel::growData()"></a>10. Parcel::growData()</h2><pre><code>status_t Parcel::growData(size_t len)
{
    size_t newSize = ((mDataSize+len)*3)/2;
    return (newSize &lt;= mDataSize)
            ? (status_t) NO_MEMORY
            : continueWrite(newSize);
}</code></pre><p>说明：Parcel增加容量时，是按1.5倍进行增长。mDataSize=0，而len=4；因此会执行continueWrite(6)。  </p>
<p><a name="anchor3_11"></a></p>
<h2 id="11-Parcel-continueWrite"><a href="#11-Parcel-continueWrite" class="headerlink" title="11. Parcel::continueWrite()"></a>11. Parcel::continueWrite()</h2><pre><code>status_t Parcel::continueWrite(size_t desired)
{
    size_t objectsSize = mObjectsSize;

    ...

    if (mOwner) {
        ...
    } else if (mData) {
        ...

        // We own the data, so we can just do a realloc().
        if (desired &gt; mDataCapacity) {
            uint8_t* data = (uint8_t*)realloc(mData, desired);
            if (data) {
                mData = data;
                mDataCapacity = desired;
            } else if (desired &gt; mDataCapacity) {
                ...
            }
        } else {
            ...
        }

    } else {
        ...
    }

    return NO_ERROR;
}</code></pre><p>说明：mObjectsSize的初始值为0，mOwner的初始值为NULL，mData非空；并且，desired=6，mDataCapacity=0。因此，会调用realloc()给mData重新分配内存大小为6字节。分配成功后，更新”数据地址mData”和”数据容量mDataCapacity=6”。  </p>
<p>接下来，回到writeAligned()中，它会跳转到restart_write标签处。先将int32_t的整形数保存到mData中，然后再调用finishWrite()进行同步。</p>
<p><a name="anchor3_12"></a></p>
<h2 id="12-Parcel-finishWrite"><a href="#12-Parcel-finishWrite" class="headerlink" title="12. Parcel::finishWrite()"></a>12. Parcel::finishWrite()</h2><pre><code>status_t Parcel::finishWrite(size_t len)
{
    mDataPos += len;
    if (mDataPos &gt; mDataSize) {
        mDataSize = mDataPos;
        ...
    }
    return NO_ERROR;
}</code></pre><p>说明：前面已经将数据写入到mData中，现在就通过finishWrite()来改变数据的当前指针位置(方便下一次写入)和数据的大小。<br>(01) len是int32_t的大小，很显然是4个字节，len=4。所以，mDataPos=4。<br>(02) mDataPos=4，mDataSize=0；因此if(mDataPos&gt;mDataSize)为true，所以，mDataSize=4。  </p>
<p>此时，就分析完了writeInterfaceToken()中的writeInt32()就分析完毕了.<br><strong>mData</strong>：它的第0~3个字节保存了int32_t类型的数据STRICT_MODE_PENALTY_GATHER。<br><strong>mDataPos</strong>：值为4，即下一个写入mData中的数据从第4个字节开始。<br><strong>mDataSize</strong>：值为4，即mData中数据的大小。<br><strong>mDataCapacity</strong>：值为6，即mData的数据容量为6字节。<br>此时，mData的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add01.jpg" alt></a></p>
<p>接下来，看看再writeString16(“android.os.IServiceManager”)如何将字符串写入到Parcel中。</p>
<p><a name="anchor3_13"></a></p>
<h2 id="13-Parcel-writeString16"><a href="#13-Parcel-writeString16" class="headerlink" title="13. Parcel::writeString16()"></a>13. Parcel::writeString16()</h2><pre><code>status_t Parcel::writeString16(const String16&amp; str)
{
    return writeString16(str.string(), str.size());
}

status_t Parcel::writeString16(const char16_t* str, size_t len)
{
    if (str == NULL) return writeInt32(-1);

    // 将字符串长度写入到Parcel中
    status_t err = writeInt32(len);
    if (err == NO_ERROR) {
        len *= sizeof(char16_t);
        // 在将字符串写入之前，增加mData的容量
        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));
        if (data) {
            // 将字符串拷贝到mData中
            memcpy(data, str, len);
            // 字符串结束符
            *reinterpret_cast&lt;char16_t*&gt;(data+len) = 0;
            return NO_ERROR;
        }
        err = mError;
    }
    return err;
}</code></pre><p>说明：writeString16()是重载函数。<br>(01) writeString16(str, len)中，str=”android.os.IServiceManager”；len是由str.size()得来，虽然这里的字符串是String16类型(即每个字符占2个字节)，但是str.size()是获取str中有效数据的个数(不包含字符串结束符)，因此，len=26。<br>(02) 首先调用writeInt32(len)将字符串的长度写入到Parcel中，writeInt32()在前面已经介绍过了。当再次写入int32_t类型的数据时，数据容量不够，会再次增长为12，即mDataCapacity=12；而写入int32_t类型的数据之后，mDataPos和mDataSize都增长为8。 此时，mData的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add02.jpg" alt></a></p>
<p>在通过writeInt32(len)写入数据长度之后，再重新计算len=52；接着，通过writeInplace()写入数据。  </p>
<p><a name="anchor3_14"></a></p>
<h2 id="14-Parcel-writeInplace"><a href="#14-Parcel-writeInplace" class="headerlink" title="14. Parcel::writeInplace()"></a>14. Parcel::writeInplace()</h2><pre><code>#define PAD_SIZE(s) (((s)+3)&amp;~3)

void* Parcel::writeInplace(size_t len)
{   
    // 4字节对齐
    const size_t padded = PAD_SIZE(len);

    ...

    if ((mDataPos+padded) &lt;= mDataCapacity) {
restart_write:                        
        uint8_t* const data = mData+mDataPos;

        // 如果padded!=len，则根据大端法还是小端法进行地址对齐设置。
        if (padded != len) {
            ...
        }

        finishWrite(padded);
        return data;
    }   

    status_t err = growData(padded);
    if (err == NO_ERROR) goto restart_write;
    return NULL;
}</code></pre><p>说明：参数len=54。<br>(01) PAD_SIZE()是4字节对齐的宏，PAD_SIZE(54)=56。<br>(02) 函数的初始值为padded=56，mDataPos=8，mDataCapacity=12。因此，会先调用growData(padded)来增加数据容量。growData()在前面已经介绍过；此时，它会将容量mDataCapacity增加至96。<br>(03) 接着会跳转到restart_write标签处，然后调用finishWrite(padded)来更新mDataPos和mDataSize。</p>
<p>至此，writeInplace()就分析完了，它的作用就是增加mData的容量，并返回即将写入数据的地址。接着，回到writeString16()中，执行mmap(data, str, len)将数据拷贝到mData中；拷贝完毕之后，设置字符串的结束符为0。</p>
<pre><code>status_t Parcel::writeString16(const char16_t* str, size_t len)
{
    if (str == NULL) return writeInt32(-1);

    // 将字符串长度写入到Parcel中
    status_t err = writeInt32(len);
    if (err == NO_ERROR) {
        len *= sizeof(char16_t);
        // 在将字符串写入之前，增加mData的容量
        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));
        if (data) {
            // 将字符串拷贝到mData中
            memcpy(data, str, len);
            // 字符串结束符
            *reinterpret_cast&lt;char16_t*&gt;(data+len) = 0;
            return NO_ERROR;
        }
        err = mError;
    }
    return err;
}</code></pre><br>
这样，data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor())就分析完了。此时，mData中数据如下图所示：

<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add03.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add03.jpg" alt></a></p>
<p><a name="anchor3_15"></a></p>
<h2 id="15-Parcel-writeString16"><a href="#15-Parcel-writeString16" class="headerlink" title="15. Parcel::writeString16()"></a>15. Parcel::writeString16()</h2><p>继续回到addService()中，接着会通过data.writeString16(name)将MediaPlayerService服务的名称写入到data中，此处的name=”media.player”。在前面已经详细介绍过writeString16()，这里执行完该语句后，mData中的数据如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add04.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add04.jpg" alt></a></p>
<p>接着，addService()会调用data.writeStrongBinder(service)将MediaPlayerService对象写入到data中。这个数据最重要，下面分析下writeStrongBinder()的实现。  </p>
<p><a name="anchor3_16"></a></p>
<h2 id="16-Parcel-writeStrongBinder"><a href="#16-Parcel-writeStrongBinder" class="headerlink" title="16. Parcel::writeStrongBinder()"></a>16. Parcel::writeStrongBinder()</h2><pre><code>status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)
{
    return flatten_binder(ProcessState::self(), val, this);
}</code></pre><p>说明：该函数调用flatten_binder()将数据打包。</p>
<p><a name="anchor3_17"></a></p>
<h2 id="17-Parcel-flatten-binder"><a href="#17-Parcel-flatten-binder" class="headerlink" title="17. Parcel::flatten_binder()"></a>17. Parcel::flatten_binder()</h2><pre><code>status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; proc,
    const sp&lt;IBinder&gt;&amp; binder, Parcel* out)
{       
    flat_binder_object obj;

    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
    if (binder != NULL) {
        IBinder *local = binder-&gt;localBinder();
        if (!local) {
            ...
        } else {
            obj.type = BINDER_TYPE_BINDER;
            obj.binder = local-&gt;getWeakRefs();
            obj.cookie = local;
        }       
    } else {
        ...
    }

    return finish_flatten_binder(binder, obj, out);
}</code></pre><p>说明：该函数是将MediaPlayerService对象封装到结构体flat_binder_object中。Binder驱动认识flat_binder_object结构体类型的数据，在C++层将数据发送给Binder驱动后，Binder驱动能够解析该结构体。<br>(01) 先看看参数，proc是ProcessState对象，binder是MediaPlayerService对象，out是Parcel自己。<br>(02) binder不为NULL，因此，执行if(binder!=NULL)中的语句。binder-&gt;localBinder()返回的BBinder对象，即本地Binder对象。(BBinder是MediaPlayerService的父类，localBinder()函数在frameworks/native/libs/binder/Binder.cpp中实现)。因此，local不为NULL。  </p>
<pre><code>obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;    // 标记
obj.type = BINDER_TYPE_BINDER;                      // 类型
obj.binder = local-&gt;getWeakRefs();                  // MediaPlayerService的弱引用
obj.cookie = local;                                 // MediaPlayerService自身</code></pre><p>注意：从这里就可以看出，MediaPlayerService添加服务时，发送给驱动的数据是MediaPlayerService的本地Binder对象，即BBinder实例。准确的来说，该数据是保存在obj.cookie中的，该数据的类型是BINDER_TYPE_BINDER。</p>
<p>(03) 调用finish_flatten_binder()将数据写入到Parcel中。</p>
<p><a name="anchor3_18"></a></p>
<h2 id="18-Parcel-finish-flatten-binder"><a href="#18-Parcel-finish-flatten-binder" class="headerlink" title="18. Parcel::finish_flatten_binder()"></a>18. Parcel::finish_flatten_binder()</h2><pre><code>inline static status_t finish_flatten_binder(
    const sp&lt;IBinder&gt;&amp; binder, const flat_binder_object&amp; flat, Parcel* out)
{       
    return out-&gt;writeObject(flat, false);
}       </code></pre><p>说明：该函数是flat_binder_object对象写入到Parcel中。 </p>
<p><a name="anchor3_19"></a></p>
<h2 id="19-Parcel-writeObject"><a href="#19-Parcel-writeObject" class="headerlink" title="19. Parcel::writeObject()"></a>19. Parcel::writeObject()</h2><pre><code>status_t Parcel::writeObject(const flat_binder_object&amp; val, bool nullMetaData)
{   
    const bool enoughData = (mDataPos+sizeof(val)) &lt;= mDataCapacity;
    const bool enoughObjects = mObjectsSize &lt; mObjectsCapacity;
    if (enoughData &amp;&amp; enoughObjects) {
restart_write:
        *reinterpret_cast&lt;flat_binder_object*&gt;(mData+mDataPos) = val;

        // val.binder非空
        if (nullMetaData || val.binder != NULL) {
            // 将地址偏移位置保存到mObjects[0]中
            mObjects[mObjectsSize] = mDataPos;
            acquire_object(ProcessState::self(), val, this);
            // 增加mObjectsSize的值
            mObjectsSize++;
        }

        ...

        return finishWrite(sizeof(flat_binder_object));
    }

    if (!enoughData) {
        const status_t err = growData(sizeof(val));
        if (err != NO_ERROR) return err;
    }
    if (!enoughObjects) {
        // 增加容量
        size_t newSize = ((mObjectsSize+2)*3)/2;
        // 分配内存
        size_t* objects = (size_t*)realloc(mObjects, newSize*sizeof(size_t));
        if (objects == NULL) return NO_MEMORY;
        // 设置mObjects的内存地址起始地址
        mObjects = objects;
        // 设置mObjects对象的容量
        mObjectsCapacity = newSize;
    }

    goto restart_write;
}</code></pre><p>说明：<br>(01) 此时，mDataPos=96, sizeof(val)=32, mDataCapacity=96；因此，enoughData=false。mObjectsSize和mObjectsCapacity的初始值=0，因此，enoughObjects=false。<br>(02) 首先，执行if(!enoughData)部分，通过growData()将数据的容量增加至192。即，mDataCapacity=192。<br>(03) 接着，执行if(!enoughObjects)部分，该部分的目的是分配对象空间，并修改mObjects和mObjectsCapacity的值。增加之后的容量mObjectsCapacity=3。<br>(04) 然后，跳转到restart_write标签处。 <em>reinterpret_cast&lt;flat_binder_object</em>&gt;(mData+mDataPos) = val是保存val对象到mDataPos+mDataPos所指的地址中。<br>(04) mObjects[mObjectsSize]=mDataPos，此处的mObjectsSize=0；这里是将对象的地址偏移mDataPos保存到mObjects[0]中。随后执行mObjectsSize++增加mObjectsSize的值为1。<br>(05) 最后，调用finishWrite()更新mDataPos和mDataSize的值。</p>
<p><br>至此，data.writeStrongBinder()就分析完了。将MediaPlayerService写入data之后，它的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add05.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add05.jpg" alt></a></p>
<p>最后，调用data.writeInt32(allowIsolated ? 1 : 0)。allowIsolated为false，因此，data.writeInt32(0)。执行该函数之后，data的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add06.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add06.jpg" alt></a></p>
<p>以上就是addService()中的data的数据。接下来执行remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply)。前面已经说过，remote()返回的是BpBinder对象，该BpBinder对象是在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中调用defaultServiceManager()时初始化的。下面查看BpBinder的transact()。</p>
<p><a name="anchor3_20"></a></p>
<h2 id="20-BpBinder-transact"><a href="#20-BpBinder-transact" class="headerlink" title="20. BpBinder::transact()"></a>20. BpBinder::transact()</h2><pre><code>status_t BpBinder::transact(            
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // mAlive的初始值为1
    if (mAlive) {
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }

    return DEAD_OBJECT;
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/BpBinder.cpp中。由于mAlive的初始值为1，因此该函数会调用IPCThreadState::self()-&gt;transact()。我们知道，IPCThreadState::self()是获取全局IPCThreadState对象，因此最终会调用IPCThreadState::transact()。</p>
<p><a name="anchor3_21"></a></p>
<h2 id="21-IPCThreadState-transact"><a href="#21-IPCThreadState-transact" class="headerlink" title="21. IPCThreadState::transact()"></a>21. IPCThreadState::transact()</h2><pre><code>status_t IPCThreadState::transact(int32_t handle,
                                  uint32_t code, const Parcel&amp; data,
                                  Parcel* reply, uint32_t flags)
{
    status_t err = data.errorCheck();

    flags |= TF_ACCEPT_FDS;

    ...

    if (err == NO_ERROR) {
        ...
        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
    }

    ...

    if ((flags &amp; TF_ONE_WAY) == 0) {
        if (reply) {
            err = waitForResponse(reply);
        } else {
            ...
        }
    } else {
        ...
    }

    return err;
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/IPCThreadState.cpp中。<br>(01) 先看看函数的参数。handle是BpBinder中的mHandle对象，BpBinder中的mHandle是ServiceManager的句柄，值为0。code=ADD_SERVICE_TRANSACTION。data就是在addService中设置的Parcel对象。reply是用来接收Binder驱动反馈数据的Parcel对象。flags是默认值0。<br>(02) 该函数会先通过writeTransactionData()将数据打包。<br>(03) flags的初始化为0，并且reply非空。因此，将数据打包号之后，会调用waitForResponse()将数据发送给Binder驱动，然后等待Binder驱动反馈。</p>
<p><a name="anchor3_22"></a></p>
<h2 id="22-IPCThreadState-writeTransactionData"><a href="#22-IPCThreadState-writeTransactionData" class="headerlink" title="22. IPCThreadState::writeTransactionData()"></a>22. IPCThreadState::writeTransactionData()</h2><pre><code>status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,
    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)
{
    binder_transaction_data tr;

    tr.target.handle = handle;
    tr.code = code;
    tr.flags = binderFlags;
    tr.cookie = 0;
    tr.sender_pid = 0;
    tr.sender_euid = 0;

    const status_t err = data.errorCheck();
    if (err == NO_ERROR) {
        tr.data_size = data.ipcDataSize();
        tr.data.ptr.buffer = data.ipcData();
        tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t);
        tr.data.ptr.offsets = data.ipcObjects();
    } else if (statusBuffer) {
        ..
    } else {
        ...
    }

    mOut.writeInt32(cmd);
    mOut.write(&amp;tr, sizeof(tr));

    return NO_ERROR;
}</code></pre><p>说明：该函数会读取Parcel中的数据，然后将其打包到binder_transaction_data结构体中。binder_transaction_data结构体是Binder驱动能够识别并对之进行解析的数据结构。<br>  ipcDataSize()是返回mDataSize，ipcData()是返回mData，ipcObjectsCount()是返回mObjectsSize，而ipcObjects则是返回mObjects。这些数据就是前面我们在addService中分析的Parcel对象的数据。下面给出初始化之后tr的值。  </p>
<pre><code>tr.target.handle = handle;  // 0，即Service Manager的句柄
tr.code = code;             // ADD_SERVICE_TRANSACTION
tr.flags = binderFlags;     // TF_ACCEPT_FDS
tr.cookie = 0;
tr.sender_pid = 0;

tr.data_size = data.ipcDataSize();      // 数据大小(对应mDataSize)
tr.data.ptr.buffer = data.ipcData();    // 数据的起始地址(对应mData)
tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t); // data中保存的对象个数(对应mObjectsSize)
tr.data.ptr.offsets = data.ipcObjects();                 // data中保存的对象的偏移地址数组(对应mObjects)</code></pre><p>初始化tr之后，将cmd=BC_TRANSACTION和tr重新打包到mOut中。mOut中的数据将来会被以请求的方式发送给Binder驱动。重新打包后的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/data_01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/data_01.jpg" alt></a></p>
<p>在上图中，mOut包含了”事务指令”+”binder_transaction_data”结构体对象。而具体的MediaPlayerService对象，则包含在binder_transaction_data的data数据区域；它是被封装在flat_binder_object结构体中的。</p>
<p><a name="anchor3_23"></a></p>
<h2 id="23-IPCThreadState-waitForResponse"><a href="#23-IPCThreadState-waitForResponse" class="headerlink" title="23. IPCThreadState::waitForResponse()"></a>23. IPCThreadState::waitForResponse()</h2><p>writeTransactionData()分析完毕之后，再看看waitForResponse()的代码。</p>
<pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) {
        // 先通过talkWithDriver()和Binder驱动交互
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        ...
        if (mIn.dataAvail() == 0) continue;

        // 然后读取返回结果，再根据结果进行处理
        cmd = mIn.readInt32();

        switch (cmd) {
        case BR_TRANSACTION_COMPLETE:
            ...
        case BR_DEAD_REPLY:
            ...
        case BR_FAILED_REPLY:
            ...
        case BR_ACQUIRE_RESULT:
            ...
        case BR_REPLY:
            ...
        default:
            err = executeCommand(cmd);
            if (err != NO_ERROR) goto finish;
            break;
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：waitForResponse()会先调用talkWithDriver()和Binder驱动交互，然后根据反馈结果来进行处理。</p>
<p><a name="anchor3_24"></a></p>
<h2 id="24-IPCThreadState-talkWithDriver"><a href="#24-IPCThreadState-talkWithDriver" class="headerlink" title="24. IPCThreadState::talkWithDriver()"></a>24. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    binder_write_read bwr;

    // Is the read buffer empty?
    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();
    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we&apos;ll read.
    if (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
        bwr.read_buffer = 0;
    }

    ...
    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    status_t err;
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：talkWithDriver()会先初始化bwr(binder_write_read类型的变量)，然后将bwr变量通过ioctl()发送给Binder驱动。该函数的参数doReceive的默认值为true。<br>(01) 现在，mIn中还没有被写入数据，因此它的值都是初始值。那么，mIn.dataPosition()返回mDataPos，它的值为0；mIn.dataSize()返回mDataSize，它的初始值也为0。因此，needRead=true。<br>(02) doReceive=true，但是needRead=true；因此，outAvail=mOut.dataSize，outAvail不为0。接下来，就对bwr进行初始化，关于bwr的介绍，请参考<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。bwr初始化完毕之后，各个成员的值如下：  </p>
<pre><code>bwr.write_size = outAvail;                          // mOut中数据大小，大于0
bwr.write_buffer = (long unsigned int)mOut.data();  // mOut中数据的地址
bwr.write_consumed = 0;
bwr.read_size = mIn.dataCapacity();                 // 256
bwr.read_buffer = (long unsigned int)mIn.data();    // mIn.mData，实际上为空
bwr.read_consumed = 0;</code></pre><p>(03) bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。</p>
<p>通过binder_write_read再次打包后的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/data_02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/data_02.jpg" alt></a></p>
<p>如上图所示，ioctl()传输的数据包含”BINDER_WRITE_READ”+”binder_write_read结构体对象”。在binder_write_read的write_buffer中包含了事务数据；而在数据数据的data中又包含了flat_binder_object等数据。在flat_binder_object中就包含了需要传输的MediaPlayerService对象。<br>总体来看，数据经过了三次封装。下面看看在Binder驱动中是如何一层层将它们剖析开来的。</p>
<p><a name="anchor3_25"></a></p>
<h2 id="25-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#25-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="25. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>25. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h2><pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  // 中断等待函数。
  // 1. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。
  // 2. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。
  //    当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时；
  //    则继续执行；否则，再进入等待状态。
  ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);

  binder_lock(__func__);
  // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。
  thread = binder_get_thread(proc);
  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：关于该函数在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中已经介绍过了。这里将binder_write_read从用户空间拷贝到内核空间之后，读取bwr.write_size和bwr.read_size都&gt;0，因此先写后读。</p>
<p><a name="anchor3_26"></a></p>
<h2 id="26-Binder驱动中binder-thread-write-的源码"><a href="#26-Binder驱动中binder-thread-write-的源码" class="headerlink" title="26. Binder驱动中binder_thread_write()的源码"></a>26. Binder驱动中binder_thread_write()的源码</h2><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
      ...
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p>说明：读取出来的交易码是BC_TRANSACTION。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。  </p>
<p><a name="anchor3_27"></a></p>
<h2 id="27-Binder驱动中binder-transaction-的源码"><a href="#27-Binder驱动中binder-transaction-的源码" class="headerlink" title="27. Binder驱动中binder_transaction()的源码"></a>27. Binder驱动中binder_transaction()的源码</h2><pre><code>static void binder_transaction(struct binder_proc *proc,
                   struct binder_thread *thread,
                   struct binder_transaction_data *tr, int reply)
{
    struct binder_transaction *t;
    struct binder_work *tcomplete;
    size_t *offp, *off_end;
    struct binder_proc *target_proc;
    struct binder_thread *target_thread = NULL;
    struct binder_node *target_node = NULL;
    struct list_head *target_list;
    wait_queue_head_t *target_wait;
    struct binder_transaction *in_reply_to = NULL;
    struct binder_transaction_log_entry *e;
    uint32_t return_error;

    ...

    if (reply) {
        ...
    } else {
        if (tr-&gt;target.handle) {
            ...
        } else {
            // 事务目标对象是ServiceManager的binder实体
            // 即，该事务是交给Service Manager来处理的。
            target_node = binder_context_mgr_node;
            ...
        }
        ...
        // 设置处理事务的目标进程
        target_proc = target_node-&gt;proc;
        ...
    }

    if (target_thread) {
        ...
    } else {
        target_list = &amp;target_proc-&gt;todo;
        target_wait = &amp;target_proc-&gt;wait;
    }
    ...

    // 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
    t = kzalloc(sizeof(*t), GFP_KERNEL);
    ...

    // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
    ...

    t-&gt;debug_id = ++binder_last_id;
    ...

    // 设置from，表示该事务是MediaPlayerService发起的
    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
        t-&gt;from = thread;
    else
        t-&gt;from = NULL;
    // 下面的一些赋值是初始化事务t
    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
    // 事务将交给target_proc进程进行处理
    t-&gt;to_proc = target_proc;
    // 事务将交给target_thread线程进行处理
    t-&gt;to_thread = target_thread;
    // 事务编码
    t-&gt;code = tr-&gt;code;
    // 事务标志
    t-&gt;flags = tr-&gt;flags;
    // 事务优先级
    t-&gt;priority = task_nice(current);

    ...

    // 分配空间
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    ...
    t-&gt;buffer-&gt;allow_user_free = 0;
    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
    // 保存事务
    t-&gt;buffer-&gt;transaction = t;
    // 保存事务的目标对象(即处理该事务的binder对象)
    t-&gt;buffer-&gt;target_node = target_node;
    trace_binder_transaction_alloc_buf(t-&gt;buffer);
    if (target_node)
        binder_inc_node(target_node, 1, 0, NULL);

    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));

    // 将&quot;用户空间的数据&quot;拷贝到内核中
    // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户空间的数据中所含对象的偏移地址&quot;拷贝到内核中
    // tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数
    // 拷贝之后，offp就是flat_binder_object对象数组在内核空间的偏移数组的起始地址
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }
    ...
    // off_end就是flat_binder_object对象数组在内核空间的偏移地址的结束地址
    off_end = (void *)offp + tr-&gt;offsets_size;
    // 将所有的flat_binder_object对象读取出来
    // 对MediaPlayerService而言，只有一个flat_binder_object对象。
    for (; offp &lt; off_end; offp++) {
        struct flat_binder_object *fp;
        ...
        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);

        switch (fp-&gt;type) {
        case BINDER_TYPE_BINDER:
        case BINDER_TYPE_WEAK_BINDER: {
            struct binder_ref *ref;
            // 在proc中查找binder实体对应的binder_node
            struct binder_node *node = binder_get_node(proc, fp-&gt;binder);
            // 若找不到，则新建一个binder_node；下次就可以直接使用了。
            if (node == NULL) {
                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);
                if (node == NULL) {
                    ...
                }
                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;
                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);
            }
            ...
            // 在target_proc(即，ServiceManager的进程上下文)中查找是否包行&quot;该Binder实体的引用&quot;，
            // 如果没有找到的话，则将&quot;该binder实体的引用&quot;添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该
Binder实体进行管理了。
            ref = binder_get_ref_for_node(target_proc, node);
            if (ref == NULL) {
                ...
            }
            // 修改type
            if (fp-&gt;type == BINDER_TYPE_BINDER)
                fp-&gt;type = BINDER_TYPE_HANDLE;
            else
                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;
            // 修改handle。handle和binder是联合体，这里将handle设为引用的描述。
            // 根据该handle可以找到&quot;该binder实体在target_proc中的binder引用&quot;；
            // 即，可以根据该handle，可以从Service Manager找到对应的Binder实体的引用，从而获取Binder实体。
            fp-&gt;handle = ref-&gt;desc;
            // 增加引用计数，防止&quot;该binder实体&quot;在使用过程中被销毁。
            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,
                       &amp;thread-&gt;todo);

            trace_binder_transaction_node_to_ref(t, node, ref);
            ...
        } break;
        ...
        }
    }
    if (reply) {
        ..
    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {
        BUG_ON(t-&gt;buffer-&gt;async_transaction != 0);
        t-&gt;need_reply = 1;
        t-&gt;from_parent = thread-&gt;transaction_stack;
        // 将当前事务添加到当前线程的事务栈中
        thread-&gt;transaction_stack = t;
    } else {
        ...
    }
    // 设置事务的类型为BINDER_WORK_TRANSACTION
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    // 将事务添加到target_list队列中，即target_list的待处理事务中
    list_add_tail(&amp;t-&gt;work.entry, target_list);
    // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
    // 唤醒目标进程
    if (target_wait)
        wake_up_interruptible(target_wait);
    return;

    ...
}</code></pre><p>说明：这里的tr-&gt;target.handle=0，因此，会设置target_node为ServiceManager对应的Binder实体。下面是target_node,target_proc等值初始化之后的值。  </p>
<pre><code>target_node = binder_context_mgr_node; // 目标节点为Service Manager对应的Binder实体
target_proc = target_node-&gt;proc;       // 目标进程为Service Manager对应的binder_proc进程上下文信息
target_list = &amp;target_thread-&gt;todo;    // 待处理事务队列
target_wait = &amp;target_thread-&gt;wait;    // 等待队列</code></pre><p>目标节点是Service Manager对应的Binder实体。这是指MediaPlayerService的addService()这个指令是来提交给Service Manager进行处理的，它最终会发送给Service Manager进行处理。。</p>
<p>在初始化完target_node等目标节点之后，会新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。待处理事务t会被提交给目标(即ServiceManager对应的Binder实体)进行处理；而待完成的工作tcomplete则是为了反馈给MediaPlayerService服务，告诉MediaPlayerService它的请求Binder驱动已经收到了。注意，这里仅仅是告诉MediaPlayerService该请求已经被收到，而不是处理完毕！待ServiceManager处理完毕该请求之后，Binder驱动会再次反馈相应的消息给MediaPlayerService。</p>
<pre><code>// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
t = kzalloc(sizeof(*t), GFP_KERNEL);
...

// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
...

t-&gt;debug_id = ++binder_last_id;
...

if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
    t-&gt;from = thread;
else
    t-&gt;from = NULL;
// 下面的一些赋值是初始化事务t
t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
// 事务将交给target_proc进程进行处理
t-&gt;to_proc = target_proc;
// 事务将交给target_thread线程进行处理
t-&gt;to_thread = target_thread;
// 事务编码
t-&gt;code = tr-&gt;code;
// 事务标志
t-&gt;flags = tr-&gt;flags;
// 事务优先级
t-&gt;priority = task_nice(current);

...

// 分配空间
t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
    tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
...
t-&gt;buffer-&gt;allow_user_free = 0;
t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
// 保存事务
t-&gt;buffer-&gt;transaction = t;
// 保存事务的目标对象(即处理该事务的binder对象)
t-&gt;buffer-&gt;target_node = target_node;
trace_binder_transaction_alloc_buf(t-&gt;buffer);
if (target_node)
    binder_inc_node(target_node, 1, 0, NULL);</code></pre><p>在初始化完待处理事务t之后，接着将MediaPlayerService请求的数据拷贝到内核空间并解析出来。从数据中解析出MediaPlayerService请求数据中的flat_binder_object对象，只有一个flat_binder_object对象。该flat_binder_object对象的类型是BINDER_TYPE_BINDER，然后调用binder_get_node()在当前进程的上下文环境proc中查找fp-&gt;binder对应的Binder实体，fp-&gt;binder是Android的flatten_binder()中赋值的，它是MediaPlayerService对象的本地引用的描述(即MediaPlayerService对应的BBinder对象的描述)；此外，在MediaPlayerService是初次与Binder驱动通信，因此肯定找不到该对象fp-&gt;binder对应的Binder实体；因此node=NULL。  接下来，就调用binder_new_node()新建fp-&gt;binder对应的Binder实体，这也就是MediaPlayerService对应的Binder实体。然后，调用binder_get_ref_for_node(target_proc, node)获取该Binder实体在target_proc(即ServiceManager的进程上下文环境)中的Binder引用，此时，在target_proc中肯定也找不到该Binder实体对应的引用；那么，就新建Binder实体的引用，并将其添加到target_proc-&gt;refs_by_node红黑树 和 target_proc-&gt;refs_by_desc红黑树中。 这样，Service Manager的进程上下文中就存在MediaPlayerService的Binder引用，Service Manager也就可以对MediaPlayerService进行管理了！<br>  然后，修改fp-&gt;type=BINDER_TYPE_HANDLE，并使fp-&gt;handle = ref-&gt;desc。</p>
<p>这样，就将MediaPlayerService的请求数据解析出来，并且在Binder驱动中创建了MediaPlayerService对应的Binder实体，而且将该Binder实体添加到MediaPlayerService的进程上下文proc中。更重要的是，在ServiceManager的refs_by_node和refs_by_desc这两颗红黑树中创建了”MediaPlayerService对应的Binder实体的Binder引用”。这意味着，在Binder驱动中，已经能在ServiceManager的进程上下文中找到MediaPlayerService。</p>
<pre><code>    // 将&quot;用户空间的数据&quot;拷贝到内核中
    // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户空间的数据中所含对象的偏移地址&quot;拷贝到内核中
    // tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数
    // 拷贝之后，offp就是flat_binder_object对象数组在内核空间的起始地址
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }
    ...
    // off_end就是flat_binder_object对象数组在内核空间的结束地址
    off_end = (void *)offp + tr-&gt;offsets_size;
    // 将所有的flat_binder_object对象读取出来
    // 对MediaPlayerService而言，只有一个flat_binder_object对象。
    for (; offp &lt; off_end; offp++) {
        struct flat_binder_object *fp;
        ...
        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);

        switch (fp-&gt;type) {
        case BINDER_TYPE_BINDER:
        case BINDER_TYPE_WEAK_BINDER: {
            struct binder_ref *ref;
            // 在proc中查找binder实体对应的binder_node
            struct binder_node *node = binder_get_node(proc, fp-&gt;binder);
            // 若找不到，则新建一个binder_node；下次就可以直接使用了。
            if (node == NULL) {
                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);
                if (node == NULL) {
                    ...
                }
                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;
                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);
            }
            ...
            // 在target_proc(即，Service Manager的进程上下文)中查找是否包行&quot;该binder实体的引用&quot;，
            // 如果没有找到的话，则将&quot;该binder实体的引用&quot;添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该
Binder实体进行管理了。
            ref = binder_get_ref_for_node(target_proc, node);
            if (ref == NULL) {
                ...
            }
            // 修改type
            if (fp-&gt;type == BINDER_TYPE_BINDER)
                fp-&gt;type = BINDER_TYPE_HANDLE;
            else
                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;
            // 修改handle。handle和binder是联合体，这里将handle设为引用的描述。
            // 根据该handle可以找到&quot;该binder实体在target_proc中的binder引用&quot;；
            // 即，可以根据该handle，可以从Service Manager找到对应的binder实体的引用，从而获取binder实体。
            fp-&gt;handle = ref-&gt;desc;
            // 增加引用计数，防止&quot;该binder实体&quot;在使用过程中被销毁。
            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,
                       &amp;thread-&gt;todo);

            trace_binder_transaction_node_to_ref(t, node, ref);
            ...
        } break;
        ...
        }
    }</code></pre><p>然后，设置待处理事务的类型为BINDER_WORK_TRANSACTION，并将其添加到target_list中。即，添加事务到Service Manager对应的待处理事务队列中。<br>设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE，并将其添加到当前线程的待完成工作中。此时，Binder驱动已经收到了MediaPlayerService的请求，这个所谓的待完成工作，就是用来让Binder驱动告诉MediaPlayerService，它的请求已经被处理了。<br>最后，target_wait是ServiceManager的等待队列，肯定不为空(因为前面刚刚将BINDER_WORK_TRANSACTION事务添加到待处理事务中)。因此，便会执行wake_up_interruptible(target_wait)唤醒Service Manager进程。<br><strong>注意</strong>，此时都是运行在MediaPlayerService的进程中的！</p>
<pre><code>// 设置事务的类型为BINDER_WORK_TRANSACTION
t-&gt;work.type = BINDER_WORK_TRANSACTION;
// 将事务添加到target_list队列中，即target_list的待处理事务中
list_add_tail(&amp;t-&gt;work.entry, target_list);
// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
// 唤醒目标进程
if (target_wait)
    wake_up_interruptible(target_wait);
return;</code></pre><p>此时，MediaPlayerService进程还会继续运行，而且它也通过wake_up_interruptible()唤醒了ServiceManager进程。ServiceManager被唤醒后，所做的工作就是将MediaPlayerService注册到它的服务队列中进行管理；它的具体流程稍候再分析，现在还是先分析完MediaPlayerService进程。</p>
<p>至此，binder_transaction()就分析完了。在binder_transaction()中，我们主要进行了以下工作：<br>(01) 解析出来MediaPlayerService的请求数据。<br>(02) 新建MediaPlayerService对应的Binder实体和Binder引用，并将ServiceManager的进程上下文中存在MediaPlayerService的Binder引用。<br>(03) 新建了待处理事务，并将该事务添加到了ServiceManager的待处理事务队列中。然后，唤醒ServiceManager来处理该事务。<br>(04) 新建了待完成工作，并将待完成工作添加到了当前线程的待完成工作队列中。  </p>
<p><a name="anchor3_28"></a></p>
<h2 id="28-Binder驱动中binder-thread-write-的源码"><a href="#28-Binder驱动中binder-thread-write-的源码" class="headerlink" title="28. Binder驱动中binder_thread_write()的源码"></a>28. Binder驱动中binder_thread_write()的源码</h2><p>接着分析MediaPlayerService进程的工作。binder_thread_write()中执行binder_transaction()后，会更新*consumed的值，即bwr.write_consumed的值。意味着，Binder驱动已经驱动完成MediaPlayerService的请求数据。</p>
<pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
      ...
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p><a name="anchor3_29"></a></p>
<h2 id="29-Binder驱动中binder-thread-read-的源码"><a href="#29-Binder驱动中binder-thread-read-的源码" class="headerlink" title="29. Binder驱动中binder_thread_read()的源码"></a>29. Binder驱动中binder_thread_read()的源码</h2><p>接下来，ioctl()会执行binder_thread_read()来设置反馈数据给MediaPlayerService进程。  </p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                  struct binder_thread *thread,
                  void  __user *buffer, int size,
                  signed long *consumed, int non_block)
{
    void __user *ptr = buffer + *consumed;
    void __user *end = buffer + size;

    int ret = 0;
    int wait_for_proc_work;

    // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区
    if (*consumed == 0) {
        if (put_user(BR_NOOP, (uint32_t __user *)ptr))
            return -EFAULT;
        ptr += sizeof(uint32_t);
    }

retry:
    // 等待proc进程的事务标记。
    // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。
    wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;
                list_empty(&amp;thread-&gt;todo);

    ...

    if (wait_for_proc_work) {
        ...
    } else {
        if (non_block) {
            ...
        } else
            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));
    }

    ...

    while (1) {
        uint32_t cmd;
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */
                goto retry;
            break;
        }

        ...

        switch (w-&gt;type) {
        ...
        case BINDER_WORK_TRANSACTION_COMPLETE: {
            cmd = BR_TRANSACTION_COMPLETE;
            // 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中
            if (put_user(cmd, (uint32_t __user *)ptr))
                return -EFAULT;
            ptr += sizeof(uint32_t);

            binder_stat_br(proc, thread, cmd);
            ...

            // 待完成事务已经处理完毕，将其从待完成事务队列中删除。
            list_del(&amp;w-&gt;entry);
            kfree(w);
            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
        } break;
        ...
        }

        if (!t)
            continue;

        ...
    }

    ...
    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：<br>(01) 先看看函数的参数，buffer是bwr.read_buffer，是反馈数据缓冲区。size是bwr.read_size，是缓冲区大小，为256字节；而consumed是指向bwr.read_consumed的，它的值是0，表示反馈数据还没有被MediaPlayerService读取过。non_block为0。<br>(02) <em>consumed=0，因此会先将BR_NOOP从内核空间拷贝到用户空间，即拷贝到bwr.read_buffer中。<br>(03) 在binder_transaction()中，我们有添加待完成工作到thread的待完成工作队列中。因此，wait_for_proc_work是false。<br>(04) binder_has_thread_work(thread)为ture，因此wait_event_interruptible()不会进入中断等待状态，而是继续往下运行。<br>(05) 接着，进入while循环。list_empty(&amp;thread-&gt;todo)为flase，执行list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry)从thread的待完成工作队列中取出待完成的工作t。<br>(06) 根据binder_transaction()中的分析可知，t-&gt;type的值为BINDER_WORK_TRANSACTION_COMPLETE。执行对应的case分支，会将数据cmd=BR_TRANSACTION_COMPLETE拷贝到用户空间，即bwr.read_buffer中。拷贝之后，即代表该工作已完成，然后从当前线程的工作队列中将该工作删除，并释放所分配的空间。<br>(07) 由于t=null，因此，会再次从头开始执行while循环。而此时，list_empty(&amp;thread-&gt;todo)为true，并且list_empty(&amp;proc-&gt;todo)也为true；因此会执行break跳出while循环。<br>(08) 在跳出while循环之后，会更新</em>consumed的值。即，更新bwr.read_consumed的值。此时，由于写入了BR_NOOP和BR_TRANSACTION_COMPLETE两个指令，bwr.read_consumed=8。</p>
<br>
接下来，回到binder_ioctl()中。将bwr数据拷贝到用户空间后返回。此时，bwr中各个参数的值如下：

<pre><code>bwr.write_size = outAvail;                          
bwr.write_buffer = (long unsigned int)mOut.data();
bwr.write_consumed = outAvail;                      // 等于write_size
bwr.read_size = mIn.dataCapacity();
bwr.read_buffer = (long unsigned int)mIn.data();    // 存储了BR_NOOP和BR_TRANSACTION_COMPLETE两个返回指令
bwr.read_consumed = 8;                              // 等于write_size</code></pre><p>bwr中的write_<em>参数是保存”MediaPlayerService发送给Binder驱动的请求内容的”，而read_</em>则是保存”Binder驱动反馈给MediaPlayerService的内容的”。此时，write_consumed和write_size相同，意味着”Binder驱动已经将请求的内容都处理完毕了”；而read_consumed&gt;0，则意味着”Binder驱动有反馈内容给MediaPlayerService”。<br>回到talkWithDriver()中，看看ioctl()之后做了些什么？</p>
<p><a name="anchor3_30"></a></p>
<h2 id="30-IPCThreadState-talkWithDriver"><a href="#30-IPCThreadState-talkWithDriver" class="headerlink" title="30. IPCThreadState::talkWithDriver()"></a>30. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                ...
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：ioctl()返回值为0，err=NO_ERROR，退出while循环。<br>(01) bwr.write_consumed&gt;0，并且bwr.write_consumed=mOut.dataSize。因此，调用mOut.setDataSize(0)将释放mOut的内存，并且将mOut的mDataSize和mObjectsSize设为0。<br>(02) bwr.read_consumed&gt;0，因此调用mIn.setDataSize()为mIn分配空间，并将mIn的mDataSize设为=bwr.read_consumed。然后，将位置mDataPos初始化为0。<br>之后，跳出talkWithDriver()，返回到waitForResponse()中。</p>
<p><a name="anchor3_31"></a></p>
<h2 id="31-IPCThreadState-waitForResponse"><a href="#31-IPCThreadState-waitForResponse" class="headerlink" title="31. IPCThreadState::waitForResponse()"></a>31. IPCThreadState::waitForResponse()</h2><pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{       
    int32_t cmd;
    int32_t err;

    while (1) {
        // 先通过talkWithDriver()和Binder驱动交互
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        err = mIn.errorCheck();
        if (err &lt; NO_ERROR) break;
        if (mIn.dataAvail() == 0) continue;

        // 然后读取返回结果，再根据结果进行处理
        cmd = mIn.readInt32();

        switch (cmd) {
        case BR_TRANSACTION_COMPLETE:
            ...
        case BR_DEAD_REPLY:
            ...
        case BR_FAILED_REPLY:
            ...
        case BR_ACQUIRE_RESULT:
            ...
        case BR_REPLY:
            ...
        default:
            err = executeCommand(cmd);
            if (err != NO_ERROR) goto finish;
            break;
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：从talkWithDriver()正常返回之后，会读取mIn中的数据。而mIn中的数据就是Binder驱动返回的”BR_NOOP和BR_TRANSACTION_COMPLETE两个指令”。先读出的指令是BR_NOOP，因此这里执行executeCommand(cmd)。</p>
<p><a name="anchor3_32"></a></p>
<h2 id="32-IPCThreadState-executeCommand"><a href="#32-IPCThreadState-executeCommand" class="headerlink" title="32. IPCThreadState::executeCommand()"></a>32. IPCThreadState::executeCommand()</h2><pre><code>status_t IPCThreadState::executeCommand(int32_t cmd)
{
    BBinder* obj;
    RefBase::weakref_type* refs;
    status_t result = NO_ERROR;

    switch (cmd) {
    case BR_ERROR:
        ...
    case BR_OK:
        ...
    case BR_NOOP:
        break;
    default:
        ...
    }

    if (result != NO_ERROR) {
        mLastError = result;
    }

    return result;
}</code></pre><p>说明：BR_NOOP没有进行任何操作，直接返回。继续回到waitForResponse()中，重新开始while循环，执行talkWithDriver()。</p>
<p><a name="anchor3_33"></a></p>
<h2 id="33-IPCThreadState-talkWithDriver"><a href="#33-IPCThreadState-talkWithDriver" class="headerlink" title="33. IPCThreadState::talkWithDriver()"></a>33. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    binder_write_read bwr;

    // Is the read buffer empty?
    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();
    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we&apos;ll read.
    if (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
        bwr.read_buffer = 0;
    }

    ...
    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    status_t err;
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：<br>(01) 此时，因为在waitForResponse()中已经通过mIn.readInt32()读取了4个字节，因此mIn.dataPosition()=4，而mIn.dataSize()=8；因此，needRead=false。<br>(02) needRead=false，而doReceive=true；因此，outAvail=0。<br>最终，由于 bwr.write_size和bwr.read_size都为0，因此直接返回NO_ERROR。</p>
<p>再次回到waitForResponse()中，此时读出的cmd为BR_TRANSACTION_COMPLETE。此时，由于reply不为NULL，因此再次重新执行while循环，调用talkWithDriver()。</p>
<p>(01) 此时，已经读取了mIn中的全部数据，因此mIn.dataPosition()=8，而mIn.dataSize()=8；因此，needRead=true。<br>(02) outAvail=mOut.dataSize()，前面已经将mOut清空，因此outAvail=0。bwr初始化完毕之后，各个成员的值如下：</p>
<pre><code>bwr.write_size = 0;
bwr.write_buffer = (long unsigned int)mOut.data();
bwr.write_consumed = 0;
bwr.read_size = mIn.dataCapacity();                 // 256字节
bwr.read_buffer = (long unsigned int)mIn.data();
bwr.read_consumed = 0;</code></pre><p>其实，此时MediaPlayerService已经处理完”addService()这个请求，包括已经处理完了该请求的反馈”。对MediaPlayerService而言，它已经成功的注册到Service Manager中；接下来，就是等待Client的请求了。<br>那么如何去等待Client的请求呢？这和前面分析Service Manager服务启动之后等待Client的请求类似。MediaPlayerService服务，会通过ioctl()给Binder驱动发送读写请求，而此时的bwr.write_size=0，意味着不会进行写；bwr.read_size&gt;0，意味着会进行读。这样，Binder驱动就会执行读取动作，进而去查看”MediaPlayerService在Binder驱动中的待处理事务队列”是否有事务需要处理，有的话，就进行事务处理；否则，就进入中断等待状态，等待Client的请求。</p>
<p>下面，看看它到底是如何做到的。</p>
<pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>此时，bwr.write_size=0，因此不会执行binder_thread_write()。而bwr.read_size&gt;0，因此会调用binder_thread_read()进行读取动作。</p>
<p><a name="anchor3_34"></a></p>
<h2 id="34-Binder驱动中binder-thread-read-的源码"><a href="#34-Binder驱动中binder-thread-read-的源码" class="headerlink" title="34. Binder驱动中binder_thread_read()的源码"></a>34. Binder驱动中binder_thread_read()的源码</h2><pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  int ret = 0;
  int wait_for_proc_work;

  // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区
  if (*consumed == 0) {
      if (put_user(BR_NOOP, (uint32_t __user *)ptr))
          return -EFAULT;
      // 修改指针位置
      ptr += sizeof(uint32_t);
  }

retry:
  // 等待proc进程的事务标记。
  // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。
  wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;
              list_empty(&amp;thread-&gt;todo);

  ...
  if (wait_for_proc_work) {
      ...
      // 设置当前线程的优先级=proc-&gt;default_priority。
      // 即，当前线程要处理proc的事务，所以设置优先级和proc一样。
      binder_set_nice(proc-&gt;default_priority);
      if (non_block) {
          ...
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
  } else {
      ...
  }
  ...
}</code></pre><p>(01) 此时，bwr.read_consumed=0，意味着*consumed=0。因此，还是会先将BR_NOOP写入到bwr.read_buffer中。<br>(02) 此时，当前线程的事务栈和待处理事务队列都是空，因此wait_for_proc_work=true。<br>(03) 在调用binder_set_nice()设置当前线程的优先级之后，就会调用wait_event_interruptible()。而此时binder_has_proc_work()为false，因此当前线程会进入中断等待状态。当Service Manager处理完MediaPlayerService的请求之后，就会将其唤醒。</p>
<br>
至此，MediaPlayerService进程的addService的请求发送部分就讲解完了。在继续了解请求的处理之前，先回顾一下本部分的内容。

<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService01_send.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService01_send.jpg" alt></a></p>
<p>如上图所示，MediaPlayerService发送一个BC_TRANSACTION事务给Binder驱动。Binder驱动收到该事务之后，对请求数据进行解析，在Kernel中新建了MediaPlayerService对应的Binder实体，并将在ServiceManager的进程上下文中添加了该Binder实体的Binder引用。解析完数据之后，新增一个待处理事务并提交到ServiceManager的待处理事务列表中；接着，就唤醒了ServiceManager。与此同时，Binder驱动还反馈了一个BR_TRANSACTION_COMPLETE给MediaPlayerService，告诉MediaPlayerService它的addService请求已经发送成功；MediaPlayerService在解析完BR_TRANSACTION_COMPLETE之后，就进入等待状态，等待ServiceManager的处理完请求之后反馈结果给它。</p>
<p>下面一篇文章，就看看ServiceManager被唤醒之后，具体都做了些什么工作！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/04/android/os/binder/2014-09-04-Binder-defaultServiceManager/" itemprop="url">Android Binder机制(四) defaultServiceManager()的实现</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-04T01:04:00.000Z" itemprop="datePublished">9月 4 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            32 分钟 read (About 4732 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文介绍defaultServiceManager()的流程。这里的defaultServiceManager()返回的是”IServiceManager对象”，获取”IServiceManager对象”的目的是为了和”ServiceManager进程”进行通信。例如，Server要通过”IServiceManager对象”发送请求指令注册到”ServiceManager进程”中，Client要通过”IServiceManager对象”发送请求来获取”Server对象”。<br>这里要搞清楚：<strong>defaultServiceManager()获取到的，不是”ServiceManager进程”，而是”IServiceManager对象”</strong>。”ServiceManager进程”是一个守护进程，而defaultServiceManager()获取到的是C++层的IServiceManager类的一个实例。当然，通过该defaultServiceManager()返回的”IServiceManager对象”是可以和ServiceManager进行通信的。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">defaultServiceManager概述</a><br><strong>2</strong>. <a href="#anchor2">defaultServiceManager流程详解</a><br><strong>2.1</strong>. <a href="#anchor2_1">defaultServiceManager()</a><br><strong>2.2</strong>. <a href="#anchor2_2">ProcessState::self()</a><br><strong>2.3</strong>. <a href="#anchor2_3">ProcessState::ProcessState()</a><br><strong>2.4</strong>. <a href="#anchor2_4">ProcessState::open_driver()</a><br><strong>2.5</strong>. <a href="#anchor2_5">mmap()</a><br><strong>2.6</strong>. <a href="#anchor2_6">ProcessState::getContextObject()</a><br><strong>2.7</strong>. <a href="#anchor2_7">ProcessState::getStrongProxyForHandle()</a><br><strong>2.8</strong>. <a href="#anchor2_8">ProcessState::lookupHandleLocked()</a><br><strong>2.9</strong>. <a href="#anchor2_9">BpBinder::BpBinder</a><br><strong>2.10</strong>. <a href="#anchor2_10">IPCThreadState::self()</a><br><strong>2.11</strong>. <a href="#anchor2_11">IPCThreadState::IPCThreadState()</a><br><strong>2.12</strong>. <a href="#anchor2_12">interface_cast()</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="defaultServiceManager概述"><a href="#defaultServiceManager概述" class="headerlink" title="defaultServiceManager概述"></a>defaultServiceManager概述</h1><h2 id="1-defaultServiceManager流程图"><a href="#1-defaultServiceManager流程图" class="headerlink" title="1. defaultServiceManager流程图"></a>1. defaultServiceManager流程图</h2><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/defaultServiceManager.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/defaultServiceManager.jpg" alt></a></p>
<p>上面是defaultServiceManager()的时序图。<br>defaultServiceManager()会返回一个sp<iservicemanager>类型的对象。IServiceManager提供了addService()供MediaPlayerService等服务注册到ServiceManager中，提供了getService()供MediaPlayer等MediaPlayer等客户端获取服务。<br>它首先会调用ProcessState::self()获取到ProcessState对象，该ProcessState对象是采用单例模式创建的；因此，当ProcessState::self()第一次被调用时，会新建ProcessState对象。在ProcessState的构造函数中，会先通过open_driver()打开”/dev/binder”，接着调用mmap()映射内存到当前进程中。此时，ProcessState就初始化完毕，它将”/dev/binder”的文件句柄以及映射内存都保存在自己的私有成员中。<br>在获取到ProcessState对象之后，会通过该对象调用getContextObject()来获取一个IBinder对象。getContextObject()会调用getStrongProxyForHandle(0)来获取”句柄0的强引用代理对象”，这里的句柄0被赋予了特殊意义；它就是ServiceManager的句柄，在Binder驱动中，若获取到句柄的值是0，则会将其目标当作是ServiceManager。getStrongProxyForHandle(0)会先通过lookupHandleLocked()在”ProcessState的矢量数组mHandleToObject”中查找句柄为0的对象；找不到的话，则新建句柄为0的对象，并将其添加到mHandleToObject矢量数组中；这样，下次再通过getStrongProxyForHandle()查找时，就能快速的找到。由此可见，mHandleToObject是ProcessState中保存句柄的缓冲数组。  随后，会新建句柄0对应的BpBinder对象，BpBinder是IBinder的代理；这里就获取到了ServiceManager的BpBinder代理对象。简而言之，getContextObject()的目的就是获取ServiceManager对应的BpBinder代理对象。 在新建BpBinder时，会通过IPCThreadState::self()获取IPCThreadState对象；因为，需要通过IPCThreadState对象来与Binder驱动进行交互。<br>前面已经成功获取到了ServiceManager的BpBinder代理，而defaultServiceManager()返回的是IServiceManager对象。这里，使用了一个技巧，通过宏interface_cast而调用asInterface()函数，从而返回IServiceManager的代理BpServiceManager。这样，defaultServiceManager()就执行完毕了。</iservicemanager></p>
<p>在上面的流程中，涉及到了比较多的类。下面通过类图理清它们之间的关系。</p>
<h2 id="2-defaultServiceManager相关类的类图"><a href="#2-defaultServiceManager相关类的类图" class="headerlink" title="2. defaultServiceManager相关类的类图"></a>2. defaultServiceManager相关类的类图</h2><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/defaultServiceManager_leitu.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/defaultServiceManager_leitu.jpg" alt></a></p>
<p>上面是获取defaultServiceManager()时涉及到的类的类图。defaultServiceManager()虽然在IServiceManager.cpp中实现，但它并不属于IServiceManager的成员方法，而是一个全局方法。</p>
<ol>
<li><p>RefBase<br>它定义在system/core/include/utils/RefBase.h中。RefBase是一个公共父类，它声明了许多常用的接口。包括增加引用计数，获取引用计数，新增对象的弱引用等接口。</p>
</li>
<li><p>IInterface<br>它定义在frameworks/native/include/binder/IInterface.h中。和RefBase类似，它也是一个公共父类，IInterface中声明了asBinder()方法，用于获取对象的IBinder对象。</p>
</li>
<li><p>IBinder<br>它定义在frameworks/native/include/binder/IBinder.h中。IBinder也是一个抽象出来的类，它包括了localBinder(), remoteBinder()和transact()等非常重要的接口。IBinder有两个直接子类类：BpBinder和BBinder。<br>BpBinder是Binder代理类。通过remoteBinder()可以获取BpBinder对象；而且，对于C++层而言，它相当于一个远程Binder。BpBinder的事务接口transact()会调用IPCThreadState的transact()，进而实现与Binder驱动的事务交互。此外，BpBinder中有一个mHandle句柄成员，它用来保存Server位于Binder驱动中的”Binder引用的描述”。句柄0是ServiceManager的句柄。<br>BBinder是本地Binder。通过localBinder()可以获取BBinder对象。当Server收到请求之后，会调用BBinder的onTransact()函数进行处理。而不同的Server会重载onTransact()函数，从而可以根据各自的情况对事务进行处理。</p>
</li>
</ol>
<ol start="4">
<li><p>BpInterface<br>它定义在frameworks/native/include/binder/IInterface.h中。实际上，BpInterface是一个<interface>模板类，同时继承了BpRefBase和INTERFACE，这里的INTERFACE是模板。像IServiceManager，IMediaPlayerService等Server都是通过继承模板类是实现的。  </interface></p>
</li>
<li><p>BnInterface<br>它定义在frameworks/native/include/binder/IInterface.h中。和BpInterface类似，BnInterface也是一个<interface>模板类，它同时继承了BBinder和INTERFACE。像BnServiceManager，BnMediaPlayerService等本地Server都是通过继承模板类是实现的。  </interface></p>
</li>
<li><p>BpRefBase<br>它定义在frameworks/native/include/binder/Binder.h中。BpRefBase继承于RefBase，它有一个IBinder*类型的成员mRemote，同时提供了获取该mRemote的方法。实际上，该mRemote就是BpBinder对象。</p>
</li>
<li><p>ProcessState<br>它定义在frameworks/native/libs/binder/ProcessState.cpp中中。ProcessState的实例是采用单例模式实现的，它拥有两个非常重要的成员：mDriverFD和mHandleToObject。<br>mDriverFD是文件”/dev/binder”的句柄，而mHandleToObject是一个Vector矢量数组，矢量数组中的每个元素都保存了两个变量：Server的句柄，以及Server对应的BpBinder对象。实际上，Server的句柄是”Server在Binder驱动中的Binder引用的描述”；句柄0是ServiceManager的句柄。 关于Binder引用，可以回顾<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。</p>
</li>
<li><p>IPCThreadState<br>它定义在frameworks/native/libs/binder/IPCThreadState.cpp中中。IPCThreadState的实例也是采用单例模式实现的，它是正在与Binder驱动进行交互的类。  </p>
</li>
</ol>
<br>
理解上面几个类的基本概念之后，现在在从整体上对它们进行一下介绍！  
对于一个Server而言，它都会存在一个"远程BpBinder对象"和"本地BBinder对象"。   
(01) 远程BpBinder对象的作用，是和Binder驱动进行交互。具体的方式是，当Server要向Binder发起事务请求时，会调用BpBinder的transact()接口，而该接口会调用到IPCThreadState::transact()接口，通过IPCThreadState类来和Binder驱动交互。此外，该BpBinder在Binder驱动中的Binder引用的描述会被保存到ProcessState的mHandleToObject矢量缓冲数组中。  
(02) 本地BBinder对象的作用，是Server响应Client请求的类。当Client有请求发送给Server时，都会调用到BBinder的onTransact()函数，而每个Server都会覆盖onTransact()函数。这样，每个Server就可以在onTransact()中根据自己的情况对请求进行处理。



<p><a name="anchor2"></a></p>
<h1 id="defaultServiceManager流程详解"><a href="#defaultServiceManager流程详解" class="headerlink" title="defaultServiceManager流程详解"></a>defaultServiceManager流程详解</h1><p>接下来通过源码来查看defaultServiceManager()的实现。通过源码分析，会对上面的类图有更清楚的认识！</p>
<p><a name="anchor2_1"></a></p>
<h2 id="1-defaultServiceManager"><a href="#1-defaultServiceManager" class="headerlink" title="1. defaultServiceManager()"></a>1. defaultServiceManager()</h2><pre><code>sp&lt;IServiceManager&gt; defaultServiceManager()
{
    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;

    {
        AutoMutex _l(gDefaultServiceManagerLock);
        while (gDefaultServiceManager == NULL) {
            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(
                ProcessState::self()-&gt;getContextObject(NULL));
            if (gDefaultServiceManager == NULL)
                sleep(1);
        }
    }

    return gDefaultServiceManager;
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/IServiceManager.cpp中。它是获取IServiceManager对象，该函数的声明在frameworks/native/include/binder/IServiceManager.h中。虽然defaultServiceManager()在IServiceManager.cpp文件中实现，但是它并不是IServiceManager的一个成员方法，而是一个全局方法。<br>(01) gDefaultServiceManagerLock是全局互斥锁，gDefaultServiceManager是全局的IServiceManager对象。它们都定义在frameworks/native/libs/binder/Static.cpp中。<br>(02) gDefaultServiceManager是采用单例模式实现的，第一次调用该函数时，会创建gDefaultServiceManager对象。gDefaultServiceManager的实现可以简化为以下语句：</p>
<pre><code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL));</code></pre><p>下面逐个对该语句中的代码进行解析。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-ProcessState-self"><a href="#2-ProcessState-self" class="headerlink" title="2. ProcessState::self()"></a>2. ProcessState::self()</h2><pre><code>sp&lt;ProcessState&gt; ProcessState::self()
{
    Mutex::Autolock _l(gProcessMutex);
    if (gProcess != NULL) {
        return gProcess;
    }
    gProcess = new ProcessState;
    return gProcess;
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中，它的作用是返回gProcess对象。gProcess也是单例模式对象，它也定义在frameworks/native/libs/binder/Static.cpp中。第一次执行self()时，会新建ProcessState对象。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="3-ProcessState-ProcessState"><a href="#3-ProcessState-ProcessState" class="headerlink" title="3. ProcessState::ProcessState()"></a>3. ProcessState::ProcessState()</h2><pre><code>ProcessState::ProcessState()
    : mDriverFD(open_driver())
    , mVMStart(MAP_FAILED)
    , mManagesContexts(false)
    , mBinderContextCheckFunc(NULL)
    , mBinderContextUserData(NULL)
    , mThreadPoolStarted(false)
    , mThreadPoolSeq(1)
{
    if (mDriverFD &gt;= 0) {
        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
        if (mVMStart == MAP_FAILED) {
            // *sigh*
            ALOGE(&quot;Using /dev/binder failed: unable to mmap transaction memory.\n&quot;);
            close(mDriverFD);
            mDriverFD = -1;
        }
    }
    ...
}</code></pre><p>说明：在ProcessState的构造函数中，它会进行一系列的初始化。比较重要的有如下两步。<br>(01) 通过open_driver()打开”/open/binder”，并将文件句柄赋值给mDriverFD。<br>(02) 通过调用mmap()映射内存。<br>下面，看看这两步的代码。</p>
<p><a name="anchor2_4"></a></p>
<h2 id="4-ProcessState-open-driver"><a href="#4-ProcessState-open-driver" class="headerlink" title="4. ProcessState::open_driver()"></a>4. ProcessState::open_driver()</h2><pre><code>static int open_driver()
{
    // 打开文件/dev/binder
    int fd = open(&quot;/dev/binder&quot;, O_RDWR);
    if (fd &gt;= 0) {
        fcntl(fd, F_SETFD, FD_CLOEXEC);
        int vers;
        // 检查/dev/binder的版本
        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);
        if (result == -1) {
            close(fd);
            ...
        }
        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {
            close(fd);
            ...
        }

        // 设置该进程最大线程数
        size_t maxThreads = 15;
        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);
        if (result == -1) {
            ...
        }
    } else {
        ...
    }
    return fd;
}</code></pre><p>说明：<br>(01) open_driver()首先打开”/dev/binder”文件。它会对应执行Binder驱动的binder_open()函数，该函数在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中已经详细介绍过了。<br>(02) 在成功打开文件之后，就会调用ioctl检查Binder版本，检查版本的部分非常简单(就是读取出版本号，判断读取的版本号与已有的版本号是否一样!)，这里就不再对Binder驱动的BINDER_VERSION进行展开了。<br>(03) 在检查版本通过之后，在调用ioctl(,BINDER_SET_MAX_THREADS,)设置该进程的最大线程数。它会对应调用Binder驱动的binder_ioctl()函数。    </p>
<p><strong>注意</strong>：要区分”此处的open(“/dev/binder”,…)” 和 “ServiceManager守护进程中的open(“/dev/binder”,…)”。它们分别是属于不同的进程，本文的open(“/dev/binder”,…)是属于调用defaultServiceManager()的进程；而在ServiceManager中的open(“/dev/binder”,…)是属于ServiceManager进程的。</p>
<h3 id="4-1-Binder驱动中binder-ioctl-的BINDER-SET-MAX-THREADS相关部分的源码"><a href="#4-1-Binder驱动中binder-ioctl-的BINDER-SET-MAX-THREADS相关部分的源码" class="headerlink" title="4.1 Binder驱动中binder_ioctl()的BINDER_SET_MAX_THREADS相关部分的源码"></a>4.1 Binder驱动中binder_ioctl()的BINDER_SET_MAX_THREADS相关部分的源码</h3><pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);

  // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。
  thread = binder_get_thread(proc);
  ...

  switch (cmd) {
    case BINDER_SET_MAX_THREADS:
        if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) {
            ret = -EINVAL;
            goto err;
        }
        break;

  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：BINDER_SET_MAX_THREADS的代码很简单，就是将最大线程数目从用户空间拷贝到内核空间，进而赋值给binder_proc-&gt;max_threads。</p>
<p><a name="anchor2_5"></a></p>
<h2 id="5-mmap"><a href="#5-mmap" class="headerlink" title="5. mmap()"></a>5. mmap()</h2><p>在执行完open_driver()之后，将调用mmap()映射内存到当前进程的虚拟地址空间。mmap()详细代码在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中已经详细分析过，这里就不再重复说明了。</p>
<p><br> 到目前为止，ProcessState::self()就分析完毕。gDefaultServiceManager的赋值语句可以进一步的简化：</p>
<pre><code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::getContextObject(NULL));</code></pre><p><a name="anchor2_6"></a></p>
<h2 id="6-ProcessState-getContextObject"><a href="#6-ProcessState-getContextObject" class="headerlink" title="6. ProcessState::getContextObject()"></a>6. ProcessState::getContextObject()</h2><pre><code>sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; caller)
{
    return getStrongProxyForHandle(0);
}</code></pre><p>说明：getContextObject()调用了getStrongProxyForHandle(0)。这里的0是代表Service Manager的句柄。</p>
<p><a name="anchor2_7"></a></p>
<h2 id="7-ProcessState-getStrongProxyForHandle"><a href="#7-ProcessState-getStrongProxyForHandle" class="headerlink" title="7. ProcessState::getStrongProxyForHandle()"></a>7. ProcessState::getStrongProxyForHandle()</h2><pre><code>sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp&lt;IBinder&gt; result;

    AutoMutex _l(mLock);

    // 在矢量数组mHandleToObject中查找&quot;句柄值为handle的handle_entry对象&quot;；
    // 找到的话，则直接返回；找不到的话，则新建handle对应的handle_entry，并将其添加到mHandleToObject中。
    handle_entry* e = lookupHandleLocked(handle);

    if (e != NULL) {
        IBinder* b = e-&gt;binder;
        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
            // 当handle==0(即是Service Manager的句柄)时，尝试去ping Binder驱动。
            if (handle == 0) {
                Parcel data;
                status_t status = IPCThreadState::self()-&gt;transact(
                        0, IBinder::PING_TRANSACTION, data, NULL, 0);
                if (status == DEAD_OBJECT)
                   return NULL;
            }

            // 新建BpBinder代理
            b = new BpBinder(handle);
            e-&gt;binder = b;
            if (b) e-&gt;refs = b-&gt;getWeakRefs();
            result = b;
        } else {
            ...
        }
    }

    return result;
}</code></pre><p>说明：getStrongProxyForHandle()的目的是返回句柄为handle的IBinder代理，这里是返回Service Manager的IBinder代理。<br>(01) lookupHandleLocked()，是在矢量数组mHandleToObject中查找是否有句柄为handle的handle_entry对象。有的话，则返回该handle_entry对象；没有的话，则新建handle对应的handle_entry，并将其添加到矢量数组mHandleToObject中，然后再返回。mHandleToObject是用于保存各个IBinder代理对象的矢量数组，它相当于一个缓冲。<br>(02) 很显然，此时e!=NULL为true，进入if(e!=NULL)中。而此时e-&gt;binder=NULL，并且handle=0；则调用IPCThreadState::self()-&gt;transact()尝试去和Binder驱动通信(尝试去ping内核中Binder驱动)。由于Binder驱动已启动，ping通信是能够成功的。ping通信涉及到”Binder机制中Server和Client的通信”，后面再专门对Server和Client的交互进行介绍；这里只要了解ping通信能够成功即可。<br>(03) 接着，新建BpBinder对象，并赋值给e-&gt;binder。然后，将该BpBinder对象返回。</p>
<p>上面对流程进行了整体介绍，下面逐个进行分析！</p>
<p><a name="anchor2_8"></a></p>
<h2 id="8-ProcessState-lookupHandleLocked"><a href="#8-ProcessState-lookupHandleLocked" class="headerlink" title="8. ProcessState::lookupHandleLocked()"></a>8. ProcessState::lookupHandleLocked()</h2><pre><code>ProcessState::handle_entry* ProcessState::lookupHandleLocked(int32_t handle)
{               
    const size_t N=mHandleToObject.size();
    if (N &lt;= (size_t)handle) {
        handle_entry e;
        e.binder = NULL;
        e.refs = NULL;
        status_t err = mHandleToObject.insertAt(e, N, handle+1-N);
        if (err &lt; NO_ERROR) return NULL;
    }   
    return &amp;mHandleToObject.editItemAt(handle);
}           </code></pre><p>说明：mHandleToObject是Vector矢量数组。mHandleToObject的初始大小为0，因此if (N &lt;= handle)为true。接下来，就新建handle_entry，并将其添加到mHandleToObject中，然后返回该handle_entry。mHandleToObject和handle_entry的定义如下：</p>
<pre><code>class ProcessState : public virtual RefBase
{
    ...
private:
    ...
    struct handle_entry {
        IBinder* binder;
        RefBase::weakref_type* refs;
    };

    ...

    Vector&lt;handle_entry&gt;mHandleToObject;
    ...
}</code></pre><p>说明：该代码定义在frameworks/native/include/binder/ProcessState.h中。前面说过，mHandleToObject是个缓冲矢量数组。它的成员binder是保存的Server的BpBinder对象，而refs是保存的Server在Binder驱动中的Binder引用的描述。</p>
<p><a name="anchor2_9"></a></p>
<h2 id="9-BpBinder-BpBinder"><a href="#9-BpBinder-BpBinder" class="headerlink" title="9. BpBinder::BpBinder"></a>9. BpBinder::BpBinder</h2><p>new BpBinder(0)会新建BpBinder对象，下面看看BpBinder的构造函数。</p>
<pre><code>BpBinder::BpBinder(int32_t handle)
    : mHandle(handle)
    , mAlive(1)
    , mObitsSent(0)
    , mObituaries(NULL)
{
    ALOGV(&quot;Creating BpBinder %p handle %d\n&quot;, this, mHandle);

    extendObjectLifetime(OBJECT_LIFETIME_WEAK);
    IPCThreadState::self()-&gt;incWeakHandle(handle);
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/BpBinder.cpp中。主要工作是初始化。<br>(01) 将句柄handle保存到私有成员mHandle中。这里是将ServiceManager的句柄保存到mHandle中。<br>(02) 增加IPCThreadState的引用计数。IPCThreadState::self()是获取IPCThreadState对象，实际上，在前面介绍的ProcessState::getStrongProxyForHandle()中已经调用过该函数。下面看看它的代码。</p>
<p><a name="anchor2_10"></a></p>
<h2 id="10-IPCThreadState-self"><a href="#10-IPCThreadState-self" class="headerlink" title="10. IPCThreadState::self()"></a>10. IPCThreadState::self()</h2><pre><code>static pthread_mutex_t gTLSMutex = PTHREAD_MUTEX_INITIALIZER;
static bool gHaveTLS = false;
static pthread_key_t gTLS = 0;
static bool gShutdown = false;
static bool gDisableBackgroundScheduling = false;

IPCThreadState* IPCThreadState::self()
{
    if (gHaveTLS) {
restart:
        const pthread_key_t k = gTLS;
        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);
        if (st) return st;
        return new IPCThreadState;
    }

    if (gShutdown) return NULL;

    pthread_mutex_lock(&amp;gTLSMutex);
    if (!gHaveTLS) {
        if (pthread_key_create(&amp;gTLS, threadDestructor) != 0) {
            pthread_mutex_unlock(&amp;gTLSMutex);
            return NULL;
        }
        gHaveTLS = true;
    }
    pthread_mutex_unlock(&amp;gTLSMutex);
    goto restart;
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/IPCThreadState.cpp中。self()的源码比较简单，它的作用是获取IPCThreadState对象。若该对象已经存在，则直接返回；否则，新建IPCThreadState对象。</p>
<p><a name="anchor2_11"></a></p>
<h2 id="11-IPCThreadState-IPCThreadState"><a href="#11-IPCThreadState-IPCThreadState" class="headerlink" title="11. IPCThreadState::IPCThreadState()"></a>11. IPCThreadState::IPCThreadState()</h2><pre><code>IPCThreadState::IPCThreadState()
    : mProcess(ProcessState::self()),
      mMyThreadId(androidGetTid()),
      mStrictModePolicy(0),
      mLastTransactionBinderFlags(0)
{
    pthread_setspecific(gTLS, this);
    clearCaller();
    mIn.setDataCapacity(256);
    mOut.setDataCapacity(256);
}</code></pre><p>说明：<br>(01) 获取ProcessState对象，并将其赋值给成员mProcess。ProcessState::self()在前面已经介绍国，它是获取全局的ProcessState对象。<br>(02) 设置mIn和mOut的容量为256字节。IPCThreadState是和Binder驱动交互的类，mOut是用来保存”IPCThreadState需要发送给Binder驱动的内容的”，而mIn则是用来保存”Binder驱动反馈给IPCThreadState的内容的”。后面在介绍”Server和Client”通信中用到它们时，再进一步说明。</p>
<br>
到目前为止，ProcessState::getContextObject()就分析完了。gDefaultServiceManager的赋值语句可以进一步的简化：

<pre><code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(new BpBinder(0));</code></pre><p>接下来，看看interface_cast<iservicemanager>。</iservicemanager></p>
<p><a name="anchor2_12"></a></p>
<h2 id="12-interface-cast"><a href="#12-interface-cast" class="headerlink" title="12. interface_cast()"></a>12. interface_cast()</h2><pre><code>template&lt;typename INTERFACE&gt;
inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)
{
    return INTERFACE::asInterface(obj);
}   </code></pre><p>说明：该代码在frameworks/native/include/binder/IInterface.h中。它是一个模板函数，对于interface_cast<iservicemanager>而言，返回的结果是IServiceManager::asInterface()。</iservicemanager></p>
<p><a name="anchor2_13"></a></p>
<h2 id="13-IServiceManager-asInterface"><a href="#13-IServiceManager-asInterface" class="headerlink" title="13. IServiceManager::asInterface()"></a>13. IServiceManager::asInterface()</h2><p>接下来，就是查找IServiceManager::asInterface()的实现了。在IServiceManager.cpp中不存在，追踪代码，发现asInterface()是通过DECLARE_META_INTERFACE()来声明，并通过IMPLEMENT_META_INTERFACE()来实现的。</p>
<p>(01) IServiceManager中的DECLARE_META_INTERFACE()声明和IMPLEMENT_META_INTERFACE()实现，分别在头文件frameworks/native/include/binder/IServiceManager.h 以及 frameworks/native/libs/binder/IServiceManager.cpp中。</p>
<pre><code>// IServiceManager.h中的声明
class IServiceManager : public IInterface
{
public:
    DECLARE_META_INTERFACE(ServiceManager);
    ...
}

// IServiceManager.pp中的实现
IMPLEMENT_META_INTERFACE(ServiceManager, &quot;android.os.IServiceManager&quot;);</code></pre><p>(02) DECLARE_META_INTERFACE()和IMPLEMENT_META_INTERFACE()的定义在frameworks/native/include/binder/IInterface.h中。 </p>
<pre><code>#define DECLARE_META_INTERFACE(INTERFACE)                               \
    static const android::String16 descriptor;                          \
    static android::sp&lt;I##INTERFACE&gt; asInterface(                       \
            const android::sp&lt;android::IBinder&gt;&amp; obj);                  \
    virtual const android::String16&amp; getInterfaceDescriptor() const;    \
    I##INTERFACE();                                                     \
    virtual ~I##INTERFACE();                                            \

#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \
    const android::String16 I##INTERFACE::descriptor(NAME);             \
    const android::String16&amp;                                            \
            I##INTERFACE::getInterfaceDescriptor() const {              \
        return I##INTERFACE::descriptor;                                \
    }                                                                   \
    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                \
            const android::sp&lt;android::IBinder&gt;&amp; obj)                   \
    {                                                                   \
        android::sp&lt;I##INTERFACE&gt; intr;                                 \
        if (obj != NULL) {                                              \
            intr = static_cast&lt;I##INTERFACE*&gt;(                          \
                obj-&gt;queryLocalInterface(                               \
                        I##INTERFACE::descriptor).get());               \
            if (intr == NULL) {                                         \
                intr = new Bp##INTERFACE(obj);                          \
            }                                                           \
        }                                                               \
        return intr;                                                    \
    }                                                                   \
    I##INTERFACE::I##INTERFACE() { }                                    \
    I##INTERFACE::~I##INTERFACE() { }                                   \


#define CHECK_INTERFACE(interface, data, reply)                         \
    if (!data.checkInterface(this)) { return PERMISSION_DENIED; }       \</code></pre><p>用ServiceManager替换INTERFACE之后，得到结果如下：<br>IMPLEMENT_META_INTERFACE(ServiceManager, “android.os.IServiceManager”);</p>
<pre><code>#define DECLARE_META_INTERFACE(IServiceManager)                         \
    static const android::String16 descriptor;                          \
    static android::sp&lt;IServiceManager&gt; asInterface(                    \
            const android::sp&lt;android::IBinder&gt;&amp; obj);                  \
    virtual const android::String16&amp; getInterfaceDescriptor() const;    \
    IServiceManager();                                                  \
    virtual ~IServiceManager();                                         \


#define IMPLEMENT_META_INTERFACE(IServiceManager, &quot;android.os.IServiceManager&quot;)        \
    const android::String16 IServiceManager::descriptor(&quot;android.os.IServiceManager&quot;); \
    const android::String16&amp;                                                           \
            IServiceManager::getInterfaceDescriptor() const {                          \
        return IServiceManager::descriptor;                                            \
    }                                                                                  \
    android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(                         \
            const android::sp&lt;android::IBinder&gt;&amp; obj)                                  \
    {                                                                                  \
        android::sp&lt;IServiceManager&gt; intr;                                             \
        if (obj != NULL) {                                                             \
            intr = static_cast&lt;IServiceManager*&gt;(                                      \
                obj-&gt;queryLocalInterface(                                              \
                        IServiceManager::descriptor).get());                           \
            if (intr == NULL) {                                                        \
                intr = new BpServiceManager(obj);                                      \
            }                                                                          \
        }                                                                              \
        return intr;                                                                   \
    }                                                                                  \
    IServiceManager::IServiceManager() { }                                             \
    IServiceManager::~IServiceManager() { }</code></pre><p>因此，得到IServiceManager::asInterface()的源码如下：</p>
<pre><code>android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(const android::sp&lt;android::IBinder&gt;&amp; obj)
{
    android::sp&lt;IServiceManager&gt; intr;
    if (obj != NULL) {
        intr = static_cast&lt;IServiceManager*&gt;(
            obj-&gt;queryLocalInterface(
                    IServiceManager::descriptor).get());
        if (intr == NULL) {
            intr = new BpServiceManager(obj);
        }
    }
    return intr;
}</code></pre><p>说明：asInterface()的作用是获取IServiceManager接口。<br>(01) obj是传入的BpBinder对象，不为NULL。因此，执行obj-&gt;queryLocalInterface(“android.os.IServiceManager”)来查找名称为”android.os.IServiceManager”的本地接口，queryLocalInterface()的实现在BpBinder的父类IBinder中，具体在文件frameworks/native/libs/binder/Binder.cpp中。很显然，IServiceManager接口还没创建，因此intr=NULL。<br>(02) 新建BpServiceManager(obj)对象，并返回。BpServiceManager的实现在frameworks/native/libs/binder/IServiceManager.cpp中。  </p>
<pre><code>sp&lt;IInterface&gt;  IBinder::queryLocalInterface(const String16&amp; descriptor)
{   
    return NULL;
}   </code></pre><br>
到目前为止，gDefaultServiceManager的创建流程就分析完了，它实际返回的是一个BpServiceManager对象，该对象包含IBinder的代理BpBinder。以下是转换后的获取gDefaultServiceManager的语句。

<pre><code>gDefaultServiceManager = new BpServiceManager(new BpBinder(0));</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/03/android/os/binder/2014-09-03-Binder-ServiceManager-Daemon/" itemprop="url">Android Binder机制(三) ServiceManager守护进程</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-03T01:01:00.000Z" itemprop="datePublished">9月 3 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 read (About 8281 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>ServiceManager是用户空间的一个守护进程，它一直运行在后台。它的职责是管理Binder机制中的各个Server。当Server启动时，Server会将”Server对象的名字”连同”Server对象的信息”一起注册到ServiceManager中；而当Client需要获取Server接入点时，则通过”Server的名字”来从ServiceManager中找到对应的Server。<br>本文的主要内容就是对ServiceManager进行介绍，通过它的启动流程来分析它是如何成为Server管理者的。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor_1st">ServiceManager流程图</a><br><strong>2</strong>. <a href="#anchor_2nd">ServiceManager流程详解</a><br><strong>2.1</strong>. <a href="#anchor1">main()</a><br><strong>2.2</strong>. <a href="#anchor2">binder_open()</a><br><strong>2.3</strong>. <a href="#anchor3">open(“/dev/binder”)</a><br><strong>2.4</strong>. <a href="#anchor4">mmap()</a><br><strong>2.5</strong>. <a href="#anchor5">binder_become_context_manager()</a><br><strong>2.6</strong>. <a href="#anchor6">ioctl(, BINDER_SET_CONTEXT_MGR,)</a><br><strong>2.7</strong>. <a href="#anchor7">binder_loop()</a><br><strong>2.8</strong>. <a href="#anchor8">for(;;)</a><br><strong>3</strong>. <a href="#anchor_3rd">ServiceManager流程总结</a>  </p>
</blockquote>
<p><a name="anchor_1st"></a></p>
<h1 id="ServiceManager流程图"><a href="#ServiceManager流程图" class="headerlink" title="ServiceManager流程图"></a>ServiceManager流程图</h1><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/ServiceManager.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/ServiceManager.jpg" alt></a></p>
<p>上面是ServiceManager的时序图。它启动之后，会先打开”/dev/binder”文件(“/dev/binder”是Binder驱动注册的设备节点)。打开文件之后，再告诉Binder驱动，它是Binder的上下文管理者。之后，就进入到了消息循环中。进入消息循环之后，会不断的从Binder的待处理事务队列中读取事务(Binder请求或反馈)，读出事务之后就进行解析，然后交给相应的进程进行处理。若没有事务，则进入等待状态，等待被唤醒。</p>
<p><a name="anchor_2nd"></a></p>
<h1 id="ServiceManager流程详解"><a href="#ServiceManager流程详解" class="headerlink" title="ServiceManager流程详解"></a>ServiceManager流程详解</h1><p><a name="anchor1"></a></p>
<h2 id="1-main"><a href="#1-main" class="headerlink" title="1. main()"></a>1. main()</h2><p>ServiceManager是一个守护进程。它的main()函数源码如下：</p>
<pre><code>int main(int argc, char **argv)
{
    struct binder_state *bs;
    void *svcmgr = BINDER_SERVICE_MANAGER;

    bs = binder_open(128*1024);

    if (binder_become_context_manager(bs)) {
        ALOGE(&quot;cannot become context manager (%s)\n&quot;, strerror(errno));
        return -1; 
    }   

    svcmgr_handle = svcmgr;
    binder_loop(bs, svcmgr_handler);
    return 0;
}</code></pre><p>说明：该代码在frameworks/native/cmds/servicemanager/service_manager.c中。main()主要进行了三项工作：<br>(01) 通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。<br>(02) 调用binder_become_context_manager()，通过ioctl()告诉Binder驱动程序自己是Binder上下文管理者。<br>(03) 调用binder_loop()进入消息循环，等待Client的请求。如果没有Client请求，则进入中断等待状态；当有Client请求时，就被唤醒，然后读取并处理Client请求。  </p>
<blockquote>
<p>ServiceManager是如何启动的？<br>这里简要介绍一下ServiceManager的启动方式。当Kernel启动加载完驱动之后，会启动Android的init程序，init程序会解析init.rc，进而启动init.rc中定义的守护进程。而ServiceManager则正是通过注册在init.rc中，而被启动的。 </p>
</blockquote>
<p><a name="anchor2"></a></p>
<h2 id="2-binder-open"><a href="#2-binder-open" class="headerlink" title="2. binder_open()"></a>2. binder_open()</h2><p>下面，对main()的逐个步骤进行详细分析。先看看binder_open()，代码如下：</p>
<pre><code>struct binder_state *binder_open(unsigned mapsize)
{
    struct binder_state *bs;

    bs = malloc(sizeof(*bs));
    ...

    bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR);
    ...

    bs-&gt;mapsize = mapsize;
    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0); 
    ...

    return bs;
}</code></pre><p>说明： 该代码定义在frameworks/native/cmds/servicemanager/binder.c中。binder_open的作用是打开”/dev/binder”设备文件，然后调用mmap()将设备文件”/dev/binder”映射到进程空间的起始地址。<br>(01) open(“/dev/binder”, O_RDWR)对应会调用驱动的open函数。<br>(02) mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0)对应会调用驱动的mmap函数。第一个参数是映射内存的起始地址，NULL代表让系统自动选定地址；mapsize大小是128*1024B，即128K；PROT_READ表示映射区域是可读的；MAP_PRIVATE表示建立一个写入时拷贝的私有映射，即，当进程中对该内存区域进行写入时，是写入到映射的拷贝中；bs-&gt;fd是”/dev/binder”句柄；而0表示偏移。<br>(03) binder_state结构体是来保存/dev/binder设备信息的。其中，fd是用来保存文件句柄，mmaped是映射内存的起始地址，mapsize映射内存大小。</p>
<p><a name="anchor3"></a></p>
<h2 id="3-open-“-dev-binder”"><a href="#3-open-“-dev-binder”" class="headerlink" title="3. open(“/dev/binder”)"></a>3. open(“/dev/binder”)</h2><h3 id="3-1-Binder驱动注册信息"><a href="#3-1-Binder驱动注册信息" class="headerlink" title="3.1 Binder驱动注册信息"></a>3.1 Binder驱动注册信息</h3><p>下面看看open(“/dev/binder”, O_RDWR)到底做了些什么。先看看下面的代码：</p>
<pre><code>static const struct file_operations binder_fops = {
  .owner = THIS_MODULE,
  .poll = binder_poll,
  .unlocked_ioctl = binder_ioctl,
  .mmap = binder_mmap,
  .open = binder_open,
  .flush = binder_flush,
  .release = binder_release,
};

static struct miscdevice binder_miscdev = {
  .minor = MISC_DYNAMIC_MINOR,
  .name = &quot;binder&quot;,
  .fops = &amp;binder_fops
};

static int __init binder_init(void)
{
    ...
    ret = misc_register(&amp;binder_miscdev);
    ...
}

device_initcall(binder_init);</code></pre><p>说明：上面是Kernel中Binder驱动代码，定义在drivers/staging/android/binder.c中。<br>(01) device_initcall(binder_init)的作用是将binder_init()函数注册到Kernel的初始化函数列表中。当Kernel启动后，会按照一定的次序调用初始化函数列表，也就会执行binder_init()函数；执行binder_init()时便会加载Binder驱动。<br>(02) binder_init()函数中会通过misc_register(&amp;binder_miscdev)将Binder驱动注册到文件节点”/dev/binder”上。在Linux中，一切都是文件！将Binder驱动注册到文件节点上之后，就可以通过操作文件节点进而对Binder驱动进行操作。而该文件节点”/dev/binder”的设备信息是binder_miscdev这个结构体对象。<br>(03) binder_miscdev变量是struct miscdevice类型。minor是次设备号，这个我们不需要关心；name是Binder驱动对应在/dev虚拟文件系统下的设备节点名称，也就是/dev/binder中的”binder”；fops是该设备节点的文件操作对象，它是我们需要重点关注的！fops指向binder_fops变量。<br>(04) binder_fops变量是struct file_operations类型。owner是标明了该文件操作变量的拥有者，就是该驱动；poll则指定了poll函数指针，当我们对/dev/binder文件节点执行poll()操作时，实际上就是调用的binder_poll()函数；同理，mmap()对应binder_mmap()，open()对应binder_open()，ioctl()对应binder_ioctl()…</p>
<h3 id="3-2-Binder驱动中的binder-open-函数源码"><a href="#3-2-Binder驱动中的binder-open-函数源码" class="headerlink" title="3.2 Binder驱动中的binder_open()函数源码"></a>3.2 Binder驱动中的binder_open()函数源码</h3><p>经过上面的介绍，我们可以知道open(“/dev/binder”, O_RDWR)实际上是调用Binder驱动中的binder_open()函数。  </p>
<pre><code>static HLIST_HEAD(binder_procs);
...

static int binder_open(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc;

    binder_debug(BINDER_DEBUG_OPEN_CLOSE, &quot;binder_open: %d:%d\n&quot;,
           current-&gt;group_leader-&gt;pid, current-&gt;pid);

    // 为proc分配内存
    proc = kzalloc(sizeof(*proc), GFP_KERNEL);
    if (proc == NULL)
      return -ENOMEM;
    get_task_struct(current);
    // 将proc-&gt;tsk指向当前线程
    proc-&gt;tsk = current;
    // 初始化proc的待处理事务列表
    INIT_LIST_HEAD(&amp;proc-&gt;todo);
    // 初始化proc的等待队列
    init_waitqueue_head(&amp;proc-&gt;wait);
    // 设置proc的进程优先级为当前线程的优先级
    proc-&gt;default_priority = task_nice(current);

    binder_lock(__func__);

    binder_stats_created(BINDER_STAT_PROC);
    // 将该进程上下文信息proc保存到&quot;全局哈希表binder_procs&quot;中
    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);
    // 设置进程id
    proc-&gt;pid = current-&gt;group_leader-&gt;pid;
    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);
    // 将proc添加到私有数据中。
    // 这样，mmap(),ioctl()等函数都可以通过私有数据获取到proc，即该进程的上下文信息
    filp-&gt;private_data = proc;

    binder_unlock(__func__);

    if (binder_debugfs_dir_entry_proc) {
      char strbuf[11];
      snprintf(strbuf, sizeof(strbuf), &quot;%u&quot;, proc-&gt;pid);
      proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,
          binder_debugfs_dir_entry_proc, proc, &amp;binder_proc_fops);
    }

    return 0;
}</code></pre><p>说明：binder_proc是记录进程上下文信息的结构体，它的详细介绍请参考<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。该函数的作用如下。<br>(01) 创建并初始化binder_proc结构体变量proc。binder_proc是描述Binder进程的上下文信息结构体。这里，就是将ServiceManager这个进程的信息都存储到proc中。<br>(02) 将proc添加到全局哈希表binder_procs中。binder_procs不是我们关注的重点，也就不多说了。<br>(03) 将proc设为filp的私有成员。这样，在mmap()，ioctl()等函数中，我们都可以根据filp的私有成员来获取proc信息。  </p>
<p><a name="anchor4"></a></p>
<h2 id="4-mmap"><a href="#4-mmap" class="headerlink" title="4. mmap()"></a>4. mmap()</h2><p>分析完了open()，接下来看看mmap()。mmap()对应会调用Binder驱动的binder_mmap()函数。</p>
<h3 id="4-1-Binder驱动中的binder-mmap-源码"><a href="#4-1-Binder驱动中的binder-mmap-源码" class="headerlink" title="4.1 Binder驱动中的binder_mmap()源码"></a>4.1 Binder驱动中的binder_mmap()源码</h3><pre><code>static int binder_mmap(struct file *filp, struct vm_area_struct *vma)
{
  int ret;
  struct vm_struct *area;
  struct binder_proc *proc = filp-&gt;private_data;
  const char *failure_string;
  struct binder_buffer *buffer;

  // 有效性检查：映射的内存不能大于4M
  if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)
      vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;

  ...

  vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;

  mutex_lock(&amp;binder_mmap_lock);

  // 获取空闲的内核空间地址
  area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);
  ...

  // 将内核空间地址赋值给proc-&gt;buffer，即保存到进程上下文中
  proc-&gt;buffer = area-&gt;addr;
  // 计算 &quot;内核空间地址&quot; 和 &quot;进程虚拟地址&quot; 的偏移
  proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;
  mutex_unlock(&amp;binder_mmap_lock);

  // 为proc-&gt;pages分配内存
  proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);
  ...

  // 内核空间的内存大小 = 进程虚拟地址区域(用户空间)的内存大小
  proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;

  vma-&gt;vm_ops = &amp;binder_vm_ops;
  // 将 proc(进程上下文信息) 赋值给vma私有数据
  vma-&gt;vm_private_data = proc;

  // 通过调用binder_update_page_range()来分配物理页面。
  // 即，将物理内存映射到内核空间 以及 用户空间
  if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) {
      goto err_alloc_small_buf_failed;
  }
  buffer = proc-&gt;buffer;
  INIT_LIST_HEAD(&amp;proc-&gt;buffers);
  // 将物理内存添加到proc-&gt;buffers链表中进行管理。
  list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);
  buffer-&gt;free = 1;
  binder_insert_free_buffer(proc, buffer);
  proc-&gt;free_async_space = proc-&gt;buffer_size / 2;
  barrier();
  proc-&gt;files = get_files_struct(proc-&gt;tsk);
  // 将用户空间地址信息保存到proc中
  proc-&gt;vma = vma;
  proc-&gt;vma_vm_mm = vma-&gt;vm_mm;

  return 0;
  ...
}</code></pre><p>说明：mmap的作用是进行内存映射。当应用调用mmap()映射内存到进程虚拟地址时，该函数会进行两个操作：第一，将指定大小的”物理内存” 映射到 “用户空间”(即，进程的虚拟地址中)。 第二，将该”物理内存” 也映射到 “内核空间(即，内核的虚拟地址中)”。<br>  简单来说，就是”将进程虚拟地址空间和内核虚拟地址空间映射同一个物理页面”。为什么要这么做呢？这就是Binder进程间通信机制的精髓所在了！在讲解之前，先回顾一下进程间通信的基础知识。</p>
<blockquote>
<p>在32位Linux系统的内存地址划分中，0<del>3G为用户空间，3</del>4G为内核空间。应用程序都运行在用户空间，而kernel和驱动都运行在内核空间。应用程序之间若涉及到数据交换(例如，Client进程向Server进程发送请求)，即进程间通信，需要使用管道/消息队列/Socket/共享内存等IPC机制。共享内存控制比较复杂，而Socket常用于网络通信，这里将它们排除；剩下的就是管道/消息队列。下面对管道/消息队列的IPC等通信方式进行介绍。假如现在采用管道/消息队列从Client向Server发送请求，需要先将Client进程的数据拷贝到内核空间，然后再从内核空间拷贝到Server进程中。这其中，总共涉及到了2次内存拷贝！<br>而Binder机制则只需要进行1次内存拷贝即可！</p>
</blockquote>
<p>在Binder通信机制中，mmap()会将Server进程的虚拟地址和内核虚拟地址映射到同一个物理页面。那么当Client进程向Server进程发送请求时，只需要将Client的数据拷贝到内核空间即可！由于Server进程的地址和内核空间映射到同一个物理页面，因此，Client中的数据拷贝到内核空间时，也就相当于拷贝到了Server进程中。因此，Binder通信机制中，数据传输时，只需要1次内存拷贝！</p>
<br>
有了上面的理论基础，再来看mmap()是如何实现的。  
(01) proc = flip->private_data。该flip的私有数据是在binder_open()中设置的，这里通过该私有数据就获取binder_proc变量proc。  
(02) area = get_vm_area(vma->vm_end - vma->vm_start, VM_IOREMAP)。 它的作用是从内核虚拟地址中，获取指定大小的空闲地址，将空闲地址的起始地址赋值给area。 area是vm_struct类型，vm_struct是描述内核虚拟地址信息的结构体。此外，vm_area_struct则是描述进程虚拟地址信息的结构体。  
(03) 接着，给proc->buffer(内核空间地址)，proc->user_buffer_offset(内核空间地址和进程虚拟地址的偏移值)，proc->pages(内核空间所占物理页面的数目)，proc->buffer_size(内核地址空间的大小)赋值。  
(04) 然后，调用binder_update_page_range(proc, 1, proc->buffer, proc->buffer + PAGE_SIZE, vma)。它作用是分配物理内存，下面看看它的实现。  


<h3 id="4-2-Binder驱动中的binder-update-page-range-源码"><a href="#4-2-Binder驱动中的binder-update-page-range-源码" class="headerlink" title="4.2 Binder驱动中的binder_update_page_range()源码"></a>4.2 Binder驱动中的binder_update_page_range()源码</h3><pre><code>static int binder_update_page_range(struct binder_proc *proc, int allocate,
                  void *start, void *end,
                  struct vm_area_struct *vma)
{
  void *page_addr;
  unsigned long user_page_addr;
  struct vm_struct tmp_area;
  struct page **page;

  ...

  // 分配物理页面，
  // 并将&quot;内核空间&quot;和&quot;用户空间(进程的内存区域)&quot;指向同一块物理内存。
  for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) {
      int ret;
      struct page **page_array_ptr;
      page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];

      // 分配物理页面
      *page = alloc_page(GFP_KERNEL | __GFP_ZERO);
      ...

      tmp_area.addr = page_addr;
      tmp_area.size = PAGE_SIZE + PAGE_SIZE /* guard page? */;
      page_array_ptr = page;
      // 将物理页面映射到内核空间中
      ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr);
      ...

      user_page_addr =
          (uintptr_t)page_addr + proc-&gt;user_buffer_offset;
      // 将物理页面映射插入到进程的虚拟内存中
      ret = vm_insert_page(vma, user_page_addr, page[0]);
      ...
  }

  return 0;

  ...
}</code></pre><p>说明： binder_update_page_range()既可分配物理页面，也可以释放物理页面。当参数allocate=1时，会执行分配物理页面的操作；否则，会执行释放物理页面的操作。这里，allocate=1；因此，我们只关心分配物理页面的部分。<br>在for循环中，每分配一个物理页面都会先通过map_vm_area()将该物理内存映射到内核虚拟地址中；然后再将该物理页面插入到进程的虚拟地址空间。</p>
<p><br>至此，binder_open(128<em>1024)算是介绍完了。从”用户空间的ServiceManager进程” 和 “Binder驱动”这两个方面分析它的作用。<br>(01) *</em>ServiceManager进程<strong>：就是打开/dev/binder，同时映射物理内存到进程空间。<br>(02) **Binder驱动</strong>：新建并初始化该进程对应的binder_proc结构体，同时将内核虚拟地址和该进程的虚拟地址映射到同一物理内存中。</p>
<p><a name="anchor5"></a></p>
<h2 id="5-binder-become-context-manager"><a href="#5-binder-become-context-manager" class="headerlink" title="5. binder_become_context_manager()"></a>5. binder_become_context_manager()</h2><p>下面接着分析binder_become_context_manager(bs)。</p>
<pre><code>int binder_become_context_manager(struct binder_state *bs)
{
    return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);
}</code></pre><p>说明：根据前面介绍的Binder驱动初始化信息可知，ioctl()就是调用Binder驱动中的binder_ioctl()函数。 </p>
<p><a name="anchor6"></a></p>
<h2 id="6-ioctl-BINDER-SET-CONTEXT-MGR"><a href="#6-ioctl-BINDER-SET-CONTEXT-MGR" class="headerlink" title="6. ioctl(, BINDER_SET_CONTEXT_MGR,)"></a>6. ioctl(, BINDER_SET_CONTEXT_MGR,)</h2><h3 id="6-1-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#6-1-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="6.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>6.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h3><pre><code>// 全局binder实体，准确点说是ServiceManager的binder实体
static struct binder_node *binder_context_mgr_node;
// ServiceManager守护进程的uid
static uid_t binder_context_mgr_uid = -1;
static int binder_stop_on_user_error;
...

static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  // 中断等待函数。
  // 1. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。
  // 2. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。
  //    当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时；
  //    则继续执行；否则，再进入等待状态。
  ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
  ...

  binder_lock(__func__);
  // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。
  thread = binder_get_thread(proc);
  ...

  switch (cmd) {
  ...

  case BINDER_SET_CONTEXT_MGR:
      if (binder_context_mgr_node != NULL) {
          ...
      }
      if (binder_context_mgr_uid != -1) {
          ...
      } else
          // 设置ServiceManager对应的uid
          binder_context_mgr_uid = current-&gt;cred-&gt;euid;

      // 新建binder实体，并将proc进程上下文信息保存到binder实体中；
      // 然后，将该binder实体赋值给全局变量binder_context_mgr_node。
      // 这个全局的binder实体，是ServiceManager对应的binder实体。
      binder_context_mgr_node = binder_new_node(proc, NULL, NULL);
      ...

      // 设置binder实体的引用计数等参数
      binder_context_mgr_node-&gt;local_weak_refs++;
      binder_context_mgr_node-&gt;local_strong_refs++;
      binder_context_mgr_node-&gt;has_strong_ref = 1;
      binder_context_mgr_node-&gt;has_weak_ref = 1;
      break;
  ...

  }
  ret = 0;

err:
  // 去掉thread的BINDER_LOOPER_STATE_NEED_RETURN标记
  if (thread)
      thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;
  binder_unlock(__func__);
  wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
  ...

  return ret;
}</code></pre><p>说明：binder_ioctl()的内容很多，上面仅仅列出与BINDER_SET_CONTEXT_MGR相关的代码。<br>(01) proc = flip-&gt;private_data。该flip的私有数据是在binder_open()中设置的，这里通过该私有数据就获取binder_proc变量proc。<br>(02) 接着调用wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2)。由于binder_stop_on_user_error是全局变量，它的初始值是0，因此binder_stop_on_user_error &lt; 2为true，不进入中断等待，而是直接跳过该函数继续运行。<br>(03) binder_get_thread()会在proc中查找当前线程对应的binder_thread结构体；由于之前还未创建该线程的binder_thread结构体，因此查找失败。进而创建一个binder_thread结构体变量，并将其添加到proc-&gt;threads红黑树中，然后返回该变量。<br>(04) cmd的值是我们调用ioctl()传入的参数BINDER_SET_CONTEXT_MGR。在BINDER_SET_CONTEXT_MGR分支中，会设置binder_context_mgr_uid，binder_context_mgr_uid是一个全局变量，它代表ServiceManager对应的uid；接着，通过binder_new_node()新建一个Binder实体(即binder_node结构体对象)，并将该Binder实体赋值给全局变量binder_context_mgr_node，binder_context_mgr_node就是Serveice Manager对应的Binder实体；最后，设置binder实体的引用计数等参数。<br>(05) 清除thread-&gt;looper的BINDER_LOOPER_STATE_NEED_RETURN标记。这个BINDER_LOOPER_STATE_NEED_RETURN标记，是在调用binder_get_thread()中创建binder_thread对象时添加的。  </p>
<p>关于binder_node结构体，在<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>中有消息的介绍。特别需要了解的是，对于每一个Server，Binder驱动都会为其分配一个binder_node对象。对于ServiceManager这个Binder上下文管理者而言，Binder驱动更是会将它的Binder实体保存到全局变量中。</p>
<h3 id="6-2-Binder驱动中的binder-get-thread-源码"><a href="#6-2-Binder驱动中的binder-get-thread-源码" class="headerlink" title="6.2 Binder驱动中的binder_get_thread()源码"></a>6.2 Binder驱动中的binder_get_thread()源码</h3><p>下面看看binder_get_thread()中做了什么。</p>
<pre><code>static struct binder_thread *binder_get_thread(struct binder_proc *proc)
{
  struct binder_thread *thread = NULL;
  struct rb_node *parent = NULL;
  struct rb_node **p = &amp;proc-&gt;threads.rb_node;

  // 在proc-&gt;threads这棵红黑树中，查找是否有线程的pid和current-&gt;pid相同。
  // 即，查找当前线程中是否创建过binder_thread信息
  while (*p) {
      parent = *p;
      thread = rb_entry(parent, struct binder_thread, rb_node);

      if (current-&gt;pid &lt; thread-&gt;pid)
          p = &amp;(*p)-&gt;rb_left;
      else if (current-&gt;pid &gt; thread-&gt;pid)
          p = &amp;(*p)-&gt;rb_right;
      else
          break;
  }
  // 若当前线程中没有创建过binder_thread信息；
  // 则创建binder_thread，并初始化；然后将其添加到binder_proc进程的proc-&gt;threads中
  if (*p == NULL) {
      thread = kzalloc(sizeof(*thread), GFP_KERNEL);
      if (thread == NULL)
          return NULL;
      binder_stats_created(BINDER_STAT_THREAD);
      // 将进程的上下文信息保存到thread中
      thread-&gt;proc = proc;
      thread-&gt;pid = current-&gt;pid;
      // 初始化thread的等待队列
      init_waitqueue_head(&amp;thread-&gt;wait);
      // 初始化thread的待处理事件列表
      INIT_LIST_HEAD(&amp;thread-&gt;todo);
      // 将该thread链接到proc-&gt;threads这棵红黑树中
      rb_link_node(&amp;thread-&gt;rb_node, parent, p);
      rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);
      thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;
      thread-&gt;return_error = BR_OK;
      thread-&gt;return_error2 = BR_OK;
  }
  return thread;
}</code></pre><p>说明：<br>(01) 理解”红黑树”和”rb_entry”是理解while循环的前提。这里简单介绍下，proc-&gt;threads这棵红黑树是根据proc-&gt;thread-&gt;pid来排序的；而rb_entry(parent, struct binder_thread, rb_node)的作用根据binder_thread结构体对象中的已知成员的地址(binder_thread-&gt;rb_node的地址，也就是parent的值)来获取binder_thread结构体对象的地址。<br>(02) 很显然，由于之前没有创建过当前线程对应的binder_thread对象，所以*p==null为true。那么，接下来就新建binder_thread对象，并对其进行初始化，然后再添加到红黑树proc-&gt;threads中。</p>
<h3 id="6-3-Binder驱动中的binder-new-node-源码"><a href="#6-3-Binder驱动中的binder-new-node-源码" class="headerlink" title="6.3 Binder驱动中的binder_new_node()源码"></a>6.3 Binder驱动中的binder_new_node()源码</h3><p>下面看看binder_ioctl()中调用的binder_new_node()的代码。</p>
<pre><code>static struct binder_node *binder_new_node(struct binder_proc *proc,
                     void __user *ptr,
                     void __user *cookie)
{
  struct rb_node **p = &amp;proc-&gt;nodes.rb_node;
  struct rb_node *parent = NULL;
  struct binder_node *node;

  // 在proc-&gt;nodes这棵红黑树中，查找有要查找的binder实体(通过ptr成员来判断)
  while (*p) {
      parent = *p;
      node = rb_entry(parent, struct binder_node, rb_node);

      if (ptr &lt; node-&gt;ptr)
          p = &amp;(*p)-&gt;rb_left;
      else if (ptr &gt; node-&gt;ptr)
          p = &amp;(*p)-&gt;rb_right;
      else
          return NULL;
  }

  // 如果没有要找的binder实体，则新建该binder实体
  node = kzalloc(sizeof(*node), GFP_KERNEL);
  if (node == NULL)
      return NULL;
  binder_stats_created(BINDER_STAT_NODE);
  // 将node链接到红黑树proc-&gt;nodes中
  rb_link_node(&amp;node-&gt;rb_node, parent, p);
  rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);
  node-&gt;debug_id = ++binder_last_id;
  // 将进程上下文信息保存到node-&gt;proc中
  node-&gt;proc = proc;
  node-&gt;ptr = ptr;
  node-&gt;cookie = cookie;
  node-&gt;work.type = BINDER_WORK_NODE;
  INIT_LIST_HEAD(&amp;node-&gt;work.entry);
  INIT_LIST_HEAD(&amp;node-&gt;async_todo);
  return node;
}</code></pre><p>说明：跟binder_get_thread()类似，这里是先在proc-&gt;nodes这棵红黑树中查找是否有binder实体(即binder_node对象)存在。有的话，返回NULL，即不需要新建binder实体；没有的话，则新建并初始化binder_node对象，然后将其添加到proc-&gt;nodes红黑树中。</p>
<p><br>至此，binder_become_context_manager()就介绍完了。它的作用：<br>(01) <strong>ServiceManager进程</strong>：告诉Kernel驱动，当前进程(即ServiceManager进程)是Binder上下文管理者。<br>(02) <strong>Binder驱动</strong>：新建当前线程对应的binder_thread对象，并将其添加到进程上下文信息binder_proc的threads红黑树中；新建ServiceManager对应的binder实体，并将该binder实体保存到全局变量binder_context_mgr_node中。</p>
<p><a name="anchor7"></a></p>
<h2 id="7-binder-loop"><a href="#7-binder-loop" class="headerlink" title="7. binder_loop()"></a>7. binder_loop()</h2><p>我们继续回到main()函数，分析一下binder_loop(bs, svcmgr_handler)。</p>
<h3 id="7-1-binder-loop-的源码"><a href="#7-1-binder-loop-的源码" class="headerlink" title="7.1 binder_loop()的源码"></a>7.1 binder_loop()的源码</h3><pre><code>void binder_loop(struct binder_state *bs, binder_handler func)
{
    int res; 
    struct binder_write_read bwr;
    unsigned readbuf[32];

    bwr.write_size = 0;
    bwr.write_consumed = 0;
    bwr.write_buffer = 0;

    // 告诉Kernel，ServiceManager进程进入了消息循环状态。
    readbuf[0] = BC_ENTER_LOOPER;
    binder_write(bs, readbuf, sizeof(unsigned));

    for (;;) {
        bwr.read_size = sizeof(readbuf);
        bwr.read_consumed = 0;
        bwr.read_buffer = (unsigned) readbuf;

        // 向Kernel中发送消息(先写后读)。
        // 先将消息传递给Kernel，然后再从Kernel读取消息反馈
        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);

        ...

        // 解析读取的消息反馈
        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);
        ...
    }
}</code></pre><p>说明： 该代码定义在frameworks/native/cmds/servicemanager/binder.c中。<br>  binder_loop()首先调用binder_write(,BC_ENTER_LOOPER,)告诉Kernel，ServiceManager进入了消息循环状态。紧接着，就通过ioctl(,BINDER_WRITE_READ,)进入消息循环，等待Client发送请求(例如，MediaPlayer进程调用addService将MediaPlayer注册到ServiceManager中进行管理)。如果没有消息，则进入中断等待状态；如果有消息，则进行消息处理！ </p>
<h3 id="7-2-binder-write-的源码"><a href="#7-2-binder-write-的源码" class="headerlink" title="7.2 binder_write()的源码"></a>7.2 binder_write()的源码</h3><p>下面看看binder_loop()中的binder_write(,BC_ENTER_LOOPER,)。</p>
<pre><code>int binder_write(struct binder_state *bs, void *data, unsigned len)
{
    struct binder_write_read bwr;
    int res;
    bwr.write_size = len;                // 数据长度
    bwr.write_consumed = 0;             
    bwr.write_buffer = (unsigned) data;  // 数据是BINDER_WRITE_READ
    bwr.read_size = 0;
    bwr.read_consumed = 0;
    bwr.read_buffer = 0;
    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
    if (res &lt; 0) {
        fprintf(stderr,&quot;binder_write: ioctl failed (%s)\n&quot;,
                strerror(errno));
    }
    return res;
}</code></pre><p>说明：binder_write()单单只是向Kernel发送一个消息，而不会去读取消息反馈。这里的ioctl()又会调用到binder_ioctl()。<br>这里涉及到了Binder通信中常用的数据结构体binder_write_read。bwr.write_size&gt;0，表示通过ServiceManager有数据(即BC_ENTER_LOOPER指令)发送给Binder驱动，而发送的数据就保存在bwr.write_buffer中，bwr.write_consumed则表示已经被读取并处理的数据的大小。bwr.read_XXX则是用来保存Binder驱动即将反馈给ServiceManager的信息的。<br>更多关于binder_write_read的介绍，请参考<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。</p>
<h3 id="7-3-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#7-3-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="7.3 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>7.3 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h3><p>下面我们看看Binder驱动部分的对应代码。</p>
<pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  // 中断等待函数。
  // 1. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。
  // 2. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。
  //    当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时；
  //    则继续执行；否则，再进入等待状态。
  ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);

  binder_lock(__func__);
  // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。
  thread = binder_get_thread(proc);
  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：<br>(01) wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2)中binder_stop_on_user_error &lt; 2为true。因此，不进入中断等待状态而是直接跳过该函数。<br>(02) thread = binder_get_thread(proc)。由于在上一次调用ioctl时，已经创建了该线程对应的binder_thread对象。因此，这次能在proc-&gt;threads红黑树中找到对应的binder_thread对象，然后，返回给thread。<br>(03) copy_from_user()的作用是将用户空间的数据拷贝到内核空间。即，将ServiceManager中调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)时的bwr对象拷贝到Binder驱动中。<br>(04) 在binder_write()中，设置的bwr.write_size&gt;0；所以，调用binder_thread_write()进行写操作。<br>(05) 在binder_write()中，设置的bwr.read_size为0；所以，不调用binder_thread_read()进行读操作。<br>(06) 读写操作完毕之后，将bwr从内核空间再拷贝到用户空间。  </p>
<h3 id="7-4-Binder驱动中binder-thread-write-的源码"><a href="#7-4-Binder驱动中binder-thread-write-的源码" class="headerlink" title="7.4 Binder驱动中binder_thread_write()的源码"></a>7.4 Binder驱动中binder_thread_write()的源码</h3><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
      ...
      case BC_ENTER_LOOPER:
          ...
          // 设置线程的状态为BINDER_LOOPER_STATE_ENTERED；
          // 即，进入了循环状态
          thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;
          break;
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p>说明：binder_thread_write()从brw.write_buffer中读取4个字节作为cmd。这4个字节就是ServiceManager传递的指令BC_ENTER_LOOPER。<br>在BC_ENTER_LOOPER对应的switch分支中，就是将BINDER_LOOPER_STATE_ENTERED加入到thread-&gt;looper中。即，告诉Binder驱动，ServiceManager进程进入了消息循环状态。</p>
<p><a name="anchor8"></a></p>
<h2 id="8-for"><a href="#8-for" class="headerlink" title="8. for(;;)"></a>8. for(;;)</h2><p>继续往下走。回到binder_loop()中后，便进入了for(;;)消息循环中。进入循环后，首先调用ioctl(,BINDER_WRITE_READ,)；此时，对应的bwr内容如下：</p>
<pre><code>bwr.write_size = 0;
bwr.write_consumed = 0;
bwr.write_buffer = 0;
bwr.read_size = sizeof(readbuf);
bwr.read_consumed = 0;
bwr.read_buffer = (unsigned) readbuf;</code></pre><p>bwr.write_size=0，而bwr.read_size&gt;0；表示只会从Binder驱动读取数据，而并不会向Binder驱动中写入数据。接着，调用ioctl()便再次进入到Binder驱动binder_ioctl()中。</p>
<h3 id="8-1-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#8-1-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="8.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>8.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h3><pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  ...
  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：由于此次bwr.write_size=0，而bwr.read_size不为0。因此，在通过copy_from_user()将数据从用户空间拷贝到内核空间之后，不进行写操作，而只进行读操作，即只执行binder_thread_read()。 在读操作执行完毕之后，再通过copy_to_user()，将数据返回给用户空间。  </p>
<h3 id="8-2-Binder驱动中binder-thread-read-的源码"><a href="#8-2-Binder驱动中binder-thread-read-的源码" class="headerlink" title="8.2 Binder驱动中binder_thread_read()的源码"></a>8.2 Binder驱动中binder_thread_read()的源码</h3><pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  int ret = 0;
  int wait_for_proc_work;

  // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区
  if (*consumed == 0) {
      if (put_user(BR_NOOP, (uint32_t __user *)ptr))
          return -EFAULT;
      // 修改指针位置
      ptr += sizeof(uint32_t);
  }

retry:
  // 等待proc进程的事务标记。
  // 当线程的事务栈为空 并且 待处理事务列表为空时，该标记位true。
  wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;
              list_empty(&amp;thread-&gt;todo);

  ...

  // 设置线程为&quot;等待状态&quot;
  thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;
  if (wait_for_proc_work)
      proc-&gt;ready_threads++;

  ...
  if (wait_for_proc_work) {
      ...
      // 设置当前线程的优先级=proc-&gt;default_priority。
      // 即，当前线程要处理proc的事务，所以设置优先级和proc一样。
      binder_set_nice(proc-&gt;default_priority);
      if (non_block) {
          // 非阻塞式的读取，则通过binder_has_proc_work()读取proc的事务；
          // 若没有，则直接返回
          if (!binder_has_proc_work(proc, thread))
              ret = -EAGAIN;
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
  } else {
      ...
  }
  ...
}</code></pre><p>说明：<br>(01) 很显然，bwr.read_consumed=0。因此，*consumed=0，那么就将BR_NOOP拷贝到用户空间的bwr.read_buffer缓存区中。<br>(02) 目前为止，并没有进程将事务添加到当前线程中；因此，线程的事务栈和待处理事务队列都是为空。于是得到wait_for_proc_work的值是true。<br>(03) binder_set_nice()的作用是设置当前线程的优先级=proc-&gt;default_priority。<br>(04) 根据上下文，可知non_block为false。因此调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))。 而目前ServiceManager进程中没有待处理事务，因此binder_has_proc_work(proc, thread)为false。从而当前线程进入中断等待状态，等待其它进程将ServiceManager唤醒。 </p>
<p><br>至此，ServiceManager进入了等待状态，binder_loop()就分析就暂告一段落。<br>(01) <strong>ServiceManager进程</strong>：binder_loop()通过BC_ENTER_LOOPER告诉Kernel，ServiceManager进入了消息循环状态。接着，ServiceManager就进入等待状态，等待Client请求。<br>(02) <strong>Binder驱动</strong>：已知ServiceManager进入了消息循环状态；在收到ServiceManager的BINDER_WRITE_READ消息之后，就去ServiceManager的从进程上下文binder_proc对象中读取是否有待处理事务，由于没有事务处理，则将ServiceManager线程设为中断等待状态。  </p>
<p><a name="anchor_3rd"></a></p>
<h1 id="ServiceManager流程总结"><a href="#ServiceManager流程总结" class="headerlink" title="ServiceManager流程总结"></a>ServiceManager流程总结</h1><p>总结上面的分析，ServiceManager的main()进程完成了以下工作。 </p>
<ol>
<li><p>对于<strong>ServiceManager进程</strong>而言<br>它打开了Binder设备文件，并且将内存映射到ServiceManager的进程空间。然后，它告诉Binder驱动自己是Binder上下文的管理者。最后，进入消息循环，等待Client请求。</p>
</li>
<li><p>对于<strong>Binder驱动</strong>而言<br>初始化了ServiceManager对应的进程上下文环境(即binder_proc变量)，并将内核虚拟地址和进程虚拟地址映射到同一物理内存中。然后，新建当前线程对应的binder_thread对象，并将其添加到进程上下文信息binder_proc-&gt;threads红黑树中。在得知ServiceManager是Binder上下文管理者后，建立ServiceManager对应的Binder实体，并将该Binder实体保存到全局变量中。最后，得知ServiceManager进入消息循环后，由于当前线程中没有事务可处理，则进入中断等待状态，等待其他进程将其唤醒。</p>
</li>
</ol>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/02/android/os/binder/2014-09-02-Binder-Datastruct/" itemprop="url">Android Binder机制(二) Binder中的数据结构</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-02T01:01:00.000Z" itemprop="datePublished">9月 2 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            32 分钟 read (About 4753 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>在对Binder代码展开详细介绍之前，先列举出Binder机制中涉及到的数据结构。本文是一篇参考文章，读者在阅读代码的过程中遇到相关的数据结构，就可以查阅此文中的内容。本文列举的数据结构，涵盖了内核空间和用户空间两个部分。内核空间部分就是Binder驱动中涉及到的数据结构；而用户空间的部分，包括ServiceManager守护进程，以及Android的C++层和Framework层的相关数据结构。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">内核空间的Binder数据结构</a><br><strong>1.1</strong>. <a href="#anchor1_1">binder_proc</a><br><strong>1.2</strong>. <a href="#anchor1_2">binder_buffer</a><br><strong>1.3</strong>. <a href="#anchor1_3">binder_thread</a><br><strong>1.4</strong>. <a href="#anchor1_4">binder_node</a><br><strong>1.5</strong>. <a href="#anchor1_5">binder_ref</a><br><strong>1.6</strong>. <a href="#anchor1_6">binder_write_read</a><br><strong>1.7</strong>. <a href="#anchor1_7">flat_binder_object</a><br><strong>1.8</strong>. <a href="#anchor1_8">binder_transaction_data</a><br><strong>2</strong>. <a href="#anchor2">用户空间的</a><br><strong>2.1</strong>. <a href="#anchor2_1">ServiceManager守护进程中的数据结构</a><br><strong>2.2</strong>. <a href="#anchor2_2">C++层的数据结构</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-内核空间的Binder数据结构"><a href="#1-内核空间的Binder数据结构" class="headerlink" title="1. 内核空间的Binder数据结构"></a>1. 内核空间的Binder数据结构</h1><p>在介绍Binder驱动中的数据结构时，先回顾一下上一篇提到的”内核中的Binder设计图”，有一个整体印象。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds01.jpg" alt></a></p>
<p>前面说过，binder_proc是描述进程上下文信息的，每一个用户空间的进程都对应一个binder_proc结构体。binder_node是Binder实体对应的结构体，它是Server在Binder驱动中的体现。binder_ref是Binder引用对应的结构体，它是Client在Binder驱动中的体现。</p>
<p><a name="anchor1_1"></a></p>
<h2 id="1-1-binder-proc"><a href="#1-1-binder-proc" class="headerlink" title="1.1 binder_proc"></a>1.1 binder_proc</h2><p>binder_proc是描述Binder进程上下文信息的结构体。Binder驱动的文件节点是”/dev/binder”，每当一个程序打开该文件节点时；Binder驱动中都会新建一个binder_proc对象来保存该进程的上下文信息。</p>
<pre><code>struct binder_proc {
  struct hlist_node proc_node;    // 根据proc_node，可以获取该进程在&quot;全局哈希表binder_procs(统计了所有的binder proc进程)&quot;中的位置
  struct rb_root threads;         // binder_proc进程内用于处理用户请求的线程组成的红黑树(关联binder_thread-&gt;rb_node)
  struct rb_root nodes;           // binder_proc进程内的binder实体组成的红黑树(关联binder_node-&gt;rb_node)
  struct rb_root refs_by_desc;    // binder_proc进程内的binder引用组成的红黑树，该引用以句柄来排序(关联binder_ref-&gt;rb_node_desc)
  struct rb_root refs_by_node;    // binder_proc进程内的binder引用组成的红黑树，该引用以它对应的binder实体的地址来排序(关联binder_ref-&gt;rb_node)
  int pid;                        // 进程id
  struct vm_area_struct *vma;     // 进程的内核虚拟内存
  struct mm_struct *vma_vm_mm;
  struct task_struct *tsk;        // 进程控制结构体(每一个进程都由task_struct 数据结构来定义)。
  struct files_struct *files;     // 保存了进程打开的所有文件表数据
  struct hlist_node deferred_work_node;
  int deferred_work;
  void *buffer;                   // 该进程映射的物理内存在内核空间中的起始位置
  ptrdiff_t user_buffer_offset;   // 内核虚拟地址与进程虚拟地址之间的差值

  // 内存管理的相关变量
  struct list_head buffers;         // 和binder_buffer-&gt;entry关联到同一链表，从而对Binder内存进行管理
  struct rb_root free_buffers;      // 空闲内存，和binder_buffer-&gt;rb_node关联。
  struct rb_root allocated_buffers; // 已分配内存，和binder_buffer-&gt;rb_node关联。
  size_t free_async_space;

  struct page **pages;            // 映射内存的page页数组，page是描述物理内存的结构体
  size_t buffer_size;             // 映射内存的大小
  uint32_t buffer_free;
  struct list_head todo;          // 该进程的待处理事件队列。
  wait_queue_head_t wait;         // 等待队列。
  struct binder_stats stats;
  struct list_head delivered_death;
  int max_threads;                // 最大线程数。定义threads中可包含的最大进程数。
  int requested_threads;
  int requested_threads_started;
  int ready_threads;
  long default_priority;          // 默认优先级。
  struct dentry *debugfs_entry;
};</code></pre><p>说明：binder_proc定义在drivers/staging/android/binder.c中。由于定义在.c文件中，可见binder_proc是Binder驱动的私有结构体。上面已经给出了相关成员的注释，这里只对部分比较重要的成员进行说明。<br>(01) proc_node, 它的作用是通过proc_node，将该binder_proc添加到”全局哈希表binder_procs(它记录了所有的binder_proc)”。不过binder_procs在Kernel驱动中暂时没有太大用处，所以不用太过关注该成员。<br>(02) threads，它是包含该进程内用于处理用户请求的所有线程的红黑树。threads成员和binder_thread-&gt;rb_node关联到一棵红黑树，从而将binder_proc和binder_thread关联起来。<br>(03) nodes，它是包行该进程内的所有Binder实体所组成的红黑树。nodes成员和binder_node-&gt;rb_node关联到一棵红黑树，从而将binder_proc和binder_node关联起来。<br>(04) refs_by_desc，它是包行该进程内的所有Binder引用所组成的红黑树。refs_by_desc成员和binder_ref-&gt;rb_node_desc关联到一棵红黑树，从而将binder_proc和binder_ref关联起来。<br>(05) refs_by_node，它是包行该进程内的所有Binder引用所组成的红黑树。refs_by_node成员和binder_ref-&gt;rb_node_node关联到一棵红黑树，从而将binder_proc和binder_ref关联起来。<br>(06) buffer，它是该进程内核虚拟内存的起始地址。而user_buffer_offset，则是该内核虚拟地址和进程虚拟地址之间的差值。在Binder驱动中，将进程的内核虚拟地址和进程虚拟地址映射到同一物理页面，该user_buffer_offset则是它们之间的差值；这样，已知其中一个，就可以根据差值算出另外一个。<br>(07) todo是该进程的待处理事务队列，而wait则是等待队列。它们的作用是实现进程的等待/唤醒。例如，当Server进程的wait等待队列为空时，Server就进入中断等待状态；当某Client向Server发送请求时，就将该请求添加到Server的todo待处理事务队列中，并尝试唤醒Server等待队列上的线程。如果，此时Server的待处理事务队列不为空，则Server被唤醒后；唤醒后，则取出待处理事务进行处理，处理完毕，则将结果返回给Client。  </p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-binder-buffer"><a href="#1-2-binder-buffer" class="headerlink" title="1.2 binder_buffer"></a>1.2 binder_buffer</h2><p>binder_buffer是描述Binder进程所管理的每段内存的结构体。</p>
<pre><code>struct binder_buffer {
    struct list_head entry;    // 和binder_proc-&gt;buffers关联到同一链表，从而使Binder进程对内存进行管理。
    struct rb_node rb_node;    // 和binder_proc-&gt;free_buffers或binder_proc-&gt;allocated_buffers关联到同一红黑树，从而对已有内存和空闲内存进行管理。

    unsigned free:1;                // 空闲与否的标记
    unsigned allow_user_free:1;
    unsigned async_transaction:1;
    unsigned debug_id:29;

    struct binder_transaction *transaction;

    struct binder_node *target_node;
    size_t data_size;
    size_t offsets_size;
    uint8_t data[0];
};</code></pre><p>说明：binder_buffer是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。Binder驱动将Binder进程的内存分成一段一段进行管理，而这每一段则是使用binder_buffer来描述的。</p>
<p><a name="anchor1_3"></a></p>
<h2 id="1-3-binder-thread"><a href="#1-3-binder-thread" class="headerlink" title="1.3 binder_thread"></a>1.3 binder_thread</h2><p>binder_thread是描述Binder线程的结构体。binder_proc是描述进程的，而binder_thread是描述进程中的线程。</p>
<pre><code>struct binder_thread {
    struct binder_proc *proc;   // 线程所属的Binder进程
    struct rb_node rb_node;     // 红黑树节点，关联到红黑树binder_proc-&gt;threads中。
    int pid;                    // 进程id
    int looper;                 // 线程状态。可以取BINDER_LOOPER_STATE_REGISTERED等值
    struct binder_transaction *transaction_stack;   // 正在处理的事务栈
    struct list_head todo;                          // 待处理的事务链表
    uint32_t return_error; /* Write failed, return error code in read buf */
    uint32_t return_error2; /* Write failed, return error code in read */

    wait_queue_head_t wait;                         // 等待队列
    struct binder_stats stats;                      // 保存一些统计信息
};</code></pre><p>说明：binder_thread是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。binder_thread是描述Binder线程相关信息的结构体。<br>(01) proc，它是binder_proc(进程上下文信息)结构体对象。目的是保存该线程所属的Binder进程。<br>(02) rb_node，它是红黑树节点。通过将rb_node binder关联到红黑树proc-&gt;threads中，从而将该线程添加到进程的threads红黑树中进行管理。</p>
<p><a name="anchor1_4"></a></p>
<h2 id="1-4-binder-node"><a href="#1-4-binder-node" class="headerlink" title="1.4 binder_node"></a>1.4 binder_node</h2><p>binder_node是描述Binder实体的结构体。</p>
<pre><code>struct binder_node {
    int debug_id;
    struct binder_work work;
    union {
        struct rb_node rb_node;         // 如果这个Binder实体还在使用，则将该节点链接到proc-&gt;nodes中。
        struct hlist_node dead_node;    // 如果这个Binder实体所属的进程已经销毁，而这个Binder实体又被其它进程所引用，则这个Binder实体通过dead_node进入到一个哈希表中去存放
    };
    struct binder_proc *proc;           // 该binder实体所属的Binder进程
    struct hlist_head refs;             // 该Binder实体的所有Binder引用所组成的链表
    int internal_strong_refs;
    int local_weak_refs;
    int local_strong_refs;
    void __user *ptr;                   // Binder实体在用户空间的地址(为Binder实体对应的Server在用户空间的本地Binder的引用)
    void __user *cookie;                // Binder实体在用户空间的其他数据(为Binder实体对应的Server在用户空间的本地Binder自身)
    unsigned has_strong_ref:1;
    unsigned pending_strong_ref:1;
    unsigned has_weak_ref:1;
    unsigned pending_weak_ref:1;
    unsigned has_async_transaction:1;
    unsigned accept_fds:1;
    unsigned min_priority:8;
    struct list_head async_todo;
};</code></pre><p>说明：binder_node是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。binder_node是描述Binder实体相关信息的结构体。<br>(01) rb_node和dead_node属于一个union。如果该Binder实体还在使用，则通过rb_node将该节点链接到proc-&gt;nodes红黑树中；否则，则将该Binder实体通过dead_node链接到全局哈希表binder_dead_nodes中。<br>(02) proc，它是binder_proc(进程上下文信息)结构体对象。目的是保存该Binder实体的进程。<br>(03) refs，它是该Binder实体的所有引用所组成的链表。</p>
<p>在Binder驱动中，会为每一个Server都创建一个Binder实体，即会为每个Server都创建一个binder_node对象。</p>
<p><a name="anchor1_5"></a></p>
<h2 id="1-5-binder-ref"><a href="#1-5-binder-ref" class="headerlink" title="1.5 binder_ref"></a>1.5 binder_ref</h2><p>binder_ref是描述Binder引用的结构体。</p>
<pre><code>struct binder_ref {
    int debug_id;
    struct rb_node rb_node_desc;    // 关联到binder_proc-&gt;refs_by_desc红黑树中
    struct rb_node rb_node_node;    // 关联到binder_proc-&gt;refs_by_node红黑树中
    struct hlist_node node_entry;   // 关联到binder_node-&gt;refs哈希表中
    struct binder_proc *proc;       // 该Binder引用所属的Binder进程
    struct binder_node *node;       // 该Binder引用对应的Binder实体
    uint32_t desc;                  // 描述
    int strong;                     
    int weak;
    struct binder_ref_death *death;
};</code></pre><p>说明：binder_ref是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。它是用来描述Binder引用的相关信息的。<br>(01) rb_node_desc和rb_node_node都是红黑树节点。通过rb_node_desc，Binder引用和binder_proc-&gt;refs_by_desc红黑树相关联；通过rb_node_node，Binder引用和binder_proc-&gt;refs_by_node红黑树相关联。<br>(02) node是该Binder引用所引用的Binder实体。而node_entry在是关联到该Binder实体的binder_node-&gt;refs哈希表中。<br>(03) proc，它是binder_proc(进程上下文信息)结构体对象。目的是保存该Binder引用所属的进程。<br>(04) desc是Binder引用的描述，实际上它就是Binder驱动为该Binder分配的一个唯一的int型整数。通过该desc，可以在binder_proc-&gt;refs_by_desc中找到该Binder引用，进而可以找到该Binder引用所引用的Binder实体等信息。  </p>
<p>在Binder驱动中，会为每个Client创建对应的Binder引用，即会为每个Client创建binder_ref对象。</p>
<p><strong>“Binder实体”和”Binder引用”可以很好的将Server和Client关联起来：因为Binder实体和Binder引用分别是Server和Client在Binder驱动中的体现。 Client获取到Server对象后，”Binder引用所引用的Biner实体(即binder_ref.node)” 会指向 “Server对应的Biner实体”；同样的，Server被某个Client引用之后，”Server对应的Binder实体的引用列表(即，binder_node.refs)” 会包含 “Client对应的Binder引用”。</strong></p>
<p><a name="anchor1_6"></a></p>
<h2 id="1-6-binder-write-read"><a href="#1-6-binder-write-read" class="headerlink" title="1.6 binder_write_read"></a>1.6 binder_write_read</h2><p>binder_write_read是描述Binder读写信息的结构体。</p>
<pre><code>struct binder_write_read {
    signed long write_size;
    signed long write_consumed;
    unsigned long   write_buffer;
    signed long read_size;
    signed long read_consumed;
    unsigned long   read_buffer;
};</code></pre><p>说明：binder_write_read是内核空间和用户空间的通信结构体，它记录了Binder读写内容的相关信息。在内核中，它定义在drivers/staging/android/binder.h中；在Android中，它对应的引用在external/kernel-headers/original/linux/binder.h中。<br>当用户空间的应用程序和Binder驱动通信时，它会将数据打包到binder_write_read中。write_开头的是记录应用程序要发送给Binder驱动的内容，而read_开头的是记录Binder驱动要反馈给应用程序的内容。<br>(01) write_size，是写内容的总大小；write_consumed，是已写内容的大小；write_buffer，是写的内容的虚拟地址。<br>(02) read_size，是读内容的总大小；read_consumed，是已读内容的大小；read_buffer，是读的内容的虚拟地址。</p>
<p><a name="anchor1_7"></a></p>
<h2 id="1-7-flat-binder-object"><a href="#1-7-flat-binder-object" class="headerlink" title="1.7 flat_binder_object"></a>1.7 flat_binder_object</h2><p>flat_binder_object是描述Binder对象信息的结构体。</p>
<pre><code>struct flat_binder_object {
    unsigned long       type;   // binder类型：可以为BINDER_TYPE_BINDER或BINDER_TYPE_HANDLE等类型
    unsigned long       flags;  // 标记

    union {
        void        *binder;    // 当type=BINDER_TYPE_BINDER时，它指向Binder对象位于C++层的本地Binder对象(即BBinder对象)的弱引用。 
        signed long handle;     // 当type=BINDER_TYPE_HANDLE时，它等于Binder对象在Binder驱动中对应的Binder实体的Binder引用的描述。
    };

    void            *cookie;    // 当type=BINDER_TYPE_BINDER时才有效，它指向Binder对象位于C++层的本地Binder对象(即BBinder对象)。 
};</code></pre><p>说明： flat_binder_object是用来描述Binder信息的结构体。它也属于内核空间和用户空间的通信结构体。当它在用户空间被使用时(例如，Server发送添加服务请求给ServiceManager)，flat_binder_object就是记录的Server位于用户空间的Binder对象的信息的结构体；此时的type的值一般都是BINDER_TYPE_BINDER类型，对应的union中的binder的值是该Binder对象在用户空间的本地Binder(即BBinder对象)的引用；同时，cookie则是本地Binder自身。  而当flat_binder_object在Binder驱动中被使用(例如，当Binder驱动收到发送服务请求时)，它会将type修改为BINDER_TYPE_HANDLE，然后将联合体中的handle修改为”该Server对应的Binder实体的Binder引用”的描述；根据Binder引用的描述就能找到该Server。总体来说，在用户空间，flat_binder_object是描述该Binder实体在用户空间的存在形式；而在内核空间中，flat_binder_object则描述该Binder实体在内核中的存在形式。</p>
<p><a name="anchor1_8"></a></p>
<h2 id="1-8-binder-transaction-data"><a href="#1-8-binder-transaction-data" class="headerlink" title="1.8 binder_transaction_data"></a>1.8 binder_transaction_data</h2><p>binder_transaction_data是描述Binder事务交互的数据格式的结构体。</p>
<pre><code>struct binder_transaction_data {
    union {
        size_t  handle; // 当binder_transaction_data是由用户空间的进程发送给Binder驱动时，
                        // handle是该事务的发送目标在Binder驱动中的信息，即该事务会交给handle来处理；
                        // handle的值是目标在Binder驱动中的Binder引用。
        void    *ptr;   // 当binder_transaction_data是有Binder驱动反馈给用户空间进程时，
                        // ptr是该事务的发送目标在用户空间中的信息，即该事务会交给ptr对应的服务来处理；
                        // ptr是处理该事务的服务的服务在用户空间的本地Binder对象。
    } target;           // 该事务的目标对象(即，该事务数据包是给该target来处理的)
    void        *cookie;    // 只有当事务是由Binder驱动传递给用户空间时，cookie才有意思，它的值是处理该事务的Server位于C++层的本地Binder对象
    unsigned int    code;   // 事务编码。如果是请求，则以BC_开头；如果是回复，则以BR_开头。

    unsigned int    flags;
    pid_t       sender_pid;
    uid_t       sender_euid;
    size_t      data_size;    // 数据大小
    size_t      offsets_size; // 数据中包含的对象的个数

    union {
        struct {
            const void  *buffer;
            const void  *offsets;
        } ptr;
        uint8_t buf[8];
    } data;                   // 数据
};</code></pre><p>说明： binder_transaction_data是用来描述Binder事务交互的数据结构体。它也属于内核空间和用户空间的通信结构体。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-用户空间的Binder数据结构"><a href="#2-用户空间的Binder数据结构" class="headerlink" title="2. 用户空间的Binder数据结构"></a>2. 用户空间的Binder数据结构</h1><p><a name="anchor2_1"></a></p>
<h2 id="2-1-ServiceManager守护进程中的数据结构"><a href="#2-1-ServiceManager守护进程中的数据结构" class="headerlink" title="2.1 ServiceManager守护进程中的数据结构"></a>2.1 ServiceManager守护进程中的数据结构</h2><p><a name="anchor2_1_1"></a></p>
<h3 id="2-1-1-binder-state"><a href="#2-1-1-binder-state" class="headerlink" title="2.1.1 binder_state"></a>2.1.1 binder_state</h3><pre><code>struct binder_state
{
    int fd;           // 文件节点&quot;/dev/binder&quot;的句柄
    void *mapped;     // 映射内存的起始地址
    unsigned mapsize; // 映射内存的大小
};  </code></pre><p>说明：binder_state定义在frameworks/native/cmds/servicemanager/binder.c中，它是ServiceManager用来描述打开的”/dev/binder”的信息结构体。</p>
<p><a name="anchor2_1_2"></a></p>
<h3 id="2-1-2-binder-object"><a href="#2-1-2-binder-object" class="headerlink" title="2.1.2 binder_object"></a>2.1.2 binder_object</h3><p>binder_object是与flat_binder_object对应的结构体。</p>
<pre><code>struct binder_object
{
    uint32_t type;  // 类型
    uint32_t flags;
    void *pointer;
    void *cookie;
};</code></pre><p>说明：binder_object定义在frameworks/native/cmds/servicemanager/binder.h中，它是ServiceManager中与flat_binder_object对应的结构体。</p>
<p><a name="anchor2_1_3"></a></p>
<h3 id="2-1-3-binder-txn"><a href="#2-1-3-binder-txn" class="headerlink" title="2.1.3 binder_txn"></a>2.1.3 binder_txn</h3><p>binder_txn与binder_transaction_data对应的结构体。</p>
<pre><code>struct binder_txn
{
    void *target;
    void *cookie;
    uint32_t code;
    uint32_t flags;

    uint32_t sender_pid;
    uint32_t sender_euid;

    uint32_t data_size;
    uint32_t offs_size;
    void *data;
    void *offs;
};</code></pre><p>说明：binder_txn定义在frameworks/native/cmds/servicemanager/binder.h中，它是ServiceManager中与binder_transaction_data对应的结构体。</p>
<p><a name="anchor2_1_4"></a></p>
<h3 id="2-1-4-svcinfo"><a href="#2-1-4-svcinfo" class="headerlink" title="2.1.4 svcinfo"></a>2.1.4 svcinfo</h3><pre><code>struct svcinfo
{
    struct svcinfo *next;         // 下一个&quot;服务的信息&quot;
    void *ptr;                    // 服务在Binder驱动中的Binder引用的描述
    struct binder_death death;
    int allow_isolated;
    unsigned len;                 // 服务的名称长度
    uint16_t name[0];             // 服务的名称
};      </code></pre><p>说明：svcinfo定义在frameworks/native/cmds/servicemanager/service_manager.c中。它是ServiceManager守护进程的私有结构体。<br>  svcinfo是保存”注册到ServiceManager中的服务”的相关信息的结构体。它是一个单链表，在ServiceManager守护进程中的svclist是保存注册到ServiceManager中的服务的链表，它就是struct info类型。svcinfo中的next是指向下一个服务的节点，而ptr是该服务在Binder驱动中Binder引用的描述。name则是服务的名称。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-C-层的数据结构"><a href="#2-2-C-层的数据结构" class="headerlink" title="2.2 C++层的数据结构"></a>2.2 C++层的数据结构</h2><p><a name="anchor2_2_1"></a></p>
<h3 id="2-2-1-Parcel"><a href="#2-2-1-Parcel" class="headerlink" title="2.2.1 Parcel"></a>2.2.1 Parcel</h3><p>Parcel是描述Binder通信信息的结构体。</p>
<pre><code>class Parcel {
public:
    ...

    // 获取数据(返回mData)
    const uint8_t*      data() const;
    // 获取数据大小(返回mDataSize)
    size_t              dataSize() const;
    // 获取数据指针的当前位置(返回mDataPos)
    size_t              dataPosition() const;

private:
    ...

    status_t            mError;                                   
    uint8_t*            mData;            // 数据
    size_t              mDataSize;        // 数据大小
    size_t              mDataCapacity;    // 数据容量
    mutable size_t      mDataPos;         // 数据指针的当前位置
    size_t*             mObjects;         // 对象在mData中的偏移地址
    size_t              mObjectsSize;     // 对象个数
    size_t              mObjectsCapacity; // 对象的容量

    ...
}</code></pre><p>说明：Parcel定义在frameworks/native/include/binder/Parcel.h中。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/01/android/os/binder/2014-09-01-Binder-Introduce/" itemprop="url">Android Binder机制(一) Binder的设计和框架</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-01T01:01:00.000Z" itemprop="datePublished">9月 1 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            44 分钟 read (About 6605 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>这是关于Android中Binder机制的一系列纯技术贴。花了一个多礼拜的时间，才终于将其整理完毕。行文于此，以做记录；也是将自己所得与大家分享。<br>和以往一样，介绍Binder时，先讲解框架，然后再从设计和细节等方面一一展开。若文章若错误或纰漏，请不吝指出。谢谢！</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Binder架构解析</a><br><strong>1.1</strong>. <a href="#anchor1_1">Binder模型</a><br><strong>1.2</strong>. <a href="#anchor1_2">Binder驱动存在的原因和意义</a><br><strong>1.3</strong>. <a href="#anchor1_3">ServiceManager存在的原因和意义</a><br><strong>1.4</strong>. <a href="#anchor1_4">为什么采用Binder机制，而不是其他的IPC通信方式</a><br><strong>1.5</strong>. <a href="#anchor1_5">Binder中各角色之间关系</a><br><strong>2</strong>. <a href="#anchor2">Binder设计解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">Binder设计</a><br><strong>2.1.1</strong>. <a href="#anchor2_1_1">内核空间的Binder设计</a><br><strong>2.1.2</strong>. <a href="#anchor2_1_2">用户空间的Binder设计</a><br><strong>2.2</strong>. <a href="#anchor2_2">Binder通信</a><br><strong>2.2.1</strong>. <a href="#anchor2_2_1">Binder通信模型</a><br><strong>2.2.2</strong>. <a href="#anchor2_2_2">Binder通信数据</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder架构解析"><a href="#1-Binder架构解析" class="headerlink" title="1. Binder架构解析"></a>1. Binder架构解析</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-Binder模型"><a href="#1-1-Binder模型" class="headerlink" title="1.1 Binder模型"></a>1.1 Binder模型</h2><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_frame.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_frame.jpg" alt></a></p>
<p>上图中涉及到Binder模型的4类角色：<strong>Binder驱动</strong>，<strong>ServiceManager</strong>，<strong>Server</strong>和<strong>Client</strong>。 因为后面章节讲解Binder时，都是以MediaPlayerService和MediaPlayer为代表进行讲解的；这里就使用MediaPlayerService代表了Server，而MediaPlayer则代表了Client。</p>
<p>Binder机制的目的<strong>是实现IPC(Inter-Process Communication)，即实现进程间通信</strong>。在上图中，由于MediaPlayerService是Server的代表，而MediaPlayer是Client的代表；因此，对于上图而言，Binder机制则表现为”实现MediaPlayerService和MediaPlayer之间的通信”。</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-Binder驱动存在的原因和意义"><a href="#1-2-Binder驱动存在的原因和意义" class="headerlink" title="1.2 Binder驱动存在的原因和意义"></a>1.2 Binder驱动存在的原因和意义</h2><p>在回答”Binder机制中Binder驱动存在的原因和意义”之前，先介绍几个基本的概念。</p>
<h3 id="1-Linux系统中的内存划分"><a href="#1-Linux系统中的内存划分" class="headerlink" title="1. Linux系统中的内存划分"></a>1. Linux系统中的内存划分</h3><p>Android是基于Linux内核而打造的操作系统。<br>以32位Linux系统而言，它的内存最大是4G。在这4G内存中，0<del>3G为用户空间，3</del>4G为内核空间。应用程序都运行在用户空间，而Kernel和驱动都运行在内核空间。用户空间和内核空间若涉及到通信(即，数据交互)，两者不能简单地使用指针传递数据，而必须在”内核”中通过copy_from_user(),copy_to_user(),get_user()或put_user()等函数传递数据。copy_from_user()和get_user()是将内核空间的数据拷贝到用户空间，而copy_to_user()和put_user()则是将用户空间的数据拷贝到内核空间。</p>
<h3 id="2-进程的基本概念"><a href="#2-进程的基本概念" class="headerlink" title="2. 进程的基本概念"></a>2. 进程的基本概念</h3><p>进程拥有独立的内存单元，它是系统进行资源分配和调度的基本单位。对于Linux系统而言，每一个运行在用户空间的应用程序都可以看作一个进程。<br>不同的进程在不同的内存中，因此当一个程序崩溃之后，不会对其它的程序造成影响。</p>
<br>
通过上面的"Linux的内存划分"和"进程"，我们可以了解到：**应用程序都运行在用户空间，每个应用程序都有它自己独立的内存空间；若不同的应用程序之间涉及到通信，需要通过内核进行中转，因为需要用到内核的copy_from_user()和copy_to_user()等函数。**   
现在，再回到上面的框架图中。图中的ServiceManager, MediaPlayerService和MediaPlayer都位于用户空间，它们是不同的进程。前面说过，Binder机制的最终目的是实现"MediaPlayerService和MediaPlayer这两个不同进程之间的通信"。而这两个不同进程的通信必须要内核进行中转，对于Android而言，在内核中起中转作用便是Binder驱动。那么Binder驱动是如何进行数据中转的呢？这里概括的介绍一下，后面再详细说明。   
Android的通信是基于Client-Server架构的，进程间的通信无非就是Client向Server发起请求，Server响应Client的请求。这里以发起请求为例：当Client向Server发起请求(例如，MediaPlayer向MediaPlayerService发起请求)，Client会先将请求数据从用户空间拷贝到内核空间(将数据从MediaPlayer发给Binder驱动)；数据被拷贝到内核空间之后，再通过驱动程序，将内核空间中的数据拷贝到Server位于用户空间的缓存中(Binder驱动将数据发给MediaPlayerService)。这样，就成功的将Client进程中的请求数据传递到了Server进程中。

<p>实际上，Binder驱动是整个Binder机制的核心。除了实现上面所说的数据传输之外，Binder驱动还是实现线程控制(通过中断等待队列实现线程的等待/唤醒)，以及UID/PID等安全机制的保证。</p>
<p><a name="anchor1_3"></a></p>
<h2 id="1-3-ServiceManager存在的原因和意义"><a href="#1-3-ServiceManager存在的原因和意义" class="headerlink" title="1.3 ServiceManager存在的原因和意义"></a>1.3 ServiceManager存在的原因和意义</h2><p>Binder是要实现Android的C-S架构的，即Client-Server架构。而ServiceManager，是以服务管理者的身份存在的。</p>
<p>ServiceManager也是运行在用户空间的一个独立进程。<br>(01) 对于Binder驱动而言，<strong>ServiceManager是一个守护进程，更是Android系统各个服务的管理者</strong>。Android系统中的各个服务，都是添加到ServiceManager中进行管理的，而且每个服务都对应一个服务名。当Client获取某个服务时，则通过服务名来从ServiceManager中获取相应的服务。<br>(02) 对于MediaPlayerService和MediaPlayer而言，<strong>ServiceManager是一个Server服务端，是一个服务器</strong>。当要将MediaPlayerService等服务添加到ServiceManager中进行管理时，ServiceManager是服务器，它会收到MediaPlayerService进程的添加服务请求。当MediaPlayer等客户端要获取MediaPlayerService等服务时，它会向ServiceManager发起获取服务请求。</p>
<p>当MediaPlayer和MediaPlayerService通信时，MediaPlayerService是服务端；而当MediaPlayerService则ServiceManager通信时，ServiceManager则是服务端。这样，就造就了ServiceManager的特殊性。于是，在Binder驱动中，将句柄0指定为ServiceManager对应的句柄，通过这个特殊的句柄就能获取ServiceManager对象。这部分的知识后面会详细介绍。</p>
<p><a name="anchor1_4"></a></p>
<h2 id="1-4-为什么采用Binder机制，而不是其他的IPC通信方式"><a href="#1-4-为什么采用Binder机制，而不是其他的IPC通信方式" class="headerlink" title="1.4 为什么采用Binder机制，而不是其他的IPC通信方式"></a>1.4 为什么采用Binder机制，而不是其他的IPC通信方式</h2><p>前面说过，Android是在Linux内核的基础上设计的。而在Linux中，已经拥有”管道/消息队列/共享内存/信号量/Socket等等”众多的IPC通信手段；但是，Google为什么单单选择了Binder，而不是其它的IPC机制呢？</p>
<p>这肯定是因为Binder具有无可比拟的优势。下面就从 “实用性(Client-Server架构)/传输效率/操作复杂度/安全性” 等几方面进行分析。</p>
<h3 id="第一-Binder能够很好的实现Client-Server架构"><a href="#第一-Binder能够很好的实现Client-Server架构" class="headerlink" title="第一. Binder能够很好的实现Client-Server架构"></a>第一. Binder能够很好的实现Client-Server架构</h3><p>对于Android系统，Google想提供一套基于Client-Server的通信方式。<br>例如，将”电池信息/马达控制/wifi信息/多媒体服务”等等不同的服务都由不同的Server提供，当Client需要获取某Server的服务时，只需要Client向Server发送相应的请求，Server收到请求之后进行处理，处理完毕再将反馈内容发送给Client。</p>
<p>但是，目前Linux支持的”传统的管道/消息队列/共享内存/信号量/Socket等”IPC通信手段中，只有Socket是Client-Server的通信方式。但是，Socket主要用于网络间通信以及本机中进程间的低速通信，它的传输效率太低。</p>
<h3 id="第二-Binder的传输效率和可操作性很好"><a href="#第二-Binder的传输效率和可操作性很好" class="headerlink" title="第二. Binder的传输效率和可操作性很好"></a>第二. Binder的传输效率和可操作性很好</h3><p>前面已经说了，Socket传输效率很低，已经被排除。而消息队列和管道又采用存储-转发方式，使用它们进行IPC通信时，需要经过2次内存拷贝！效率太低！</p>
<p>为什么消息队列和管道的数据传输需要经过2次内存拷贝呢？ 首先，数据先从发送方的缓存区(即，Linux中的用户存储空间)拷贝到内核开辟的缓存区(即，Linux中的内核存储空间)中，是第1次拷贝。接着，再从内核缓存区拷贝到接收方的缓存区(也是Linux中的用户存储空间)，这是第2次拷贝。<br>而采用Binder机制的话，则只需要经过1次内存拷贝即可！ 即，从发送方的缓存区拷贝到内核的缓存区，而接收方的缓存区与内核的缓存区是映射到同一块物理地址的，因此只需要1次拷贝即可。</p>
<p>至于共享内存呢，虽然使用它进行IPC通信时进行的内存拷贝次数是0。但是，共享内存操作复杂，也将它排除。</p>
<h3 id="第三-Binder机制的安全性很高"><a href="#第三-Binder机制的安全性很高" class="headerlink" title="第三. Binder机制的安全性很高"></a>第三. Binder机制的安全性很高</h3><p>传统IPC没有任何安全措施，完全依赖上层协议来确保。传统IPC的接收方无法获得对方进程可靠的UID/PID(用户ID/进程ID)，从而无法鉴别对方身份。而Binder机制则为每个进程分配了UID/PID来作为鉴别身份的标示，并且在Binder通信时会根据UID/PID进行有效性检测。</p>
<p><a name="anchor1_5"></a></p>
<h2 id="1-5-Binder中各角色之间关系"><a href="#1-5-Binder中各角色之间关系" class="headerlink" title="1.5 Binder中各角色之间关系"></a>1.5 Binder中各角色之间关系</h2><p>先看看下面的关系图</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_4relationship.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_4relationship.jpg" alt></a></p>
<p>在解释上面的图之前，先解释图中涉及到的几个非常重要的概念。</p>
<p><strong>1. Binder实体</strong></p>
<p>  Binder实体，是各个Server以及ServiceManager在内核中的存在形式。<br>  Binder实体实际上是内核中binder_node结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。<br>  在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。</p>
<p><strong>2. Binder引用</strong></p>
<p>   说到Binder实体，就不得不说”Binder引用”。所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。<br>   如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。</p>
<p>   Binder实体和Binder引用都是内核(即，Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。</p>
<p><strong>3. 远程服务</strong></p>
<p>   Server都是以服务的形式注册到ServiceManager中进行管理的。如果将Server本身看作是”本地服务”的话，那么Client中的”远程服务”就是本地服务的代理。如果你对代理模式比较熟悉的话，就很容易理解了，远程服务就是本地服务的一个代理，通过该远程服务Client就能和Server进行通信。</p>
<br>
理解上面3个概念之后，下面再通过几个典型的通信示例来解析该关系图。

<p><strong>ServiceManager守护进程</strong><br>  ServiceManager是用户空间的一个守护进程。当该应用程序启动时，它会和Binder驱动进行通信，告诉Binder驱动它是服务管理者；对Binder驱动而言，它则会新建ServiceManager对应的Binder实体，并将该Binder实体设为全局变量。为什么要将它设为全局变量呢？这点应该很容易理解–因为Client和Server都需要和ServiceManager进行通信，不将它设为全局变量的话，怎么找到ServiceManager呢！</p>
<p><strong>Server注册到ServiceManager中</strong><br>  Server首先会向Binder驱动发起注册请求，而Binder驱动在收到该请求之后就将该请求转发给ServiceManager进程。但是Binder驱动怎么才能知道该请求是要转发给ServiceManager的呢？这是因为Server在发送请求的时候，会告诉Binder驱动这个请求是交给0号Binder引用对应的进程来进行处理的。而Binder驱动中指定了0号引用是与ServiceManager对应的。<br>  在Binder驱动转发该请求之前，它其实还做了两件很重要的事：(01) 当它知道该请求是由一个Server发送的时候，它会新建该Server对应的Binder实体。 (02) 它在ServiceManager的”保存Binder引用的红黑树”中查找是否存在该Server的Binder引用；找不到的话，就新建该Server对应的Binder引用，并将其添加到”ServiceManager的保存Binder引用的红黑树”中。简言之，Binder驱动会创建Server对应的Binder实体，并在ServiceManager的红黑树中添加该Binder实体的Binder引用。<br>  当ServiceManager收到Binder驱动转发的注册请求之后，它就将该Server的相关信息注册到”Binder引用组成的单链表”中。这里所说的Server相关信息主要包括两部分：Server对应的服务名 + Server对应的Binder实体的一个Binder引用。</p>
<p><strong>Client获取远程服务</strong><br>  Client要和某个Server通信，需要先获取到该Server的远程服务。那么Client是如何获取到Server的远程服务的呢？<br>  Client首先会向Binder驱动发起获取服务的请求。Binder驱动在收到该请求之后也是该请求转发给ServiceManager进程。ServiceManager在收到Binder驱动转发的请求之后，会从”Binder引用组成的单链表”中找到要获取的Server的相关信息。至于ServiceManager是如何从单链表中找到需要的Server的呢？答案是Client发送的请求数据中，会包括它要获取的Server的服务名；而ServiceManager正是根据这个服务名来找到Server的。<br>  接下来，ServiceManager通过Binder驱动将Server信息反馈给Client的。它反馈的信息是Server对应的Binder实体的Binder引用信息。而Client在收到该Server的Binder引用信息之后，就根据该Binder引用信息创建一个Server对应的远程服务。这个远程服务就是Server的代理，Client通过调用该远程服务的接口，就相当于在调用Server的服务接口一样；因为Client调用该Server的远程服务接口时，该远程服务会对应的通过Binder驱动和真正的Server进行交互，从而执行相应的动作。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-Binder设计解析"><a href="#2-Binder设计解析" class="headerlink" title="2. Binder设计解析"></a>2. Binder设计解析</h1><p>有了上面Binder模型的理论基础，接下来就可以逐步来讲解Binder的设计了。实际上，在设计C-S架构时，要考虑以下两个非常重要的因素。</p>
<p><strong>第一，Server要提供接入点</strong></p>
<p>  如果C-S架构中的Client和Server属于同一进程的话，那么Client和Server之间的通信将非常容易。只需要在Client端先获取相应的Server端对象；然后，再通过Server对象调用Server的相应接口即可。但是，Binder机制中涉及到的Client和Server是位于不同的进程中的，这也就意味着，不可能直接获取到Server对象。那么怎么办呢？ 那就需要Server提供一个接入点给Client。<br>  这个接入点就是<strong>“Server的远程服务代理”</strong>！<br>  Client能够获取到Server的远程服务，它就相当于Server的代理。Client要和Server通信时，它只需要调用该远程服务的相应接口即可，其他的工作都交给远程服务来处理。远程服务收到Client请求之后，会和Binder驱动通信；因为远程服务中有Server在Binder驱动中的Binder引用信息，因此远程服务就能轻易的找到对应的Server，进而将Client的请求内容发送Server。</p>
<p><strong>第二，通信协议</strong></p>
<p>  Binder机制中，涉及到大量的”内核的Binder驱动 和 用户空间的引用程序”之间的通信。需要指定对应的通信协议，确保通信的安全和正常。关于这部分，稍候再详细展开。</p>
<p>有了上面的两个中心思想之后，再来对Binder驱动的设计和协议进行逐步展开。</p>
<p><a name="anchor2_1"></a></p>
<h2 id="2-1-Binder设计"><a href="#2-1-Binder设计" class="headerlink" title="2.1 Binder设计"></a>2.1 Binder设计</h2><p>讲解Binder设计时，分为”内核空间”和”用户空间”这两部分进程讲解。内核空间就是Binder驱动中的Binder设计，而用户空间则是Android的C++层中的Binder设计。</p>
<p><a name="anchor2_1_1"></a></p>
<h3 id="2-1-1-内核空间的Binder设计"><a href="#2-1-1-内核空间的Binder设计" class="headerlink" title="2.1.1 内核空间的Binder设计"></a>2.1.1 内核空间的Binder设计</h3><p>内核空间的Binder设计涉及到3个非常重要的结构体：binder_proc，binder_node和binder_ref。由于本文的重点是介绍Binder机制的理论知识，因此，在这里我并不打算展开这3个结构体对它们进行详细介绍。当然，后面会再撰文对这些类进行详细说明。这里只需要了解个大概即可。</p>
<p>binder_proc是描述进程上下文信息的，每一个用户空间的进程都对应一个binder_proc结构体。<br>binder_node是Binder实体对应的结构体，它是Server在Binder驱动中的体现。<br>binder_ref是Binder引用对应的结构体，它是Client在Binder驱动中的体现。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds01.jpg" alt></a></p>
<p>如上图所示，binder_proc中包含了3棵红黑树。<br>(01) Binder实体红黑树是保存”binder_proc对应的进程”所包含的Binder实体的，而Binder实体是与Server的服务对应的。可以将Binder实体红黑树理解为Server进程中包行的Server服务的红黑树。<br>(02) 图中有两棵Binder引用红黑树，这两棵树所包含的Binder引用都是一样的。不同的是，红黑树的排序基准不同，一个是以Binder实体来排序，而另一个则是以Binder引用描述(Binder引用描述实际上就是一个32位的整型数)来排序。以Binder引用描述的红黑树是为了方便进行快速查找。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds02.jpg" alt></a></p>
<p>上图是描述Binder驱动中Binder实体结构体的。如图所示，Binder实体中有一个Binder引用的哈希表，专门来存放该Binder实体的Binder引用。这也如我们之前所说，每个Binder实体则可以多个Binder引用，而每个Binder引用则都只对应一个Binder实体。</p>
<p><a name="anchor2_1_2"></a></p>
<h3 id="2-1-2-用户空间的Binder设计"><a href="#2-1-2-用户空间的Binder设计" class="headerlink" title="2.1.2 用户空间的Binder设计"></a>2.1.2 用户空间的Binder设计</h3><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_user_ds01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_user_ds01.jpg" alt></a></p>
<p>上面是用户空间中Binder模型图，该图仅仅只描述出Server的相关类图，并没有Client部分。不过不要紧，通过这个Server的模型图，就能理清用户空间的Binder框架。</p>
<p>  前面说过，Server是以服务的形式注册到ServiceManager中，而Server在Client中则是以远程服务的形式存在的。因此，这个图的主干就是理清楚本地服务和远程服务这两者之间的关系。<br>  “本地服务”就是Server提供的服务本身，而”远程服务”就是服务的代理；”服务接口”则是抽象出了它们的通用接口。这3个角色都是通用的，对于不同的服务而言，它们的名称都不相同。例如，对于MediaPlayerService服务而言，本地服务就是MediaPlayerService自身，远程服务是BpMediaPlayerService，而服务接口是IMediaPlayerService。当Client需要向MediaPlayerService发送请求时，它需要先获取到服务的代理(即，远程服务对象)，也就是BpMediaPlayerService实例，然后通过该实例和MediaPlayerService进行通信。</p>
<p>  图中的ProcessState和IPCThreadState都是采用单例模式实现的，它们的实例都是全局的，而且只有唯一一个。</p>
<p>(01) 当Server启动之后，它会先将自己注册到ServiceManager中。注册时，Binder驱动会创建Server对应的Binder实体，并将”Server对应的本地服务对象的地址”保存到Binder实体中。注册成功之后，Server就进入消息循环，等待Client的请求。<br>(02) 当Client需要和Server通信时，会先获取到Server接入点，即获取到远程服务对象；而且Client要获取的远程服务对象是”服务接口”类型的。Client向ServiceManager发送获取服务的请求时，会通过IPCThreadState和Binder驱动进行通信；当ServiceManager反馈之后，IPCThreadState会将ServiceManager反馈的”Server的Binder引用信息”保存BpBinder中(具体来说，BpBinder的mHandle成员保存的就是Server的Binder引用信息)。然后，会根据该BpBinder对象创建对应的远程服务。这样，Client就获取到了远程服务对象，而且远程服务对象的成员中保存了Server的Binder引用信息。<br>(03) 当Client获取到远程服务对象之后，它就可以轻松的和Server进行通信了。当它需要向Server发送请求时，它会调用远程服务接口；远程服务能够获取到BpBinder对象，而BpBinder则通过IPCThreadState和Binder驱动进行通信。由于BpBinder中保存了Server在Binder驱动中的Binder引用；因此，IPCThreadState和Binder驱动通信时，是知道该请求是需要传给哪个Server的。Binder驱动通过Binder引用找到对应的Binder实体，然后将Binder实体中保存的”Server对应的本地服务对象的地址”返回给用户空间。当IPC收到Binder驱动反馈的内容之后，它从内容中找到”Server对应的本地服务对象”，然后调用该对象的onTransact()。不同的本地服务都可以实现自己的onTransact()；这样，不同的服务就可以按照自己的需求来处理请求。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-Binder通信"><a href="#2-2-Binder通信" class="headerlink" title="2.2 Binder通信"></a>2.2 Binder通信</h2><p>Binder通信协议是基于Command-Reply的方式的。</p>
<p><a name="anchor2_2_1"></a></p>
<h3 id="2-2-1-Binder通信模型"><a href="#2-2-1-Binder通信模型" class="headerlink" title="2.2.1 Binder通信模型"></a>2.2.1 Binder通信模型</h3><p>下面是Client和Server的交互模型图。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_communication.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_communication.jpg" alt></a></p>
<p>图中的原理很简单。<br>(01) Server进程启动之后，会进入中断等待状态，等待Client的请求。<br>(02) 当Client需要和Server通信时，会将请求发送给Binder驱动。<br>(03) Binder驱动收到请求之后，会唤醒Server进程。<br>(04) 接着，Binder驱动还会反馈信息给Client，告诉Client：它发送给Binder驱动的请求，Binder驱动已经收到。<br>(05) Client将请求发送成功之后，就进入等待状态。等待Server的回复。<br>(06) Binder驱动唤醒Server之后，就将请求转发给Server进程。<br>(07) Server进程解析出请求内容，并将回复内容发送给Binder驱动。<br>(08) Binder驱动收到回复之后，唤醒Client进程。<br>(09) 接着，Binder驱动还会反馈信息给Server，告诉Server：它发送给Binder驱动的回复，Binder驱动已经收到。<br>(10) Server将回复发送成功之后，再次进入等待状态，等待Client的请求。<br>(11) 最后，Binder驱动将回复转发给Client。</p>
<p><a name="anchor2_2_2"></a></p>
<h3 id="2-2-2-Binder通信数据"><a href="#2-2-2-Binder通信数据" class="headerlink" title="2.2.2 Binder通信数据"></a>2.2.2 Binder通信数据</h3><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_data.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_data.jpg" alt></a></p>
<p>上面是用户空间和内核空间进行交互时，数据的打包方式。例如，当Client向Server发送请求时，Client会将数据打包成上诉格式，然后通过ioctl()发送给Binder驱动。根据数据的层次，从外到里分为3层进行说明。</p>
<p><strong>第一层</strong>：这是用户空间的进程调用ioctl(fd,BINDER_WRITE_READ,&amp;bwr)时传递给Binder驱动的信息。fd是Binder驱动的文件句柄，BINDER_WRITE_READ是ioctl()的一个标识，而bwr是传递的数据，它对应是途中的binder_write_read结构体的指针。binder_write_read中以write_开头的是保存请求数据的，而read_开头的是保存反馈数据的。其中，write_size是请求数据的大小，write_buffer是请求数据的内容，而write_consumed是用来记录请求数据中已经被Binder驱动处理过的数据的大小。</p>
<p><strong>第二层</strong>：这层的数据是”事务指令”+”binder_transaction_data结构体”组成的。图中给出的事务指令是BC_TRANSACTION，表示该事务是请求；如果是回复，则是BR_开头的，例如BR_TRANSACTION。binder_transaction_data是描述事务交互数据的结构体；例如，target是指定事务目标，用来表示这个事务是交给谁进行处理的；code是事务编码，用来表示这是一个什么样的事务(例如，注册服务事务/获取服务事务等待)；data是保存事务中具体数据的内存地址。</p>
<p><strong>第三层</strong>：这层是有效数据。如果该请求是传递给ServiceManager进行处理的，则有效数据是：消息头+”Server的相关信息”。消息头是用来进行有效性检查的，而”Server的相关信息”则是请求要处理的信息。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/08/26/android/os/message/2014-08-26-MessageQueue/" itemprop="url">Android消息机制架构和源码解析</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-08-26T01:01:00.000Z" itemprop="datePublished">8月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            36 分钟 read (About 5349 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文会介绍Android的消息处理机制。  </p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Android消息机制的架构</a><br><strong>2</strong>. <a href="#anchor2">Android消息机制的源码解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">消息循环</a><br><strong>2.2</strong>. <a href="#anchor2_2">消息的发送</a><br><strong>2.3</strong>. <a href="#anchor2_3">消息的处理</a>  </p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Android消息机制的架构"><a href="#Android消息机制的架构" class="headerlink" title="Android消息机制的架构"></a>Android消息机制的架构</h1><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/messagequeue/message_queue01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/messagequeue/message_queue01.jpg" alt></a></p>
<p>上面是消息机制的框架图。<br>(01) Looper是消息循环类，它包括了mQueue成员变量；mQueue是消息队列MessageQueue的实例。Looper还包含了loop()方法，通过调用loop()就能进入到消息循环中。<br>(02) MessageQueue是消息队列类，它包含了mMessages成员；mMessages是消息Message的实例。MessageQueue提供了next()方法来获取消息队列的下一则消息。<br>(03) Message是消息类。Message包含了next，next是Message的实例；由此可见，Message是一个单链表。Message还包括了target成员，target是Handler实例。此外，它还包括了arg1,arg2,what,obj等参数，它们都是用于记录消息的相关内容。<br>(04) Handler是消息句柄类。Handler提供了sendMessage()来向消息队列发送消息；发送消息的API有很多，它们的原理都是一样的，这里仅仅只列举了sendMessage()一个。  此外，Handler还提供了handleMessage()来处理消息队列的消息；这样，用户通过覆盖handleMessage()就能处理相应的消息。<br>消息机制位于Java层的框架主要就有上面4个类所组成。在C++层，比较重要的是NativeMessageQueue和Loop这两个类。<br>当我们启动一个APK时，ActivityManagerService会为我们的Activity创建并启动一个主线程(ActivityThread对象)；在启动主线程时，就会创建主线程对应的消息循环，并通过调用loop()进入到消息循环中。当我们需要往消息队列发送消息时，可以继承Handler类，然后创建Handler类的实例；接着，通过该实例的sendMessage()方法就可以向消息队列发送消息。  也就是说，主线程的消息队列也一直存在的。当消息队列中没有消息时，消息队列会进入空闲等待状态；当有消息时，则消息队列会进入运行状态，进而将相应的消息发送给handleMessage()进行处理。</p>
<br>
下面是消息机制的流程图：消息队列没有消息时进入空闲等待，有消息时才获取并发送消息。这种机制是通过pipe(管道)机制实现的，关于pipe机制的相关内容，后面再详细说明。

<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/messagequeue/message_queue02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/messagequeue/message_queue02.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="Android消息机制的源码解析"><a href="#Android消息机制的源码解析" class="headerlink" title="Android消息机制的源码解析"></a>Android消息机制的源码解析</h1><p>下面从”消息循环、消息发送和消息处理”这3个方面对消息机制进行介绍。</p>
<p><a name="anchor2_1"></a></p>
<h2 id="1-消息循环"><a href="#1-消息循环" class="headerlink" title="1. 消息循环"></a>1. 消息循环</h2><p>Looper是消息循环类。下面先看看ActivityThread中是如何使用Looper的。</p>
<pre><code>public final class ActivityThread {

    ...

    public static void main(String[] args) {

        ...

        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        ...

        Looper.loop();

        ...
    }
}</code></pre><p>说明：上面是frameworks/base/core/java/android/app/ActivityThread.java中的main()函数代码。<br>通常在新打开一个APK界面时，系统会为APK启动创建一个ActivityThread对象，并调用它的main()方法。该main函数主要做了两件事：(01),新建ActivityThread对象。  (02),使用主线程进入消息循环。</p>
<pre><code>public final class Looper {
    private static final String TAG = &quot;Looper&quot;;

    static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
    private static Looper sMainLooper;  // guarded by Looper.class

    final MessageQueue mQueue;
    final Thread mThread;

    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
            }
            sMainLooper = myLooper();
        }
    }

    public static Looper getMainLooper() {
        synchronized (Looper.class) {
            return sMainLooper;
        }
    }

    public static Looper myLooper() {
        return sThreadLocal.get();
    }

    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }

    ...
}</code></pre><p>说明：上面是frameworks/base/core/java/android/os/Looper.java中创建消息循环的相关代码。<br>(01), prepareMainLooper()是新调用prepare()创建一个Looper对象，并且该Looper对象对应的消息队列是不能退出(quit)的。<br>(02), 新建的Looper对象是存放在sThreadLocal成员变量里面的，而sThreadLocal的类型为ThreadLocal。这意味着，它是一个线程局部变量，即保证每一个调用了prepareMainLooper函数的线程里面都有一个独立的Looper对象。<br>(03)，Looper()的构造函数中会新建消息队列MessageQueue对象，并且将当前的主线程保存到mThread中。实际上，Looper中的消息都是通过存放到MessageQueue消息队列中再进行处理的。</p>
<pre><code>public final class MessageQueue {

    // True if the message queue can be quit.
    private final boolean mQuitAllowed;

    @SuppressWarnings(&quot;unused&quot;)
    private int mPtr; // used by native code

    private native static int nativeInit();

    ...

    MessageQueue(boolean quitAllowed) {
        mQuitAllowed = quitAllowed;
        mPtr = nativeInit();
    }

    ...
}</code></pre><p>说明：该代码在frameworks/base/core/java/android/os/MessageQueue.java中。MessageQueue的构造函数会执行nativeInit()，nativeInit()是一个JNI函数，它的实现在frameworks/base/core/jni/android_os_MessageQueue.cpp中。</p>
<pre><code>static jint android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {
    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();
    if (!nativeMessageQueue) {
        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);
        return 0;
    }   

    nativeMessageQueue-&gt;incStrong(env);
    return reinterpret_cast&lt;jint&gt;(nativeMessageQueue);
}</code></pre><p>说明：该代码在frameworks/base/core/jni/android_os_MessageQueue.cpp中。android_os_MessageQueue_nativeInit()是与nativeInit()对应的JNI函数。<br>(01) 在该函数中，会新建NativeMessageQueue对象。这是我们分析的重点。<br>(02) nativeMessageQueue-&gt;incStrong(env); 它的作用是增加引用计数。  </p>
<pre><code>NativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) {
    mLooper = Looper::getForThread();
    if (mLooper == NULL) {
        mLooper = new Looper(false);
        Looper::setForThread(mLooper);
    }
}</code></pre><p>说明：该代码在frameworks/base/core/jni/android_os_MessageQueue.cpp中。NativeMessageQueue继承于MessageQueue，而MessageQueue包含mLooper成员，mLooper是一个Looper对象。 该函数中，会新建Looper对象，并调用setForThread()。</p>
<pre><code>Looper::Looper(bool allowNonCallbacks) :
        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),
        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {
    int wakeFds[2];
    int result = pipe(wakeFds);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not create wake pipe.  errno=%d&quot;, errno);

    mWakeReadPipeFd = wakeFds[0];
    mWakeWritePipeFd = wakeFds[1];

    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake read pipe non-blocking.  errno=%d&quot;,
            errno);

    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake write pipe non-blocking.  errno=%d&quot;,
            errno);

    mIdling = false;

    // Allocate the epoll instance and register the wake pipe.
    mEpollFd = epoll_create(EPOLL_SIZE_HINT);
    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);

    struct epoll_event eventItem;
    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
    eventItem.events = EPOLLIN;
    eventItem.data.fd = mWakeReadPipeFd;
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake read pipe to epoll instance.  errno=%d&quot;,
            errno);
}</code></pre><p>说明：该代码在system/core/libutils/Looper.cpp中。Looper构造函数所在做的事情非常重要，它跟消息机制的原理息息相关：Looper是通过管道(pipe)实现的。</p>
<blockquote>
<p>关于管道，简单来说，管道就是一个文件。<br>在管道的两端，分别是两个打开文件文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的。<br>一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。这个等待和唤醒的操作是如何进行的呢，这就要借助Linux系统中的epoll机制了。 Linux系统中的epoll机制为处理大批量句柄而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
</blockquote>
<p>(01) pipe(wakeFds)，该函数创建了两个管道句柄。<br>(02) mWakeReadPipeFd=wakeFds[0]，是读管道的句柄。<br>(03) mWakeWritePipeFd=wakeFds[1]，是写管道的句柄。<br>(04) epoll_create(EPOLL_SIZE_HINT)是创建epoll句柄。<br>(05) epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem)，它的作用是告诉mEpollFd，它要监控mWakeReadPipeFd文件描述符的EPOLLIN事件，即当管道中有内容可读时，就唤醒当前正在等待管道中的内容的线程。</p>
<br>
至此，就介绍完消息循环的创建/准备阶段。该节点的主要工作可以概括为2部分内容：  
(01) Java层，创建Looper对象，Looper的构造函数中会创建消息队列MessageQueue的对象。MessageQueue的作用存储消息队列，用来管理消息的。  
(02) C++层，消息队列创建时，会调用JNI函数，初始化NativeMessageQueue对象。NativeMessageQueue则会初始化Looper对象。Looper的作用就是，当Java层的消息队列中没有消息时，就使Android应用程序主线程进入等待状态，而当Java层的消息队列中来了新的消息后，就唤醒Android应用程序的主线程来处理这个消息。



<br>
下面分析Looper.loop()函数。

<pre><code>public final class Looper {

    ...

    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
        }
        final MessageQueue queue = me.mQueue;

        ...

        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                return;
            }

            ...

            msg.target.dispatchMessage(msg);

            ...

            msg.recycle();
        }
    }  

    ...
}</code></pre><p>说明：loop()的作用就是不断的从消息队列中获取消息，然后分发处理。<br>(01) myLooper()，是获取当前的Looper对象；而mQueue则是Looper对应的消息队列对象。<br>(02) queue.next()是消息队列的下一个要处理消息。如果消息为空，则退出loop循环；否则，调用dispatchMessage()分发消息。  </p>
<pre><code>Message next() {
    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        // 调用JNI函数Poll消息。nextPollTimeoutMillis是消息队列中没消息时的等待时间。
        // (01) nextPollTimeoutMillis = 0，不等待。
        // (02) nextPollTimeoutMillis = -1，无限等待。
        nativePollOnce(mPtr, nextPollTimeoutMillis);

        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            // 如果当前消息非空，但是当前消息的目标是空；则获取下一则消息。
            if (msg != null &amp;&amp; msg.target == null) {
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    // 如果消息队列中有消息，并且当前时间小于于消息中的执行时间，
                    // 则设置消息的等待时间
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // 如果消息队列中有消息，并且当前时间大于/等于消息中的执行时间，
                    // 则将该消息返回给Looper。
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false) Log.v(&quot;MessageQueue&quot;, &quot;Returning message: &quot; + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // 如果消息队列中无消息，则设置nextPollTimeoutMillis=-1；
                // 下次调用nativePollOnce()时，则会进入无穷等待状态。
                nextPollTimeoutMillis = -1;
            }

            // 如主线程调用的quit()函数，则退出消息循环。
            if (mQuitting) {
                dispose();
                return null;
            }

            // 查看空闲等待(不是忙等待)对应的pendingIdleHandlerCount数量。
            // 如果pendingIdleHandlerCount=0，则继续下一次循环。
            if (pendingIdleHandlerCount &lt; 0
                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            // 将mIdleHandlers转换位数组
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // 执行mPendingIdleHandlers中每一个IdleHandler的queueIdle()，
        // 即，进行空闲等待。
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(&quot;MessageQueue&quot;, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}</code></pre><p>说明：next()的作用是获取消息队列的下一条待处理消息。该函数可能导致主线程进入等待状态。源码中已经消息标明了注释，这里就不再重复说明了。 下面分析next()中的nativePollOnce()，它对应的实现函数是android_os_MessageQueue_nativePollOnce()。 </p>
<pre><code>static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jclass clazz,
        jint ptr, jint timeoutMillis) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;pollOnce(env, timeoutMillis);
}</code></pre><p>说明：该函数调用了pollOnce()。</p>
<pre><code>void NativeMessageQueue::pollOnce(JNIEnv* env, int timeoutMillis) {
    ...
    mLooper-&gt;pollOnce(timeoutMillis);
    ...
}</code></pre><p>说明：NativeMessageQueue的pollOnce()，调用了Looper.java中(即mLooper)的pollOnce()。</p>
<pre><code>int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    ...
    int result = 0;
    for (;;) {
        ...   

        if (result != 0) {
            ...
            return result;
        }   

        result = pollInner(timeoutMillis);
    }   
}</code></pre><p>说明：pollOnce()调用了pollInner()。 </p>
<pre><code>int Looper::pollInner(int timeoutMillis) {

    ...

    // 通过epoll_wait()等待mEpollFd上IO事件的发生
    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    ...

    // 如果epoll_wait()时出错，则直接跳到Done处。
    if (eventCount &lt; 0) {
        ...
        goto Done;
    }

    // 如果没有IO事件发生，则直接跳到Done处。
    if (eventCount == 0) {
        ...
        goto Done;
    }

    // 如果有IO事件发生，则逐个取出IO事件，如果是写事件(EPOLLIN)，则调用awoken()
    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeReadPipeFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            } else {
                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;, epollEvents);
            }
        } else {
            ...
        }
    }

Done: ;

    ...

    return result;
}</code></pre><p>说明：pollInner()就是先通过epoll_wait()进入空闲等待状态，等待消息队列的管道上的消息(IO事件)。如果有消息待处理(即管道上有IO写事件发生，写事件是EPOLLIN类型)，则调用awoken()将消息读取出来。</p>
<pre><code>void Looper::awoken() {
    ...

    char buffer[16];
    ssize_t nRead;
    do {
        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));
    } while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer));
}</code></pre><p>说明：awoken()的作用只是把管道中的内容都读取出来。在了解了后面将介绍的”发送消息”之后，会了解到，这里读取的数据内容是无所谓的(实际上读取到的数据就是一个”w”)。重要的是，通过往管道中读/写数据来使处于等待状态的主线程继续运行。</p>
<br>
至此，"消息循环"部分就介绍完毕了！  
回到Looper.loop()中，next()获取到了消息队列的下一则待处理的消息之后；接着，会调用dispatchMessage()来分发处理消息了。dispatchMessage()的内容，我们放到后面的"消息的处理"部分再来介绍。





<p><a name="anchor2_2"></a></p>
<h2 id="2-消息的发送"><a href="#2-消息的发送" class="headerlink" title="2. 消息的发送"></a>2. 消息的发送</h2><p>还是以ActivityThread为例，看看如何发送消息。在启动Activity时，会调用scheduleLaunchActivity()，下面看看scheduleLaunchActivity()是如何发送消息的。</p>
<pre><code>public final class ActivityThread {
    ...

    private class ApplicationThread extends ApplicationThreadNative {
        ...

        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo,
                int procState, Bundle state, List&lt;ResultInfo&gt; pendingResults,
                List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward,
                String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) {

            ...

            sendMessage(H.LAUNCH_ACTIVITY, r);
        }

        ...
    }

    ...

    private void sendMessage(int what, Object obj) {
        sendMessage(what, obj, 0, 0, false);
    }

    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {

        Message msg = Message.obtain();
        msg.what = what;
        msg.obj = obj;
        msg.arg1 = arg1;
        msg.arg2 = arg2;
        if (async) {
            msg.setAsynchronous(true);
        }
        mH.sendMessage(msg);
    }

    ...
}</code></pre><p>说明：scheduleLaunchActivity()定义在类ApplicationThread中，而ApplicationThread是ActivityThread的内部类。<br>(01) scheduleLaunchActivity()调用sendMessage()发送消息，实际上是调用的ActivityThread类中的sendMessage。<br>(02) 在sendMessage()中，会新建一个Message；然后调用mH.sendMessage(msg)来发送消息。  </p>
<pre><code>public final class ActivityThread {

    ...

    final H mH = new H();

    ...

    private class H extends Handler {
        ... 

        public void handleMessage(Message msg) {
            ...

            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;

                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ...
            }
        }
    }
}</code></pre><p>说明：mH是H实例，H继承于Handler。sendMessage()的实现在Handler中，下面看看它的实现代码。</p>
<pre><code>public class Handler {

    ...

    public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }

    public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis &lt; 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }

    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }

    ...
}</code></pre><p>说明：该代码在frameworks/base/core/java/android/os/Handler.java中。<br>(01) sendMessage()调用sendMessageDelayed(msg, delayMillis)。sendMessageDelayed(msg, delayMillis)是延时发送消息函数，sendMessage()传入的delayMillis=0，表示延时是0。<br>(02) sendMessageDelayed()调用sendMessageAtTime()。sendMessageAtTime()是指定消息的执行时间的函数。<br>(03) sendMessageAtTime()调用enqueueMessage()。<br>(04) enqueueMessage()queue.enqueueMessage()将消息添加到消息队列中。  </p>
<pre><code>public final class MessageQueue {

    ...

    boolean enqueueMessage(Message msg, long when) {

        ...

        synchronized (this) {
            if (mQuitting) {
                return false;
            }

            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                // 消息队列无消息
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // 消息队列有消息。将当前消息插入到适当的位置
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // 唤醒主线程
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }

    ...

}</code></pre><p>说明：enqueueMessage()会将消息加入到消息队列中。把消息加入到消息队列时，分2种情况：<br>(01)，消息队列为空。  这时候应用程序的主线程一般就是处于空闲等待状态了，这时候就要唤醒它。<br>(02)，消息队列不为空。  这时候就不需要唤醒应用程序的主线程了，因为这时候它一定是在忙着处于消息队列中的消息，因此不会处于空闲等待的状态。<br>在添加完消息之后，如果主线程需要唤醒，则调用nativeWake()。nativeWake()是个JNI函数，它对应的实现是frameworks/base/core/jni/android_os_MessageQueue.cpp中的android_os_MessageQueue_nativeWake()。</p>
<pre><code>static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jint ptr) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    return nativeMessageQueue-&gt;wake();
}</code></pre><p>说明：该函数会调用NativeMessageQueue类中的wake()。</p>
<pre><code>void NativeMessageQueue::wake() {
    mLooper-&gt;wake();
}</code></pre><p>说明：该函数会调用system/core/libutils/Looper.cpp中的wake()。mLooper是创建NativeMessageQueue时创建的Looper对象，这在前面已经介绍过了。</p>
<pre><code>void Looper::wake() {

    ...       

    ssize_t nWrite;
    do {
        nWrite = write(mWakeWritePipeFd, &quot;W&quot;, 1);
    } while (nWrite == -1 &amp;&amp; errno == EINTR);

    ...       
}           </code></pre><p>说明：wake()的作用很简单，就是通过打开文件描述符mWakeWritePipeFd往管道的写入一个”W”字符串。<br>其实，往管道写入什么内容并不重要，往管道写入内容的目的是为了唤醒应用程序的主线程。<strong>前面我们在分析应用程序的消息循环时说到，当应用程序的消息队列中没有消息处理时，应用程序的主线程就会进入空闲等待状态，而这个空闲等待状态就是通过调用这个Looper类的pollInner()函数来进入的，具体就是在pollInner()函数中调用epoll_wait()函数来等待管道中有内容可读的</strong>。这样，就将发送消息和接收消息联系起来了。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="3-消息的处理"><a href="#3-消息的处理" class="headerlink" title="3. 消息的处理"></a>3. 消息的处理</h2><p>前面介绍了”消息的发送过程”；而且我们又知道，在”消息循环”中，会不断读取消息，然后调用dispatchMessage()来分发处理。</p>
<pre><code>public final class Looper {

    ...

    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
        }
        final MessageQueue queue = me.mQueue;

        ...

        for (;;) {
            // 取出消息
            Message msg = queue.next(); // might block
            if (msg == null) {
                return;
            }

            ...

            // 分发处理
            msg.target.dispatchMessage(msg);

            ...

            msg.recycle();
        }
    }  

    ...
}</code></pre><p>说明：上面就是loop()消息循环的代码，这在前面已经介绍过了。首先，从消息队列中通过next()取出消息；然后通过dispatchMessage()分发消息。<br>下面，现看看msg.target是什么对象。 </p>
<pre><code>public class Handler {

    ...

    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }

    ...
}</code></pre><p>说明：实际上，msg.target是在”发送消息时”调用的enqueueMessage()中赋值的。this就是Handler对象，而在”消息的发送”中，真正发送消息的是Handler的子类H。也就是说，this是类H的实例。  </p>
<pre><code>public final class ActivityThread {

    ...

    private class H extends Handler {
        ... 
    }

    ...

}</code></pre><p>说明：上面就是ActivityThread中H的定义。<br>现在，我们已经澄清了msg.target是H类的实例。那么，再次回到 msg.target.dispatchMessage(msg)中，它实际上是调用的Handler类(H类的父类)的dispatchMessage()函数。</p>
<pre><code>public class Handler {

    ...

    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }

    ...

}</code></pre><p>说明：在本文的示例ActivityThread中，msg.callback为空。dispatchMessage()最终会调用handleMessage()处理消息。下面看看H中handleMessage()的代码。</p>
<pre><code>public final class ActivityThread {

    ...

    final H mH = new H();

    ...

    private class H extends Handler {
        ... 

        public void handleMessage(Message msg) {
            ...

            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;

                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ...
            }
        }
    }
}</code></pre><p>说明：handleMessage()的内容不是重点，需要关注的是：消息队列的消息最终是通过handleMessage()来处理的！</p>
<br>
至此，消息机制的发送/接受/处理消息部分都介绍完毕了！总的来说：  
(01)，应用程序先通过Looper.prepareMainLooper()来创建消息队列。在创建消息队列的过程中，会创建Looper对象，MessageQueue对象，并调用JNI函数；最终，通过管道来进入空闲等待状态。  
(02)，当应用程序调用sendMessage()或其他类似接口发送消息时，消息会被添加到消息队列；并最终会先管道中写入内容，从而唤醒管道上处于空闲等待状态的主线程。  
(03)，管道上的空闲状态的主线程被唤醒之后，就会读出消息队列的消息，然后通过dispatchMessage()来分发处理。最终，消息会通过handleMessage()来进行处理。



    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/26/android/api_guide/animation/drawable_animation/2014-07-24-DrawableAnimation-BasicUsage/" itemprop="url">Android 之Animation动画(七)之 Drawable Animation</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-26T01:00:00.000Z" itemprop="datePublished">7月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 read (About 265 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Android中的Drawable Animation。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Drawable Animation的简介和语法</a><br><strong>2</strong>. <a href="#anchor2">Drawable Animation的示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Drawable-Animation的简介和语法"><a href="#Drawable-Animation的简介和语法" class="headerlink" title="Drawable Animation的简介和语法"></a>Drawable Animation的简介和语法</h1><p>Drawable Animation(Frame Animation)：帧动画，就像GIF图片，通过一系列Drawable依次显示来模拟动画的效果。</p>
<p>Drawable Animation的定义是通过在<strong>res/anim</strong>目录下新建一个xml文件来定义。xml文件的格式如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:oneshot=&quot;false&quot;&gt;
    &lt;item android:drawable=&quot;@drawable/rocket_thrust1&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/rocket_thrust2&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/rocket_thrust3&quot; android:duration=&quot;200&quot; /&gt;
&lt;/animation-list&gt;</code></pre><p>说明：<br>(01) oneshot表示是否循环播放。true表示不循环播放，否则就循环播放。<br>(02) duration表示每帧的播放时间。  </p>
<p><a name="anchor2"></a></p>
<h1 id="Drawable-Animation的示例"><a href="#Drawable-Animation的示例" class="headerlink" title="Drawable Animation的示例"></a>Drawable Animation的示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/drawable_animation/01_basic/AnimationTest" target="_blank" rel="noopener">Drawable Animation示例的完整源码</a></p>
<p>示例中是通过ImageView来使用Drawable Animation的。 下面是获取ImageView的AnimationDrawable对象的方法：</p>
<pre><code>mImage = (ImageView)findViewById(R.id.animation);
mImage.setBackgroundResource(R.anim.anim_kof);
mAnimation = (AnimationDrawable) mImage.getBackground();</code></pre><p>说明：res/anim/anim_kof.xml就是动画的定义。</p>
<p>得到AnimationDrawable对象之后，就可以通过mAnimation.start()直接启动动画了。 </p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/25/android/api_guide/animation/view_animation/2014-07-24-ViewAnimation-BasicUsage/" itemprop="url">Android 之Animation动画(六)之 View Animation</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-25T01:00:00.000Z" itemprop="datePublished">7月 25 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            6 分钟 read (About 930 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Android中的View Animation。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">View Animation简介</a><br><strong>2</strong>. <a href="#anchor2">View Animation的语法规则</a><br><strong>3</strong>. <a href="#anchor3">View Animation的示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="View-Animation简介"><a href="#View-Animation简介" class="headerlink" title="View Animation简介"></a>View Animation简介</h1><p>View Animation(Tween Animation): 补间动画，给出两个关键帧，通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。</p>
<p>View Animation只能用来实现四种基本动作：透明/伸缩/移动/旋转。它与”Property Animation适用于任意Object类型不同”，View Animation只适用于View。但是View Animation相比于Property Animation的使用更加简单。</p>
<p><a name="anchor2"></a></p>
<h1 id="View-Animation的语法规则"><a href="#View-Animation的语法规则" class="headerlink" title="View Animation的语法规则"></a>View Animation的语法规则</h1><h2 id="1-View-Animation的样式"><a href="#1-View-Animation的样式" class="headerlink" title="1. View Animation的样式"></a>1. View Animation的样式</h2><p>View Animation通常在<strong>res/anim</strong>目录下新建一个xml文件来定义。xml文件的格式如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;
    android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt;
    &lt;alpha
        android:fromAlpha=&quot;float&quot;
        android:toAlpha=&quot;float&quot; /&gt;
    &lt;scale
        android:fromXScale=&quot;float&quot;
        android:toXScale=&quot;float&quot;
        android:fromYScale=&quot;float&quot;
        android:toYScale=&quot;float&quot;
        android:pivotX=&quot;float&quot;
        android:pivotY=&quot;float&quot; /&gt;
    &lt;translate
        android:fromXDelta=&quot;float&quot;
        android:toXDelta=&quot;float&quot;
        android:fromYDelta=&quot;float&quot;
        android:toYDelta=&quot;float&quot; /&gt;
    &lt;rotate
        android:fromDegrees=&quot;float&quot;
        android:toDegrees=&quot;float&quot;
        android:pivotX=&quot;float&quot;
        android:pivotY=&quot;float&quot; /&gt;
    &lt;set&gt;
        ...
    &lt;/set&gt;
&lt;/set&gt;</code></pre><p>说明：<br>(01) <strong>set</strong>: 是动画的集合，相当于一个容器。<br>(02) <strong>interpolator</strong>: 动画的动作类型，比如accelerate_interpolator类型的动画是加速的，它会越来越快。<br>(03) <strong>shareInterpolator</strong>: 将set的interpolator应用到set所包行的动画中。<br>(04) <strong>alpha</strong>: 透明度。<br>&nbsp;&nbsp; a) <strong>fromAlpha</strong>: 起始动画的透明度。它的值是0<del>1.0之间；0表示完全透明，1.0表示完全不透明。<br>&nbsp;&nbsp; b) <strong>toAlpha</strong>: 结束动画的透明度。它的值是0</del>1.0之间；0表示完全透明，1.0表示完全不透明。<br>(05) <strong>scale</strong>: 缩放。<br>&nbsp;&nbsp; a) <strong>fromXScale</strong>: 起始动画在X轴上的缩放倍数。0表示没有，2表示2倍。<br>&nbsp;&nbsp; b) <strong>toXScale</strong>: 结束动画在X轴上的缩放倍数。0表示没有，2表示2倍。<br>&nbsp;&nbsp; c) <strong>fromYScale</strong>: 起始动画在Y轴上的缩放倍数。0表示没有，2表示2倍。<br>&nbsp;&nbsp; d) <strong>toYScale</strong>: 结束动画在Y轴上的缩放倍数。0表示没有，2表示2倍。<br>&nbsp;&nbsp; e) <strong>pivotX</strong>: 动画缩放时，中心点在X轴上的位置(相对于原始的视图)。50%表示在视图的X轴中间。<br>&nbsp;&nbsp; f) <strong>pivotY</strong>: 动画缩放时，中心点在Y轴上的位置(相对于原始的视图)。50%表示在视图的Y轴中间。<br>(06) <strong>training</strong>: 移动。<br>&nbsp;&nbsp; a) <strong>fromXDelta</strong>: 起始动画在X轴上的偏移像素(相对于视图左上角)。<br>&nbsp;&nbsp; b) <strong>toXDelta</strong>: 结束动画在X轴上的偏移像素(相对于视图左上角)。<br>&nbsp;&nbsp; c) <strong>fromYDelta</strong>: 起始动画在Y轴上的偏移像素(相对于视图左上角)。<br>&nbsp;&nbsp; d) <strong>toYDelta</strong>: 结束动画在Y轴上的偏移像素(相对于视图左上角)。<br>(07) <strong>rotate</strong>: 旋转。<br>&nbsp;&nbsp; a) <strong>fromDegrees</strong>: 起始动画在的角度。可以是负数，也可以大于360。<br>&nbsp;&nbsp; b) <strong>toDegrees</strong>: 起始动画在的角度。可以是负数，也可以大于360。<br>&nbsp;&nbsp; c) <strong>pivotX</strong>: 动画旋转时，中心点在X轴上的位置(相对于原始的视图)。50%表示在视图的X轴中间。<br>&nbsp;&nbsp; d) <strong>pivotY</strong>: 动画旋转时，中心点在Y轴上的位置(相对于原始的视图)。50%表示在视图的Y轴中间。<br>rotate既可以顺时针旋转，也可以逆时针旋转。 </p>
<h2 id="2-interpolator的样式"><a href="#2-interpolator的样式" class="headerlink" title="2. interpolator的样式"></a>2. interpolator的样式</h2><p>系统自带的interpolator样式如下：</p>
<p>@android:anim/accelerate_decelerate_interpolator<br>@android:anim/accelerate_interpolator<br>@android:anim/anticipate_interpolator<br>@android:anim/anticipate_overshoot_interpolator<br>@android:anim/bounce_interpolator<br>@android:anim/cycle_interpolator<br>@android:anim/decelerate_interpolator<br>@android:anim/linear_interpolator<br>@android:anim/overshoot_interpolator</p>
<p><a name="anchor3"></a></p>
<h1 id="View-Animation的示例"><a href="#View-Animation的示例" class="headerlink" title="View Animation的示例"></a>View Animation的示例</h1><p>点击查看: <a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/view_animation/01_basic/AnimationTest" target="_blank" rel="noopener">View Animation的示例源码</a></p>
<p>该示例包括View Animation的”透明/伸缩/移动/旋转”，也包括”它们的组合”。</p>
<p>View Animation的具体播放代码如下：</p>
<pre><code>Animation anim = AnimationUtils.loadAnimation(this, R.anim.anim_alpha);
view.startAnimation(anim);</code></pre><p>说明：view是一个View对象。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-Layout/" itemprop="url">Android 之Animation动画(五)之 Property Animation的布局动画</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T04:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 分钟 read (About 385 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章如何通过Property Animation设置Android的布局动画。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Property Animation布局动画简介</a><br><strong>2</strong>. <a href="#anchor2">Property Animation布局动画示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Property-Animation布局动画简介"><a href="#Property-Animation布局动画简介" class="headerlink" title="Property Animation布局动画简介"></a>Property Animation布局动画简介</h1><p>Property Animation支持对ViewGroup中的View设置动画。</p>
<p>例如，当你添加或者移除ViewGroup中的View时，或者你调用View的setVisibility()方法来控制其显示或消失时；就可以设置相应的Property Animation动画。</p>
<p>Android的View视图支持动画的主要有四种行为：<br><strong>APPEARING</strong>：某个View被添加到ViewGroup中时，该View的动画。<br><strong>DISAPPEARING</strong>：某个View从ViewGroup中删除时，该View的动画。<br><strong>CHANGE_APPEARING</strong>：某个View被添加到ViewGroup中，并引起该ViewGroup中其他View的变化位置时，其他View的动画。<br><strong>CHANGE_DISAPPEARING</strong>：某个View从ViewGroup中删除，，并引起该ViewGroup中其他View的变化位置时，其他View的动画。</p>
<p><a name="anchor2"></a></p>
<h1 id="Property-Animation布局动画示例"><a href="#Property-Animation布局动画示例" class="headerlink" title="Property Animation布局动画示例"></a>Property Animation布局动画示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/property_animation/04_layout_animation/AnimationTest" target="_blank" rel="noopener">Property Animation布局动画示例</a></p>
<p>该示例中，包括：Android默认的动画，以及前面介绍的View的四种类型的动画的演示。以APPEARING来简单说明下布局动画的使用。</p>
<pre><code>// 设置ViewGroup(mSelfLayout)对应的LayoutTransition。
LayoutTransition transition = new LayoutTransition();
mSelfLayout.setLayoutTransition(transition);

// (添加)动画：APPEARING
ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 90f, 0f);
animIn.setDuration(transition.getDuration(LayoutTransition.APPEARING));
transition.setAnimator(LayoutTransition.APPEARING, animIn);
animIn.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator anim) {
        View view = (View) ((ObjectAnimator) anim).getTarget();
        view.setRotationY(0f);
    }   
}); </code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-MultiPropChange/" itemprop="url">Android 之Animation动画(四)之 Property Animation的多属性变化</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T03:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 read (About 354 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Property Animation中多属性变化的情况。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Property Animation的多属性变化的种类</a><br><strong>2</strong>. <a href="#anchor2">Property Animation的关键帧</a><br><strong>3</strong>. <a href="#anchor3">Property Animation的完整示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Property-Animation的多属性变化的种类"><a href="#Property-Animation的多属性变化的种类" class="headerlink" title="Property Animation的多属性变化的种类"></a>Property Animation的多属性变化的种类</h1><p>给同一个View实现同一个动画效果(同时变化x和y)，有下面三种方法。</p>
<p><strong>方法一：用多个ObjectAnimator对象</strong> </p>
<pre><code>ObjectAnimator animX = ObjectAnimator.ofFloat(myView, &quot;x&quot;, 50f);
ObjectAnimator animY = ObjectAnimator.ofFloat(myView, &quot;y&quot;, 100f);
AnimatorSet animSetXY = new AnimatorSet();
animSetXY.playTogether(animX, animY);
animSetXY.start();</code></pre><p><strong>方法二：用一个ObjectAnimator对象加多个PropertyValuesHolder</strong></p>
<pre><code>PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(&quot;x&quot;, 50f);
PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(&quot;y&quot;, 100f);
ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();</code></pre><p><strong>方法三：用ViewPropertyAnimator</strong></p>
<pre><code>myView.animate().x(50f).y(100f);</code></pre><p><a name="anchor2"></a></p>
<h1 id="Property-Animation的关键帧"><a href="#Property-Animation的关键帧" class="headerlink" title="Property Animation的关键帧"></a>Property Animation的关键帧</h1><p>通过关键帧，我们能实现较为复杂的动画；例如，实现曲线运动。下面给出关键帧的使用示例：</p>
<pre><code>// ==== view4的动画 ==== (利用&quot;关键帧&quot;实现曲线运动)
PropertyValuesHolder anim4Y = PropertyValuesHolder.ofFloat(
        &quot;y&quot;, 0f, (float)(view2.getHeight() - view2.getWidth()));
float x = view2.getX();
// 三个关键帧
Keyframe kf0 = Keyframe.ofFloat(0f, x); 
Keyframe kf1 = Keyframe.ofFloat(.5f, x + 20f);
Keyframe kf2 = Keyframe.ofFloat(1f, x); 
PropertyValuesHolder anim4X = PropertyValuesHolder.ofKeyframe(
        &quot;x&quot;, kf0, kf1, kf2);
ObjectAnimator anim4 = ObjectAnimator.ofPropertyValuesHolder(view4, anim4Y, anim4X);
anim4.setDuration(1000);
anim4.setInterpolator(new AccelerateInterpolator());
anim4.setRepeatCount(1);
anim4.setRepeatMode(ValueAnimator.REVERSE);
anim4.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        //view4.invalidate();
        mContainer.invalidate();
    }   
}); </code></pre><p><a name="anchor3"></a></p>
<h1 id="Property-Animation的完整示例"><a href="#Property-Animation的完整示例" class="headerlink" title="Property Animation的完整示例"></a>Property Animation的完整示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/property_animation/03_multi_action/AnimationTest" target="_blank" rel="noopener">多属性变化和关键帧的完整源码</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-XmlUsage/" itemprop="url">Android 之Animation动画(三)之 Property Animation的XML属性和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T02:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 read (About 545 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面介绍了Property Animation的相关类和类的基本使用方法，本章将介绍Property Animation的属性以及如何通过属性来使用Property Animation。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Property Animation属性介绍</a><br><strong>2</strong>. <a href="#anchor2">Property Animation属性使用示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Property-Animation属性介绍"><a href="#Property-Animation属性介绍" class="headerlink" title="Property Animation属性介绍"></a>Property Animation属性介绍</h1><p>我们可以用XML文件来定义Property Animation。XML的基本语法如下：</p>
<pre><code>&lt;set
  android:ordering=[&quot;together&quot; | &quot;sequentially&quot;]&gt;

    &lt;objectAnimator
        android:propertyName=&quot;string&quot;
        android:duration=&quot;int&quot;
        android:valueFrom=&quot;float | int | color&quot;
        android:valueTo=&quot;float | int | color&quot;
        android:startOffset=&quot;int&quot;
        android:repeatCount=&quot;int&quot;
        android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]
        android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt;

    &lt;animator
        android:duration=&quot;int&quot;
        android:valueFrom=&quot;float | int | color&quot;
        android:valueTo=&quot;float | int | color&quot;
        android:startOffset=&quot;int&quot;
        android:repeatCount=&quot;int&quot;
        android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]
        android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt;

    &lt;set&gt;
        ...
    &lt;/set&gt;
&lt;/set&gt;</code></pre><p>说明：<br>(01) <strong><set></set></strong>: 是objectAnimator和animator的集合。<set>标签是可以嵌套的。<br>(02) <strong><objectanimator></objectanimator></strong>: 对应是ObjectAnimator动画。<br>(03) <strong><animator></animator></strong>: 对应是ValueAnimator动画。<br>(04) <strong>android:propertyName</strong>: 属性名。仅ObjectAnimator才有该属性。<br>(05) <strong>android:duration</strong>: 动画的总时间，以ms为单位，默认是300ms。<br>(06) <strong>android:valueFrom</strong>: 动画的起始值。<br>(07) <strong>android:valueTo</strong>: 动画的结束值。<br>(08) <strong>android:startOffset</strong>: 动画的起始偏移时间，以ms为单位。<br>(09) <strong>android:repeatCount</strong>: 动画重复播放重复次数。-1表示无穷次，默认是0。<br>(10) <strong>android:repeatMode</strong>: 动画重复播放时的模式。repeat表示和原来一样从头开始播放，reverse表示反向播放；默认是repeat。<br>(11) <strong>android:valueType</strong>: 属性的值的类型。可以位intType或floatType。  </set></p>
<p>假设存在res/anim/property_animator.xml文件，该文件中定义了Property Animation动画。则动画的使用方法如下：</p>
<pre><code>AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,
    R.anim.property_animator);
set.setTarget(myObject);
set.start();</code></pre><p>此外，补充说明两点：<br>(01) View Animation的部分属性在Property Animation中也是可以使用的。例如，android:interpolator。<br>(02) 为了区分Property Animation和View Animation的资源文件，从Android 3.1开始，Property Animation的xml文件存在res/animator/目录下（View Animation存在res/anim/目录下）， animator这个名是可选的。</p>
<p><a name="anchor2"></a></p>
<h1 id="Property-Animation属性使用示例"><a href="#Property-Animation属性使用示例" class="headerlink" title="Property Animation属性使用示例"></a>Property Animation属性使用示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/property_animation/02_xml_basic/AnimationTest" target="_blank" rel="noopener">Property Animation属性使用示例的源码</a></p>
<p>在该示例中存在多种动画。下面列举一种：球加速下落，并具有弹跳效果。</p>
<p>动画的配置文件res/anim/view01.xml的内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1200&quot;
    android:propertyName=&quot;y&quot;
    android:valueFrom=&quot;0&quot;
    android:valueTo=&quot;249&quot;
    android:valueType=&quot;floatType&quot;
    android:interpolator=&quot;@android:anim/bounce_interpolator&quot;
    android:repeatCount=&quot;0&quot; /&gt;</code></pre><p>动画的使用代码如下：</p>
<pre><code>ObjectAnimator anim1 = (ObjectAnimator) AnimatorInflater.loadAnimator(context, R.anim.view01);
anim1.setTarget(view1);
anim1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        view1.invalidate();
    }
});</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-BasicUsage/" itemprop="url">Android 之Animation动画(二)之 Property Animation的基本介绍和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T01:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 read (About 1598 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Android的Property Animation。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Property Animation简介</a><br><strong>2</strong>. <a href="#anchor2">Property Animation的基本用法和示例源码</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Property-Animation简介"><a href="#Property-Animation简介" class="headerlink" title="Property Animation简介"></a>Property Animation简介</h1><p>Property Animation是属性动画。它是在Android 3.0中才引进的，它比View Animation和Drawable Animation功能更加强大。</p>
<h2 id="1-Property-Animation支持的属性"><a href="#1-Property-Animation支持的属性" class="headerlink" title="1. Property Animation支持的属性"></a>1. Property Animation支持的属性</h2><p>在Property Animation中，可以对动画应用以下属性：<br><strong>Duration</strong>：动画的持续时间。<br><strong>TimeInterpolation</strong>：属性值的计算方式，如先快后慢。<br><strong>TypeEvaluator</strong>：根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值。<br><strong>Repeat Count and behavoir</strong>：重复次数与方式，如播放3次、5次、无限循环，可以此动画一直重复，或播放完时再反向播放。<br><strong>Animation sets</strong>：动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同开始偏移。<br><strong>Frame refreash delay</strong>：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响。  </p>
<h2 id="2-Property-Animation的工作原理"><a href="#2-Property-Animation的工作原理" class="headerlink" title="2. Property Animation的工作原理"></a>2. Property Animation的工作原理</h2><p>对于下图的动画，这个对象的X坐标在40ms内从0移动到40 pixel。默认的10ms刷新一次，这个对象会移动4次，每次移动40/4=10pixel。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/animation/property_animation/pic/01.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/animation/property_animation/pic/01.png" alt></a></p>
<p>也可以改变属性值的改变方法，即设置不同的interpolation，在下图中运动速度先快后慢。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/animation/property_animation/pic/02.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/animation/property_animation/pic/02.png" alt></a></p>
<h2 id="3-Property-Animation的框架"><a href="#3-Property-Animation的框架" class="headerlink" title="3. Property Animation的框架"></a>3. Property Animation的框架</h2><p>Animator<br>&nbsp;&nbsp; – &nbsp;&nbsp; ValueAnimator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; – &nbsp;&nbsp; ObjectAnimator<br>&nbsp;&nbsp;  –  AnimatorSet<br>AnimatorInflater<br>Keyframe<br>KeyframeSet<br>PropertyValuesHolder<br>AnimatorListenerAdapter.java<br>TypeEvaluator<br>&nbsp;&nbsp; –  IntEvaluator<br>&nbsp;&nbsp; –  FloatEvaluator<br>&nbsp;&nbsp; –  ArgbEvaluator  </p>
<p>说明：<br>(01) Animator, ValueAnimator, ObjectAnimator是描述动画的核心类。其中，Animator是父类，它定义了动画开始/结束/暂停/恢复/重复等接口，并实现了公共函数。ValueAnimator和ObjectAnimator是描述动画的具体类。<br>(02) AnimatorSet是动画集合。<br>(03) AnimatorInflater是解析xml定义的动画的核心类。<br>(04) Keyframe是关键帧，通过关键帧可以实现较复杂的动画(例如，曲线运动等)。KeyframeSet是关键帧的辅助类。<br>(05) PropertyValuesHolder通常用于动画中有多个属性需要同时变化的情况。<br>(06) AnimatorUpdateListener中实现了全部的动画监听接口。但是，监听函数体都没有执行任何动作。在我们需要监听动画相应动作时，可以实现Animator提供的接口，也可以继承于AnimatorUpdateListener。<br>(07) TypeEvaluator则是动画中需要变化的属性值的计算类。Android提供了三种：用于计算int类型属性的IntEvaluator，用于计算float类型属性的FloatEvaluator，和用于计算rgb颜色类属性的ArgbEvaluator。若上面的三种均无法满足你的需求，则你可以自定义属性计算类。  </p>
<h2 id="4-Property-Animation和View-Animation的区别"><a href="#4-Property-Animation和View-Animation的区别" class="headerlink" title="4. Property Animation和View Animation的区别"></a>4. Property Animation和View Animation的区别</h2><ol>
<li><p>Property Animation的动画对象是Object类型，而View Animation仅仅适用于View对象。</p>
</li>
<li><p>View Animation动画的功能有限：它可以进行缩放和旋转，但是却无法改变背景色。</p>
</li>
<li><p>View Animation动画在变化时，仅仅改变了View的绘制位置，并没有改变View本身的实际位置。<br>比如，如果当通过View Animation让一个按钮移动到屏幕上的另一个位置时；虽然它绘制在目标位置，但是它的点击区域并没改变，还是和变化之前的点击区域一样。</p>
</li>
</ol>
<p>Property Animation就不存在上面的问题，它是确实地改变了View对象的属性。虽然，View Animation存在上述缺点；但它一个明显的有点就是使用方法更简单。在View Animation能满足你的需求时，就不需要使用Property Animation。</p>
<p><a name="anchor2"></a></p>
<h1 id="Property-Animation的基本用法和示例源码"><a href="#Property-Animation的基本用法和示例源码" class="headerlink" title="Property Animation的基本用法和示例源码"></a>Property Animation的基本用法和示例源码</h1><p>Android提供的Property Animation动画类主要有两个：ValueAnimator和ObjectAnimator。</p>
<p>点击查看: <a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/property_animation/01_basic/AnimationTest" target="_blank" rel="noopener">PropertyAnimation基本用法的完整源码</a></p>
<h2 id="1-ValueAnimator的基本用法"><a href="#1-ValueAnimator的基本用法" class="headerlink" title="1. ValueAnimator的基本用法"></a>1. ValueAnimator的基本用法</h2><p>在显示动画的具体图像之前，需要执行两步操作：<br>(01) 计算属性值。<br>(02) 根据此时的属性值执行相应的动作，如改变对象的某一属性。  </p>
<p>ValueAnimator只完成了第一步。当我们使用ValueAnimator时，需要自己完成第二步。如下示例：</p>
<pre><code>// 创建ValueAnimator动画。ofFloat()的参数是从&quot;动画开始&quot; 到 &quot;动画结束&quot;对应的值。
ValueAnimator anim2 = ValueAnimator.ofFloat(0f, (float)(view2.getHeight() - view2.getWidth()));
// 总的显示时间
anim2.setDuration(500);
// 变化模式(加速)
anim2.setInterpolator(new AccelerateInterpolator());
// 监听：每次变化时的回调函数
anim2.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        // 设置view2的纵坐标y
        view2.setY((Float) animation.getAnimatedValue());
        // 更新view2
        view2.invalidate();
    }
});</code></pre><p>说明：<br>(01) view2是自定义的View试图，它是一个圆。<br>(02) 对于ValueAnimator而言，需要我们实现AnimatorUpdateListener()接口，并在接口中处理试图的位置变化。例如，view2.setY()就是用于设置view2的位置。这就是上面所说的第二步。<br>(03) onAnimationUpdate()是动画变化的回调函数。当动画发生变化时，回执行该函数。  </p>
<h2 id="2-ObjectAnimator的基本用法"><a href="#2-ObjectAnimator的基本用法" class="headerlink" title="2. ObjectAnimator的基本用法"></a>2. ObjectAnimator的基本用法</h2><p>ObjectAnimator继承于ValueAnimator。它相比于ValueAnimator，完成了第二部。下面看看ObjectAnimator的使用方法。  </p>
<pre><code>// 创建ObjectAnimator动画。view1中必须有setY方法
ObjectAnimator anim1 = ObjectAnimator.ofFloat(view1, &quot;y&quot;, 0f, (float)(view1.getHeight() - view1.getWidth()));
// 总的显示时间
anim1.setDuration(1200);
// 变化模式(弹跳)
anim1.setInterpolator(new BounceInterpolator());
// 监听：每次变化时的回调函数
anim1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        // 更新view1
        view1.invalidate();
    }
});</code></pre><p>说明<br>(01) 虽然ObjectAnimator完成了第二步。ObjectAnimator的操作对象必须有对应的set<propertyname>方法。例如，上面的示例中操作的属性是”y”，因此view1类中必须要有setY(float)函数。<br>(02) 虽然Object完成了位置的计算和设置。但是，我们还必须在onAnimationUpdate()中更新要显示的视图。  </propertyname></p>
<h2 id="3-AnimatorSet的基本用法"><a href="#3-AnimatorSet的基本用法" class="headerlink" title="3. AnimatorSet的基本用法"></a>3. AnimatorSet的基本用法</h2><p>AnimatorSet是动画集合。用于来管理多个动画的播放次序。 如下示例：</p>
<pre><code>AnimatorSet animSet = new AnimatorSet();
animSet.playTogether(anim1, anim2, anim3);// 并行
animSet.playSequentially(anim3, anim4, anim5);// 串行
animSet.start();</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/2014-07-24-Animation/" itemprop="url">Android 之Animation动画(一)之 Animation介绍</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T00:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            几秒 read (About 74 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>Android动画都支持通过”代码”和”属性”两种方式进行控制。Google官网文档建议，通过”属性”的方式来控制动画。</p>
<p>Android动画包括三种：View Animation，Drawable Animation和Property Animation。</p>
<p>下面分别对这3种动画进行介绍。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/06/android/api_guide/app_component/content_provider/2014-07-06-ContentProvider-Permission/" itemprop="url">Android 之ContentProvider(三)之 Permission权限设置</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-06T04:11:00.000Z" itemprop="datePublished">7月 6 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 分钟 read (About 451 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面自定义Permission权限。自定义权限除了用在ContentProvider中之外，也可以用在Activity与Service中。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Permission介绍</a><br><strong>2</strong>. <a href="#anchor2">自定义Permission示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Permission介绍"><a href="#Permission介绍" class="headerlink" title="Permission介绍"></a>Permission介绍</h1><pre><code>&lt;permission
    android:name=&quot;com.skw.permission.myprovider&quot;
    android:protectionLevel=&quot;normal&quot;
    android:label=&quot;@string/permission_label&quot;
    android:description=&quot;@string/permission_description&quot;
    /&gt;</code></pre><p>说明：permission常用的几个属性如下：<br>(01) <strong>android:name</strong>: 必需的。权限的名称，通常应遵循android 命名方案(<em>.permission.</em>)。<br>(02) <strong>android:protectionLevel</strong>: 必需的。权限的安全级别，共包括”normal, dangerous, signature, signatureOrSystem”四种。  </p>
<blockquote>
<p>normal 表示权限是低风险的，不会对系统、用户或其他应用程序造成危害；<br>dangerous 表示权限是高风险的，系统将可能要求用户输入相关信息，才会授予此权限；<br>signature 表示只有当应用程序所用数字签名与声明引权限的应用程序所用数字签名相同时，才能将权限授给它；<br>signatureOrSystem 表示将权限授给具有相同数字签名的应用程序或android 包类。</p>
</blockquote>
<p>(03) <strong>android:permissionGroup</strong>: 非必需的。可以将权限放在一个组中，但对于自定义权限，应该避免设置此属性。<br>(04) <strong>android:label</strong>: 非必需的。标签。<br>(05) <strong>android:description</strong>: 非必需的。描述。<br>(06) <strong>android:icon</strong>非必需的。图标。  </p>
<p><a name="anchor2"></a></p>
<h1 id="自定义Permission示例"><a href="#自定义Permission示例" class="headerlink" title="自定义Permission示例"></a>自定义Permission示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/contentprovider/02_permission/MyProvider" target="_blank" rel="noopener">自定义Permission完整源码</a></p>
<h2 id="1-设置权限"><a href="#1-设置权限" class="headerlink" title="1. 设置权限"></a>1. 设置权限</h2><pre><code>&lt;application 
    android:exported=&quot;true&quot;
    android:label=&quot;@string/app_name&quot; 
    android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;provider 
        android:name=&quot;MyProvider&quot;
        android:authorities=&quot;com.skw.myprovider&quot;
        android:permission=&quot;com.skw.permission.myprovider&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/provider&gt;
&lt;/application&gt;

&lt;permission
    android:name=&quot;com.skw.permission.myprovider&quot;
    android:protectionLevel=&quot;normal&quot;
    android:label=&quot;@string/permission_label&quot;
    android:description=&quot;@string/permission_description&quot;
    /&gt;</code></pre><p>说明：上面是自定义权限的manifest文件内容。<br>(01) 首先，在需要定义权限的ContentProvider中声明权限android:permission=”com.skw.permission.myprovider”。<br>(02) 接着，再定义permission。permission对应的name与声明的权限对应。 </p>
<h2 id="2-获取权限"><a href="#2-获取权限" class="headerlink" title="2. 获取权限"></a>2. 获取权限</h2><p>在需要使用ContentProvider的APK的manifest中需要声明使用该权限。声明方法如下：</p>
<pre><code>&lt;uses-permission android:name=&quot;com.skw.permission.myprovider&quot; /&gt;</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/06/android/api_guide/app_component/content_provider/2014-07-06-ContentProvider-Usage/" itemprop="url">Android 之ContentProvider(二)之 ContentProvider基本用法</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-06T02:11:00.000Z" itemprop="datePublished">7月 6 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            12 分钟 read (About 1796 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章给出ContentProvider的完整示例，并对之进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">ContentProvider简介</a><br><strong>2</strong>. <a href="#anchor2">ContentProvider示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="ContentProvider简介"><a href="#ContentProvider简介" class="headerlink" title="ContentProvider简介"></a>ContentProvider简介</h1><p>ContentProvider通常用于共享数据。</p>
<p>当其他程序需要访问本程序的数据，并且数据的结构比较复杂时，就可以使用ContentProvider来共享数据。如果数据不需要跨程序访问，使用数据库即可；如果数据结构比较简单，可以考虑前面提到的通过Intent共享文本等简单数据，或者通过FileProvider共享文件。</p>
<p><a name="anchor2"></a></p>
<h1 id="ContentProvider示例"><a href="#ContentProvider示例" class="headerlink" title="ContentProvider示例"></a>ContentProvider示例</h1><p>接下来，实现一个ContentProvider。该ContentProvider包括两部分：ContentProvider提供者APK 和 ContentProvider测试APK。<br>(01) ContentProvider提供者：自定义一个ContentProvider，并监听相应的URI。客户可以通过URI插入/删除/更新/查询数据。ContentProvider中的数据记录的是人的信息，包括”姓名，出生年月，email，性别”等信息。<br>(02) ContentProvider测试APK：通过URI向ContentProvider发起插入/删除/更新/查询等操作。  </p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/contentprovider/01_basic/MyProvider" target="_blank" rel="noopener">ContentProvider示例的完整源码</a></p>
<p>下面介绍ContentProvider的实现步骤。</p>
<h2 id="1-ContentProvider提供者APK"><a href="#1-ContentProvider提供者APK" class="headerlink" title="1. ContentProvider提供者APK"></a>1. ContentProvider提供者APK</h2><h3 id="1-1-ContentProvider的存储表格"><a href="#1-1-ContentProvider的存储表格" class="headerlink" title="1.1 ContentProvider的存储表格"></a>1.1 ContentProvider的存储表格</h3><p>根据ContentProvider的数据特性，我们建立一张表，表格包括”id/姓名/出生年月/email/性别”这些信息。表对应的类如下：</p>
<pre><code>public final class MyContract {
    public MyContract() {}

    /** 
     * BaseColumns类中有两个属性：_ID 和 _COUNT
     */
    public static abstract class Entry implements BaseColumns {
        public static final String TABLE_NAME = &quot;mytable01&quot;;
        public static final String NAME       = &quot;name&quot;;
        public static final String BIRTH_DAY  = &quot;birthday&quot;;
        public static final String EMAIL      = &quot;email&quot;;
        public static final String GENDER     = &quot;gender&quot;;
    }   
}</code></pre><p>说明：BaseColumns是Android自带的类，它集成了”_ID”和”_COUNT”两个属性。 </p>
<h3 id="1-2-ContentProvider对应的manifest"><a href="#1-2-ContentProvider对应的manifest" class="headerlink" title="1.2 ContentProvider对应的manifest"></a>1.2 ContentProvider对应的manifest</h3><p>在manifest中声明我们自定义的ContentProvider。</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;provider android:name=&quot;MyProvider&quot; android:authorities=&quot;com.skw.myprovider&quot; /&gt;
&lt;/application&gt;</code></pre><h3 id="1-3-自定义的ContentProvider类"><a href="#1-3-自定义的ContentProvider类" class="headerlink" title="1.3 自定义的ContentProvider类"></a>1.3 自定义的ContentProvider类</h3><p>完成ContentProvider类，主要需要注意以下几点：<br>(01) ContentProvider的数据一般是以”数据库”或”网络数据”的方式存储的。如果是数据库，则需要实现SQLiteOpenHelper类。通过SQLiteOpenHelper类新建/管理数据库。<br>(02) ContentProvider主要是以Uri的形式方式访问的(也可以通过Intent)。要通过UriMatcher注册ContentProvider监听的Uri。<br>(03) ContentProvider是一个抽象类。当我们需要以继承ContentProvider的方式自定义ContentProvider时，需要实现query(), insert(), update(), delete(), getType(), onCreate()这六个函数。  </p>
<h3 id="1-3-1-数据库"><a href="#1-3-1-数据库" class="headerlink" title="1.3.1 数据库"></a>1.3.1 数据库</h3><p>下面，先介绍ContentProvider的数据库的实现。</p>
<pre><code>// 创建表格的SQL语句
private static final String SQL_CREATE_ENTRIES =
    &quot;CREATE TABLE &quot; + Entry.TABLE_NAME + &quot; (&quot; +
    Entry._ID + &quot; INTEGER PRIMARY KEY,&quot; +
    Entry.NAME + &quot; TEXT NOT NULL, &quot; +
    Entry.BIRTH_DAY + &quot; TEXT, &quot; +
    Entry.EMAIL + &quot; TEXT, &quot; +
    Entry.GENDER + &quot; INTEGER &quot; +
    &quot; )&quot;;

...

private class DBLiteHelper extends SQLiteOpenHelper {
    public static final int DATABASE_VERSION = 1;
    public static final String DATABASE_NAME = &quot;MyProvider.db&quot;;

    public DBLiteHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(SQL_CREATE_ENTRIES);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    }
}</code></pre><p>说明：关于SQLiteOpenHelper的内容在”<a href="/2014/05/30/SavingData/">数据存储章节</a>“中已经详细介绍过了。</p>
<h3 id="1-3-2-注册Uri"><a href="#1-3-2-注册Uri" class="headerlink" title="1.3.2 注册Uri"></a>1.3.2 注册Uri</h3><pre><code>// Uri的authority
public static final String AUTHORITY = &quot;com.skw.myprovider&quot;;
// Uri的path
public static final String PATH = &quot;table01&quot;;
// UriMatcher中URI对应的序号
public static final int ITEM_ALL = 1;
public static final int ITEM_ID  = 2;

private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
static {
    URI_MATCHER.addURI(AUTHORITY, PATH, ITEM_ALL);
    URI_MATCHER.addURI(AUTHORITY, PATH+&quot;/#&quot;, ITEM_ID);
}</code></pre><p>说明：通过addURI()就可以将URI注册到UriMatcher中，从而实现ContentProvider对URI的监听。这里的AUTHORITY与manifest中的android:authorities一致！<br>例如， URI_MATCHER.addURI(AUTHORITY, PATH, ITEM_ALL); 意味着ContentProvider对”content://con.skw.myprovider/table01”进行监听。<br>例如， URI_MATCHER.addURI(AUTHORITY, PATH+”/#”, ITEM_ALL); 意味着ContentProvider对”content://con.skw.myprovider/table01/5”进行监听。   </p>
<h3 id="1-3-2-实现ContentProvider的抽象函数"><a href="#1-3-2-实现ContentProvider的抽象函数" class="headerlink" title="1.3.2 实现ContentProvider的抽象函数"></a>1.3.2 实现ContentProvider的抽象函数</h3><h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h4><pre><code>@Override
public boolean onCreate() {
    mDbHelper = new DBLiteHelper(this.getContext());
    Log.d(TAG, &quot;open/create table&quot;);
    return true;
}</code></pre><p>说明：onCreate()中新建SQLiteOpenHelper对象。</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h4><pre><code>@Override
public int delete(Uri uri, String selection, String[] selectionArgs) {
    SQLiteDatabase db = mDbHelper.getWritableDatabase();

    int count = 0;
    switch (URI_MATCHER.match(uri)) {
    case ITEM_ALL:
        count = db.delete(Entry.TABLE_NAME, selection, selectionArgs);
        Log.d(TAG, &quot;delete ITEM uri=&quot;+uri+&quot;, count=&quot;+count);
        break;
    case ITEM_ID:
        // 获取id列的值
        String id = uri.getPathSegments().get(1);
        count = db.delete(Entry.TABLE_NAME, Entry._ID+&quot;=?&quot;, new String[]{id});
        Log.d(TAG, &quot;delete ITEM_ID id=&quot;+id+&quot;, uri=&quot;+uri+&quot;, count=&quot;+count);
        break;
    default:
        throw new IllegalArgumentException(&quot;Unknown URI&quot;+uri);
    }
    getContext().getContentResolver().notifyChange(uri, null);
    return count;
}</code></pre><p>说明：delete()中会通过match()获取uri对应的编码。这里的编码就是和addURI()注册uri的编码是相对应的。此外，notifyChange()的作用是通常数据库变化，若有ContentObserver监听该Uri，则notifyChange()最终会将消息传递给监听者。</p>
<p>insert(), update(), query()的实现与delete()类似，就不再说明。</p>
<h4 id="getType"><a href="#getType" class="headerlink" title="getType()"></a>getType()</h4><pre><code>@Override
public String getType(Uri uri) {
    switch (URI_MATCHER.match(uri)) {
    case ITEM_ALL:
        return &quot;skw.myprovider.dir/table01&quot;;
    case ITEM_ID:
        return &quot;skw.myprovider.item/table01&quot;;
    default:
        throw new IllegalArgumentException(&quot;Unknown URI&quot;+uri);
    }
}</code></pre><p>说明：getType()是返回Uri对应的数据类型。</p>
<h2 id="2-ContentProvider测试APK"><a href="#2-ContentProvider测试APK" class="headerlink" title="2. ContentProvider测试APK"></a>2. ContentProvider测试APK</h2><pre><code>public class ProviderTest extends Activity 
    implements View.OnClickListener {

    private static final String TAG = &quot;##ProviderTest##&quot;;

    // 数据库的属性，与MyProvider的表格属性一致
    public static final String NAME      = &quot;name&quot;;
    public static final String BIRTH_DAY = &quot;birthday&quot;;
    public static final String EMAIL     = &quot;email&quot;;
    public static final String GENDER    = &quot;gender&quot;;
    // 数据库的URI
    public static final Uri CONTENT_URI = Uri.parse(&quot;content://com.skw.myprovider/table01&quot;);

    private ContentResolver mContentResolver = null;
    /** Called when the activity is first created. */

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        ((Button)findViewById(R.id.insert)).setOnClickListener(this);
        ((Button)findViewById(R.id.deleteFirst)).setOnClickListener(this);
        ((Button)findViewById(R.id.deleteKate)).setOnClickListener(this);
        ((Button)findViewById(R.id.deleteAll)).setOnClickListener(this);
        ((Button)findViewById(R.id.update)).setOnClickListener(this);
        ((Button)findViewById(R.id.show)).setOnClickListener(this);

        // 删除第一行，然后全部打印出来
        mContentResolver = getContentResolver();

    }


    @Override
    public void onClick(View view) {
        switch(view.getId()) {
            case R.id.insert:
                // 添加
                insert(&quot;Jimmy&quot;, &quot;20020201&quot;, &quot;Jimmy20020201@126.com&quot;, 1);
                insert(&quot;Kate&quot;,  &quot;20030104&quot;, &quot;kate20030104@126.com&quot;, 0);
                insert(&quot;Li Lei&quot;, &quot;20021124&quot;, &quot;lilei20101124@126.com&quot;, 1);
                insert(&quot;Lucy&quot;, &quot;20010624&quot;, &quot;lucy20101124@126.com&quot;, 0);
                break;
            case R.id.deleteFirst:
                ContentUris cus = new ContentUris();
                Uri uri = cus.withAppendedId(CONTENT_URI, 1);
                Log.d(TAG, &quot;delete uri=&quot;+uri);
                mContentResolver.delete(uri, null, null);
                break;
            case R.id.deleteKate:
                // 删除“username=Kate”的行，然后全部打印出来
                mContentResolver.delete(CONTENT_URI, NAME+&quot;=?&quot;, new String[]{&quot;Kate&quot;});
                break;
            case R.id.deleteAll:
                // 删除全部的行，然后全部打印出来
                deleteAll() ;
                break;
            case R.id.update:
                // 更新第1个值，然后全部打印出来
                updateItem() ;
                break;
            case R.id.show:
                // 打印全部的值
                printAll() ;
                break;
            default:
                // 查找第2个值
                //querySecondItem() ;
                break;
        }
    }

    /*
     * 通过ContentResolver,将值插入到MyProvider中
     */
    private void insert(String name, String date, String email, int gender) {

        ContentResolver cr = getContentResolver();

        ContentValues cv = new ContentValues();
        cv.put(NAME, name);
        cv.put(BIRTH_DAY, date);
        cv.put(EMAIL, email);
        cv.put(GENDER, gender);
        Uri uri = cr.insert(CONTENT_URI, cv);
        Log.d(TAG, &quot;insert uri=&quot;+uri);
    }

    private void updateItem() {
        ContentResolver cr = getContentResolver();

        ContentUris cus = new ContentUris();
        Uri uri = cus.withAppendedId(CONTENT_URI, 1);

        ContentValues cv = new ContentValues();
        cv.put(NAME, &quot;update_name&quot;);
        cv.put(BIRTH_DAY, &quot;update_date&quot;);
        cv.put(EMAIL, &quot;update_email&quot;);
        cv.put(GENDER, 1);
        cr.update(uri, cv, null, null);
    }

    /*
     * 通过ContentResolver,将MyProvider中的值全部删除
     */
    private void deleteAll() {

        Log.d(TAG, &quot;delete all value!&quot;);
        ContentResolver cr = getContentResolver();
        cr.delete(CONTENT_URI, null, null);
    }

    private void querySecondItem() {
        ContentResolver cr = getContentResolver();
        ContentUris cus = new ContentUris();
        Uri uri = cus.withAppendedId(CONTENT_URI, 2);
        String[] proj = new String[] { NAME, BIRTH_DAY, EMAIL, GENDER};
        Cursor cursor = cr.query(uri, proj, null, null, null);
        int index = 0;
        while (cursor.moveToNext()) {
            Log.d(TAG, &quot;querySecondItem--&quot;+index+&quot;--&quot;
                    +&quot;, email=&quot; + cursor.getString(cursor.getColumnIndex(EMAIL))
                    +&quot;, username=&quot; + cursor.getString(cursor.getColumnIndex(NAME))
                    +&quot;, date=&quot; + cursor.getString(cursor.getColumnIndex(BIRTH_DAY))
                    +&quot;, gender=&quot; + cursor.getInt(cursor.getColumnIndex(GENDER)));
            index++;
        }
    }

    private void printAll() {
        //通过contentResolver进行查找
        ContentResolver cr = getContentResolver();

        Log.d(TAG, &quot;print all value!&quot;);
        // query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
        // 返回的列
        String[] proj = new String[] { NAME, BIRTH_DAY, EMAIL, GENDER};
        Cursor cursor = cr.query(
            CONTENT_URI, proj, null, null, null);
        int index = 0;
        while (cursor.moveToNext()) {
            Log.d(TAG, &quot;printAll--&quot;+index+&quot;--&quot;
                    +&quot;, email=&quot; + cursor.getString(cursor.getColumnIndex(EMAIL))
                    +&quot;, username=&quot; + cursor.getString(cursor.getColumnIndex(NAME))
                    +&quot;, date=&quot; + cursor.getString(cursor.getColumnIndex(BIRTH_DAY))
                    +&quot;, gender=&quot; + cursor.getString(cursor.getColumnIndex(GENDER)));
            index++;
        }
        startManagingCursor(cursor);  //查找后关闭游标
    }
}</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/06/android/api_guide/app_component/content_provider/2014-07-06-ContentProvider-Uri/" itemprop="url">Android 之ContentProvider(一)之 Uri介绍</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-06T01:11:00.000Z" itemprop="datePublished">7月 6 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 read (About 592 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Uri及其相关内容。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">URI简介</a><br><strong>2</strong>. <a href="#anchor2">Content URIs介绍</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="URI简介"><a href="#URI简介" class="headerlink" title="URI简介"></a>URI简介</h1><p>URI(Universal Resource Identifier)，又被称为”通用资源标志符”。</p>
<p>URI由许多部分所组成，示例及解说如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/app_components/contentprovider/pic/uri01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/app_components/contentprovider/pic/uri01.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="Content-URIs介绍"><a href="#Content-URIs介绍" class="headerlink" title="Content URIs介绍"></a>Content URIs介绍</h1><p>Android遵循URI的标准，定义了一套专用的Uri(即，Content URIs)。并且，Android提供了ContentUris、UriMatcher等类用于操作Content URIs。</p>
<h2 id="1-Content-URIs语法"><a href="#1-Content-URIs语法" class="headerlink" title="1. Content URIs语法"></a>1. Content URIs语法</h2><p>Content URIs的语法如下：</p>
<p><strong>content://authority/path/id</strong></p>
<p>Content URIs的示例及说明如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/app_components/contentprovider/pic/uri02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/app_components/contentprovider/pic/uri02.jpg" alt></a></p>
<p>说明：<br><strong>content</strong>: Content URIs前缀，它对应与标准URI的scheme。它的值为ContentResolver.SCHEME_CONTENT(即，content://)。<br><strong>authority</strong>: 一个唯一的标识符，Google建议使用类的全名来作为authority。外部调用者可以根据这个标识来找到它。<br><strong>path</strong>: 它可以用来表示我们要操作的数据，外部调用者根据这个路径信息来判断要返回什么类型的数据。这个后缀路径可以自由定义。<br><strong>id</strong>: 唯一的数字标识符。它表示要具体操作的数据类型中的具体某一项。</p>
<h2 id="2-Content-URIs相关类介绍"><a href="#2-Content-URIs相关类介绍" class="headerlink" title="2. Content URIs相关类介绍"></a>2. Content URIs相关类介绍</h2><h3 id="2-1-ContentUris"><a href="#2-1-ContentUris" class="headerlink" title="2.1 ContentUris"></a>2.1 ContentUris</h3><p>ContentUris中包含了三个静态函数:  </p>
<blockquote>
<p> long parseId(Uri uri): 解析Uri中的末尾id。成功返回id，失败则返回-1。<br> Uri withAppendedId(Uri uri, long id): 将id追加到uri中，并返回追加id后的uri。<br> Uri.Builder appendId(Uri.Builder builder, long id): 将id追加到builder中，并返回追加id后的builder。  </p>
</blockquote>
<h3 id="2-2-UriMatcher"><a href="#2-2-UriMatcher" class="headerlink" title="2.2 UriMatcher"></a>2.2 UriMatcher</h3><p>UriMatcher用于匹配Uri。它的用法如下：<br>(01) 创建UriMatcher对象。<br>(02) 把你需要匹配Uri路径通过addURI()注册到UriMatcher对象上。<br>(03) 注册成功后，ContentProvider就可以通过UriMatcher监听你注册的Uri。当有匹配的Uri动作(如插入)时，再就可以通过UriMatcher的match()函数来获取Uri的一个标识，该标识是在addURI()时传入的。这个标识的作用是方便在switch语句中对不同的Uri进行处理。  </p>
<p>UriMatcher的主要API说明：  </p>
<blockquote>
<p>void addURI(String authority, String path, int code): 将”authority”+”path”注册的Uri注册到UriMatcher中，code是该Uri对应的标识。<br>int match(Uri uri): 匹配Uri，并返回Uri对应的标识。这里返回的标识与addURI中的标识对应。</p>
</blockquote>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/26/android/api_guide/app_component/activity/2014-06-26-OtherModeAttrs/" itemprop="url">Android 之Activity启动模式(三)之 启动模式的其它属性</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-26T04:10:00.000Z" itemprop="datePublished">6月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 read (About 525 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面两章分别介绍了”四种launchMode”以及”Intent中与启动模式相关的Flag标签”，本章补充介绍一下manifest中其他与启动模式相关的属性。除非是有特殊需求，否则本章涉及到的知识很少会被用到。</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h1><pre><code>android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;]
android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;]
android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;]
android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;]
android:noHistory=[&quot;true&quot; | &quot;false&quot;]
android:taskAffinity=&quot;string&quot;</code></pre><ol>
<li><p><strong>android:taskAffinity</strong></p>
<p>它在前面两章都已经涉及到了。它的作用是描述了不同Activity之间的亲密关系。拥有相同的taskAffinity的Activity是亲密的，它们之间在相互跳转时，会位于同一个task中，而不会新建一个task！<br>如果在manifest中没有对Activity的android:taskAffinity进行配置，则每个Activity都采用和Application相同的taskAffinity；这也就意味着，同一个Application中的所有Activity的taskAffinity在默认情况下是相同的！</p>
</li>
</ol>
<ol start="2">
<li><p><strong>allowTaskReparenting</strong></p>
<p>与字面理解相同，本属性允许activity重新指定Task。默认值是false。<br>假设存在A并且它allowTaskReparenting为true。当系统中存在一个A的实例，并且A位于task1中时；此时，task2中的某一个Activity要跳转到A中，则此时会将A从task1转移到task2中。</p>
</li>
</ol>
<ol start="3">
<li><p><strong>alwaysRetainTaskState</strong></p>
<p>总是保留task的状态。默认值是false。<br>如果某个Activity的allowTaskReparenting设置为true；那么当该Activity位于某个task的栈底时，不管出现任何情况, 系统都会一直会保留task栈中Activity的状态。</p>
</li>
</ol>
<ol start="4">
<li><p><strong>clearTaskOnLaunch</strong></p>
<p>默认值是false。<br>如果某个Activity的clearTaskOnLaunch设置为true。当该Activity位于某个task的栈底时，如果你离开当前的task而转到别的task；那么，该task中除了该Activity之外的其它Activity都会被删除！</p>
</li>
</ol>
<ol start="5">
<li><p><strong>finishOnTaskLaunch</strong></p>
<p>默认值是false。<br>如果某个Activity的finishOnTaskLaunch设置位true。只要你一离开这个task栈, 则系统会马上清除这个Activity, 不管这个Activity在堆栈的任何位置。</p>
</li>
</ol>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/26/android/api_guide/app_component/activity/2014-06-26-IntentFlag/" itemprop="url">Android 之Activity启动模式(二)之 Intent的Flag属性</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-26T02:12:00.000Z" itemprop="datePublished">6月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            18 分钟 read (About 2728 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面介绍了通过launchMode设置Activity的启动模式。本章接着介绍Activity的启动模式相关内容，讲解的内容是Intent与启动模式相关的Flag，以及android:taskAffinity的属性。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Intent与启动模式相关的Flag简介</a><br><strong>2</strong>. <a href="#anchor2">1. FLAG_ACTIVITY_NEW_TASK标签测试</a><br><strong>3</strong>. <a href="#anchor3">2. FLAG_ACTIVITY_CLEAR_TOP标签测试</a><br><strong>4</strong>. <a href="#anchor4">3. FLAG_ACTIVITY_CLEAR_TASK标签测试</a><br><strong>5</strong>. <a href="#anchor5">4. FLAG_ACTIVITY_SINGLE_TOP标签测试</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Intent与启动模式相关的Flag简介"><a href="#Intent与启动模式相关的Flag简介" class="headerlink" title="Intent与启动模式相关的Flag简介"></a>Intent与启动模式相关的Flag简介</h1><p>这里仅仅对几个常用的与启动模式相关的Flag进行介绍。</p>
<ol>
<li><strong>FLAG_ACTIVITY_NEW_TASK</strong><br>在google的官方文档中介绍，它与launchMode=”singleTask”具有相同的行为。实际上，并不是完全相同！<br>很少单独使用FLAG_ACTIVITY_NEW_TASK，通常与FLAG_ACTIVITY_CLEAR_TASK或FLAG_ACTIVITY_CLEAR_TOP联合使用。因为单独使用该属性会导致奇怪的现象，通常达不到我们想要的效果！尽管如何，后面还是会通过”FLAG_ACTIVITY_NEW_TASK示例一”和”FLAG_ACTIVITY_NEW_TASK示例二”会向你展示单独使用它的效果。</li>
</ol>
<ol start="2">
<li><p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong><br>在google的官方文档中介绍，它与launchMode=”singleTop”具有相同的行为。实际上，的确如此！单独的使用FLAG_ACTIVITY_SINGLE_TOP，就能达到和launchMode=”singleTop”一样的效果。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong><br>顾名思义，FLAG_ACTIVITY_CLEAR_TOP的作用清除”包含Activity的task”中位于该Activity实例之上的其他Activity实例。FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_NEW_TASK两者同时使用，就能达到和launchMode=”singleTask”一样的效果！</p>
</li>
<li><p><strong>FLAG_ACTIVITY_CLEAR_TASK</strong><br>FLAG_ACTIVITY_CLEAR_TASK的作用包含Activity的task。使用FLAG_ACTIVITY_CLEAR_TASK时，通常会包含FLAG_ACTIVITY_NEW_TASK。这样做的目的是启动Activity时，清除之前已经存在的Activity实例所在的task；这自然也就清除了之前存在的Activity实例！</p>
</li>
</ol>
<p>注意：<strong>当同时使用launchMode和上面的FLAG_ACTIVITY_NEW_TASK等标签时，以FLAG_ACTIVITY_NEW_TASK为标准。也就是说，代码的优先级比manifest中配置文件的优先级更高</strong>！ </p>
<p>下面，通过几个实例加深对这几个标记的理解。</p>
<p><a name="anchor2"></a></p>
<h1 id="1-FLAG-ACTIVITY-NEW-TASK标签测试"><a href="#1-FLAG-ACTIVITY-NEW-TASK标签测试" class="headerlink" title="1. FLAG_ACTIVITY_NEW_TASK标签测试"></a>1. FLAG_ACTIVITY_NEW_TASK标签测试</h1><h2 id="1-1-FLAG-ACTIVITY-NEW-TASK示例一"><a href="#1-1-FLAG-ACTIVITY-NEW-TASK示例一" class="headerlink" title="1.1 FLAG_ACTIVITY_NEW_TASK示例一"></a>1.1 FLAG_ACTIVITY_NEW_TASK示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/02_new_task/01_same_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_NEW_TASK示例一的源码</a></p>
<p>在该实例中，有两个Activity：ActivityTest和SecondActivity。manifest定义如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot; /&gt;
&lt;/application&gt;</code></pre><p>说明：通过manifest可以看出，ActivityTest和SecondActivity在同一个APK中。这也就意味着它们的android:taskAffinity是一样的！</p>
<p><strong>ActivityTest的源码</strong></p>
<pre><code>public class ActivityTest extends Activity {
    private static final String TAG=&quot;##ActivityTest##&quot;;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        Log.d(TAG, &quot;onCreate: &quot;+this.toString()+&quot;, taskId=&quot;+this.getTaskId());
        TextView tv = (TextView) findViewById(R.id.tv);
        tv.setText(this.toString()+&quot;, taskId=&quot;+this.getTaskId());
    }   

    public void onJump(View view) {
        Intent intent = new Intent(this, SecondActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this+&quot;, taskId=&quot;+this.getTaskId());
    }   
}</code></pre><p>说明：onJump()是ActivityTest中一个按钮的回调函数，点击该按钮会跳转到SecondActivity。<strong>注意，跳转的Intent添加了FLAG_ACTIVITY_NEW_TASK标志</strong>。</p>
<p><strong>SecondActivity的源码</strong></p>
<pre><code>public class SecondActivity extends Activity {

    private static final String TAG=&quot;##SecondActivity##&quot;;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.second);

        Log.d(TAG, &quot;onCreate: &quot;+this.toString()+&quot;, taskId=&quot;+this.getTaskId());
        TextView tv = (TextView) findViewById(R.id.tv2);
        tv.setText(this.toString()+&quot;, taskId=&quot;+this.getTaskId());
    }   

    public void onBack(View view) {
        Intent intent = new Intent(this, ActivityTest.class);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this+&quot;, taskId=&quot;+this.getTaskId());
    }   
}</code></pre><p>说明：onBack()是SecondActivity中一个按钮的回调函数，点击该按钮会跳转回ActivityTest。</p>
<p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在同一个task中。 (02) 两个SecondActivity不同的实例！<br><strong>结果分析</strong>：如果说FLAG_ACTIVITY_NEW_TASK的作用和singleTask具有相同的效果。那么这个示例很明显的否则了这个结论！事实上，在相互跳转的两个Activity的android:taskAffinity相同的情况下，单独使用FLAG_ACTIVITY_NEW_TASK不会产生任何效果！</p>
<p>那如果两个Activity的android:taskAffinity不相同呢？此时会导致什么效果呢？下面，我们通过示例来看看效果。</p>
<h2 id="1-2-FLAG-ACTIVITY-NEW-TASK示例二"><a href="#1-2-FLAG-ACTIVITY-NEW-TASK示例二" class="headerlink" title="1.2 FLAG_ACTIVITY_NEW_TASK示例二"></a>1.2 FLAG_ACTIVITY_NEW_TASK示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/02_new_task/02_diff_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_NEW_TASK示例二的源码</a></p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中manifest，将ActivityTest和SecondActivity的android:taskAffinity改为不同；其余的保持不变！修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:taskAffinity=&quot;com.skw.activitytest01&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:taskAffinity=&quot;com.skw.activitytest02&quot;
        /&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在不同task中！ (02) 当第二次进入到ActivityTest中，再企图从ActivityTest中进入到SecondActivity时，没有产生任何效果，仍然停留在ActivityTest中！即第二次ActivityTest –&gt; SecondActivity压根就没发生！<br><strong>结果分析</strong>：当相互跳转的两个Activity的android:taskAffinity不同时，添加FLAG_ACTIVITY_NEW_TASK确实产生了一些效果：第一次启动Activity时，会新建一个task，并将Activity添加到该task中。这与singleTask产生的效果是一样的！但是，当企图再次从ActivityTest进入到SecondActivity时，却什么也没有发生！<br>为什么呢？是因为此时SecondActivity实例已经存在，但是它所在的task的栈顶是ActivityTest；而单独的添加FLAG_ACTIVITY_NEW_TASK又不会”删除task中位于SecondActivity之上的Activity实例”，所以就没有发生跳转！  </p>
<p>好的，那下面，我们添加FLAG_ACTIVITY_CLEAR_TOP之后，再来看看效果。</p>
<p><a name="anchor3"></a></p>
<h1 id="2-FLAG-ACTIVITY-CLEAR-TOP标签测试"><a href="#2-FLAG-ACTIVITY-CLEAR-TOP标签测试" class="headerlink" title="2. FLAG_ACTIVITY_CLEAR_TOP标签测试"></a>2. FLAG_ACTIVITY_CLEAR_TOP标签测试</h1><h2 id="2-1-FLAG-ACTIVITY-CLEAR-TOP示例一"><a href="#2-1-FLAG-ACTIVITY-CLEAR-TOP示例一" class="headerlink" title="2.1 FLAG_ACTIVITY_CLEAR_TOP示例一"></a>2.1 FLAG_ACTIVITY_CLEAR_TOP示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/03_clear_top/01_same_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_CLEAR_TOP示例一的源码</a>。</p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下：</p>
<pre><code>public void onJump(View view) {
    Intent intent = new Intent(this, SecondActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
            | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    startActivity(intent);
}   </code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在同一个task中！ (02) 两个SecondActivity是不同的实例。<br><strong>结果分析</strong>：这与没有添加FLAG_ACTIVITY_CLEAR_TOP时效果一样！这说明，当相互跳转的两个Activity的android:taskAffinity一样时，不会产生任何效果！  </p>
<p>接下来，看看不同android:taskAffinity的情况。</p>
<h2 id="2-2-FLAG-ACTIVITY-CLEAR-TOP示例二"><a href="#2-2-FLAG-ACTIVITY-CLEAR-TOP示例二" class="headerlink" title="2.2 FLAG_ACTIVITY_CLEAR_TOP示例二"></a>2.2 FLAG_ACTIVITY_CLEAR_TOP示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/03_clear_top/02_diff_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_CLEAR_TOP示例二的源码</a>。</p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下：</p>
<pre><code>public void onJump(View view) {
    Intent intent = new Intent(this, SecondActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
            | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    startActivity(intent);
}   </code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在不同task中！ (02) 两个SecondActivity是同一个实例。<br><strong>结果分析</strong>：此时的表现和SecondActivity是singleTask一样！ 这说明，在相互跳转的Activity的android:taskAffinity不同时，同时使用FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP，才具有和singleTask一样的效果！</p>
<p>总的来说：FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP的使用和android:taskAffinity相关。在同时使用FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP的情况下，以A启动B来说<br>(01) 当A和B的taskAffinity相同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP没有任何作用。和没有添加时的效果一样！<br>(02) 当A和B的taskAffinity不同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP后，表现的和B是singleTask一样！</p>
<p><a name="anchor4"></a></p>
<h1 id="3-FLAG-ACTIVITY-CLEAR-TASK标签测试"><a href="#3-FLAG-ACTIVITY-CLEAR-TASK标签测试" class="headerlink" title="3. FLAG_ACTIVITY_CLEAR_TASK标签测试"></a>3. FLAG_ACTIVITY_CLEAR_TASK标签测试</h1><h2 id="3-1-FLAG-ACTIVITY-CLEAR-TASK示例一"><a href="#3-1-FLAG-ACTIVITY-CLEAR-TASK示例一" class="headerlink" title="3.1 FLAG_ACTIVITY_CLEAR_TASK示例一"></a>3.1 FLAG_ACTIVITY_CLEAR_TASK示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/04_clear_task/01_same_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_CLEAR_TASK示例一的源码</a></p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下：</p>
<pre><code>public void onJump(View view) {
    Intent intent = new Intent(this, SecondActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
            | Intent.FLAG_ACTIVITY_CLEAR_TASK);
    startActivity(intent);
}   </code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在同一个task中！ (02) 两个SecondActivity是不同的实例。<br><strong>结果分析</strong>：这与没有添加FLAG_ACTIVITY_CLEAR_TASK时效果一样！这说明，当相互跳转的两个Activity的android:taskAffinity一样时，不会产生任何效果！  </p>
<p>接下来，看看不同android:taskAffinity的情况。</p>
<h2 id="3-2-FLAG-ACTIVITY-CLEAR-TASK示例二"><a href="#3-2-FLAG-ACTIVITY-CLEAR-TASK示例二" class="headerlink" title="3.2 FLAG_ACTIVITY_CLEAR_TASK示例二"></a>3.2 FLAG_ACTIVITY_CLEAR_TASK示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/04_clear_task/02_diff_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_CLEAR_TASK示例二的源码</a></p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下：</p>
<pre><code>public void onJump(View view) {
    Intent intent = new Intent(this, SecondActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
            | Intent.FLAG_ACTIVITY_CLEAR_TASK);
    startActivity(intent);
}   </code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity –&gt; 返回键 –&gt; 返回键<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在不同的task中！ (02) 两个SecondActivity是不同的实例。 (03) 第一次返回键，返回到第一个ActivityTest中。 (04) 第二次返回键，返回到进入第一个ActivityTest之前的画面。<br><strong>结果分析</strong>：当同时使用FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK时，每次启动Activity时，若该Activity的实例已经存在于某个task中，则清除该task中的全部内容；然后重新创建task并将Activity添加到新建的task中；否则，直接启动新的task并将该Activity添加到新建的task中。</p>
<p>总的来说：FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TASK的使用和android:taskAffinity相关。在同时使用FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK的情况下，以A启动B来说<br>(01) 当A和B的taskAffinity相同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK没有任何作用。和没有添加时的效果一样！<br>(02) 当A和B的taskAffinity不同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK后，启动B时，若该B已经存在于某个task中，则清除该task中的全部内容；然后重新创建task并将B添加到新建的task中；否则，直接启动新的task并将B添加到新建的task中。</p>
<p><a name="anchor5"></a></p>
<h1 id="4-FLAG-ACTIVITY-SINGLE-TOP标签测试"><a href="#4-FLAG-ACTIVITY-SINGLE-TOP标签测试" class="headerlink" title="4. FLAG_ACTIVITY_SINGLE_TOP标签测试"></a>4. FLAG_ACTIVITY_SINGLE_TOP标签测试</h1><p>FLAG_ACTIVITY_SINGLE_TOP的特性和launchMode=”singleTop”一样！这里就不做过多的说明了。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/01_single_top/01_single" target="_blank" rel="noopener">FLAG_ACTIVITY_SINGLE_TOP示例一的源码</a>。该示例中，只有一个Activity示例，点击该Activity会跳转到它自身。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/01_single_top/02_same_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_SINGLE_TOP示例二的源码</a>。该示例中，有两个Activity示例，两个Activity之间可以相互跳转。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/26/android/api_guide/app_component/activity/2014-06-26-LaunchMode/" itemprop="url">Android 之Activity启动模式(一)之 lauchMode</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-26T01:10:00.000Z" itemprop="datePublished">6月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            23 分钟 read (About 3457 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Activity的四种launchMode。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">launchMode简介</a><br><strong>2</strong>. <a href="#anchor2">1. standard模式</a><br><strong>3</strong>. <a href="#anchor3">2. singleTop模式</a><br><strong>4</strong>. <a href="#anchor4">3. singleTask模式</a><br><strong>5</strong>. <a href="#anchor5">4. singleInstance模式</a><br><strong>6</strong>. <a href="#anchor6">模式总结</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="launchMode简介"><a href="#launchMode简介" class="headerlink" title="launchMode简介"></a>launchMode简介</h1><p>在讲解launchMode之前，需要先了解两个概念：task和taskAffinity。</p>
<p>task是一个”First In Last Out”的栈，task可以有一个或多个Activity。我们可以将task看作是管理Activity的单元。某一时刻，系统可以有多个task；每个task可以有一个或多个Activity。同一个Activity可能只允许存在一个实例，也可能可以有多个实例，而且这些实例既可以位于同一个task，也可以位于不同的task。Activity究竟是怎么处理它的实例，以及它在task中的分布情况；这些都可以通过launchMode进行设置。</p>
<p>android:taskAffinity是Activity的一个属性。例如,android:taskAffinity=”string”。它的作用是描述了不同Activity之间的亲密关系。拥有相同的taskAffinity的Activity是亲密的，它们之间在相互跳转时，会位于同一个task中，而不会新建一个task！<br>如果在manifest中没有对Activity的android:taskAffinity进行配置，则每个Activity都采用和Application相同的taskAffinity；这也就意味着，同一个Application中的所有Activity的taskAffinity在默认情况下是相同的！</p>
<p>下面开始介绍四种launchMode模式，在通过示例介绍之后，再来对这四种launchMode进行总结。</p>
<p><a name="anchor2"></a></p>
<h1 id="1-standard模式"><a href="#1-standard模式" class="headerlink" title="1. standard模式"></a>1. standard模式</h1><p>standard模式是默认模式。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个task，也可以位于不同的task。</p>
<p>下面通过示例来对standard进行验证。在该示例中，ActivityTest是standard模式的，而且点击ActivityTest中的按钮能跳转到它自身。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/01_standard" target="_blank" rel="noopener">standard模式的测试源码</a></p>
<p>manifest源码</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
&lt;/application&gt;</code></pre><p>ActivityTest的代码</p>
<pre><code>public class ActivityTest extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        TextView tv = (TextView) findViewById(R.id.tv);
        tv.setText(this.toString()+&quot;, taskId=&quot;+this.getTaskId());
    }   

    public void onJump(View view) {
        Intent intent = new Intent(this, ActivityTest.class);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent);
    }   
}</code></pre><p>说明：上面的ActivityTest就是android:launchMode=”standard”模式的。onJump()是按钮的回调函数，点击该按钮，会重新创建一个ActivityTest实例。</p>
<p><strong>测试内容</strong>：ActivityTest –&gt; ActivityTest –&gt; ActivityTest。 (注：ActivityTest –&gt; ActivityTest表示从ActivityTest跳转到ActivityTest)<br><strong>测试结果</strong>：每一个ActivityTest实例都是不同的，而且这三个ActivityTest实例都位于同一个task中。<br><strong>结果分析</strong>：这与我们前面介绍的standard模式的特性是相符的。</p>
<p><a name="anchor3"></a></p>
<h1 id="2-singleTop模式"><a href="#2-singleTop模式" class="headerlink" title="2. singleTop模式"></a>2. singleTop模式</h1><p>singleTop模式下，在同一个task中，如果存在该Activity的实例，并且该Activity实例位于栈顶(即，该Activity位于前端)，则调用startActivity()时，不再创建该Activity的示例；而仅仅只是调用Activity的onNewIntent()。否则的话，则新建该Activity的实例，并将其置于栈顶。</p>
<h2 id="2-1-singleTop示例一"><a href="#2-1-singleTop示例一" class="headerlink" title="2.1 singleTop示例一"></a>2.1 singleTop示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/02_single_top/SingleActvity" target="_blank" rel="noopener">singleTop示例二的源码</a></p>
<p>我们将”standard示例”中ActivityTest的launchMode修改为singleTop，其他的保持不变。修改后的manifest如下：</p>
<pre><code>&lt;activity android:name=&quot;ActivityTest&quot;
          android:launchMode=&quot;singleTop&quot;
          android:label=&quot;@string/app_name&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;</code></pre><p>说明：上面的ActivityTest就是android:launchMode=”singleTop”模式的。并不会创建新的ActivityTest实例；但是会调用onNewIntent()。<br>        </p>
<p><strong>测试内容</strong>：ActivityTest –&gt; ActivityTest –&gt; ActivityTest<br><strong>测试结果</strong>：每一个ActivityTest实例都是相同的！当从一个ActivityTest跳转到它自身时，没有创建新的ActivityTest实例，但是会调用onNewIntent()。<br><strong>结果分析</strong>：这与我们前面介绍的singleTop模式的特性是相符的。</p>
<p>如果是singleTop模式的Activity不在栈顶，那会如何呢？我们通过下面的示例来进行分析。</p>
<h2 id="2-2-singleTop示例二"><a href="#2-2-singleTop示例二" class="headerlink" title="2.2 singleTop示例二"></a>2.2 singleTop示例二</h2><p>在该示例中，有两个Activity：ActivityTest和SecondActivity。其中ActivityTest是singleTop类型的，而SecondActivity则是standard类型的。这两个Activity之间能相互跳转。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/02_single_top/TwoActivity" target="_blank" rel="noopener">singleTop示例二的源码</a></p>
<p>manifest的源码</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;singleTop&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:launchMode=&quot;standard&quot;/&gt;
&lt;/application&gt;</code></pre><p>ActivityTest的代码</p>
<pre><code>public class ActivityTest extends Activity {
    private static final String TAG=&quot;##ActivityTest##&quot;;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        Log.d(TAG, &quot;onCreate: &quot;+this.toString());
        TextView tv = (TextView) findViewById(R.id.tv);
        tv.setText(this.toString());
    }   

    public void onJump(View view) {
        Log.d(TAG, &quot;onJump: &quot;+this.toString());
        Intent intent = new Intent(this, SecondActivity.class);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this);
    }   

}</code></pre><p>说明：上面的ActivityTest就是android:launchMode=”singleTop”模式的。onJump()是按钮的回调函数，点击该按钮，会跳转到SecondActivity中。</p>
<pre><code>public class SecondActivity extends Activity {

    private static final String TAG=&quot;##SecondActivity##&quot;;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.second);

        Log.d(TAG, &quot;onCreate: &quot;+this.toString());
        TextView tv = (TextView) findViewById(R.id.tv2);
        tv.setText(this.toString());
    }   

    public void onBack(View view) {
        Log.d(TAG, &quot;onBack: &quot;+this.toString());
        Intent intent = new Intent(this, ActivityTest.class);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this);
    }   
}</code></pre><p>说明：上面的SecondActivity是standard模式的。onBack是按钮的回调函数，点击该按钮，会跳转回ActivityTest。</p>
<p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest<br><strong>测试结果</strong>：两个ActivityTest是不同的实例！<br><strong>结果分析</strong>：这与我们之前的描述是相符的，当singleTop类型的Activity不在栈顶时，会新建Activity实例。</p>
<p><a name="anchor4"></a></p>
<h1 id="4-singleTask模式"><a href="#4-singleTask模式" class="headerlink" title="4. singleTask模式"></a>4. singleTask模式</h1><p>Google官网对singleTask的描述如下：</p>
<blockquote>
<p>The system creates a new task and instantiates the activity at the root of the new task. However, if an instance of the activity already exists in a separate task, the system routes the intent to the existing instance through a call to its onNewIntent() method, rather than creating a new instance. Only one instance of the activity can exist at a time. </p>
</blockquote>
<p>大致意思是：</p>
<blockquote>
<p>在singleTask模式下，如果是第一次创建该Activity实例时，则会新建task并将该Activity添加到该task中。否则(该Activity的实例已存在)，则会打开已有的Activity实例，并调用Activity的onNewIntent()方法，而不会新建Activity实例。在任意时刻，最多只会有该一个Activity实例存在。</p>
</blockquote>
<p>上面的描述…其实特别抽象。我们通过实例来对singleTask进行了解，最后再对singleTask进行总结。需要建立的一个概念是：singleTask，顾名思义，只容许有一个包含该Activity实例的task存在！</p>
<h2 id="4-1-singleTask示例一"><a href="#4-1-singleTask示例一" class="headerlink" title="4.1 singleTask示例一"></a>4.1 singleTask示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/03_single_task/01_same_taskAffinity" target="_blank" rel="noopener">singleTask示例一的测试源码</a></p>
<p>该示例是来验证：(01) 第一次创建singleTask类型的Activity时，会创建新的task！(02) 该Activity实例已经存在时，不会创建新的Activity实例，才是跳转到已有的Activity实例中。</p>
<p>将前面的”singleTop示例二”中的ActivityTest的模式改为”standard”，将SecondActivity的模式改为”singleTask”。修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;standard&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
        android:launchMode=&quot;singleTask&quot; /&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在同一个task中。 (02) 两个SecondActivity是相同的实例！<br><strong>结果分析</strong>：结论(01)验证失败，结论(02)验证成功!</p>
<p>为什么会出现结论(01)验证失败呢？根据Google官网的描述，分明会启动一个新的task才对啊？为什么呢？<br>会不会是由于ActivityTest和SecondActivity位于同一个APK中，由于它们的android:taskAffinity相同导致的！嗯…到底是不是呢？下面就通过示例来进一步验证！</p>
<h2 id="4-2-singleTask示例二"><a href="#4-2-singleTask示例二" class="headerlink" title="4.2 singleTask示例二"></a>4.2 singleTask示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/03_single_task/02_diff_taskAffinity" target="_blank" rel="noopener">singleTask示例二的测试源码</a></p>
<p>将”singleTask示例一”中的两个Activity的taskAffinity改为不同，其他保持不变。修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;standard&quot;
              android:taskAffinity=&quot;com.skw.activitytest.task01&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:taskAffinity=&quot;com.skw.activitytest.task02&quot;
              android:launchMode=&quot;singleTask&quot; /&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) 第一个ActivityTest和第一个SecondActivity在不同task中。 (02) 两个SecondActivity是相同的实例！<br><strong>结果分析</strong>：结论(01)验证成功，结论(02)验证成功!</p>
<p>进一步进行测试：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity  –&gt; 返回键 –&gt; 返回键<br><strong>测试结果</strong>：在前面测试的基础上，按两次返回键。结果：第一次按返回键的时候，回到第一次创建的ActivityTest实例；再按一次返回键的话，则返回到原始画面(第一次进入ActivityTest之前的画面)！<br><strong>结果分析</strong>：这个结果表明，再次进入SecondActivity时，会将SecondActivity所在task中位于SecondActivity之上的全部Activity都删除！  </p>
<p>总结来说：singleTask的结论与android:taskAffinity相关。以A启动B来说<br>(01) 当A和B的taskAffinity相同时：第一次创建B的实例时，并不会启动新的task，而是直接将B添加到A所在的task；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。<br>(02) 当A和B的taskAffinity不同时：第一次创建B的实例时，会启动新的task，然后将B添加到新建的task中；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。  </p>
<p><a name="anchor5"></a></p>
<h1 id="5-singleInstance模式"><a href="#5-singleInstance模式" class="headerlink" title="5. singleInstance模式"></a>5. singleInstance模式</h1><p>singleInstance，顾名思义，是单一实例的意思，即任意时刻只允许存在唯一的Activity实例！<br>根据Google官网的描述，在模式下，只允许有一个Activity实例。当第一次创建该Activity实例时，会新建一个task，并将该Activity添加到该task中。<strong>注意：该task只能容纳该Activity实例，不会再添加其他的Activity实例！</strong>如果该Activity实例已经存在于某个task，则直接跳转到该task。</p>
<h2 id="5-1-singleInstance示例一"><a href="#5-1-singleInstance示例一" class="headerlink" title="5.1 singleInstance示例一"></a>5.1 singleInstance示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/04_single_instance/singleTop_singleInstance" target="_blank" rel="noopener">singleInstance示例一的测试源码</a></p>
<p>将前面的”singleTop示例二”中的ActivityTest的模式改为”standard”，将SecondActivity的模式改为”singleInstance”。修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;standard&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) 两个SecondActivity是同一个实例。 (02) 第一次进入的ActivityTest和第一次进入的SecondActivity位于不同的task中。 (03) 两个ActivityTest是位于同一个task中的不同实例。<br> <strong>结果分析</strong>：这个结论与预期是相同的，即，singleInstance类型的Activity的实例只能有一个，而且它只允许存在于单独的一个task中。singleInstance与相互跳转的两个Activity的taskAffinity无关系！</p>
<p>至于为什么两个ActivityTest是位于同一个task中的不同实例，那是因为它是standard类型的。我们可以将ActivityTest修改为singleTop等其他类型进行测试。</p>
<h2 id="5-2-singleInstance示例二"><a href="#5-2-singleInstance示例二" class="headerlink" title="5.2 singleInstance示例二"></a>5.2 singleInstance示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/04_single_instance/standard_singleInstance" target="_blank" rel="noopener">singleInstance示例二的测试源码</a></p>
<p>将前面的”singleInstance示例一”中的ActivityTest的模式改为”singleTop”。修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;singleTop&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) 两个SecondActivity是同一个实例。 (02) 第一次进入的ActivityTest和第一次进入的SecondActivity位于不同的task中。 (03) 两个ActivityTest是同一个实例。<br> <strong>结果分析</strong>：这个结论与预期是相同的。</p>
<p><a name="anchor6"></a></p>
<h1 id="launchMode模式总结"><a href="#launchMode模式总结" class="headerlink" title="launchMode模式总结"></a>launchMode模式总结</h1><p>现在，总结一下launchMode的四种模式：</p>
<h2 id="1-standard"><a href="#1-standard" class="headerlink" title="1. standard"></a>1. standard</h2><p>它是默认模式。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个task，也可以位于不同的task。  </p>
<h2 id="2-singleTop"><a href="#2-singleTop" class="headerlink" title="2.singleTop"></a>2.singleTop</h2><p>该模式下，在同一个task中，如果存在该Activity的实例，并且该Activity实例位于栈顶(即，该Activity位于前端)，则调用startActivity()时，不再创建该Activity的示例；而仅仅只是调用Activity的onNewIntent()。否则的话，则新建该Activity的实例，并将其置于栈顶。</p>
<h2 id="3-singleTask"><a href="#3-singleTask" class="headerlink" title="3. singleTask"></a>3. singleTask</h2><p>顾名思义，只容许有一个包含该Activity实例的task存在！</p>
<p>总的来说：singleTask的结论与android:taskAffinity相关。以A启动B来说<br>(01) 当A和B的taskAffinity相同时：第一次创建B的实例时，并不会启动新的task，而是直接将B添加到A所在的task；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。<br>(02) 当A和B的taskAffinity不同时：第一次创建B的实例时，会启动新的task，然后将B添加到新建的task中；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。  </p>
<h2 id="4-singleInstance"><a href="#4-singleInstance" class="headerlink" title="4. singleInstance"></a>4. singleInstance</h2><p>顾名思义，是单一实例的意思，即任意时刻只允许存在唯一的Activity实例，而且该Activity所在的task不能容纳除该Activity之外的其他Activity实例！  </p>
<p>它与singleTask有相同之处，也有不同之处。<br><strong>相同之处</strong>：任意时刻，最多只允许存在一个实例。<br><strong>不同之处</strong>：(01) singleTask受android:taskAffinity属性的影响，而singleInstance不受android:taskAffinity的影响。 (02) singleTask所在的task中能有其它的Activity，而singleInstance的task中不能有其他Activity。 (03) 当跳转到singleTask类型的Activity，并且该Activity实例已经存在时，会删除该Activity所在task中位于该Activity之上的全部Activity实例；而跳转到singleInstance类型的Activity，并且该Activity已经存在时，不需要删除其他Activity，因为它所在的task只有该Activity唯一一个Activity实例。</p>

    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/categories/android/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/categories/android/page/3/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/categories/android/">1</a></li>
        
        <li><a class="pagination-link is-current" href="/categories/android/page/2/">2</a></li>
        
        <li><a class="pagination-link" href="/categories/android/page/3/">3</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 炸鸡叔&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>