<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Category: java - PillBlog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta property="og:type" content="website">
<meta property="og:title" content="PillBlog">
<meta property="og:url" content="https://apppills.com/categories/java/page/2/index.html">
<meta property="og:site_name" content="PillBlog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PillBlog">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">归档</a>
            
            <a class="navbar-item " href="/about">关于</a>
            
            <a class="navbar-item " href="https://everything.apppills.com">Everything</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5><i class="far fa-folder"></i>java</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/20/java/collection/2012-02-20-hashcode-and-equals/" itemprop="url">Java 集合系列扩展(二) hashCode()和equals()的若干问题解答</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-20T01:01:00.000Z" itemprop="datePublished">2月 20 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            29 分钟 read (About 4321 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>本章的内容主要解决下面几个问题：<br>(01) equals() 的作用是什么？<br>(02) equals() 与 == 的区别是什么？<br>(03) hashCode() 的作用是什么？<br>(04) hashCode() 和 equals() 之间有什么联系？</p>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 equals() 的作用</a><br><a href="#anchor2">第2部分 equals() 与 == 的区别是什么？</a><br><a href="#anchor3">第3部分 hashCode() 的作用</a><br><a href="#anchor4">第4部分 hashCode() 和 equals() 的关系</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-equals-的作用"><a href="#第1部分-equals-的作用" class="headerlink" title="第1部分 equals() 的作用"></a>第1部分 equals() 的作用</h1><p>equals() 的作用是 用来判断两个对象是否相等。</p>
<p>equals() 定义在JDK的Object.java中。通过判断两个对象的地址是否相等(即，是否是同一个对象)来区分它们是否相等。源码如下：</p>
<pre><code>public boolean equals(Object obj) {
    return (this == obj);
}</code></pre><p>既然Object.java中定义了equals()方法，这就意味着所有的Java类都实现了equals()方法，所有的类都可以通过equals()去比较两个对象是否相等。 但是，我们已经说过，使用默认的“equals()”方法，等价于“==”方法。因此，我们通常会重写equals()方法：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。</p>
<br>
下面根据“类是否覆盖equals()方法”，将它分为2类。  
(01) 若某个类没有覆盖equals()方法，当它的通过equals()比较两个对象时，实际上是比较两个对象是不是同一个对象。这时，等价于通过“==”去比较这两个对象。  
(02) 我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象是否相等。通常的做法是：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。


<p>下面，举例对上面的2种情况进行说明。</p>
<p><a name="anchor1_1"></a></p>
<h2 id="1-“没有覆盖equals-方法”的情况"><a href="#1-“没有覆盖equals-方法”的情况" class="headerlink" title="1. “没有覆盖equals()方法”的情况"></a>1. “没有覆盖equals()方法”的情况</h2><p>代码如下 (EqualsTest1.java)：</p>
<pre><code>import java.util.*;
import java.lang.Comparable;

/**
 * @desc equals()的测试程序。
 *
 * @author skywang
 * @emai kuiwu-wang@163.com
 */
public class EqualsTest1{

    public static void main(String[] args) {
        // 新建2个相同内容的Person对象，
        // 再用equals比较它们是否相等
        Person p1 = new Person(&quot;eee&quot;, 100);
        Person p2 = new Person(&quot;eee&quot;, 100);
        System.out.printf(&quot;%s\n&quot;, p1.equals(p2));
    }

    /**
     * @desc Person类。
     */
    private static class Person {
        int age;
        String name;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String toString() {
            return name + &quot; - &quot; +age;
        }
    }
}</code></pre><p><strong>运行结果</strong>：</p>
<pre><code>false</code></pre><p><strong>结果分析</strong></p>
<p>我们通过 p1.equals(p2) 来“比较p1和p2是否相等时”。实际上，调用的Object.java的equals()方法，即调用的 (p1==p2) 。它是比较“p1和p2是否是同一个对象”。<br>而由 p1 和 p2 的定义可知，它们虽然内容相同；但它们是两个不同的对象！因此，返回结果是false。</p>
<p><a name="anchor1_2"></a></p>
<h2 id="2-“覆盖equals-方法”的情况"><a href="#2-“覆盖equals-方法”的情况" class="headerlink" title="2. “覆盖equals()方法”的情况"></a>2. “覆盖equals()方法”的情况</h2><p>我们修改上面的EqualsTest1.java：覆盖equals()方法。</p>
<p>代码如下 (EqualsTest2.java)：</p>
<pre><code>import java.util.*;
import java.lang.Comparable;

/**
 * @desc equals()的测试程序。
 *
 * @author skywang
 * @emai kuiwu-wang@163.com
 */
public class EqualsTest2{

    public static void main(String[] args) {
        // 新建2个相同内容的Person对象，
        // 再用equals比较它们是否相等
        Person p1 = new Person(&quot;eee&quot;, 100);
        Person p2 = new Person(&quot;eee&quot;, 100);
        System.out.printf(&quot;%s\n&quot;, p1.equals(p2));
    }

    /**
     * @desc Person类。
     */
    private static class Person {
        int age;
        String name;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String toString() {
            return name + &quot; - &quot; +age;
        }

        /** 
         * @desc 覆盖equals方法 
         */  
        @Override
        public boolean equals(Object obj){  
            if(obj == null){  
                return false;  
            }  

            //如果是同一个对象返回true，反之返回false  
            if(this == obj){  
                return true;  
            }  

            //判断是否类型相同  
            if(this.getClass() != obj.getClass()){  
                return false;  
            }  

            Person person = (Person)obj;  
            return name.equals(person.name) &amp;&amp; age==person.age;  
        } 
    }
}</code></pre><p><strong>运行结果</strong>：</p>
<pre><code>true</code></pre><p><strong>结果分析</strong>： </p>
<p>我们在EqualsTest2.java 中重写了Person的equals()函数：当两个Person对象的 name 和 age 都相等，则返回true。<br>因此，运行结果返回true。</p>
<p>讲到这里，顺便说一下java对equals()的要求。有以下几点：</p>
<blockquote>
<ol>
<li>对称性：如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”。  </li>
<li>反射性：x.equals(x)必须返回是”true”。  </li>
<li>类推性：如果x.equals(y)返回是”true”，而且y.equals(z)返回是”true”，那么z.equals(x)也应该返回是”true”。  </li>
<li>一致性：如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true”。  </li>
<li>非空性，x.equals(null)，永远返回是”false”；x.equals(和x不同类型的对象)永远返回是”false”。</li>
</ol>
</blockquote>
<p>现在，再回顾一下equals()的作用：判断两个对象是否相等。当我们重写equals()的时候，可千万不好将它的作用给改变了！</p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-equals-与-的区别是什么？"><a href="#第2部分-equals-与-的区别是什么？" class="headerlink" title="第2部分 equals() 与 == 的区别是什么？"></a>第2部分 equals() 与 == 的区别是什么？</h1><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。</p>
<p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第1部分已详细介绍过)：<br>&nbsp;&nbsp;&nbsp;&nbsp; 情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>&nbsp;&nbsp;&nbsp;&nbsp; 情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</p>
<p>下面，通过示例比较它们的区别。</p>
<p>代码如下： </p>
<pre><code>import java.util.*;
import java.lang.Comparable;

/**
 * @desc equals()的测试程序。
 *
 * @author skywang
 * @emai kuiwu-wang@163.com
 */
public class EqualsTest3{

    public static void main(String[] args) {
        // 新建2个相同内容的Person对象，
        // 再用equals比较它们是否相等
        Person p1 = new Person(&quot;eee&quot;, 100);
        Person p2 = new Person(&quot;eee&quot;, 100);
        System.out.printf(&quot;p1.equals(p2) : %s\n&quot;, p1.equals(p2));
        System.out.printf(&quot;p1==p2 : %s\n&quot;, p1==p2);
    }

    /**
     * @desc Person类。
     */
    private static class Person {
        int age;
        String name;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String toString() {
            return name + &quot; - &quot; +age;
        }

        /** 
         * @desc 覆盖equals方法 
         */  
        @Override
        public boolean equals(Object obj){  
            if(obj == null){  
                return false;  
            }  

            //如果是同一个对象返回true，反之返回false  
            if(this == obj){  
                return true;  
            }  

            //判断是否类型相同  
            if(this.getClass() != obj.getClass()){  
                return false;  
            }  

            Person person = (Person)obj;  
            return name.equals(person.name) &amp;&amp; age==person.age;  
        } 
    }
}</code></pre><p><strong>运行结果</strong>：</p>
<pre><code>p1.equals(p2) : true
p1==p2 : false</code></pre><p><strong>结果分析</strong>：</p>
<p>在EqualsTest3.java 中：<br>(01) p1.equals(p2)<br>&nbsp;&nbsp;&nbsp;&nbsp; 这是判断p1和p2的内容是否相等。因为Person覆盖equals()方法，而这个equals()是用来判断p1和p2的内容是否相等，恰恰p1和p2的内容又相等；因此，返回true。<br>(02) p1==p2<br>&nbsp;&nbsp;&nbsp;&nbsp; 这是判断p1和p2是否是同一个对象。由于它们是各自新建的两个Person对象；因此，返回false。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-hashCode-的作用"><a href="#第3部分-hashCode-的作用" class="headerlink" title="第3部分 hashCode() 的作用"></a>第3部分 hashCode() 的作用</h1><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<blockquote>
<p>hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。<br>&nbsp;&nbsp;&nbsp;&nbsp; 虽然，每个Java类都包含hashCode() 函数。但是，仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，该类的hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置；其它情况下(例如，创建类的单个对象，或者创建类的对象数组等等)，类的hashCode() 没有作用。<br>&nbsp;&nbsp;&nbsp;&nbsp; 上面的散列表，指的是：Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。</p>
</blockquote>
<p>也就是说：<strong>hashCode() 在散列表中才有用，在其它情况下没用。</strong>在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<p>OK！至此，我们搞清楚了：hashCode()的作用是获取散列码。但是，散列码是用来干什么的呢？为什么散列表需要散列码呢？要解决这些问题，就需要理解散列表！关于散列表的内容，非三言两语道的明白；大家可以通过下面几篇文章来学习：<br><a href="http://www.cnblogs.com/skywang12345/p/3311899.html" target="_blank" rel="noopener">转载: 散列表(Hash Table)从理论到实用(上)</a><br><a href="http://www.cnblogs.com/skywang12345/p/3311909.html" target="_blank" rel="noopener">转载: 散列表(Hash Table)从理论到实用(中)</a><br><a href="http://www.cnblogs.com/skywang12345/p/3311915.html" target="_blank" rel="noopener">转载: 散列表(Hash Table)从理论到实用(下)</a></p>
<p>为了能理解后面的内容，这里简单的介绍一下散列码的作用。</p>
<p>我们都知道，散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！<br>散列表的本质是通过数组实现的。当我们要获取散列表中的某个“值”时，实际上是要获取数组中的某个位置的元素。而数组的位置，就是通过“键”来获取的；更进一步说，数组的位置，是通过“键”对应的散列码计算得到的。</p>
<p>下面，我们以HashSet为例，来深入说明hashCode()的作用。</p>
<blockquote>
<p>假设，HashSet中已经有1000个元素。当插入第1001个元素时，需要怎么处理？因为HashSet是Set集合，它允许有重复元素。<br>“将第1001个元素逐个的和前面1000个元素进行比较”？显然，这个效率是相等低下的。散列表很好的解决了这个问题，它根据元素的散列码计算出元素在散列表中的位置，然后将元素插入该位置即可。对于相同的元素，自然是只保存了一个。<br>由此可知，若两个元素相等，它们的散列码一定相等；但反过来确不一定。在散列表中，<br>&nbsp;&nbsp;&nbsp;&nbsp; 1、如果两个对象相等，那么它们的hashCode()值一定要相同；<br>&nbsp;&nbsp;&nbsp;&nbsp; 2、如果两个对象hashCode()相等，它们并不一定相等。<br>注意：这是在散列表中的情况。在非散列表中一定如此！</p>
</blockquote>
<p>对“hashCode()的作用”就谈这么多。</p>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-hashCode-和-equals-的关系"><a href="#第4部分-hashCode-和-equals-的关系" class="headerlink" title="第4部分 hashCode() 和 equals() 的关系"></a>第4部分 hashCode() 和 equals() 的关系</h1><p>接下面，我们讨论另外一个话题。网上很多文章将 hashCode() 和 equals 关联起来，有的讲的不透彻，有误导读者的嫌疑。在这里，我自己梳理了一下 “hashCode() 和 equals()的关系”。</p>
<p>我们以“类的用途”来将“hashCode() 和 equals()的关系”分2种情况来说明。</p>
<h2 id="1-第一种-不会创建“类对应的散列表”"><a href="#1-第一种-不会创建“类对应的散列表”" class="headerlink" title="1. 第一种 不会创建“类对应的散列表”"></a>1. 第一种 不会创建“类对应的散列表”</h2><p> 这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。</p>
<p><strong>在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！</strong><br>这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p>
<p>下面，我们通过示例查看类的两个对象相等 以及 不等时hashCode()的取值。</p>
<p>源码如下 (NormalHashCodeTest.java)：</p>
<pre><code>import java.util.*;
import java.lang.Comparable;

/**
 * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。
 *
 * @author skywang
 * @emai kuiwu-wang@163.com
 */
public class NormalHashCodeTest{

    public static void main(String[] args) {
        // 新建2个相同内容的Person对象，
        // 再用equals比较它们是否相等
        Person p1 = new Person(&quot;eee&quot;, 100);
        Person p2 = new Person(&quot;eee&quot;, 100);
        Person p3 = new Person(&quot;aaa&quot;, 200);
        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());
        System.out.printf(&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&quot;, p1.equals(p3), p1.hashCode(), p3.hashCode());
    }

    /**
     * @desc Person类。
     */
    private static class Person {
        int age;
        String name;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String toString() {
            return name + &quot; - &quot; +age;
        }

        /** 
         * @desc 覆盖equals方法 
         */  
        public boolean equals(Object obj){  
            if(obj == null){  
                return false;  
            }  

            //如果是同一个对象返回true，反之返回false  
            if(this == obj){  
                return true;  
            }  

            //判断是否类型相同  
            if(this.getClass() != obj.getClass()){  
                return false;  
            }  

            Person person = (Person)obj;  
            return name.equals(person.name) &amp;&amp; age==person.age;  
        } 
    }
}</code></pre><p><strong>运行结果</strong>：</p>
<pre><code>p1.equals(p2) : true; p1(1169863946) p2(1901116749)
p1.equals(p3) : false; p1(1169863946) p3(2131949076)</code></pre><p>从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。</p>
<h2 id="2-第二种-会创建“类对应的散列表”"><a href="#2-第二种-会创建“类对应的散列表”" class="headerlink" title="2. 第二种 会创建“类对应的散列表”"></a>2. 第二种 会创建“类对应的散列表”</h2><p>这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。</p>
<p>在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：<br>1)、如果两个对象相等，那么它们的hashCode()值一定相同。<br>&nbsp;&nbsp;&nbsp;&nbsp; 这里的相等是指，通过equals()比较两个对象时返回true。<br>2)、如果两个对象hashCode()相等，它们并不一定相等。<br>&nbsp;&nbsp;&nbsp;&nbsp; 因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是<strong>哈希冲突</strong>。</p>
<p>此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。<br>例如，创建Person类的HashSet集合，必须同时覆盖Person类的equals() 和 hashCode()方法。<br>&nbsp;&nbsp;&nbsp;&nbsp; 如果单单只是覆盖equals()方法。我们会发现，equals()方法没有达到我们想要的效果。</p>
<p>参考代码 (ConflictHashCodeTest1.java)：</p>
<pre><code>import java.util.*;
import java.lang.Comparable;

/**
 * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。
 *
 * @author skywang
 * @emai kuiwu-wang@163.com
 */
public class ConflictHashCodeTest1{

    public static void main(String[] args) {
        // 新建Person对象，
        Person p1 = new Person(&quot;eee&quot;, 100);
        Person p2 = new Person(&quot;eee&quot;, 100);
        Person p3 = new Person(&quot;aaa&quot;, 200);

        // 新建HashSet对象 
        HashSet set = new HashSet();
        set.add(p1);
        set.add(p2);
        set.add(p3);

        // 比较p1 和 p2， 并打印它们的hashCode()
        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());
        // 打印set
        System.out.printf(&quot;set:%s\n&quot;, set);
    }

    /**
     * @desc Person类。
     */
    private static class Person {
        int age;
        String name;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String toString() {
            return &quot;(&quot;+name + &quot;, &quot; +age+&quot;)&quot;;
        }

        /** 
         * @desc 覆盖equals方法 
         */  
        @Override
        public boolean equals(Object obj){  
            if(obj == null){  
                return false;  
            }  

            //如果是同一个对象返回true，反之返回false  
            if(this == obj){  
                return true;  
            }  

            //判断是否类型相同  
            if(this.getClass() != obj.getClass()){  
                return false;  
            }  

            Person person = (Person)obj;  
            return name.equals(person.name) &amp;&amp; age==person.age;  
        } 
    }
}</code></pre><p><strong>运行结果</strong>：</p>
<pre><code>p1.equals(p2) : true; p1(1169863946) p2(1690552137)
set:[(eee, 100), (eee, 100), (aaa, 200)]</code></pre><p><strong>结果分析</strong>：</p>
<p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？<br>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p>
<p>下面，我们同时覆盖equals() 和 hashCode()方法。</p>
<p>参考代码 (ConflictHashCodeTest2.java)：</p>
<pre><code>import java.util.*;
import java.lang.Comparable;

/**
 * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。
 *
 * @author skywang
 * @emai kuiwu-wang@163.com
 */
public class ConflictHashCodeTest2{

    public static void main(String[] args) {
        // 新建Person对象，
        Person p1 = new Person(&quot;eee&quot;, 100);
        Person p2 = new Person(&quot;eee&quot;, 100);
        Person p3 = new Person(&quot;aaa&quot;, 200);
        Person p4 = new Person(&quot;EEE&quot;, 100);

        // 新建HashSet对象 
        HashSet set = new HashSet();
        set.add(p1);
        set.add(p2);
        set.add(p3);

        // 比较p1 和 p2， 并打印它们的hashCode()
        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());
        // 比较p1 和 p4， 并打印它们的hashCode()
        System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());
        // 打印set
        System.out.printf(&quot;set:%s\n&quot;, set);
    }

    /**
     * @desc Person类。
     */
    private static class Person {
        int age;
        String name;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String toString() {
            return name + &quot; - &quot; +age;
        }

        /** 
         * @desc重写hashCode 
         */  
        @Override
        public int hashCode(){  
            int nameHash =  name.toUpperCase().hashCode();
            return nameHash ^ age;
        }

        /** 
         * @desc 覆盖equals方法 
         */  
        @Override
        public boolean equals(Object obj){  
            if(obj == null){  
                return false;  
            }  

            //如果是同一个对象返回true，反之返回false  
            if(this == obj){  
                return true;  
            }  

            //判断是否类型相同  
            if(this.getClass() != obj.getClass()){  
                return false;  
            }  

            Person person = (Person)obj;  
            return name.equals(person.name) &amp;&amp; age==person.age;  
        } 
    }
}</code></pre><p><strong>运行结果</strong>：</p>
<pre><code>p1.equals(p2) : true; p1(68545) p2(68545)
p1.equals(p4) : false; p1(68545) p4(68545)
set:[aaa - 200, eee - 100]</code></pre><p><strong>结果分析</strong>：</p>
<p>这下，equals()生效了，HashSet中没有重复元素。<br>比较p1和p2，我们发现：它们的hashCode()相等，通过equals()比较它们也返回true。所以，p1和p2被视为相等。<br>比较p1和p4，我们发现：虽然它们的hashCode()相等；但是，通过equals()比较它们返回false。所以，p1和p4被视为不相等。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/19/java/collection/2012-02-19-comparable-comparator/" itemprop="url">Java 集合系列扩展(一) Comparable和Comparator比较</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-19T01:01:00.000Z" itemprop="datePublished">2月 19 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            14 分钟 read (About 2145 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>本文，先介绍Comparable 和Comparator两个接口，以及它们的差异；接着，通过示例，对它们的使用方法进行说明。</p>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. Comparable 介绍</a><br><a href="#anchor2">2. Comparator 介绍</a><br><a href="#anchor3">3. Comparator 和 Comparable 比较</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Comparable-介绍"><a href="#1-Comparable-介绍" class="headerlink" title="1. Comparable 介绍"></a>1. Comparable 介绍</h1><h2 id="1-1-Comparable-介绍"><a href="#1-1-Comparable-介绍" class="headerlink" title="1.1 Comparable 介绍"></a>1.1 Comparable 介绍</h2><p>Comparable 是排序接口。</p>
<p>若一个类实现了Comparable接口，就意味着“该类支持排序”。  即然实现Comparable接口的类支持排序，假设现在存在“实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。</p>
<p>此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。</p>
<h2 id="1-2-Comparable-定义"><a href="#1-2-Comparable-定义" class="headerlink" title="1.2 Comparable 定义"></a>1.2 Comparable 定义</h2><p>Comparable 接口仅仅只包括一个函数，它的定义如下：</p>
<pre><code>package java.lang;
import java.util.*;

public interface Comparable&lt;T&gt; {
    public int compareTo(T o);
}</code></pre><p>说明： 假设我们通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-Comparator-介绍"><a href="#2-Comparator-介绍" class="headerlink" title="2. Comparator 介绍"></a>2. Comparator 介绍</h1><h2 id="2-1-Comparator-简介"><a href="#2-1-Comparator-简介" class="headerlink" title="2.1 Comparator 简介"></a>2.1 Comparator 简介</h2><p>Comparator 是比较器接口。</p>
<p>我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。</p>
<p>也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。</p>
<h2 id="2-2-Comparator-定义"><a href="#2-2-Comparator-定义" class="headerlink" title="2.2 Comparator 定义"></a>2.2 Comparator 定义</h2><p>Comparator 接口仅仅只包括两个个函数，它的定义如下：</p>
<pre><code>package java.util;

public interface Comparator&lt;T&gt; {

    int compare(T o1, T o2);

    boolean equals(Object obj);
}</code></pre><p>说明：<br>(01) 若一个类要实现Comparator接口：它一定要实现compareTo(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。<br>&nbsp;&nbsp;&nbsp;&nbsp; 为什么可以不实现 equals(Object obj) 函数呢？ 因为任何类，默认都是已经实现了equals(Object obj)的。 Java中的一切类都是继承于java.lang.Object，在Object.java中实现了equals(Object obj)函数；所以，其它所有的类也相当于都实现了该函数。<br>(02) int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-Comparator-和-Comparable-比较"><a href="#3-Comparator-和-Comparable-比较" class="headerlink" title="3. Comparator 和 Comparable 比较"></a>3. Comparator 和 Comparable 比较</h1><p>Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。<br>而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p>
<p>我们不难发现：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p>
<p>我们通过一个测试程序来对这两个接口进行说明。源码如下：</p>
<pre><code>import java.util.*;
import java.lang.Comparable;

/**
 * @desc &quot;Comparator&quot;和“Comparable”的比较程序。
 *   (01) &quot;Comparable&quot;
 *   它是一个排序接口，只包含一个函数compareTo()。
 *   一个类实现了Comparable接口，就意味着“该类本身支持排序”，它可以直接通过Arrays.sort() 或 Collections.sort()进行排序。
 *   (02) &quot;Comparator&quot;
 *   它是一个比较器接口，包括两个函数：compare() 和 equals()。
 *   一个类实现了Comparator接口，那么它就是一个“比较器”。其它的类，可以根据该比较器去排序。
 *
 *   综上所述：Comparable是内部比较器，而Comparator是外部比较器。
 *   一个类本身实现了Comparable比较器，就意味着它本身支持排序；若它本身没实现Comparable，也可以通过外部比较器Comparator进行排序。
 */
public class CompareComparatorAndComparableTest{

    public static void main(String[] args) {
        // 新建ArrayList(动态数组)
        ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;();
        // 添加对象到ArrayList中
        list.add(new Person(&quot;ccc&quot;, 20));
        list.add(new Person(&quot;AAA&quot;, 30));
        list.add(new Person(&quot;bbb&quot;, 10));
        list.add(new Person(&quot;ddd&quot;, 40));

        // 打印list的原始序列
        System.out.printf(&quot;Original  sort, list:%s\n&quot;, list);

        // 对list进行排序
        // 这里会根据“Person实现的Comparable&lt;String&gt;接口”进行排序，即会根据“name”进行排序
        Collections.sort(list);
        System.out.printf(&quot;Name      sort, list:%s\n&quot;, list);

        // 通过“比较器(AscAgeComparator)”，对list进行排序
        // AscAgeComparator的排序方式是：根据“age”的升序排序
        Collections.sort(list, new AscAgeComparator());
        System.out.printf(&quot;Asc(age)  sort, list:%s\n&quot;, list);

        // 通过“比较器(DescAgeComparator)”，对list进行排序
        // DescAgeComparator的排序方式是：根据“age”的降序排序
        Collections.sort(list, new DescAgeComparator());
        System.out.printf(&quot;Desc(age) sort, list:%s\n&quot;, list);

        // 判断两个person是否相等
        testEquals();
    }

    /**
     * @desc 测试两个Person比较是否相等。
     *   由于Person实现了equals()函数：若两person的age、name都相等，则认为这两个person相等。
     *   所以，这里的p1和p2相等。
     *
     *   TODO：若去掉Person中的equals()函数，则p1不等于p2
     */
    private static void testEquals() {
        Person p1 = new Person(&quot;eee&quot;, 100);
        Person p2 = new Person(&quot;eee&quot;, 100);
        if (p1.equals(p2)) {
            System.out.printf(&quot;%s EQUAL %s\n&quot;, p1, p2);
        } else {
            System.out.printf(&quot;%s NOT EQUAL %s\n&quot;, p1, p2);
        }
    }

    /**
     * @desc Person类。
     *       Person实现了Comparable接口，这意味着Person本身支持排序
     */
    private static class Person implements Comparable&lt;Person&gt;{
        int age;
        String name;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }

        public String toString() {
            return name + &quot; - &quot; +age;
        }

        /**
         * 比较两个Person是否相等：若它们的name和age都相等，则认为它们相等
         */
        boolean equals(Person person) {
            if (this.age == person.age &amp;&amp; this.name == person.name)
                return true;
            return false;
        }

        /**
         * @desc 实现 “Comparable&lt;String&gt;” 的接口，即重写compareTo&lt;T t&gt;函数。
         *  这里是通过“person的名字”进行比较的
         */
        @Override
        public int compareTo(Person person) {
            return name.compareTo(person.name);
            //return this.name - person.name;
        }
    }

    /**
     * @desc AscAgeComparator比较器
     *       它是“Person的age的升序比较器”
     */
    private static class AscAgeComparator implements Comparator&lt;Person&gt; {

        @Override 
        public int compare(Person p1, Person p2) {
            return p1.getAge() - p2.getAge();
        }
    }

    /**
     * @desc DescAgeComparator比较器
     *       它是“Person的age的升序比较器”
     */
    private static class DescAgeComparator implements Comparator&lt;Person&gt; {

        @Override 
        public int compare(Person p1, Person p2) {
            return p2.getAge() - p1.getAge();
        }
    }
}</code></pre><p>下面对这个程序进行说明。</p>
<p>a) Person类定义。如下：</p>
<pre><code>private static class Person implements Comparable&lt;Person&gt;{
    int age;
    String name;

        ...

    /** 
     * @desc 实现 “Comparable&lt;String&gt;” 的接口，即重写compareTo&lt;T t&gt;函数。
     *  这里是通过“person的名字”进行比较的
     */
    @Override
    public int compareTo(Person person) {
        return name.compareTo(person.name);
        //return this.name - person.name;
    }   
} </code></pre><p>说明：<br>(01) Person类代表一个人，Persong类中有两个属性：age(年纪) 和 name“人名”。<br>(02) Person类实现了Comparable接口，因此它能被排序。</p>
<p>b) 在main()中，我们创建了Person的List数组(list)。如下：</p>
<pre><code>// 新建ArrayList(动态数组)
ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;();
// 添加对象到ArrayList中
list.add(new Person(&quot;ccc&quot;, 20));
list.add(new Person(&quot;AAA&quot;, 30));
list.add(new Person(&quot;bbb&quot;, 10));
list.add(new Person(&quot;ddd&quot;, 40));</code></pre><p>c) 接着，我们打印出list的全部元素。如下：</p>
<pre><code>// 打印list的原始序列
System.out.printf(&quot;Original sort, list:%s\n&quot;, list);</code></pre><p>d) 然后，我们通过Collections的sort()函数，对list进行排序。</p>
<p>由于Person实现了Comparable接口，因此通过sort()排序时，会根据Person支持的排序方式，即 compareTo(Person person) 所定义的规则进行排序。如下：</p>
<pre><code>// 对list进行排序
// 这里会根据“Person实现的Comparable&lt;String&gt;接口”进行排序，即会根据“name”进行排序
Collections.sort(list);
System.out.printf(&quot;Name sort, list:%s\n&quot;, list);</code></pre><p>e) 对比Comparable和Comparator</p>
<p>我们定义了两个比较器 AscAgeComparator 和 DescAgeComparator，来分别对Person进行 升序 和 降低 排序。</p>
<p>e.1) AscAgeComparator比较器</p>
<p>它是将Person按照age进行升序排序。代码如下：</p>
<pre><code>/**
 * @desc AscAgeComparator比较器
 *       它是“Person的age的升序比较器”
 */
private static class AscAgeComparator implements Comparator&lt;Person&gt; {

    @Override
    public int compare(Person p1, Person p2) {
        return p1.getAge() - p2.getAge();
    }
}</code></pre><p>e.2) DescAgeComparator比较器</p>
<p>它是将Person按照age进行降序排序。代码如下：</p>
<pre><code>/**
 * @desc DescAgeComparator比较器
 *       它是“Person的age的升序比较器”
 */
private static class DescAgeComparator implements Comparator&lt;Person&gt; {

    @Override
    public int compare(Person p1, Person p2) {
        return p2.getAge() - p1.getAge();
    }
}</code></pre><p>f) 运行结果<br>运行程序，输出如下：</p>
<pre><code>Original  sort, list:[ccc - 20, AAA - 30, bbb - 10, ddd - 40]
Name      sort, list:[AAA - 30, bbb - 10, ccc - 20, ddd - 40]
Asc(age)  sort, list:[bbb - 10, ccc - 20, AAA - 30, ddd - 40]
Desc(age) sort, list:[ddd - 40, AAA - 30, ccc - 20, bbb - 10]
eee - 100 EQUAL eee - 100</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/18/java/collection/2012-02-18-collection-18-iterator_enumeration/" itemprop="url">Java 集合系列18之 Iterator和Enumeration比较</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-18T01:01:00.000Z" itemprop="datePublished">2月 18 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 read (About 1247 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>这一章，我们对Iterator和Enumeration进行比较学习。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 Iterator和Enumeration区别</a><br><a href="#anchor2">第2部分 Iterator和Enumeration实例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-Iterator和Enumeration区别"><a href="#第1部分-Iterator和Enumeration区别" class="headerlink" title="第1部分 Iterator和Enumeration区别"></a>第1部分 Iterator和Enumeration区别</h1><p>在Java集合中，我们通常都通过 “Iterator(迭代器)” 或 “Enumeration(枚举类)” 去遍历集合。今天，我们就一起学习一下它们之间到底有什么区别。</p>
<p>我们先看看 Enumeration.java 和 Iterator.java的源码，再说它们的区别。</p>
<p>Enumeration是一个接口，它的源码如下：</p>
<pre><code>package java.util;

public interface Enumeration&lt;E&gt; {

    boolean hasMoreElements();

    E nextElement();
}</code></pre><p>Iterator也是一个接口，它的源码如下：</p>
<pre><code>package java.util;

public interface Iterator&lt;E&gt; {
    boolean hasNext();

    E next();

    void remove();
}</code></pre><p>看完代码了，我们再来说说它们之间的区别。</p>
<p><strong>(01) 函数接口不同</strong><br>&nbsp;&nbsp;&nbsp;&nbsp; Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。<br>&nbsp;&nbsp;&nbsp;&nbsp;Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。</p>
<p><strong>(02) Iterator支持fail-fast机制，而Enumeration不支持。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。<br>&nbsp;&nbsp;&nbsp;&nbsp;而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-Iterator和Enumeration实例"><a href="#第2部分-Iterator和Enumeration实例" class="headerlink" title="第2部分 Iterator和Enumeration实例"></a>第2部分 Iterator和Enumeration实例</h1><p>下面，我们编写一个Hashtable，然后分别通过 Iterator 和 Enumeration 去遍历它，比较它们的效率。代码如下：</p>
<pre><code>import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Random;

/*
 * 测试分别通过 Iterator 和 Enumeration 去遍历Hashtable
 * @author skywang
 */
public class IteratorEnumeration {

    public static void main(String[] args) {
        int val;
        Random r = new Random();
        Hashtable table = new Hashtable();
        for (int i=0; i&lt;100000; i++) {
            // 随机获取一个[0,100)之间的数字
            val = r.nextInt(100);
            table.put(String.valueOf(i), val);
        }

        // 通过Iterator遍历Hashtable
        iterateHashtable(table) ;

        // 通过Enumeration遍历Hashtable
        enumHashtable(table);
    }

    /*
     * 通过Iterator遍历Hashtable
     */
    private static void iterateHashtable(Hashtable table) {
        long startTime = System.currentTimeMillis();

        Iterator iter = table.entrySet().iterator();
        while(iter.hasNext()) {
            //System.out.println(&quot;iter:&quot;+iter.next());
            iter.next();
        }

        long endTime = System.currentTimeMillis();
        countTime(startTime, endTime);
    }

    /*
     * 通过Enumeration遍历Hashtable
     */
    private static void enumHashtable(Hashtable table) {
        long startTime = System.currentTimeMillis();

        Enumeration enu = table.elements();
        while(enu.hasMoreElements()) {
            //System.out.println(&quot;enu:&quot;+enu.nextElement());
            enu.nextElement();
        }

        long endTime = System.currentTimeMillis();
        countTime(startTime, endTime);
    }

    private static void countTime(long start, long end) {
        System.out.println(&quot;time: &quot;+(end-start)+&quot;ms&quot;);
    }
}</code></pre><p>运行结果如下：</p>
<pre><code>time: 9ms
time: 5ms</code></pre><p>从中，我们可以看出。Enumeration 比 Iterator 的遍历速度更快。为什么呢？<br>这是因为，Hashtable中Iterator是通过Enumeration去实现的，而且Iterator添加了对fail-fast机制的支持；所以，执行的操作自然要多一些。</p>
<h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/17/java/collection/2012-02-17-collection-17-treeset/" itemprop="url">Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-17T01:01:00.000Z" itemprop="datePublished">2月 17 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            24 分钟 read (About 3549 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>这一章，我们对TreeSet进行学习。<br>我们先对TreeSet有个整体认识，然后再学习它的源码，最后再通过实例来学会使用TreeSet。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 TreeSet介绍</a><br><a href="#anchor2">第2部分 TreeSet数据结构</a><br><a href="#anchor3">第3部分 TreeSet源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 TreeSet遍历方式</a><br><a href="#anchor5">第5部分 TreeSet示例</a>   </p>
</blockquote>
<p>转载请注明出处：<a href="http://www.cnblogs.com/skywang12345/admin/EditPosts.aspx?postid=3311268" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/admin/EditPosts.aspx?postid=3311268</a></p>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-TreeSet介绍"><a href="#第1部分-TreeSet介绍" class="headerlink" title="第1部分 TreeSet介绍"></a>第1部分 TreeSet介绍</h1><h2 id="TreeSet简介"><a href="#TreeSet简介" class="headerlink" title="TreeSet简介"></a>TreeSet简介</h2><p>TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet<e>, Cloneable, java.io.Serializable接口。<br>TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。<br>TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。<br>TreeSet 实现了Cloneable接口，意味着它能被克隆。<br>TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。</e></p>
<p>TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。<br>TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。<br>另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。</p>
<h2 id="TreeSet的构造函数"><a href="#TreeSet的构造函数" class="headerlink" title="TreeSet的构造函数"></a>TreeSet的构造函数</h2><pre><code>// 默认构造函数。使用该构造函数，TreeSet中的元素按照自然排序进行排列。
TreeSet()

// 创建的TreeSet包含collection
TreeSet(Collection&lt;? extends E&gt; collection)

// 指定TreeSet的比较器
TreeSet(Comparator&lt;? super E&gt; comparator)

// 创建的TreeSet包含set
TreeSet(SortedSet&lt;E&gt; set)</code></pre><p>TreeSet的API</p>
<pre><code>boolean                   add(E object)
boolean                   addAll(Collection&lt;? extends E&gt; collection)
void                      clear()
Object                    clone()
boolean                   contains(Object object)
E                         first()
boolean                   isEmpty()
E                         last()
E                         pollFirst()
E                         pollLast()
E                         lower(E e)
E                         floor(E e)
E                         ceiling(E e)
E                         higher(E e)
boolean                   remove(Object object)
int                       size()
Comparator&lt;? super E&gt;     comparator()
Iterator&lt;E&gt;               iterator()
Iterator&lt;E&gt;               descendingIterator()
SortedSet&lt;E&gt;              headSet(E end)
NavigableSet&lt;E&gt;           descendingSet()
NavigableSet&lt;E&gt;           headSet(E end, boolean endInclusive)
SortedSet&lt;E&gt;              subSet(E start, E end)
NavigableSet&lt;E&gt;           subSet(E start, boolean startInclusive, E end, boolean endInclusive)
NavigableSet&lt;E&gt;           tailSet(E start, boolean startInclusive)
SortedSet&lt;E&gt;              tailSet(E start)</code></pre><p>说明：</p>
<p>(01) TreeSet是有序的Set集合，因此支持add、remove、get等方法。<br>(02) 和NavigableSet一样，TreeSet的导航方法大致可以区分为两类，一类时提供元素项的导航方法，返回某个元素；另一类时提供集合的导航方法，返回某个集合。<br>lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。</p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-TreeSet数据结构"><a href="#第2部分-TreeSet数据结构" class="headerlink" title="第2部分 TreeSet数据结构"></a>第2部分 TreeSet数据结构</h1><p>TreeSet的继承关系</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractCollection&lt;E&gt;
         ↳     java.util.AbstractSet&lt;E&gt;
               ↳     java.util.TreeSet&lt;E&gt;</code></pre><p>TreeSet的声明</p>
<pre><code>public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;        
implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable{}</code></pre><p>TreeSet与Collection关系如下图：</p>
<p><img src="/media/pic/java/collection/collection17.jpg" alt="img"></p>
<p>从图中可以看出：<br>(01) TreeSet继承于AbstractSet，并且实现了NavigableSet接口。<br>(02) TreeSet的本质是一个”有序的，并且没有重复元素”的集合，它是通过TreeMap实现的。TreeSet中含有一个”NavigableMap类型的成员变量”m，而m实际上是”TreeMap的实例”。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-TreeSet源码解析-基于JDK1-6-0-45"><a href="#第3部分-TreeSet源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 TreeSet源码解析(基于JDK1.6.0_45)"></a>第3部分 TreeSet源码解析(基于JDK1.6.0_45)</h1><p>为了更了解TreeSet的原理，下面对TreeSet源码代码作出分析。</p>
<pre><code>package java.util;

public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;
    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable
{
    // NavigableMap对象
    private transient NavigableMap&lt;E,Object&gt; m;

    // TreeSet是通过TreeMap实现的，
    // PRESENT是键-值对中的值。
    private static final Object PRESENT = new Object();

    // 不带参数的构造函数。创建一个空的TreeMap
    public TreeSet() {
        this(new TreeMap&lt;E,Object&gt;());
    }

    // 将TreeMap赋值给 &quot;NavigableMap对象m&quot;
    TreeSet(NavigableMap&lt;E,Object&gt; m) {
        this.m = m;
    }

    // 带比较器的构造函数。
    public TreeSet(Comparator&lt;? super E&gt; comparator) {
        this(new TreeMap&lt;E,Object&gt;(comparator));
    }

    // 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中
    public TreeSet(Collection&lt;? extends E&gt; c) {
        this();
        // 将集合c中的元素全部添加到TreeSet中
        addAll(c);
    }

    // 创建TreeSet，并将s中的全部元素都添加到TreeSet中
    public TreeSet(SortedSet&lt;E&gt; s) {
        this(s.comparator());
        addAll(s);
    }

    // 返回TreeSet的顺序排列的迭代器。
    // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器
    public Iterator&lt;E&gt; iterator() {
        return m.navigableKeySet().iterator();
    }

    // 返回TreeSet的逆序排列的迭代器。
    // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器
    public Iterator&lt;E&gt; descendingIterator() {
        return m.descendingKeySet().iterator();
    }

    // 返回TreeSet的大小
    public int size() {
        return m.size();
    }

    // 返回TreeSet是否为空
    public boolean isEmpty() {
        return m.isEmpty();
    }

    // 返回TreeSet是否包含对象(o)
    public boolean contains(Object o) {
        return m.containsKey(o);
    }

    // 添加e到TreeSet中
    public boolean add(E e) {
        return m.put(e, PRESENT)==null;
    }

    // 删除TreeSet中的对象o
    public boolean remove(Object o) {
        return m.remove(o)==PRESENT;
    }

    // 清空TreeSet
    public void clear() {
        m.clear();
    }

    // 将集合c中的全部元素添加到TreeSet中
    public  boolean addAll(Collection&lt;? extends E&gt; c) {
        // Use linear-time version if applicable
        if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp;
            c instanceof SortedSet &amp;&amp;
            m instanceof TreeMap) {
            SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;
            TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;
            Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator();
            Comparator&lt;? super E&gt; mc = map.comparator();
            if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) {
                map.addAllForTreeSet(set, PRESENT);
                return true;
            }
        }
        return super.addAll(c);
    }

    // 返回子Set，实际上是通过TreeMap的subMap()实现的。
    public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,
                                  E toElement,   boolean toInclusive) {
        return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive,
                                       toElement,   toInclusive));
    }

    // 返回Set的头部，范围是：从头部到toElement。
    // inclusive是是否包含toElement的标志
    public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
        return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive));
    }

    // 返回Set的尾部，范围是：从fromElement到结尾。
    // inclusive是是否包含fromElement的标志
    public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
        return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive));
    }

    // 返回子Set。范围是：从fromElement(包括)到toElement(不包括)。
    public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
        return subSet(fromElement, true, toElement, false);
    }

    // 返回Set的头部，范围是：从头部到toElement(不包括)。
    public SortedSet&lt;E&gt; headSet(E toElement) {
        return headSet(toElement, false);
    }

    // 返回Set的尾部，范围是：从fromElement到结尾(不包括)。
    public SortedSet&lt;E&gt; tailSet(E fromElement) {
        return tailSet(fromElement, true);
    }

    // 返回Set的比较器
    public Comparator&lt;? super E&gt; comparator() {
        return m.comparator();
    }

    // 返回Set的第一个元素
    public E first() {
        return m.firstKey();
    }

    // 返回Set的最后一个元素
    public E first() {
    public E last() {
        return m.lastKey();
    }

    // 返回Set中小于e的最大元素
    public E lower(E e) {
        return m.lowerKey(e);
    }

    // 返回Set中小于/等于e的最大元素
    public E floor(E e) {
        return m.floorKey(e);
    }

    // 返回Set中大于/等于e的最小元素
    public E ceiling(E e) {
        return m.ceilingKey(e);
    }

    // 返回Set中大于e的最小元素
    public E higher(E e) {
        return m.higherKey(e);
    }

    // 获取第一个元素，并将该元素从TreeMap中删除。
    public E pollFirst() {
        Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();
        return (e == null)? null : e.getKey();
    }

    // 获取最后一个元素，并将该元素从TreeMap中删除。
    public E pollLast() {
        Map.Entry&lt;E,?&gt; e = m.pollLastEntry();
        return (e == null)? null : e.getKey();
    }

    // 克隆一个TreeSet，并返回Object对象
    public Object clone() {
        TreeSet&lt;E&gt; clone = null;
        try {
            clone = (TreeSet&lt;E&gt;) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError();
        }

        clone.m = new TreeMap&lt;E,Object&gt;(m);
        return clone;
    }

    // java.io.Serializable的写入函数
    // 将TreeSet的“比较器、容量，所有的元素值”都写入到输出流中
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        s.defaultWriteObject();

        // 写入比较器
        s.writeObject(m.comparator());

        // 写入容量
        s.writeInt(m.size());

        // 写入“TreeSet中的每一个元素”
        for (Iterator i=m.keySet().iterator(); i.hasNext(); )
            s.writeObject(i.next());
    }

    // java.io.Serializable的读取函数：根据写入方式读出
    // 先将TreeSet的“比较器、容量、所有的元素值”依次读出
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in any hidden stuff
        s.defaultReadObject();

        // 从输入流中读取TreeSet的“比较器”
        Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject();

        TreeMap&lt;E,Object&gt; tm;
        if (c==null)
            tm = new TreeMap&lt;E,Object&gt;();
        else
            tm = new TreeMap&lt;E,Object&gt;(c);
        m = tm;

        // 从输入流中读取TreeSet的“容量”
        int size = s.readInt();

        // 从输入流中读取TreeSet的“全部元素”
        tm.readTreeSet(size, s, PRESENT);
    }

    // TreeSet的序列版本号
    private static final long serialVersionUID = -2479143000061671589L;
}</code></pre><p>总结：</p>
<p>(01) TreeSet实际上是TreeMap实现的。当我们构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。<br>(02) TreeSet是非线程安全的。<br>(03) TreeSet实现java.io.Serializable的方式。当写入到输出流时，依次写入“比较器、容量、全部元素”；当读出输入流时，再依次读取。</p>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-TreeSet遍历方式"><a href="#第4部分-TreeSet遍历方式" class="headerlink" title="第4部分 TreeSet遍历方式"></a>第4部分 TreeSet遍历方式</h1><h2 id="4-1-Iterator顺序遍历"><a href="#4-1-Iterator顺序遍历" class="headerlink" title="4.1 Iterator顺序遍历"></a>4.1 Iterator顺序遍历</h2><pre><code>for(Iterator iter = set.iterator(); iter.hasNext(); ) { 
    iter.next();
}   </code></pre><h2 id="4-2-Iterator顺序遍历"><a href="#4-2-Iterator顺序遍历" class="headerlink" title="4.2 Iterator顺序遍历"></a>4.2 Iterator顺序遍历</h2><pre><code>// 假设set是TreeSet对象
for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) { 
    iter.next();
}</code></pre><h2 id="4-3-for-each遍历HashSet"><a href="#4-3-for-each遍历HashSet" class="headerlink" title="4.3 for-each遍历HashSet"></a>4.3 for-each遍历HashSet</h2><pre><code>// 假设set是TreeSet对象，并且set中元素是String类型
String[] arr = (String[])set.toArray(new String[0]);
for (String str:arr)
    System.out.printf(&quot;for each : %s\n&quot;, str);</code></pre><p>TreeSet不支持快速随机遍历，只能通过迭代器进行遍历！</p>
<p>TreeSet遍历测试程序如下：</p>
<pre><code>import java.util.*;

/**
 * @desc TreeSet的遍历程序
 *
 * @author skywang
 * @email kuiwu-wang@163.com
 */
public class TreeSetIteratorTest {

    public static void main(String[] args) {
        TreeSet set = new TreeSet();
        set.add(&quot;aaa&quot;);
        set.add(&quot;aaa&quot;);
        set.add(&quot;bbb&quot;);
        set.add(&quot;eee&quot;);
        set.add(&quot;ddd&quot;);
        set.add(&quot;ccc&quot;);

        // 顺序遍历TreeSet
        ascIteratorThroughIterator(set) ;
        // 逆序遍历TreeSet
        descIteratorThroughIterator(set);
        // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组
        foreachTreeSet(set);
    }

    // 顺序遍历TreeSet
    public static void ascIteratorThroughIterator(TreeSet set) {
        System.out.print(&quot;\n ---- Ascend Iterator ----\n&quot;);
        for(Iterator iter = set.iterator(); iter.hasNext(); ) {
            System.out.printf(&quot;asc : %s\n&quot;, iter.next());
        }
    }

    // 逆序遍历TreeSet
    public static void descIteratorThroughIterator(TreeSet set) {
        System.out.printf(&quot;\n ---- Descend Iterator ----\n&quot;);
        for(Iterator iter = set.descendingIterator(); iter.hasNext(); )
            System.out.printf(&quot;desc : %s\n&quot;, (String)iter.next());
    }

    // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组
    private static void foreachTreeSet(TreeSet set) {
        System.out.printf(&quot;\n ---- For-each ----\n&quot;);
        String[] arr = (String[])set.toArray(new String[0]);
        for (String str:arr)
            System.out.printf(&quot;for each : %s\n&quot;, str);
    }
}</code></pre><p>运行结果：</p>
<pre><code> ---- Ascend Iterator ----
asc : aaa
asc : bbb
asc : ccc
asc : ddd
asc : eee

 ---- Descend Iterator ----
desc : eee
desc : ddd
desc : ccc
desc : bbb
desc : aaa

 ---- For-each ----
for each : aaa
for each : bbb
for each : ccc
for each : ddd
for each : eee</code></pre><p><a name="anchor5"></a></p>
<h1 id="第5部分-TreeSet示例"><a href="#第5部分-TreeSet示例" class="headerlink" title="第5部分 TreeSet示例"></a>第5部分 TreeSet示例</h1><p>下面通过实例学习如何使用TreeSet</p>
<pre><code>import java.util.*;

/**
 * @desc TreeSet的API测试
 *
 * @author skywang
 * @email kuiwu-wang@163.com
 */
public class TreeSetTest {

    public static void main(String[] args) {
        testTreeSetAPIs();
    }

    // 测试TreeSet的api
    public static void testTreeSetAPIs() {
        String val;

        // 新建TreeSet
        TreeSet tSet = new TreeSet();
        // 将元素添加到TreeSet中
        tSet.add(&quot;aaa&quot;);
        // Set中不允许重复元素，所以只会保存一个“aaa”
        tSet.add(&quot;aaa&quot;);
        tSet.add(&quot;bbb&quot;);
        tSet.add(&quot;eee&quot;);
        tSet.add(&quot;ddd&quot;);
        tSet.add(&quot;ccc&quot;);
        System.out.println(&quot;TreeSet:&quot;+tSet);

        // 打印TreeSet的实际大小
        System.out.printf(&quot;size : %d\n&quot;, tSet.size());

        // 导航方法
        // floor(小于、等于)
        System.out.printf(&quot;floor bbb: %s\n&quot;, tSet.floor(&quot;bbb&quot;));
        // lower(小于)
        System.out.printf(&quot;lower bbb: %s\n&quot;, tSet.lower(&quot;bbb&quot;));
        // ceiling(大于、等于)
        System.out.printf(&quot;ceiling bbb: %s\n&quot;, tSet.ceiling(&quot;bbb&quot;));
        System.out.printf(&quot;ceiling eee: %s\n&quot;, tSet.ceiling(&quot;eee&quot;));
        // ceiling(大于)
        System.out.printf(&quot;higher bbb: %s\n&quot;, tSet.higher(&quot;bbb&quot;));
        // subSet()
        System.out.printf(&quot;subSet(aaa, true, ccc, true): %s\n&quot;, tSet.subSet(&quot;aaa&quot;, true, &quot;ccc&quot;, true));
        System.out.printf(&quot;subSet(aaa, true, ccc, false): %s\n&quot;, tSet.subSet(&quot;aaa&quot;, true, &quot;ccc&quot;, false));
        System.out.printf(&quot;subSet(aaa, false, ccc, true): %s\n&quot;, tSet.subSet(&quot;aaa&quot;, false, &quot;ccc&quot;, true));
        System.out.printf(&quot;subSet(aaa, false, ccc, false): %s\n&quot;, tSet.subSet(&quot;aaa&quot;, false, &quot;ccc&quot;, false));
        // headSet()
        System.out.printf(&quot;headSet(ccc, true): %s\n&quot;, tSet.headSet(&quot;ccc&quot;, true));
        System.out.printf(&quot;headSet(ccc, false): %s\n&quot;, tSet.headSet(&quot;ccc&quot;, false));
        // tailSet()
        System.out.printf(&quot;tailSet(ccc, true): %s\n&quot;, tSet.tailSet(&quot;ccc&quot;, true));
        System.out.printf(&quot;tailSet(ccc, false): %s\n&quot;, tSet.tailSet(&quot;ccc&quot;, false));


        // 删除“ccc”
        tSet.remove(&quot;ccc&quot;);
        // 将Set转换为数组
        String[] arr = (String[])tSet.toArray(new String[0]);
        for (String str:arr)
            System.out.printf(&quot;for each : %s\n&quot;, str);

        // 打印TreeSet
        System.out.printf(&quot;TreeSet:%s\n&quot;, tSet);

        // 遍历TreeSet
        for(Iterator iter = tSet.iterator(); iter.hasNext(); ) {
            System.out.printf(&quot;iter : %s\n&quot;, iter.next());
        }

        // 删除并返回第一个元素
        val = (String)tSet.pollFirst();
        System.out.printf(&quot;pollFirst=%s, set=%s\n&quot;, val, tSet);

        // 删除并返回最后一个元素
        val = (String)tSet.pollLast();
        System.out.printf(&quot;pollLast=%s, set=%s\n&quot;, val, tSet);

        // 清空HashSet
        tSet.clear();

        // 输出HashSet是否为空
        System.out.printf(&quot;%s\n&quot;, tSet.isEmpty()?&quot;set is empty&quot;:&quot;set is not empty&quot;);
    }
}</code></pre><p>运行结果： </p>
<pre><code>TreeSet:[aaa, bbb, ccc, ddd, eee]
size : 5
floor bbb: bbb
lower bbb: aaa
ceiling bbb: bbb
ceiling eee: eee
higher bbb: ccc
subSet(aaa, true, ccc, true): [aaa, bbb, ccc]
subSet(aaa, true, ccc, false): [aaa, bbb]
subSet(aaa, false, ccc, true): [bbb, ccc]
subSet(aaa, false, ccc, false): [bbb]
headSet(ccc, true): [aaa, bbb, ccc]
headSet(ccc, false): [aaa, bbb]
tailSet(ccc, true): [ccc, ddd, eee]
tailSet(ccc, false): [ddd, eee]
for each : aaa
for each : bbb
for each : ddd
for each : eee
TreeSet:[aaa, bbb, ddd, eee]
iter : aaa
iter : bbb
iter : ddd
iter : eee
pollFirst=aaa, set=[bbb, ddd, eee]
pollLast=eee, set=[bbb, ddd]
set is empty</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/16/java/collection/2012-02-16-collection-16-hashset/" itemprop="url">Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-16T01:01:00.000Z" itemprop="datePublished">2月 16 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            17 分钟 read (About 2589 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>这一章，我们对HashSet进行学习。<br>我们先对HashSet有个整体认识，然后再学习它的源码，最后再通过实例来学会使用HashSet。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 HashSet介绍</a><br><a href="#anchor2">第2部分 HashSet数据结构</a><br><a href="#anchor3">第3部分 HashSet源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 HashSet遍历方式</a><br><a href="#anchor5">第5部分 HashSet示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-HashSet介绍"><a href="#第1部分-HashSet介绍" class="headerlink" title="第1部分 HashSet介绍"></a>第1部分 HashSet介绍</h1><h2 id="HashSet-简介"><a href="#HashSet-简介" class="headerlink" title="HashSet 简介"></a>HashSet 简介</h2><p>HashSet 是一个没有重复元素的集合。<br>它是由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null 元素。<br>HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：</p>
<pre><code>Set s = Collections.synchronizedSet(new HashSet(...));</code></pre><p>HashSet通过iterator()返回的迭代器是fail-fast的。</p>
<h2 id="HashSet的构造函数"><a href="#HashSet的构造函数" class="headerlink" title="HashSet的构造函数"></a>HashSet的构造函数</h2><pre><code>// 默认构造函数
public HashSet() 

// 带集合的构造函数
public HashSet(Collection&lt;? extends E&gt; c) 

// 指定HashSet初始容量和加载因子的构造函数
public HashSet(int initialCapacity, float loadFactor) 

// 指定HashSet初始容量的构造函数
public HashSet(int initialCapacity) 

// 指定HashSet初始容量和加载因子的构造函数,dummy没有任何作用
HashSet(int initialCapacity, float loadFactor, boolean dummy) </code></pre><h2 id="HashSet的主要API"><a href="#HashSet的主要API" class="headerlink" title="HashSet的主要API"></a>HashSet的主要API</h2><pre><code>boolean         add(E object)
void            clear()
Object          clone()
boolean         contains(Object object)
boolean         isEmpty()
Iterator&lt;E&gt;     iterator()
boolean         remove(Object object)
int             size()</code></pre><p><a name="anchor2"></a></p>
<h1 id="第2部分-HashSet数据结构"><a href="#第2部分-HashSet数据结构" class="headerlink" title="第2部分 HashSet数据结构"></a>第2部分 HashSet数据结构</h1><p>HashSet的继承关系如下：</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractCollection&lt;E&gt;
         ↳     java.util.AbstractSet&lt;E&gt;
               ↳     java.util.HashSet&lt;E&gt;</code></pre><p>public class HashSet<e><br>    extends AbstractSet<e><br>    implements Set<e>, Cloneable, java.io.Serializable { }</e></e></e></p>
<p>HashSet与Map关系如下图：</p>
<p><img src="/media/pic/java/collection/collection16.jpg" alt="img"></p>
<p>从图中可以看出：<br>(01) HashSet继承于AbstractSet，并且实现了Set接口。<br>(02) HashSet的本质是一个”没有重复元素”的集合，它是通过HashMap实现的。HashSet中含有一个”HashMap类型的成员变量”map，HashSet的操作函数，实际上都是通过map实现的。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-HashSet源码解析-基于JDK1-6-0-45"><a href="#第3部分-HashSet源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 HashSet源码解析(基于JDK1.6.0_45)"></a>第3部分 HashSet源码解析(基于JDK1.6.0_45)</h1><p>为了更了解HashSet的原理，下面对HashSet源码代码作出分析。</p>
<pre><code>package java.util;

public class HashSet&lt;E&gt;
    extends AbstractSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable
{
    static final long serialVersionUID = -5024744406713321676L;

    // HashSet是通过map(HashMap对象)保存内容的
    private transient HashMap&lt;E,Object&gt; map;

    // PRESENT是向map中插入key-value对应的value
    // 因为HashSet中只需要用到key，而HashMap是key-value键值对；
    // 所以，向map中添加键值对时，键值对的值固定是PRESENT
    private static final Object PRESENT = new Object();

    // 默认构造函数
    public HashSet() {
        // 调用HashMap的默认构造函数，创建map
        map = new HashMap&lt;E,Object&gt;();
    }

    // 带集合的构造函数
    public HashSet(Collection&lt;? extends E&gt; c) {
        // 创建map。
        // 为什么要调用Math.max((int) (c.size()/.75f) + 1, 16)，从 (c.size()/.75f) + 1 和 16 中选择一个比较大的树呢？        
        // 首先，说明(c.size()/.75f) + 1
        //   因为从HashMap的效率(时间成本和空间成本)考虑，HashMap的加载因子是0.75。
        //   当HashMap的“阈值”(阈值=HashMap总的大小*加载因子) &lt; “HashMap实际大小”时，
        //   就需要将HashMap的容量翻倍。
        //   所以，(c.size()/.75f) + 1 计算出来的正好是总的空间大小。
        // 接下来，说明为什么是 16 。
        //   HashMap的总的大小，必须是2的指数倍。若创建HashMap时，指定的大小不是2的指数倍；
        //   HashMap的构造函数中也会重新计算，找出比“指定大小”大的最小的2的指数倍的数。
        //   所以，这里指定为16是从性能考虑。避免重复计算。
        map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16));
        // 将集合(c)中的全部元素添加到HashSet中
        addAll(c);
    }

    // 指定HashSet初始容量和加载因子的构造函数
    public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);
    }

    // 指定HashSet初始容量的构造函数
    public HashSet(int initialCapacity) {
        map = new HashMap&lt;E,Object&gt;(initialCapacity);
    }

    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);
    }

    // 返回HashSet的迭代器
    public Iterator&lt;E&gt; iterator() {
        // 实际上返回的是HashMap的“key集合的迭代器”
        return map.keySet().iterator();
    }

    public int size() {
        return map.size();
    }

    public boolean isEmpty() {
        return map.isEmpty();
    }

    public boolean contains(Object o) {
        return map.containsKey(o);
    }

    // 将元素(e)添加到HashSet中
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

    // 删除HashSet中的元素(o)
    public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }

    public void clear() {
        map.clear();
    }

    // 克隆一个HashSet，并返回Object对象
    public Object clone() {
        try {
            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();
            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();
            return newSet;
        } catch (CloneNotSupportedException e) {
            throw new InternalError();
        }
    }

    // java.io.Serializable的写入函数
    // 将HashSet的“总的容量，加载因子，实际容量，所有的元素”都写入到输出流中
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out any hidden serialization magic
        s.defaultWriteObject();

        // Write out HashMap capacity and load factor
        s.writeInt(map.capacity());
        s.writeFloat(map.loadFactor());

        // Write out size
        s.writeInt(map.size());

        // Write out all elements in the proper order.
        for (Iterator i=map.keySet().iterator(); i.hasNext(); )
            s.writeObject(i.next());
    }


    // java.io.Serializable的读取函数
    // 将HashSet的“总的容量，加载因子，实际容量，所有的元素”依次读出
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in any hidden serialization magic
        s.defaultReadObject();

        // Read in HashMap capacity and load factor and create backing HashMap
        int capacity = s.readInt();
        float loadFactor = s.readFloat();
        map = (((HashSet)this) instanceof LinkedHashSet ?
               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :
               new HashMap&lt;E,Object&gt;(capacity, loadFactor));

        // Read in size
        int size = s.readInt();

        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            E e = (E) s.readObject();
            map.put(e, PRESENT);
        }
    }
}</code></pre><p>说明： HashSet的代码实际上非常简单，通过上面的注释应该很能够看懂。它是通过HashMap实现的，若对HashSet的理解有困难，建议先学习以下HashMap；学完HashMap之后，在学习HashSet就非常容易了。</p>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-HashSet遍历方式"><a href="#第4部分-HashSet遍历方式" class="headerlink" title="第4部分 HashSet遍历方式"></a>第4部分 HashSet遍历方式</h1><h2 id="4-1-通过Iterator遍历HashSet"><a href="#4-1-通过Iterator遍历HashSet" class="headerlink" title="4.1 通过Iterator遍历HashSet"></a>4.1 通过Iterator遍历HashSet</h2><p>第一步：根据iterator()获取HashSet的迭代器。</p>
<p>第二步：遍历迭代器获取各个元素。</p>
<pre><code>// 假设set是HashSet对象
for(Iterator iterator = set.iterator();
       iterator.hasNext(); ) { 
    iterator.next();
}   </code></pre><h2 id="4-2-通过for-each遍历HashSet"><a href="#4-2-通过for-each遍历HashSet" class="headerlink" title="4.2 通过for-each遍历HashSet"></a>4.2 通过for-each遍历HashSet</h2><p>第一步：根据toArray()获取HashSet的元素集合对应的数组。</p>
<p>第二步：遍历数组，获取各个元素。</p>
<pre><code>// 假设set是HashSet对象，并且set中元素是String类型
String[] arr = (String[])set.toArray(new String[0]);
for (String str:arr)
    System.out.printf(&quot;for each : %s\n&quot;, str);</code></pre><p>HashSet的遍历测试程序如下： </p>
<pre><code>import java.util.Random;
import java.util.Iterator;
import java.util.HashSet;

/*
 * @desc 介绍HashSet遍历方法
 *
 * @author skywang
 */
public class HashSetIteratorTest {

    public static void main(String[] args) {
        // 新建HashSet
        HashSet set = new HashSet();

        // 添加元素 到HashSet中
        for (int i=0; i&lt;5; i++)
            set.add(&quot;&quot;+i);

        // 通过Iterator遍历HashSet
        iteratorHashSet(set) ;

        // 通过for-each遍历HashSet
        foreachHashSet(set);
    }

    /*
     * 通过Iterator遍历HashSet。推荐方式
     */
    private static void iteratorHashSet(HashSet set) {
        for(Iterator iterator = set.iterator();
               iterator.hasNext(); ) {
            System.out.printf(&quot;iterator : %s\n&quot;, iterator.next());
        }
    }

    /*
     * 通过for-each遍历HashSet。不推荐！此方法需要先将Set转换为数组
     */
    private static void foreachHashSet(HashSet set) {
        String[] arr = (String[])set.toArray(new String[0]);
        for (String str:arr)
            System.out.printf(&quot;for each : %s\n&quot;, str);
    }
}</code></pre><p>运行结果： </p>
<p>iterator : 3<br>iterator : 2<br>iterator : 1<br>iterator : 0<br>iterator : 4<br>for each : 3<br>for each : 2<br>for each : 1<br>for each : 0<br>for each : 4</p>
<p><a name="anchor5"></a></p>
<h1 id="第5部分-HashSet示例"><a href="#第5部分-HashSet示例" class="headerlink" title="第5部分 HashSet示例"></a>第5部分 HashSet示例</h1><p>下面我们通过实例学习如何使用HashSet</p>
<p>import java.util.Iterator;<br>import java.util.HashSet;</p>
<p>/*</p>
<ul>
<li><p>@desc HashSet常用API的使用。</p>
</li>
<li></li>
<li><p>@author skywang</p>
</li>
<li><p>/<br>public class HashSetTest {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>// HashSet常用API
testHashSetAPIs() ;</code></pre><p>  }</p>
<p>  /*</p>
<ul>
<li><p>HashSet除了iterator()和add()之外的其它常用API</p>
</li>
<li><p>/<br>private static void testHashSetAPIs() {<br>  // 新建HashSet<br>  HashSet set = new HashSet();</p>
<p>  // 将元素添加到Set中<br>  set.add(“a”);<br>  set.add(“b”);<br>  set.add(“c”);<br>  set.add(“d”);<br>  set.add(“e”);</p>
<p>  // 打印HashSet的实际大小<br>  System.out.printf(“size : %d\n”, set.size());</p>
<p>  // 判断HashSet是否包含某个值<br>  System.out.printf(“HashSet contains a :%s\n”, set.contains(“a”));<br>  System.out.printf(“HashSet contains g :%s\n”, set.contains(“g”));</p>
<p>  // 删除HashSet中的“e”<br>  set.remove(“e”);</p>
<p>  // 将Set转换为数组<br>  String[] arr = (String[])set.toArray(new String[0]);<br>  for (String str:arr)</p>
<pre><code>System.out.printf(&quot;for each : %s\n&quot;, str);</code></pre><p>  // 新建一个包含b、c、f的HashSet<br>  HashSet otherset = new HashSet();<br>  otherset.add(“b”);<br>  otherset.add(“c”);<br>  otherset.add(“f”);</p>
<p>  // 克隆一个removeset，内容和set一模一样<br>  HashSet removeset = (HashSet)set.clone();<br>  // 删除“removeset中，属于otherSet的元素”<br>  removeset.removeAll(otherset);<br>  // 打印removeset<br>  System.out.printf(“removeset : %s\n”, removeset);</p>
<p>  // 克隆一个retainset，内容和set一模一样<br>  HashSet retainset = (HashSet)set.clone();<br>  // 保留“retainset中，属于otherSet的元素”<br>  retainset.retainAll(otherset);<br>  // 打印retainset<br>  System.out.printf(“retainset : %s\n”, retainset);</p>
</li>
</ul>
</li>
</ul>
<pre><code>    // 遍历HashSet
    for(Iterator iterator = set.iterator();
           iterator.hasNext(); ) 
        System.out.printf(&quot;iterator : %s\n&quot;, iterator.next());

    // 清空HashSet
    set.clear();

    // 输出HashSet是否为空
    System.out.printf(&quot;%s\n&quot;, set.isEmpty()?&quot;set is empty&quot;:&quot;set is not empty&quot;);
}</code></pre><p>}</p>
<p>运行结果： </p>
<pre><code>size : 5
HashSet contains a :true
HashSet contains g :false
for each : d
for each : b
for each : c
for each : a
removeset : [d, a]
retainset : [b, c]
iterator : d
iterator : b
iterator : c
iterator : a
set is empty</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/15/java/collection/2012-02-15-collection-15-set/" itemprop="url">Java 集合系列15之 Set架构</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-15T01:01:00.000Z" itemprop="datePublished">2月 15 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            5 分钟 read (About 728 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>前面，我们已经系统的对List和Map进行了学习。接下来，我们开始可以学习Set。相信经过Map的了解之后，学习Set会容易很多。毕竟，Set的实现类都是基于Map来实现的(HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的)。</p>
<p>首先，我们看看Set架构。</p>
<p><img src="/media/pic/java/collection/collection15.jpg" alt="img"></p>
<p>(01) Set 是继承于Collection的接口。它是一个不允许有重复元素的集合。<br>(02) AbstractSet 是一个抽象类，它继承于AbstractCollection，AbstractCollection实现了Set中的绝大部分函数，为Set的实现类提供了便利。<br>(03) HastSet 和 TreeSet 是Set的两个实现类。<br>&nbsp;&nbsp;&nbsp;&nbsp;HashSet依赖于HashMap，它实际上是通过HashMap实现的。HashSet中的元素是无序的。<br>&nbsp;&nbsp;&nbsp;&nbsp;TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。TreeSet中的元素是有序的。  </p>
<h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/14/java/collection/2012-02-14-collection-14-mapsummary/" itemprop="url">Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-14T01:01:00.000Z" itemprop="datePublished">2月 14 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 read (About 6855 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 Map概括</a><br><a href="#anchor2">第2部分 HashMap和Hashtable异同</a><br><a href="#anchor3">第3部分 HashMap和WeakHashMap异同</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-Map概括"><a href="#第1部分-Map概括" class="headerlink" title="第1部分 Map概括"></a>第1部分 Map概括</h1><p>(01) Map 是“键值对”映射的抽象接口。<br>(02) AbstractMap 实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。<br>(03) SortedMap 有序的“键值对”映射接口。<br>(04) NavigableMap 是继承于SortedMap的，支持导航函数的接口。<br>(05) HashMap, Hashtable, TreeMap, WeakHashMap这4个类是“键值对”映射的实现类。它们各有区别！<br>&nbsp;&nbsp;&nbsp;&nbsp;HashMap 是基于“拉链法”实现的散列表。一般用于单线程程序中。<br>&nbsp;&nbsp;&nbsp;&nbsp;Hashtable 也是基于“拉链法”实现的散列表。它一般用于多线程程序中。<br>&nbsp;&nbsp;&nbsp;&nbsp;WeakHashMap 也是基于“拉链法”实现的散列表，它一般也用于单线程程序中。相比HashMap，WeakHashMap中的键是“弱键”，当“弱键”被GC回收时，它对应的键值对也会被从WeakHashMap中删除；而HashMap中的键是强键。<br>&nbsp;&nbsp;&nbsp;&nbsp;TreeMap 是有序的散列表，它是通过红黑树实现的。它一般用于单线程中存储有序的映射。</p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-HashMap和Hashtable异同"><a href="#第2部分-HashMap和Hashtable异同" class="headerlink" title="第2部分 HashMap和Hashtable异同"></a>第2部分 HashMap和Hashtable异同</h1><h2 id="第2-1部分-HashMap和Hashtable的相同点"><a href="#第2-1部分-HashMap和Hashtable的相同点" class="headerlink" title="第2.1部分 HashMap和Hashtable的相同点"></a>第2.1部分 HashMap和Hashtable的相同点</h2><p>HashMap和Hashtable都是存储“键值对(key-value)”的散列表，而且都是采用拉链法实现的。<br>存储的思想都是：通过table数组存储，数组的每一个元素都是一个Entry；而一个Entry就是一个单向链表，Entry链表中的每一个节点就保存了key-value键值对数据。</p>
<p><strong>添加key-value键值对</strong>：首先，根据key值计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据数组索引找到Entry(即，单向链表)，再遍历单向链表，将key和链表中的每一个节点的key进行对比。若key已经存在Entry链表中，则用该value值取代旧的value值；若key不存在Entry链表中，则新建一个key-value节点，并将该节点插入Entry链表的表头位置。<br><strong>删除key-value键值对</strong>：删除键值对，相比于“添加键值对”来说，简单很多。首先，还是根据key计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据索引找出Entry(即，单向链表)。若节点key-value存在与链表Entry中，则删除链表中的节点即可。</p>
<p>上面介绍了HashMap和Hashtable的相同点。正是由于它们都是散列表，我们关注更多的是“它们的区别，以及它们分别适合在什么情况下使用”。那接下来，我们先看看它们的区别。</p>
<h2 id="第2-2部分-HashMap和Hashtable的不同点"><a href="#第2-2部分-HashMap和Hashtable的不同点" class="headerlink" title="第2.2部分 HashMap和Hashtable的不同点"></a>第2.2部分 HashMap和Hashtable的不同点</h2><h3 id="1-继承和实现方式不同"><a href="#1-继承和实现方式不同" class="headerlink" title="1 继承和实现方式不同"></a>1 继承和实现方式不同</h3><p>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。</p>
<p>HashMap的定义:</p>
<pre><code>public class HashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable { ... }</code></pre><p>Hashtable的定义:</p>
<pre><code>public class Hashtable&lt;K,V&gt;
    extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable { ... }</code></pre><p>从中，我们可以看出：</p>
<p>1.1 HashMap和Hashtable都实现了Map、Cloneable、java.io.Serializable接口。<br>实现了Map接口，意味着它们都支持key-value键值对操作。支持“添加key-value键值对”、“获取key”、“获取value”、“获取map大小”、“清空map”等基本的key-value键值对操作。<br>实现了Cloneable接口，意味着它能被克隆。<br>实现了java.io.Serializable接口，意味着它们支持序列化，能通过序列化去传输。  </p>
<p>1.2 HashMap继承于AbstractMap，而Hashtable继承于Dictionary<br>Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；<br>而且 Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代器)去遍历。 然而‘由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。关于这点，后面还会进一步说明。<br>AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。</p>
<h3 id="2-线程安全不同"><a href="#2-线程安全不同" class="headerlink" title="2 线程安全不同"></a>2 线程安全不同</h3><p>Hashtable的几乎所有函数都是同步的，即它是线程安全的，支持多线程。<br>而HashMap的函数则是非同步的，它不是线程安全的。若要在多线程中使用HashMap，需要我们额外的进行同步处理。 对HashMap的同步处理可以使用Collections类提供的synchronizedMap静态方法，或者直接使用JDK 5.0之后提供的java.util.concurrent包里的ConcurrentHashMap类。</p>
<h3 id="3-对null值的处理不同"><a href="#3-对null值的处理不同" class="headerlink" title="3 对null值的处理不同"></a>3 对null值的处理不同</h3><p>HashMap的key、value都可以为null。<br>Hashtable的key、value都不可以为null。</p>
<p>我们先看看HashMap和Hashtable “添加key-value”的方法</p>
<p>HashMap的添加key-value的方法</p>
<pre><code>// 将“key-value”添加到HashMap中
public V put(K key, V value) {
    // 若“key为null”，则将该键值对添加到table[0]中。
    if (key == null)
        return putForNullKey(value);
    // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。
    int hash = hash(key.hashCode());
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    // 若“该key”对应的键值对不存在，则将“key-value”添加到table中
    modCount++;
    addEntry(hash, key, value, i);
    return null;
}

// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置
private V putForNullKey(V value) {
    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
        if (e.key == null) {
            V oldValue = e.value;
            e.value = value;
            // recordAccess()函数什么也没有做
            e.recordAccess(this);
            return oldValue;
        }
    }
    // 添加第1个“key为null”的元素都table中的时候，会执行到这里。
    // 它的作用是将“设置table[0]的key为null，值为value”。
    modCount++;
    addEntry(0, null, value, 0);
    return null;
}</code></pre><p>Hashtable的添加key-value的方法</p>
<pre><code>// 将“key-value”添加到Hashtable中
public synchronized V put(K key, V value) {
    // Hashtable中不能插入value为null的元素！！！
    if (value == null) {
        throw new NullPointerException();
    }

    // 若“Hashtable中已存在键为key的键值对”，
    // 则用“新的value”替换“旧的value”
    Entry tab[] = table;
    // Hashtable中不能插入key为null的元素！！！
    // 否则，下面的语句会抛出异常！
    int hash = key.hashCode();
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
            V old = e.value;
            e.value = value;
            return old;
        }
    }

    // 若“Hashtable中不存在键为key的键值对”，
    // (01) 将“修改统计数”+1
    modCount++;
    // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)
    //  则调整Hashtable的大小
    if (count &gt;= threshold) {
        // Rehash the table if the threshold is exceeded
        rehash();

        tab = table;
        index = (hash &amp; 0x7FFFFFFF) % tab.length;
    }

    // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index];
    // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。        
    tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e);
    // (05) 将“Hashtable的实际容量”+1
    count++;
    return null;
}</code></pre><p>根据上面的代码，我们可以看出：</p>
<p>Hashtable的key或value，都不能为null！否则，会抛出异常NullPointerException。<br>HashMap的key、value都可以为null。 当HashMap的key为null时，HashMap会将其固定的插入table[0]位置(即HashMap散列表的第一个位置)；而且table[0]处只会容纳一个key为null的值，当有多个key为null的值插入的时候，table[0]会保留最后插入的value。</p>
<h3 id="4-支持的遍历种类不同"><a href="#4-支持的遍历种类不同" class="headerlink" title="4 支持的遍历种类不同"></a>4 支持的遍历种类不同</h3><p>HashMap只支持Iterator(迭代器)遍历。<br>而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。</p>
<p>Enumeration 是JDK 1.0添加的接口，只有hasMoreElements(), nextElement() 两个API接口，不能通过Enumeration()对元素进行修改 。<br>而Iterator 是JDK 1.2才添加的接口，支持hasNext(), next(), remove() 三个API接口。HashMap也是JDK 1.2版本才添加的，所以用Iterator取代Enumeration，HashMap只支持Iterator遍历。</p>
<h3 id="5-通过Iterator迭代器遍历时，遍历的顺序不同"><a href="#5-通过Iterator迭代器遍历时，遍历的顺序不同" class="headerlink" title="5 通过Iterator迭代器遍历时，遍历的顺序不同"></a>5 通过Iterator迭代器遍历时，遍历的顺序不同</h3><p>HashMap是“从前向后”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。<br>Hashtabl是“从后往前”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。</p>
<p>HashMap和Hashtable都实现Map接口，所以支持获取它们“key的集合”、“value的集合”、“key-value的集合”，然后通过Iterator对这些集合进行遍历。<br>由于“key的集合”、“value的集合”、“key-value的集合”的遍历原理都是一样的；下面，我以遍历“key-value的集合”来进行说明。</p>
<p>HashMap 和Hashtable 遍历”key-value集合”的方式是：<strong>(01) 通过entrySet()获取“Map.Entry集合”</strong>。 <strong>(02) 通过iterator()获取“Map.Entry集合”的迭代器，再进行遍历。</strong></p>
<p>HashMap的实现方式：<strong>先“从前向后”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。</strong></p>
<pre><code>// 返回“HashMap的Entry集合”
public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
    return entrySet0();
}
// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象
private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() {
    Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;
    return es != null ? es : (entrySet = new EntrySet());
}
// EntrySet对应的集合
// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。
private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
    ...
    public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
        return newEntryIterator();
    }
    ...
}
// 返回一个“entry迭代器”
Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   {
    return new EntryIterator();
}
// Entry的迭代器
private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
    public Map.Entry&lt;K,V&gt; next() {
        return nextEntry();
    }
}
private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; {
    // 下一个元素
    Entry&lt;K,V&gt; next;
    // expectedModCount用于实现fail-fast机制。
    int expectedModCount;
    // 当前索引
    int index;
    // 当前元素
    Entry&lt;K,V&gt; current;

    HashIterator() {
        expectedModCount = modCount;
        if (size &gt; 0) { // advance to first entry
            Entry[] t = table;
            // 将next指向table中第一个不为null的元素。
            // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。
            while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)
                ;
        }
    }

    public final boolean hasNext() {
        return next != null;
    }

    // 获取下一个元素
    final Entry&lt;K,V&gt; nextEntry() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        Entry&lt;K,V&gt; e = next;
        if (e == null)
            throw new NoSuchElementException();

        // 注意！！！
        // 一个Entry就是一个单向链表
        // 若该Entry的下一个节点不为空，就将next指向下一个节点;
        // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。
        if ((next = e.next) == null) {
            Entry[] t = table;
            while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)
                ;
        }
        current = e;
        return e;
    }

    ...
}</code></pre><p>Hashtable的实现方式：先从“后向往前”的遍历数组；对数组具体某一项对应的链表，则从表头开始往后遍历。</p>
<pre><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
    if (entrySet==null)
        entrySet = Collections.synchronizedSet(new EntrySet(), this);
    return entrySet;
}

private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
    public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
        return getIterator(ENTRIES);
    }
    ...
}

private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
    // 指向Hashtable的table
    Entry[] table = Hashtable.this.table;
    // Hashtable的总的大小
    int index = table.length;
    Entry&lt;K,V&gt; entry = null;
    Entry&lt;K,V&gt; lastReturned = null;
    int type;

    // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志
    // iterator为true，表示它是迭代器；否则，是枚举类。
    boolean iterator;

    // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。
    protected int expectedModCount = modCount;

    Enumerator(int type, boolean iterator) {
        this.type = type;
        this.iterator = iterator;
    }

    // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。
    public boolean hasMoreElements() {
        Entry&lt;K,V&gt; e = entry;
        int i = index;
        Entry[] t = table;
        /* Use locals for faster loop iteration */
        while (e == null &amp;&amp; i &gt; 0) {
            e = t[--i];
        }
        entry = e;
        index = i;
        return e != null;
    }

    // 获取下一个元素
    // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式”
    // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。
    // 然后，依次向后遍历单向链表Entry。
    public T nextElement() {
        Entry&lt;K,V&gt; et = entry;
        int i = index;
        Entry[] t = table;
        /* Use locals for faster loop iteration */
        while (et == null &amp;&amp; i &gt; 0) {
            et = t[--i];
        }
        entry = et;
        index = i;
        if (et != null) {
            Entry&lt;K,V&gt; e = lastReturned = entry;
            entry = e.next;
            return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);
        }
        throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;);
    }

    // 迭代器Iterator的判断是否存在下一个元素
    // 实际上，它是调用的hasMoreElements()
    public boolean hasNext() {
        return hasMoreElements();
    }

    // 迭代器获取下一个元素
    // 实际上，它是调用的nextElement()
    public T next() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        return nextElement();
    }

    ...

}</code></pre><h3 id="6-容量的初始值-和-增加方式都不一样"><a href="#6-容量的初始值-和-增加方式都不一样" class="headerlink" title="6 容量的初始值 和 增加方式都不一样"></a>6 容量的初始值 和 增加方式都不一样</h3><p>HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。<br>Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。</p>
<p>HashMap默认的“加载因子”是0.75, 默认的容量大小是16。</p>
<pre><code>// 默认的初始容量是16，必须是2的幂。
static final int DEFAULT_INITIAL_CAPACITY = 16;

// 默认加载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;

// 指定“容量大小”的构造函数
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}</code></pre><p>当HashMap的 “实际容量” &gt;= “阈值”时，(阈值 = 总的容量 * 加载因子)，就将HashMap的容量翻倍。</p>
<pre><code>// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。
void addEntry(int hash, K key, V value, int bucketIndex) {
    // 保存“bucketIndex”位置的值到“e”中
    Entry&lt;K,V&gt; e = table[bucketIndex];
    // 设置“bucketIndex”位置的元素为“新Entry”，
    // 设置“e”为“新Entry的下一个节点”
    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);
    // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小
    if (size++ &gt;= threshold)
    resize(2 * table.length);
}</code></pre><p>Hashtable默认的“加载因子”是0.75, 默认的容量大小是11。 </p>
<pre><code>// 默认构造函数。
public Hashtable() {
    // 默认构造函数，指定的容量大小是11；加载因子是0.75
    this(11, 0.75f);
}</code></pre><p>当Hashtable的 “实际容量” &gt;= “阈值”时，(阈值 = 总的容量 x 加载因子)，就将变为“原始容量x2 + 1”。</p>
<pre><code>// 调整Hashtable的长度，将长度变成原来的(2倍+1)
// (01) 将“旧的Entry数组”赋值给一个临时变量。
// (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组”
// (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中
protected void rehash() {
    int oldCapacity = table.length;
    Entry[] oldMap = table;

    int newCapacity = oldCapacity * 2 + 1;
    Entry[] newMap = new Entry[newCapacity];

    modCount++;
    threshold = (int)(newCapacity * loadFactor);
    table = newMap;

    for (int i = oldCapacity ; i-- &gt; 0 ;) {
    for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) {
        Entry&lt;K,V&gt; e = old;
        old = old.next;

        int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;
        e.next = newMap[index];
        newMap[index] = e;
    }
    }
}</code></pre><h3 id="7-添加key-value时的hash值算法不同"><a href="#7-添加key-value时的hash值算法不同" class="headerlink" title="7 添加key-value时的hash值算法不同"></a>7 添加key-value时的hash值算法不同</h3><p>HashMap添加元素时，是使用自定义的哈希算法。<br>Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。</p>
<p>HashMap添加元素时，是使用自定义的哈希算法。</p>
<pre><code>static int hash(int h) {
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}

// 将“key-value”添加到HashMap中
public V put(K key, V value) {
    // 若“key为null”，则将该键值对添加到table[0]中。
    if (key == null)
    return putForNullKey(value);
    // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。
    int hash = hash(key.hashCode());
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
    Object k;
    // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！
    if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
        V oldValue = e.value;
        e.value = value;
        e.recordAccess(this);
        return oldValue;
    }
    }

    // 若“该key”对应的键值对不存在，则将“key-value”添加到table中
    modCount++;
    addEntry(hash, key, value, i);
    return null;
}</code></pre><p>Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。</p>
<pre><code>public synchronized V put(K key, V value) {
    // Hashtable中不能插入value为null的元素！！！
    if (value == null) {
    throw new NullPointerException();
    }

    // 若“Hashtable中已存在键为key的键值对”，
    // 则用“新的value”替换“旧的value”
    Entry tab[] = table;
    int hash = key.hashCode();
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
    if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
        V old = e.value;
        e.value = value;
        return old;
        }
    }

    // 若“Hashtable中不存在键为key的键值对”，
    // (01) 将“修改统计数”+1
    modCount++;
    // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)
    //  则调整Hashtable的大小
    if (count &gt;= threshold) {
    // Rehash the table if the threshold is exceeded
    rehash();

    tab = table;
    index = (hash &amp; 0x7FFFFFFF) % tab.length;
    }

    // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中
    Entry&lt;K,V&gt; e = tab[index];
    // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。        
    tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e);
    // (05) 将“Hashtable的实际容量”+1
    count++;
    return null;
}</code></pre><h3 id="8-部分API不同"><a href="#8-部分API不同" class="headerlink" title="8 部分API不同"></a>8 部分API不同</h3><p>Hashtable支持contains(Object value)方法，而且重写了toString()方法；<br>而HashMap不支持contains(Object value)方法，没有重写toString()方法。</p>
<p>最后，再说说“HashMap和Hashtable”使用的情景。<br>其实，若了解它们之间的不同之处后，可以很容易的区分根据情况进行取舍。例如：(01) 若在单线程中，我们往往会选择HashMap；而在多线程中，则会选择Hashtable。(02)，若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。<br>但这个不是绝对的标准。例如，在多线程中，我们可以自己对HashMap进行同步，也可以选择ConcurrentHashMap。当HashMap和Hashtable都不能满足自己的需求时，还可以考虑新定义一个类，继承或重新实现散列表；当然，一般情况下是不需要的了。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-HashMap和WeakHashMap异同"><a href="#第3部分-HashMap和WeakHashMap异同" class="headerlink" title="第3部分 HashMap和WeakHashMap异同"></a>第3部分 HashMap和WeakHashMap异同</h1><h2 id="3-1-HashMap和WeakHashMap的相同点"><a href="#3-1-HashMap和WeakHashMap的相同点" class="headerlink" title="3.1 HashMap和WeakHashMap的相同点"></a>3.1 HashMap和WeakHashMap的相同点</h2><p>1 它们都是散列表，存储的是“键值对”映射。<br>2 它们都继承于AbstractMap，并且实现Map基础。<br>3 它们的构造函数都一样。<br>&nbsp;&nbsp;&nbsp;&nbsp;它们都包括4个构造函数，而且函数的参数都一样。<br>4 默认的容量大小是16，默认的加载因子是0.75。<br>5 它们的“键”和“值”都允许为null。<br>6 它们都是“非同步的”。  </p>
<h2 id="3-2-HashMap和WeakHashMap的不同点"><a href="#3-2-HashMap和WeakHashMap的不同点" class="headerlink" title="3.2 HashMap和WeakHashMap的不同点"></a>3.2 HashMap和WeakHashMap的不同点</h2><p>1 HashMap实现了Cloneable和Serializable接口，而WeakHashMap没有。<br>HashMap实现Cloneable，意味着它能通过clone()克隆自己。<br>HashMap实现Serializable，意味着它支持序列化，能通过序列化去传输。</p>
<p>2 HashMap的“键”是“强引用(StrongReference)”，而WeakHashMap的键是“弱引用(WeakReference)”。<br>WeakReference的“弱键”能实现WeakReference对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。<br>这个“弱键”实现的动态回收“键值对”的原理呢？其实，通过WeakReference(弱引用)和ReferenceQueue(引用队列)实现的。 首先，我们需要了解WeakHashMap中：<br>&nbsp;&nbsp;&nbsp;&nbsp;第一，“键”是WeakReference，即key是弱键。<br>&nbsp;&nbsp;&nbsp;&nbsp;第二，ReferenceQueue是一个引用队列，它是和WeakHashMap联合使用的。当弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 WeakHashMap中的ReferenceQueue是queue。<br>&nbsp;&nbsp;&nbsp;&nbsp;第三，WeakHashMap是通过数组实现的，我们假设这个数组是table。</p>
<p>接下来，说说“动态回收”的步骤。</p>
<p>(01) 新建WeakHashMap，将“键值对”添加到WeakHashMap中。<br>将“键值对”添加到WeakHashMap中时，添加的键都是弱键。<br>实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。<br>(02) 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到queue队列中。<br>例如，当我们在将“弱键”key添加到WeakHashMap之后；后来将key设为null。这时，便没有外部外部对象再引用该了key。<br>接着，当Java虚拟机的GC回收内存时，会回收key的相关内存；同时，将key添加到queue队列中。<br>(03) 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的“弱键”；同步它们，就是删除table中被GC回收的“弱键”对应的键值对。<br>例如，当我们“读取WeakHashMap中的元素或获取WeakReference的大小时”，它会先同步table和queue，目的是“删除table中被GC回收的‘弱键’对应的键值对”。删除的方法就是逐个比较“table中元素的‘键’和queue中的‘键’”，若它们相当，则删除“table中的该键值对”。</p>
<h2 id="3-3-HashMap和WeakHashMap的比较测试程序"><a href="#3-3-HashMap和WeakHashMap的比较测试程序" class="headerlink" title="3.3 HashMap和WeakHashMap的比较测试程序"></a>3.3 HashMap和WeakHashMap的比较测试程序</h2><pre><code>import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.Date;
import java.lang.ref.WeakReference;

/**
 * @desc HashMap 和 WeakHashMap比较程序
 *
 * @author skywang
 * @email kuiwu-wang@163.com
 */
public class CompareHashmapAndWeakhashmap {

    public static void main(String[] args) throws Exception {

    // 当“弱键”是String时，比较HashMap和WeakHashMap
    compareWithString();
    // 当“弱键”是自定义类型时，比较HashMap和WeakHashMap
    compareWithSelfClass();
    }

    /**
     * 遍历map，并打印map的大小
     */
    private static void iteratorAndCountMap(Map map) {
    // 遍历map
    for (Iterator iter = map.entrySet().iterator();
            iter.hasNext();  ) {
        Map.Entry en = (Map.Entry)iter.next();
        System.out.printf(&quot;map entry : %s - %s\n &quot;,en.getKey(), en.getValue());
    }

    // 打印HashMap的实际大小
    System.out.printf(&quot; map size:%s\n\n&quot;, map.size());
    }

    /**
     * 通过String对象测试HashMap和WeakHashMap
     */
    private static void compareWithString() {
    // 新建4个String字符串
    String w1 = new String(&quot;W1&quot;);
    String w2 = new String(&quot;W2&quot;);
    String h1 = new String(&quot;H1&quot;);
    String h2 = new String(&quot;H2&quot;);

    // 新建 WeakHashMap对象，并将w1,w2添加到 WeakHashMap中
    Map wmap = new WeakHashMap();
    wmap.put(w1, &quot;w1&quot;);
    wmap.put(w2, &quot;w2&quot;);

    // 新建 HashMap对象，并将h1,h2添加到 WeakHashMap中
    Map hmap = new HashMap();
    hmap.put(h1, &quot;h1&quot;);
    hmap.put(h2, &quot;h2&quot;);

    // 删除HashMap中的“h1”。
    // 结果：删除“h1”之后，HashMap中只有 h2 ！
    hmap.remove(h1);

    // 将WeakHashMap中的w1设置null，并执行gc()。系统会回收w1
    // 结果：w1是“弱键”，被GC回收后，WeakHashMap中w1对应的键值对，也会被从WeakHashMap中删除。
    //       w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。
    // 因此，WeakHashMap中只有 w2
    // 注意：若去掉“w1=null” 或者“System.gc()”，结果都会不一样！
    w1 = null;
    System.gc();

    // 遍历并打印HashMap的大小
    System.out.printf(&quot; -- HashMap --\n&quot;);
    iteratorAndCountMap(hmap);

    // 遍历并打印WeakHashMap的大小
    System.out.printf(&quot; -- WeakHashMap --\n&quot;);
    iteratorAndCountMap(wmap);
    }

    /**
     * 通过自定义类测试HashMap和WeakHashMap
     */
    private static void compareWithSelfClass() {
    // 新建4个自定义对象
    Self s1 = new Self(10);
    Self s2 = new Self(20);
    Self s3 = new Self(30);
    Self s4 = new Self(40);

    // 新建 WeakHashMap对象，并将s1,s2添加到 WeakHashMap中
    Map wmap = new WeakHashMap();
    wmap.put(s1, &quot;s1&quot;);
    wmap.put(s2, &quot;s2&quot;);

    // 新建 HashMap对象，并将s3,s4添加到 WeakHashMap中
    Map hmap = new HashMap();
    hmap.put(s3, &quot;s3&quot;);
    hmap.put(s4, &quot;s4&quot;);

    // 删除HashMap中的s3。
    // 结果：删除s3之后，HashMap中只有 s4 ！
    hmap.remove(s3);

    // 将WeakHashMap中的s1设置null，并执行gc()。系统会回收w1
    // 结果：s1是“弱键”，被GC回收后，WeakHashMap中s1对应的键值对，也会被从WeakHashMap中删除。
    //       w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。
    // 因此，WeakHashMap中只有 s2
    // 注意：若去掉“s1=null” 或者“System.gc()”，结果都会不一样！
    s1 = null;
    System.gc();

    /*
    // 休眠500ms
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // */

    // 遍历并打印HashMap的大小
    System.out.printf(&quot; -- Self-def HashMap --\n&quot;);
    iteratorAndCountMap(hmap);

    // 遍历并打印WeakHashMap的大小
    System.out.printf(&quot; -- Self-def WeakHashMap --\n&quot;);
    iteratorAndCountMap(wmap);
    }

    private static class Self { 
    int id;

    public Self(int id) {
        this.id = id;
    }

    // 覆盖finalize()方法
    // 在GC回收时会被执行
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.printf(&quot;GC Self: id=%d addr=0x%s)\n&quot;, id, this);
    }   
    }
}</code></pre><p>运行结果：</p>
<pre><code> -- HashMap --
map entry : H2 - h2
  map size:1

 -- WeakHashMap --
map entry : W2 - w2
  map size:1

 -- Self-def HashMap --
map entry : CompareHashmapAndWeakhashmap$Self@1ff9dc36 - s4
  map size:1

 -- Self-def WeakHashMap --
GC Self: id=10 addr=0xCompareHashmapAndWeakhashmap$Self@12276af2)
map entry : CompareHashmapAndWeakhashmap$Self@59de3f2d - s2
  map size:1</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/13/java/collection/2012-02-13-collection-13-weakhashmap/" itemprop="url">Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-13T01:01:00.000Z" itemprop="datePublished">2月 13 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            39 分钟 read (About 5819 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>这一章，我们对WeakHashMap进行学习。<br>我们先对WeakHashMap有个整体认识，然后再学习它的源码，最后再通过实例来学会使用WeakHashMap。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 WeakHashMap介绍</a><br><a href="#anchor2">第2部分 WeakHashMap数据结构</a><br><a href="#anchor3">第3部分 WeakHashMap源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 WeakHashMap遍历方式</a><br><a href="#anchor5">第5部分 WeakHashMap示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-WeakHashMap介绍"><a href="#第1部分-WeakHashMap介绍" class="headerlink" title="第1部分 WeakHashMap介绍"></a>第1部分 WeakHashMap介绍</h1><p><strong>WeakHashMap简介</strong></p>
<p>WeakHashMap 继承于AbstractMap，实现了Map接口。<br>和HashMap一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是null。<br>不过WeakHashMap的键是“弱键”。在 WeakHashMap 中，当某个键不再正常使用时，会被从WeakHashMap中被自动移除。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。某个键被终止时，它对应的键值对也就从映射中有效地移除了。<br>这个“弱键”的原理呢？大致上就是，通过WeakReference和ReferenceQueue实现的。 WeakHashMap的key是“弱键”，即是WeakReference类型的；ReferenceQueue是一个队列，它会保存被GC回收的“弱键”。实现步骤是：<br>&nbsp;&nbsp;(01) 新建WeakHashMap，将“键值对”添加到WeakHashMap中。<br>&nbsp;&nbsp;&nbsp;&nbsp;实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。<br>&nbsp;&nbsp;(02) 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。<br>&nbsp;&nbsp;(03) 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是删除table中被GC回收的键值对。</p>
<p>这就是“弱键”如何被自动从WeakHashMap中删除的步骤了。</p>
<p>和HashMap一样，WeakHashMap是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap。</p>
<p><strong>WeakHashMap的构造函数</strong></p>
<p>WeakHashMap共有4个构造函数,如下：</p>
<pre><code>// 默认构造函数。
WeakHashMap()

// 指定“容量大小”的构造函数
WeakHashMap(int capacity)

// 指定“容量大小”和“加载因子”的构造函数
WeakHashMap(int capacity, float loadFactor)

// 包含“子Map”的构造函数
WeakHashMap(Map&lt;? extends K, ? extends V&gt; map)</code></pre><p><strong>WeakHashMap的API</strong></p>
<pre><code>void                   clear()
Object                 clone()
boolean                containsKey(Object key)
boolean                containsValue(Object value)
Set&lt;Entry&lt;K, V&gt;&gt;       entrySet()
V                      get(Object key)
boolean                isEmpty()
Set&lt;K&gt;                 keySet()
V                      put(K key, V value)
void                   putAll(Map&lt;? extends K, ? extends V&gt; map)
V                      remove(Object key)
int                    size()
Collection&lt;V&gt;          values()</code></pre><p><a name="anchor2"></a></p>
<h1 id="第2部分-WeakHashMap数据结构"><a href="#第2部分-WeakHashMap数据结构" class="headerlink" title="第2部分 WeakHashMap数据结构"></a>第2部分 WeakHashMap数据结构</h1><p>WeakHashMap的继承关系如下</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractMap&lt;K, V&gt;
         ↳     java.util.WeakHashMap&lt;K, V&gt;</code></pre><p>WeakHashMap的声明</p>
<pre><code>public class WeakHashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt; {}</code></pre><p>WeakHashMap与Map关系如下图：</p>
<p><img src="/media/pic/java/collection/collection13.jpg" alt="img"></p>
<p>从图中可以看出：<br>(01) WeakHashMap继承于AbstractMap，并且实现了Map接口。<br>(02) WeakHashMap是哈希表，但是它的键是”弱键”。WeakHashMap中保护几个重要的成员变量：table, size, threshold, loadFactor, modCount, queue。<br>&nbsp;&nbsp;table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。<br>&nbsp;&nbsp;size是Hashtable的大小，它是Hashtable保存的键值对的数量。<br>&nbsp;&nbsp;threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。<br>&nbsp;&nbsp;loadFactor就是加载因子。<br>&nbsp;&nbsp;modCount是用来实现fail-fast机制的<br>&nbsp;&nbsp;queue保存的是“已被GC清除”的“弱引用的键”。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-WeakHashMap源码解析-基于JDK1-6-0-45"><a href="#第3部分-WeakHashMap源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 WeakHashMap源码解析(基于JDK1.6.0_45)"></a>第3部分 WeakHashMap源码解析(基于JDK1.6.0_45)</h1><p>下面对WeakHashMap的源码进行说明</p>
<pre><code>package java.util;
import java.lang.ref.WeakReference;
import java.lang.ref.ReferenceQueue;

public class WeakHashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt; {

    // 默认的初始容量是16，必须是2的幂。
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）
    private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    // 默认加载因子
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;

    // 存储数据的Entry数组，长度是2的幂。
    // WeakHashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表
    private Entry[] table;

    // WeakHashMap的大小，它是WeakHashMap保存的键值对的数量
    private int size;

    // WeakHashMap的阈值，用于判断是否需要调整WeakHashMap的容量（threshold = 容量*加载因子）
    private int threshold;

    // 加载因子实际大小
    private final float loadFactor;

    // queue保存的是“已被GC清除”的“弱引用的键”。
    // 弱引用和ReferenceQueue 是联合使用的：如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中
    private final ReferenceQueue&lt;K&gt; queue = new ReferenceQueue&lt;K&gt;();

    // WeakHashMap被改变的次数
    private volatile int modCount;

    // 指定“容量大小”和“加载因子”的构造函数
    public WeakHashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Initial Capacity: &quot;+
                                               initialCapacity);
        // WeakHashMap的最大容量只能是MAXIMUM_CAPACITY
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;

        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal Load factor: &quot;+
                                               loadFactor);
        // 找出“大于initialCapacity”的最小的2的幂
        int capacity = 1;
        while (capacity &lt; initialCapacity)
            capacity &lt;&lt;= 1;
        // 创建Entry数组，用来保存数据
        table = new Entry[capacity];
        // 设置“加载因子”
        this.loadFactor = loadFactor;
        // 设置“WeakHashMap阈值”，当WeakHashMap中存储数据的数量达到threshold时，就需要将WeakHashMap的容量加倍。
        threshold = (int)(capacity * loadFactor);
    }

    // 指定“容量大小”的构造函数
    public WeakHashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    // 默认构造函数。
    public WeakHashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        threshold = (int)(DEFAULT_INITIAL_CAPACITY);
        table = new Entry[DEFAULT_INITIAL_CAPACITY];
    }

    // 包含“子Map”的构造函数
    public WeakHashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, 16),
             DEFAULT_LOAD_FACTOR);
        // 将m中的全部元素逐个添加到WeakHashMap中
        putAll(m);
    }

    // 键为null的mask值。
    // 因为WeakReference中允许“null的key”，若直接插入“null的key”，将其当作弱引用时，会被删除。
    // 因此，这里对于“key为null”的清空，都统一替换为“key为NULL_KEY”，“NULL_KEY”是“静态的final常量”。
    private static final Object NULL_KEY = new Object();

    // 对“null的key”进行特殊处理
    private static Object maskNull(Object key) {
        return (key == null ? NULL_KEY : key);
    }

    // 还原对“null的key”的特殊处理
    private static &lt;K&gt; K unmaskNull(Object key) {
        return (K) (key == NULL_KEY ? null : key);
    }

    // 判断“x”和“y”是否相等
    static boolean eq(Object x, Object y) {
        return x == y || x.equals(y);
    }

    // 返回索引值
    // h &amp; (length-1)保证返回值的小于length
    static int indexFor(int h, int length) {
        return h &amp; (length-1);
    }

    // 清空table中无用键值对。原理如下：
    // (01) 当WeakHashMap中某个“弱引用的key”由于没有再被引用而被GC收回时，
    //   被回收的“该弱引用key”也被会被添加到&quot;ReferenceQueue(queue)&quot;中。
    // (02) 当我们执行expungeStaleEntries时，
    //   就遍历&quot;ReferenceQueue(queue)&quot;中的所有key
    //   然后就在“WeakReference的table”中删除与“ReferenceQueue(queue)中key”对应的键值对
    private void expungeStaleEntries() {
        Entry&lt;K,V&gt; e;
        while ( (e = (Entry&lt;K,V&gt;) queue.poll()) != null) {
            int h = e.hash;
            int i = indexFor(h, table.length);

            Entry&lt;K,V&gt; prev = table[i];
            Entry&lt;K,V&gt; p = prev;
            while (p != null) {
                Entry&lt;K,V&gt; next = p.next;
                if (p == e) {
                    if (prev == e)
                        table[i] = next;
                    else
                        prev.next = next;
                    e.next = null;  // Help GC
                    e.value = null; //  &quot;   &quot;
                    size--;
                    break;
                }
                prev = p;
                p = next;
            }
        }
    }

    // 获取WeakHashMap的table(存放键值对的数组)
    private Entry[] getTable() {
        // 删除table中“已被GC回收的key对应的键值对”
        expungeStaleEntries();
        return table;
    }

    // 获取WeakHashMap的实际大小
    public int size() {
        if (size == 0)
            return 0;
        // 删除table中“已被GC回收的key对应的键值对”
        expungeStaleEntries();
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    // 获取key对应的value
    public V get(Object key) {
        Object k = maskNull(key);
        // 获取key的hash值。
        int h = HashMap.hash(k.hashCode());
        Entry[] tab = getTable();
        int index = indexFor(h, tab.length);
        Entry&lt;K,V&gt; e = tab[index];
        // 在“该hash值对应的链表”上查找“键值等于key”的元素
        while (e != null) {
            if (e.hash == h &amp;&amp; eq(k, e.get()))
                return e.value;
            e = e.next;
        }
        return null;
    }

    // WeakHashMap是否包含key
    public boolean containsKey(Object key) {
        return getEntry(key) != null;
    }

    // 返回“键为key”的键值对
    Entry&lt;K,V&gt; getEntry(Object key) {
        Object k = maskNull(key);
        int h = HashMap.hash(k.hashCode());
        Entry[] tab = getTable();
        int index = indexFor(h, tab.length);
        Entry&lt;K,V&gt; e = tab[index];
        while (e != null &amp;&amp; !(e.hash == h &amp;&amp; eq(k, e.get())))
            e = e.next;
        return e;
    }

    // 将“key-value”添加到WeakHashMap中
    public V put(K key, V value) {
        K k = (K) maskNull(key);
        int h = HashMap.hash(k.hashCode());
        Entry[] tab = getTable();
        int i = indexFor(h, tab.length);

        for (Entry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
            // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！
            if (h == e.hash &amp;&amp; eq(k, e.get())) {
                V oldValue = e.value;
                if (value != oldValue)
                    e.value = value;
                return oldValue;
            }
        }

        // 若“该key”对应的键值对不存在于WeakHashMap中，则将“key-value”添加到table中
        modCount++;
        Entry&lt;K,V&gt; e = tab[i];
        tab[i] = new Entry&lt;K,V&gt;(k, value, queue, h, e);
        if (++size &gt;= threshold)
            resize(tab.length * 2);
        return null;
    }

    // 重新调整WeakHashMap的大小，newCapacity是调整后的单位
    void resize(int newCapacity) {
        Entry[] oldTable = getTable();
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }

        // 新建一个newTable，将“旧的table”的全部元素添加到“新的newTable”中，
        // 然后，将“新的newTable”赋值给“旧的table”。
        Entry[] newTable = new Entry[newCapacity];
        transfer(oldTable, newTable);
        table = newTable;

        if (size &gt;= threshold / 2) {
            threshold = (int)(newCapacity * loadFactor);
        } else {
            // 删除table中“已被GC回收的key对应的键值对”
            expungeStaleEntries();
            transfer(newTable, oldTable);
            table = oldTable;
        }
    }

    // 将WeakHashMap中的全部元素都添加到newTable中
    private void transfer(Entry[] src, Entry[] dest) {
        for (int j = 0; j &lt; src.length; ++j) {
            Entry&lt;K,V&gt; e = src[j];
            src[j] = null;
            while (e != null) {
                Entry&lt;K,V&gt; next = e.next;
                Object key = e.get();
                if (key == null) {
                    e.next = null;  // Help GC
                    e.value = null; //  &quot;   &quot;
                    size--;
                } else {
                    int i = indexFor(e.hash, dest.length);
                    e.next = dest[i];
                    dest[i] = e;
                }
                e = next;
            }
        }
    }

    // 将&quot;m&quot;的全部元素都添加到WeakHashMap中
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
        int numKeysToBeAdded = m.size();
        if (numKeysToBeAdded == 0)
            return;

        // 计算容量是否足够，
        // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。
        if (numKeysToBeAdded &gt; threshold) {
            int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);
            if (targetCapacity &gt; MAXIMUM_CAPACITY)
                targetCapacity = MAXIMUM_CAPACITY;
            int newCapacity = table.length;
            while (newCapacity &lt; targetCapacity)
                newCapacity &lt;&lt;= 1;
            if (newCapacity &gt; table.length)
                resize(newCapacity);
        }

        // 将“m”中的元素逐个添加到WeakHashMap中。
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())
            put(e.getKey(), e.getValue());
    }

    // 删除“键为key”元素
    public V remove(Object key) {
        Object k = maskNull(key);
        // 获取哈希值。
        int h = HashMap.hash(k.hashCode());
        Entry[] tab = getTable();
        int i = indexFor(h, tab.length);
        Entry&lt;K,V&gt; prev = tab[i];
        Entry&lt;K,V&gt; e = prev;

        // 删除链表中“键为key”的元素
        // 本质是“删除单向链表中的节点”
        while (e != null) {
            Entry&lt;K,V&gt; next = e.next;
            if (h == e.hash &amp;&amp; eq(k, e.get())) {
                modCount++;
                size--;
                if (prev == e)
                    tab[i] = next;
                else
                    prev.next = next;
                return e.value;
            }
            prev = e;
            e = next;
        }

        return null;
    }

    // 删除“键值对”
    Entry&lt;K,V&gt; removeMapping(Object o) {
        if (!(o instanceof Map.Entry))
            return null;
        Entry[] tab = getTable();
        Map.Entry entry = (Map.Entry)o;
        Object k = maskNull(entry.getKey());
        int h = HashMap.hash(k.hashCode());
        int i = indexFor(h, tab.length);
        Entry&lt;K,V&gt; prev = tab[i];
        Entry&lt;K,V&gt; e = prev;

        // 删除链表中的“键值对e”
        // 本质是“删除单向链表中的节点”
        while (e != null) {
            Entry&lt;K,V&gt; next = e.next;
            if (h == e.hash &amp;&amp; e.equals(entry)) {
                modCount++;
                size--;
                if (prev == e)
                    tab[i] = next;
                else
                    prev.next = next;
                return e;
            }
            prev = e;
            e = next;
        }

        return null;
    }

    // 清空WeakHashMap，将所有的元素设为null
    public void clear() {
        while (queue.poll() != null)
            ;

        modCount++;
        Entry[] tab = table;
        for (int i = 0; i &lt; tab.length; ++i)
            tab[i] = null;
        size = 0;

        while (queue.poll() != null)
            ;
    }

    // 是否包含“值为value”的元素
    public boolean containsValue(Object value) {
        // 若“value为null”，则调用containsNullValue()查找
        if (value==null)
            return containsNullValue();

        // 若“value不为null”，则查找WeakHashMap中是否有值为value的节点。
        Entry[] tab = getTable();
        for (int i = tab.length ; i-- &gt; 0 ;)
            for (Entry e = tab[i] ; e != null ; e = e.next)
                if (value.equals(e.value))
                    return true;
        return false;
    }

    // 是否包含null值
    private boolean containsNullValue() {
        Entry[] tab = getTable();
        for (int i = tab.length ; i-- &gt; 0 ;)
            for (Entry e = tab[i] ; e != null ; e = e.next)
                if (e.value==null)
                    return true;
        return false;
    }

    // Entry是单向链表。
    // 它是 “WeakHashMap链式存储法”对应的链表。
    // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数
    private static class Entry&lt;K,V&gt; extends WeakReference&lt;K&gt; implements Map.Entry&lt;K,V&gt; {
        private V value;
        private final int hash;
        // 指向下一个节点
        private Entry&lt;K,V&gt; next;

        // 构造函数。
        Entry(K key, V value,
          ReferenceQueue&lt;K&gt; queue,
              int hash, Entry&lt;K,V&gt; next) {
            super(key, queue);
            this.value = value;
            this.hash  = hash;
            this.next  = next;
        }

        public K getKey() {
            return WeakHashMap.&lt;K&gt;unmaskNull(get());
        }

        public V getValue() {
            return value;
        }

        public V setValue(V newValue) {
        V oldValue = value;
            value = newValue;
            return oldValue;
        }

        // 判断两个Entry是否相等
        // 若两个Entry的“key”和“value”都相等，则返回true。
        // 否则，返回false
        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;
            Object k1 = getKey();
            Object k2 = e.getKey();
            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {
                Object v1 = getValue();
                Object v2 = e.getValue();
                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))
                    return true;
            }
            return false;
        }

        // 实现hashCode()
        public int hashCode() {
            Object k = getKey();
            Object v = getValue();
            return  ((k==null ? 0 : k.hashCode()) ^
                     (v==null ? 0 : v.hashCode()));
        }

        public String toString() {
            return getKey() + &quot;=&quot; + getValue();
        }
    }

    // HashIterator是WeakHashMap迭代器的抽象出来的父类，实现了公共了函数。
    // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。
    private abstract class HashIterator&lt;T&gt; implements Iterator&lt;T&gt; {
        // 当前索引
        int index;
        // 当前元素
        Entry&lt;K,V&gt; entry = null;
        // 上一次返回元素
        Entry&lt;K,V&gt; lastReturned = null;
        // expectedModCount用于实现fast-fail机制。
        int expectedModCount = modCount;

        // 下一个键(强引用)
        Object nextKey = null;

        // 当前键(强引用)
        Object currentKey = null;

        // 构造函数
        HashIterator() {
            index = (size() != 0 ? table.length : 0);
        }

        // 是否存在下一个元素
        public boolean hasNext() {
            Entry[] t = table;

            // 一个Entry就是一个单向链表
            // 若该Entry的下一个节点不为空，就将next指向下一个节点;
            // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。
            while (nextKey == null) {
                Entry&lt;K,V&gt; e = entry;
                int i = index;
                while (e == null &amp;&amp; i &gt; 0)
                    e = t[--i];
                entry = e;
                index = i;
                if (e == null) {
                    currentKey = null;
                    return false;
                }
                nextKey = e.get(); // hold on to key in strong ref
                if (nextKey == null)
                    entry = entry.next;
            }
            return true;
        }

        // 获取下一个元素
        protected Entry&lt;K,V&gt; nextEntry() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            if (nextKey == null &amp;&amp; !hasNext())
                throw new NoSuchElementException();

            lastReturned = entry;
            entry = entry.next;
            currentKey = nextKey;
            nextKey = null;
            return lastReturned;
        }

        // 删除当前元素
        public void remove() {
            if (lastReturned == null)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();

            WeakHashMap.this.remove(currentKey);
            expectedModCount = modCount;
            lastReturned = null;
            currentKey = null;
        }

    }

    // value的迭代器
    private class ValueIterator extends HashIterator&lt;V&gt; {
        public V next() {
            return nextEntry().value;
        }
    }

    // key的迭代器
    private class KeyIterator extends HashIterator&lt;K&gt; {
        public K next() {
            return nextEntry().getKey();
        }
    }

    // Entry的迭代器
    private class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        public Map.Entry&lt;K,V&gt; next() {
            return nextEntry();
        }
    }

    // WeakHashMap的Entry对应的集合
    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;

    // 返回“key的集合”，实际上返回一个“KeySet对象”
    public Set&lt;K&gt; keySet() {
        Set&lt;K&gt; ks = keySet;
        return (ks != null ? ks : (keySet = new KeySet()));
    }

    // Key对应的集合
    // KeySet继承于AbstractSet，说明该集合中没有重复的Key。
    private class KeySet extends AbstractSet&lt;K&gt; {
        public Iterator&lt;K&gt; iterator() {
            return new KeyIterator();
        }

        public int size() {
            return WeakHashMap.this.size();
        }

        public boolean contains(Object o) {
            return containsKey(o);
        }

        public boolean remove(Object o) {
            if (containsKey(o)) {
                WeakHashMap.this.remove(o);
                return true;
            }
            else
                return false;
        }

        public void clear() {
            WeakHashMap.this.clear();
        }
    }

    // 返回“value集合”，实际上返回的是一个Values对象
    public Collection&lt;V&gt; values() {
        Collection&lt;V&gt; vs = values;
        return (vs != null ?  vs : (values = new Values()));
    }

    // “value集合”
    // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，
    // Values中的元素能够重复。因为不同的key可以指向相同的value。
    private class Values extends AbstractCollection&lt;V&gt; {
        public Iterator&lt;V&gt; iterator() {
            return new ValueIterator();
        }

        public int size() {
            return WeakHashMap.this.size();
        }

        public boolean contains(Object o) {
            return containsValue(o);
        }

        public void clear() {
            WeakHashMap.this.clear();
        }
    }

    // 返回“WeakHashMap的Entry集合”
    // 它实际是返回一个EntrySet对象
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;
        return es != null ? es : (entrySet = new EntrySet());
    }

    // EntrySet对应的集合
    // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。
    private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
            return new EntryIterator();
        }

        // 是否包含“值(o)”
        public boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;
            Object k = e.getKey();
            Entry candidate = getEntry(e.getKey());
            return candidate != null &amp;&amp; candidate.equals(e);
        }

        // 删除“值(o)”
        public boolean remove(Object o) {
            return removeMapping(o) != null;
        }

        // 返回WeakHashMap的大小
        public int size() {
            return WeakHashMap.this.size();
        }

        // 清空WeakHashMap
        public void clear() {
            WeakHashMap.this.clear();
        }

        // 拷贝函数。将WeakHashMap中的全部元素都拷贝到List中
        private List&lt;Map.Entry&lt;K,V&gt;&gt; deepCopy() {
            List&lt;Map.Entry&lt;K,V&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(size());
            for (Map.Entry&lt;K,V&gt; e : this)
                list.add(new AbstractMap.SimpleEntry&lt;K,V&gt;(e));
            return list;
        }

        // 返回Entry对应的Object[]数组
        public Object[] toArray() {
            return deepCopy().toArray();
        }

        // 返回Entry对应的T[]数组(T[]我们新建数组时，定义的数组类型)
        public &lt;T&gt; T[] toArray(T[] a) {
            return deepCopy().toArray(a);
        }
    }
}</code></pre><p>说明：WeakHashMap和HashMap都是通过”拉链法”实现的散列表。它们的源码绝大部分内容都一样，这里就只是对它们不同的部分就是说明。</p>
<p>WeakReference是“弱键”实现的哈希表。它这个“弱键”的目的就是：实现对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。<br>“弱键”是一个“弱引用(WeakReference)”，在Java中，WeakReference和ReferenceQueue 是联合使用的。在WeakHashMap中亦是如此：如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 接着，WeakHashMap会根据“引用队列”，来删除“WeakHashMap中已被GC回收的‘弱键’对应的键值对”。<br>另外，理解上面思想的重点是通过 expungeStaleEntries() 函数去理解。</p>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-WeakHashMap遍历方式"><a href="#第4部分-WeakHashMap遍历方式" class="headerlink" title="第4部分 WeakHashMap遍历方式"></a>第4部分 WeakHashMap遍历方式</h1><h2 id="4-1-遍历WeakHashMap的键值对"><a href="#4-1-遍历WeakHashMap的键值对" class="headerlink" title="4.1 遍历WeakHashMap的键值对"></a>4.1 遍历WeakHashMap的键值对</h2><p>第一步：根据entrySet()获取WeakHashMap的“键值对”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是WeakHashMap对象
// map中的key是String类型，value是Integer类型
Integer integ = null;
Iterator iter = map.entrySet().iterator();
while(iter.hasNext()) {
    Map.Entry entry = (Map.Entry)iter.next();
    // 获取key
    key = (String)entry.getKey();
        // 获取value
    integ = (Integer)entry.getValue();
}</code></pre><h2 id="4-2-遍历WeakHashMap的键"><a href="#4-2-遍历WeakHashMap的键" class="headerlink" title="4.2 遍历WeakHashMap的键"></a>4.2 遍历WeakHashMap的键</h2><p>第一步：根据keySet()获取WeakHashMap的“键”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是WeakHashMap对象
// map中的key是String类型，value是Integer类型
String key = null;
Integer integ = null;
Iterator iter = map.keySet().iterator();
while (iter.hasNext()) {
        // 获取key
    key = (String)iter.next();
        // 根据key，获取value
    integ = (Integer)map.get(key);
}</code></pre><h2 id="4-3-遍历WeakHashMap的值"><a href="#4-3-遍历WeakHashMap的值" class="headerlink" title="4.3 遍历WeakHashMap的值"></a>4.3 遍历WeakHashMap的值</h2><p>第一步：根据value()获取WeakHashMap的“值”的集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是WeakHashMap对象
// map中的key是String类型，value是Integer类型
Integer value = null;
Collection c = map.values();
Iterator iter= c.iterator();
while (iter.hasNext()) {
    value = (Integer)iter.next();
}</code></pre><p>WeakHashMap遍历测试程序如下：</p>
<pre><code>import java.util.Map;
import java.util.Random;
import java.util.Iterator;
import java.util.WeakHashMap;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Collection;

/*
 * @desc 遍历WeakHashMap的测试程序。
 *   (01) 通过entrySet()去遍历key、value，参考实现函数：
 *        iteratorHashMapByEntryset()
 *   (02) 通过keySet()去遍历key、value，参考实现函数：
 *        iteratorHashMapByKeyset()
 *   (03) 通过values()去遍历value，参考实现函数：
 *        iteratorHashMapJustValues()
 *
 * @author skywang
 */
public class WeakHashMapIteratorTest {

    public static void main(String[] args) {
        int val = 0;
        String key = null;
        Integer value = null;
        Random r = new Random();
        WeakHashMap map = new WeakHashMap();

        for (int i=0; i&lt;12; i++) {
            // 随机获取一个[0,100)之间的数字
            val = r.nextInt(100);

            key = String.valueOf(val);
            value = r.nextInt(5);
            // 添加到WeakHashMap中
            map.put(key, value);
            System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value);
        }
        // 通过entrySet()遍历WeakHashMap的key-value
        iteratorHashMapByEntryset(map) ;

        // 通过keySet()遍历WeakHashMap的key-value
        iteratorHashMapByKeyset(map) ;

        // 单单遍历WeakHashMap的value
        iteratorHashMapJustValues(map);        
    }

    /*
     * 通过entry set遍历WeakHashMap
     * 效率高!
     */
    private static void iteratorHashMapByEntryset(WeakHashMap map) {
        if (map == null)
            return ;

        System.out.println(&quot;\niterator WeakHashMap By entryset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = map.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();

            key = (String)entry.getKey();
            integ = (Integer)entry.getValue();
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }

    /*
     * 通过keyset来遍历WeakHashMap
     * 效率低!
     */
    private static void iteratorHashMapByKeyset(WeakHashMap map) {
        if (map == null)
            return ;

        System.out.println(&quot;\niterator WeakHashMap By keyset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = map.keySet().iterator();
        while (iter.hasNext()) {
            key = (String)iter.next();
            integ = (Integer)map.get(key);
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }


    /*
     * 遍历WeakHashMap的values
     */
    private static void iteratorHashMapJustValues(WeakHashMap map) {
        if (map == null)
            return ;

        Collection c = map.values();
        Iterator iter= c.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
       }
    }
}</code></pre><p><a name="anchor5"></a></p>
<h1 id="第5部分-WeakHashMap示例"><a href="#第5部分-WeakHashMap示例" class="headerlink" title="第5部分 WeakHashMap示例"></a>第5部分 WeakHashMap示例</h1><p>下面通过实例来学习如何使用WeakHashMap</p>
<pre><code>import java.util.Iterator;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.Date;
import java.lang.ref.WeakReference;

/**
 * @desc WeakHashMap测试程序
 *
 * @author skywang
 * @email kuiwu-wang@163.com
 */
public class WeakHashMapTest {

    public static void main(String[] args) throws Exception {
        testWeakHashMapAPIs();
    }

    private static void testWeakHashMapAPIs() {
        // 初始化3个“弱键”
        String w1 = new String(&quot;one&quot;);
        String w2 = new String(&quot;two&quot;);
        String w3 = new String(&quot;three&quot;);
        // 新建WeakHashMap
        Map wmap = new WeakHashMap();

        // 添加键值对
        wmap.put(w1, &quot;w1&quot;);
        wmap.put(w2, &quot;w2&quot;);
        wmap.put(w3, &quot;w3&quot;);

        // 打印出wmap
        System.out.printf(&quot;\nwmap:%s\n&quot;,wmap );

        // containsKey(Object key) :是否包含键key
        System.out.printf(&quot;contains key two : %s\n&quot;,wmap.containsKey(&quot;two&quot;));
        System.out.printf(&quot;contains key five : %s\n&quot;,wmap.containsKey(&quot;five&quot;));

        // containsValue(Object value) :是否包含值value
        System.out.printf(&quot;contains value 0 : %s\n&quot;,wmap.containsValue(new Integer(0)));

        // remove(Object key) ： 删除键key对应的键值对
        wmap.remove(&quot;three&quot;);

        System.out.printf(&quot;wmap: %s\n&quot;,wmap );



        // ---- 测试 WeakHashMap 的自动回收特性 ----

        // 将w1设置null。
        // 这意味着“弱键”w1再没有被其它对象引用，调用gc时会回收WeakHashMap中与“w1”对应的键值对
        w1 = null;
        // 内存回收。这里，会回收WeakHashMap中与“w1”对应的键值对
        System.gc();

        // 遍历WeakHashMap
        Iterator iter = wmap.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry en = (Map.Entry)iter.next();
            System.out.printf(&quot;next : %s - %s\n&quot;,en.getKey(),en.getValue());
        }
        // 打印WeakHashMap的实际大小
        System.out.printf(&quot; after gc WeakHashMap size:%s\n&quot;, wmap.size());
    }
}</code></pre><p>运行结果： </p>
<pre><code>wmap:{three=w3, one=w1, two=w2}
contains key two : true
contains key five : false
contains value 0 : false
wmap: {one=w1, two=w2}
next : two - w2
after gc WeakHashMap size:1</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/12/java/collection/2012-02-12-collection-12-treemap/" itemprop="url">Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-12T01:01:00.000Z" itemprop="datePublished">2月 12 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 小时 read (About 21590 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>这一章，我们对TreeMap进行学习。<br>我们先对TreeMap有个整体认识，然后再学习它的源码，最后再通过实例来学会使用TreeMap。内容包括</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 TreeMap介绍</a><br><a href="#anchor2">第2部分 TreeMap数据结构</a><br><a href="#anchor3">第3部分 TreeMap源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 TreeMap遍历方式</a><br><a href="#anchor5">第5部分 TreeMap示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-TreeMap介绍"><a href="#第1部分-TreeMap介绍" class="headerlink" title="第1部分 TreeMap介绍"></a>第1部分 TreeMap介绍</h1><p><strong>TreeMap 简介</strong></p>
<p>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。<br>TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。<br>TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。<br>TreeMap 实现了Cloneable接口，意味着它能被克隆。<br>TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。</p>
<p>TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。<br>TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。<br>另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。</p>
<p><strong>TreeMap的构造函数</strong></p>
<pre><code>// 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。
TreeMap()

// 创建的TreeMap包含Map
TreeMap(Map&lt;? extends K, ? extends V&gt; copyFrom)

// 指定Tree的比较器
TreeMap(Comparator&lt;? super K&gt; comparator)

// 创建的TreeSet包含copyFrom
TreeMap(SortedMap&lt;K, ? extends V&gt; copyFrom)</code></pre><p><strong>TreeMap的API</strong></p>
<pre><code>Entry&lt;K, V&gt;                ceilingEntry(K key)
K                          ceilingKey(K key)
void                       clear()
Object                     clone()
Comparator&lt;? super K&gt;      comparator()
boolean                    containsKey(Object key)
NavigableSet&lt;K&gt;            descendingKeySet()
NavigableMap&lt;K, V&gt;         descendingMap()
Set&lt;Entry&lt;K, V&gt;&gt;           entrySet()
Entry&lt;K, V&gt;                firstEntry()
K                          firstKey()
Entry&lt;K, V&gt;                floorEntry(K key)
K                          floorKey(K key)
V                          get(Object key)
NavigableMap&lt;K, V&gt;         headMap(K to, boolean inclusive)
SortedMap&lt;K, V&gt;            headMap(K toExclusive)
Entry&lt;K, V&gt;                higherEntry(K key)
K                          higherKey(K key)
boolean                    isEmpty()
Set&lt;K&gt;                     keySet()
Entry&lt;K, V&gt;                lastEntry()
K                          lastKey()
Entry&lt;K, V&gt;                lowerEntry(K key)
K                          lowerKey(K key)
NavigableSet&lt;K&gt;            navigableKeySet()
Entry&lt;K, V&gt;                pollFirstEntry()
Entry&lt;K, V&gt;                pollLastEntry()
V                          put(K key, V value)
V                          remove(Object key)
int                        size()
SortedMap&lt;K, V&gt;            subMap(K fromInclusive, K toExclusive)
NavigableMap&lt;K, V&gt;         subMap(K from, boolean fromInclusive, K to, boolean toInclusive)
NavigableMap&lt;K, V&gt;         tailMap(K from, boolean inclusive)
SortedMap&lt;K, V&gt;            tailMap(K fromInclusive)</code></pre><p><a name="anchor2"></a></p>
<h1 id="第2部分-TreeMap数据结构"><a href="#第2部分-TreeMap数据结构" class="headerlink" title="第2部分 TreeMap数据结构"></a>第2部分 TreeMap数据结构</h1><p>TreeMap的继承关系</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractMap&lt;K, V&gt;
         ↳     java.util.TreeMap&lt;K, V&gt;</code></pre><p>TreeMap的声明</p>
<pre><code>public class TreeMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable {}</code></pre><p>TreeMap与Map关系如下图：</p>
<p><img src="/media/pic/java/collection/collection12.jpg" alt="img"></p>
<p>从图中可以看出：<br>(01) TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。<br>(02) TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。<br>&nbsp;&nbsp;root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。<br>&nbsp;&nbsp;红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。<br>&nbsp;&nbsp;size是红黑数中节点的个数。</p>
<p>关于红黑数的具体算法，请参考”[红黑树(一) 原理和算法详细介绍][link_rdtree_introduce]”。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-TreeMap源码解析-基于JDK1-6-0-45"><a href="#第3部分-TreeMap源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 TreeMap源码解析(基于JDK1.6.0_45)"></a>第3部分 TreeMap源码解析(基于JDK1.6.0_45)</h1><p>为了更了解TreeMap的原理，下面对TreeMap源码代码作出分析。我们先给出源码内容，后面再对源码进行详细说明，当然，源码内容中也包含了详细的代码注释。读者阅读的时候，建议先看后面的说明，先建立一个整体印象；之后再阅读源码。</p>
<pre><code>package java.util;

public class TreeMap&lt;K,V&gt;
extends AbstractMap&lt;K,V&gt;
implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable
{

    // 比较器。用来给TreeMap排序
    private final Comparator&lt;? super K&gt; comparator;

    // TreeMap是红黑树实现的，root是红黑书的根节点
    private transient Entry&lt;K,V&gt; root = null;

    // 红黑树的节点总数
    private transient int size = 0;

    // 记录红黑树的修改次数
    private transient int modCount = 0;

    // 默认构造函数
    public TreeMap() {
        comparator = null;
    }

    // 带比较器的构造函数
    public TreeMap(Comparator&lt;? super K&gt; comparator) {
        this.comparator = comparator;
    }

    // 带Map的构造函数，Map会成为TreeMap的子集
    public TreeMap(Map&lt;? extends K, ? extends V&gt; m) {
        comparator = null;
        putAll(m);
    }

    // 带SortedMap的构造函数，SortedMap会成为TreeMap的子集
    public TreeMap(SortedMap&lt;K, ? extends V&gt; m) {
        comparator = m.comparator();
        try {
            buildFromSorted(m.size(), m.entrySet().iterator(), null, null);
        } catch (java.io.IOException cannotHappen) {
        } catch (ClassNotFoundException cannotHappen) {
        }
    }

    public int size() {
        return size;
    }

    // 返回TreeMap中是否保护“键(key)”
    public boolean containsKey(Object key) {
        return getEntry(key) != null;
    }

    // 返回TreeMap中是否保护&quot;值(value)&quot;
    public boolean containsValue(Object value) {
        // getFirstEntry() 是返回红黑树的第一个节点
        // successor(e) 是获取节点e的后继节点
        for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e))
            if (valEquals(value, e.value))
                return true;
        return false;
    }

    // 获取“键(key)”对应的“值(value)”
    public V get(Object key) {
        // 获取“键”为key的节点(p)
        Entry&lt;K,V&gt; p = getEntry(key);
        // 若节点(p)为null，返回null；否则，返回节点对应的值
        return (p==null ? null : p.value);
    }

    public Comparator&lt;? super K&gt; comparator() {
        return comparator;
    }

    // 获取第一个节点对应的key
    public K firstKey() {
        return key(getFirstEntry());
    }

    // 获取最后一个节点对应的key
    public K lastKey() {
        return key(getLastEntry());
    }

    // 将map中的全部节点添加到TreeMap中
    public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
        // 获取map的大小
        int mapSize = map.size();
        // 如果TreeMap的大小是0,且map的大小不是0,且map是已排序的“key-value对”
        if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) {
            Comparator c = ((SortedMap)map).comparator();
            // 如果TreeMap和map的比较器相等；
            // 则将map的元素全部拷贝到TreeMap中，然后返回！
            if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) {
                ++modCount;
                try {
                    buildFromSorted(mapSize, map.entrySet().iterator(),
                                null, null);
                } catch (java.io.IOException cannotHappen) {
                } catch (ClassNotFoundException cannotHappen) {
                }
                return;
            }
        }
        // 调用AbstractMap中的putAll();
        // AbstractMap中的putAll()又会调用到TreeMap的put()
        super.putAll(map);
    }

    // 获取TreeMap中“键”为key的节点
    final Entry&lt;K,V&gt; getEntry(Object key) {
        // 若“比较器”为null，则通过getEntryUsingComparator()获取“键”为key的节点
        if (comparator != null)
            return getEntryUsingComparator(key);
        if (key == null)
            throw new NullPointerException();
        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
        // 将p设为根节点
        Entry&lt;K,V&gt; p = root;
        while (p != null) {
            int cmp = k.compareTo(p.key);
            // 若“p的key” &lt; key，则p=“p的左孩子”
            if (cmp &lt; 0)
                p = p.left;
            // 若“p的key” &gt; key，则p=“p的左孩子”
            else if (cmp &gt; 0)
                p = p.right;
            // 若“p的key” = key，则返回节点p
            else
                return p;
        }
        return null;
    }

    // 获取TreeMap中“键”为key的节点(对应TreeMap的比较器不是null的情况)
    final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) {
        K k = (K) key;
        Comparator&lt;? super K&gt; cpr = comparator;
        if (cpr != null) {
            // 将p设为根节点
            Entry&lt;K,V&gt; p = root;
            while (p != null) {
                int cmp = cpr.compare(k, p.key);
                // 若“p的key” &lt; key，则p=“p的左孩子”
                if (cmp &lt; 0)
                    p = p.left;
                // 若“p的key” &gt; key，则p=“p的左孩子”
                else if (cmp &gt; 0)
                    p = p.right;
                // 若“p的key” = key，则返回节点p
                else
                    return p;
            }
        }
        return null;
    }

    // 获取TreeMap中不小于key的最小的节点；
    // 若不存在(即TreeMap中所有节点的键都比key大)，就返回null
    final Entry&lt;K,V&gt; getCeilingEntry(K key) {
        Entry&lt;K,V&gt; p = root;
        while (p != null) {
            int cmp = compare(key, p.key);
            // 情况一：若“p的key” &gt; key。
            // 若 p 存在左孩子，则设 p=“p的左孩子”；
            // 否则，返回p
            if (cmp &lt; 0) {
                if (p.left != null)
                    p = p.left;
                else
                    return p;
            // 情况二：若“p的key” &lt; key。
            } else if (cmp &gt; 0) {
                // 若 p 存在右孩子，则设 p=“p的右孩子”
                if (p.right != null) {
                    p = p.right;
                } else {
                    // 若 p 不存在右孩子，则找出 p 的后继节点，并返回
                    // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。
                    //   理解这一点的核心是，getCeilingEntry是从root开始遍历的。
                    //   若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。
                    //   能理解上面所说的，那么就很容易明白，为什么“p的后继节点”又2种可能性了。
                    Entry&lt;K,V&gt; parent = p.parent;
                    Entry&lt;K,V&gt; ch = p;
                    while (parent != null &amp;&amp; ch == parent.right) {
                        ch = parent;
                        parent = parent.parent;
                    }
                    return parent;
                }
            // 情况三：若“p的key” = key。
            } else
                return p;
        }
        return null;
    }

    // 获取TreeMap中不大于key的最大的节点；
    // 若不存在(即TreeMap中所有节点的键都比key小)，就返回null
    // getFloorEntry的原理和getCeilingEntry类似，这里不再多说。
    final Entry&lt;K,V&gt; getFloorEntry(K key) {
        Entry&lt;K,V&gt; p = root;
        while (p != null) {
            int cmp = compare(key, p.key);
            if (cmp &gt; 0) {
                if (p.right != null)
                    p = p.right;
                else
                    return p;
            } else if (cmp &lt; 0) {
                if (p.left != null) {
                    p = p.left;
                } else {
                    Entry&lt;K,V&gt; parent = p.parent;
                    Entry&lt;K,V&gt; ch = p;
                    while (parent != null &amp;&amp; ch == parent.left) {
                        ch = parent;
                        parent = parent.parent;
                    }
                    return parent;
                }
            } else
                return p;

        }
        return null;
    }

    // 获取TreeMap中大于key的最小的节点。
    // 若不存在，就返回null。
    //   请参照getCeilingEntry来对getHigherEntry进行理解。
    final Entry&lt;K,V&gt; getHigherEntry(K key) {
        Entry&lt;K,V&gt; p = root;
        while (p != null) {
            int cmp = compare(key, p.key);
            if (cmp &lt; 0) {
                if (p.left != null)
                    p = p.left;
                else
                    return p;
            } else {
                if (p.right != null) {
                    p = p.right;
                } else {
                    Entry&lt;K,V&gt; parent = p.parent;
                    Entry&lt;K,V&gt; ch = p;
                    while (parent != null &amp;&amp; ch == parent.right) {
                        ch = parent;
                        parent = parent.parent;
                    }
                    return parent;
                }
            }
        }
        return null;
    }

    // 获取TreeMap中小于key的最大的节点。
    // 若不存在，就返回null。
    //   请参照getCeilingEntry来对getLowerEntry进行理解。
    final Entry&lt;K,V&gt; getLowerEntry(K key) {
        Entry&lt;K,V&gt; p = root;
        while (p != null) {
            int cmp = compare(key, p.key);
            if (cmp &gt; 0) {
                if (p.right != null)
                    p = p.right;
                else
                    return p;
            } else {
                if (p.left != null) {
                    p = p.left;
                } else {
                    Entry&lt;K,V&gt; parent = p.parent;
                    Entry&lt;K,V&gt; ch = p;
                    while (parent != null &amp;&amp; ch == parent.left) {
                        ch = parent;
                        parent = parent.parent;
                    }
                    return parent;
                }
            }
        }
        return null;
    }

    // 将“key, value”添加到TreeMap中
    // 理解TreeMap的前提是掌握“红黑树”。
    // 若理解“红黑树中添加节点”的算法，则很容易理解put。
    public V put(K key, V value) {
        Entry&lt;K,V&gt; t = root;
        // 若红黑树为空，则插入根节点
        if (t == null) {
        // TBD:
        // 5045147: (coll) Adding null to an empty TreeSet should
        // throw NullPointerException
        //
        // compare(key, key); // type check
            root = new Entry&lt;K,V&gt;(key, value, null);
            size = 1;
            modCount++;
            return null;
        }
        int cmp;
        Entry&lt;K,V&gt; parent;
        // split comparator and comparable paths
        Comparator&lt;? super K&gt; cpr = comparator;
        // 在二叉树(红黑树是特殊的二叉树)中，找到(key, value)的插入位置。
        // 红黑树是以key来进行排序的，所以这里以key来进行查找。
        if (cpr != null) {
            do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp &lt; 0)
                    t = t.left;
                else if (cmp &gt; 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
        else {
            if (key == null)
                throw new NullPointerException();
            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
            do {
                parent = t;
                cmp = k.compareTo(t.key);
                if (cmp &lt; 0)
                    t = t.left;
                else if (cmp &gt; 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
        // 新建红黑树的节点(e)
        Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent);
        if (cmp &lt; 0)
            parent.left = e;
        else
            parent.right = e;
        // 红黑树插入节点后，不再是一颗红黑树；
        // 这里通过fixAfterInsertion的处理，来恢复红黑树的特性。
        fixAfterInsertion(e);
        size++;
        modCount++;
        return null;
    }

    // 删除TreeMap中的键为key的节点，并返回节点的值
    public V remove(Object key) {
        // 找到键为key的节点
        Entry&lt;K,V&gt; p = getEntry(key);
        if (p == null)
            return null;

        // 保存节点的值
        V oldValue = p.value;
        // 删除节点
        deleteEntry(p);
        return oldValue;
    }

    // 清空红黑树
    public void clear() {
        modCount++;
        size = 0;
        root = null;
    }

    // 克隆一个TreeMap，并返回Object对象
    public Object clone() {
        TreeMap&lt;K,V&gt; clone = null;
        try {
            clone = (TreeMap&lt;K,V&gt;) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError();
        }

        // Put clone into &quot;virgin&quot; state (except for comparator)
        clone.root = null;
        clone.size = 0;
        clone.modCount = 0;
        clone.entrySet = null;
        clone.navigableKeySet = null;
        clone.descendingMap = null;

        // Initialize clone with our mappings
        try {
            clone.buildFromSorted(size, entrySet().iterator(), null, null);
        } catch (java.io.IOException cannotHappen) {
        } catch (ClassNotFoundException cannotHappen) {
        }

        return clone;
    }

    // 获取第一个节点(对外接口)。
    public Map.Entry&lt;K,V&gt; firstEntry() {
        return exportEntry(getFirstEntry());
    }

    // 获取最后一个节点(对外接口)。
    public Map.Entry&lt;K,V&gt; lastEntry() {
        return exportEntry(getLastEntry());
    }

    // 获取第一个节点，并将改节点从TreeMap中删除。
    public Map.Entry&lt;K,V&gt; pollFirstEntry() {
        // 获取第一个节点
        Entry&lt;K,V&gt; p = getFirstEntry();
        Map.Entry&lt;K,V&gt; result = exportEntry(p);
        // 删除第一个节点
        if (p != null)
            deleteEntry(p);
        return result;
    }

    // 获取最后一个节点，并将改节点从TreeMap中删除。
    public Map.Entry&lt;K,V&gt; pollLastEntry() {
        // 获取最后一个节点
        Entry&lt;K,V&gt; p = getLastEntry();
        Map.Entry&lt;K,V&gt; result = exportEntry(p);
        // 删除最后一个节点
        if (p != null)
            deleteEntry(p);
        return result;
    }

    // 返回小于key的最大的键值对，没有的话返回null
    public Map.Entry&lt;K,V&gt; lowerEntry(K key) {
        return exportEntry(getLowerEntry(key));
    }

    // 返回小于key的最大的键值对所对应的KEY，没有的话返回null
    public K lowerKey(K key) {
        return keyOrNull(getLowerEntry(key));
    }

    // 返回不大于key的最大的键值对，没有的话返回null
    public Map.Entry&lt;K,V&gt; floorEntry(K key) {
        return exportEntry(getFloorEntry(key));
    }

    // 返回不大于key的最大的键值对所对应的KEY，没有的话返回null
    public K floorKey(K key) {
        return keyOrNull(getFloorEntry(key));
    }

    // 返回不小于key的最小的键值对，没有的话返回null
    public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
        return exportEntry(getCeilingEntry(key));
    }

    // 返回不小于key的最小的键值对所对应的KEY，没有的话返回null
    public K ceilingKey(K key) {
        return keyOrNull(getCeilingEntry(key));
    }

    // 返回大于key的最小的键值对，没有的话返回null
    public Map.Entry&lt;K,V&gt; higherEntry(K key) {
        return exportEntry(getHigherEntry(key));
    }

    // 返回大于key的最小的键值对所对应的KEY，没有的话返回null
    public K higherKey(K key) {
        return keyOrNull(getHigherEntry(key));
    }

    // TreeMap的红黑树节点对应的集合
    private transient EntrySet entrySet = null;
    // KeySet为KeySet导航类
    private transient KeySet&lt;K&gt; navigableKeySet = null;
    // descendingMap为键值对的倒序“映射”
    private transient NavigableMap&lt;K,V&gt; descendingMap = null;

    // 返回TreeMap的“键的集合”
    public Set&lt;K&gt; keySet() {
        return navigableKeySet();
    }

    // 获取“可导航”的Key的集合
    // 实际上是返回KeySet类的对象。
    public NavigableSet&lt;K&gt; navigableKeySet() {
        KeySet&lt;K&gt; nks = navigableKeySet;
        return (nks != null) ? nks : (navigableKeySet = new KeySet(this));
    }

    // 返回“TreeMap的值对应的集合”
    public Collection&lt;V&gt; values() {
        Collection&lt;V&gt; vs = values;
        return (vs != null) ? vs : (values = new Values());
    }

    // 获取TreeMap的Entry的集合，实际上是返回EntrySet类的对象。
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        EntrySet es = entrySet;
        return (es != null) ? es : (entrySet = new EntrySet());
    }

    // 获取TreeMap的降序Map
    // 实际上是返回DescendingSubMap类的对象
    public NavigableMap&lt;K, V&gt; descendingMap() {
        NavigableMap&lt;K, V&gt; km = descendingMap;
        return (km != null) ? km :
            (descendingMap = new DescendingSubMap(this,
                                                  true, null, true,
                                                  true, null, true));
    }

    // 获取TreeMap的子Map
    // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记
    public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                                    K toKey,   boolean toInclusive) {
        return new AscendingSubMap(this,
                                   false, fromKey, fromInclusive,
                                   false, toKey,   toInclusive);
    }

    // 获取“Map的头部”
    // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记
    public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
        return new AscendingSubMap(this,
                                   true,  null,  true,
                                   false, toKey, inclusive);
    }

    // 获取“Map的尾部”。
    // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记
    public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
        return new AscendingSubMap(this,
                                   false, fromKey, inclusive,
                                   true,  null,    true);
    }

    // 获取“子Map”。
    // 范围是从fromKey(包括) 到 toKey(不包括)
    public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
        return subMap(fromKey, true, toKey, false);
    }

    // 获取“Map的头部”。
    // 范围从第一个节点 到 toKey(不包括)
    public SortedMap&lt;K,V&gt; headMap(K toKey) {
        return headMap(toKey, false);
    }

    // 获取“Map的尾部”。
    // 范围是从 fromKey(包括) 到 最后一个节点
    public SortedMap&lt;K,V&gt; tailMap(K fromKey) {
        return tailMap(fromKey, true);
    }

    // ”TreeMap的值的集合“对应的类，它集成于AbstractCollection
    class Values extends AbstractCollection&lt;V&gt; {
        // 返回迭代器
        public Iterator&lt;V&gt; iterator() {
            return new ValueIterator(getFirstEntry());
        }

        // 返回个数
        public int size() {
            return TreeMap.this.size();
        }

        // &quot;TreeMap的值的集合&quot;中是否包含&quot;对象o&quot;
        public boolean contains(Object o) {
            return TreeMap.this.containsValue(o);
        }

        // 删除&quot;TreeMap的值的集合&quot;中的&quot;对象o&quot;
        public boolean remove(Object o) {
            for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) {
                if (valEquals(e.getValue(), o)) {
                    deleteEntry(e);
                    return true;
                }
            }
            return false;
        }

        // 清空删除&quot;TreeMap的值的集合&quot;
        public void clear() {
            TreeMap.this.clear();
        }
    }

    // EntrySet是“TreeMap的所有键值对组成的集合”，
    // EntrySet集合的单位是单个“键值对”。
    class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
            return new EntryIterator(getFirstEntry());
        }

        // EntrySet中是否包含“键值对Object”
        public boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
            V value = entry.getValue();
            Entry&lt;K,V&gt; p = getEntry(entry.getKey());
            return p != null &amp;&amp; valEquals(p.getValue(), value);
        }

        // 删除EntrySet中的“键值对Object”
        public boolean remove(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
            V value = entry.getValue();
            Entry&lt;K,V&gt; p = getEntry(entry.getKey());
            if (p != null &amp;&amp; valEquals(p.getValue(), value)) {
                deleteEntry(p);
                return true;
            }
            return false;
        }

        // 返回EntrySet中元素个数
        public int size() {
            return TreeMap.this.size();
        }

        // 清空EntrySet
        public void clear() {
            TreeMap.this.clear();
        }
    }

    // 返回“TreeMap的KEY组成的迭代器(顺序)”
    Iterator&lt;K&gt; keyIterator() {
        return new KeyIterator(getFirstEntry());
    }

    // 返回“TreeMap的KEY组成的迭代器(逆序)”
    Iterator&lt;K&gt; descendingKeyIterator() {
        return new DescendingKeyIterator(getLastEntry());
    }

    // KeySet是“TreeMap中所有的KEY组成的集合”
    // KeySet继承于AbstractSet，而且实现了NavigableSet接口。
    static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; {
        // NavigableMap成员，KeySet是通过NavigableMap实现的
        private final NavigableMap&lt;E, Object&gt; m;
        KeySet(NavigableMap&lt;E,Object&gt; map) { m = map; }

        // 升序迭代器
        public Iterator&lt;E&gt; iterator() {
            // 若是TreeMap对象，则调用TreeMap的迭代器keyIterator()
            // 否则，调用TreeMap子类NavigableSubMap的迭代器keyIterator()
            if (m instanceof TreeMap)
                return ((TreeMap&lt;E,Object&gt;)m).keyIterator();
            else
                return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).keyIterator());
        }

        // 降序迭代器
        public Iterator&lt;E&gt; descendingIterator() {
            // 若是TreeMap对象，则调用TreeMap的迭代器descendingKeyIterator()
            // 否则，调用TreeMap子类NavigableSubMap的迭代器descendingKeyIterator()
            if (m instanceof TreeMap)
                return ((TreeMap&lt;E,Object&gt;)m).descendingKeyIterator();
            else
                return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).descendingKeyIterator());
        }

        public int size() { return m.size(); }
        public boolean isEmpty() { return m.isEmpty(); }
        public boolean contains(Object o) { return m.containsKey(o); }
        public void clear() { m.clear(); }
        public E lower(E e) { return m.lowerKey(e); }
        public E floor(E e) { return m.floorKey(e); }
        public E ceiling(E e) { return m.ceilingKey(e); }
        public E higher(E e) { return m.higherKey(e); }
        public E first() { return m.firstKey(); }
        public E last() { return m.lastKey(); }
        public Comparator&lt;? super E&gt; comparator() { return m.comparator(); }
        public E pollFirst() {
            Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry();
            return e == null? null : e.getKey();
        }
        public E pollLast() {
            Map.Entry&lt;E,Object&gt; e = m.pollLastEntry();
            return e == null? null : e.getKey();
        }
        public boolean remove(Object o) {
            int oldSize = size();
            m.remove(o);
            return size() != oldSize;
        }
        public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,
                                      E toElement,   boolean toInclusive) {
            return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive,
                                           toElement,   toInclusive));
        }
        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
            return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive));
        }
        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
            return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive));
        }
        public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
            return subSet(fromElement, true, toElement, false);
        }
        public SortedSet&lt;E&gt; headSet(E toElement) {
            return headSet(toElement, false);
        }
        public SortedSet&lt;E&gt; tailSet(E fromElement) {
            return tailSet(fromElement, true);
        }
        public NavigableSet&lt;E&gt; descendingSet() {
            return new TreeSet(m.descendingMap());
        }
    }

    // 它是TreeMap中的一个抽象迭代器，实现了一些通用的接口。
    abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; {
        // 下一个元素
        Entry&lt;K,V&gt; next;
        // 上一次返回元素
        Entry&lt;K,V&gt; lastReturned;
        // 期望的修改次数，用于实现fast-fail机制
        int expectedModCount;

        PrivateEntryIterator(Entry&lt;K,V&gt; first) {
            expectedModCount = modCount;
            lastReturned = null;
            next = first;
        }

        public final boolean hasNext() {
            return next != null;
        }

        // 获取下一个节点
        final Entry&lt;K,V&gt; nextEntry() {
            Entry&lt;K,V&gt; e = next;
            if (e == null)
                throw new NoSuchElementException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            next = successor(e);
            lastReturned = e;
            return e;
        }

        // 获取上一个节点
        final Entry&lt;K,V&gt; prevEntry() {
            Entry&lt;K,V&gt; e = next;
            if (e == null)
                throw new NoSuchElementException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            next = predecessor(e);
            lastReturned = e;
            return e;
        }

        // 删除当前节点
        public void remove() {
            if (lastReturned == null)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。
            // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。
            //     根据“红黑树”的特性可知：
            //     当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。
            //     这意味着“当被删除节点有两个儿子时，删除当前节点之后，&apos;新的当前节点&apos;实际上是‘原有的后继节点(即下一个节点)’”。
            //     而此时next仍然指向&quot;新的当前节点&quot;。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。
            if (lastReturned.left != null &amp;&amp; lastReturned.right != null)
                next = lastReturned;
            deleteEntry(lastReturned);
            expectedModCount = modCount;
            lastReturned = null;
        }
    }

    // TreeMap的Entry对应的迭代器
    final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        EntryIterator(Entry&lt;K,V&gt; first) {
            super(first);
        }
        public Map.Entry&lt;K,V&gt; next() {
            return nextEntry();
        }
    }

    // TreeMap的Value对应的迭代器
    final class ValueIterator extends PrivateEntryIterator&lt;V&gt; {
        ValueIterator(Entry&lt;K,V&gt; first) {
            super(first);
        }
        public V next() {
            return nextEntry().value;
        }
    }

    // reeMap的KEY组成的迭代器(顺序)
    final class KeyIterator extends PrivateEntryIterator&lt;K&gt; {
        KeyIterator(Entry&lt;K,V&gt; first) {
            super(first);
        }
        public K next() {
            return nextEntry().key;
        }
    }

    // TreeMap的KEY组成的迭代器(逆序)
    final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; {
        DescendingKeyIterator(Entry&lt;K,V&gt; first) {
            super(first);
        }
        public K next() {
            return prevEntry().key;
        }
    }

    // 比较两个对象的大小
    final int compare(Object k1, Object k2) {
        return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)
            : comparator.compare((K)k1, (K)k2);
    }

    // 判断两个对象是否相等
    final static boolean valEquals(Object o1, Object o2) {
        return (o1==null ? o2==null : o1.equals(o2));
    }

    // 返回“Key-Value键值对”的一个简单拷贝(AbstractMap.SimpleImmutableEntry&lt;K,V&gt;对象)
    // 可用来读取“键值对”的值
    static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) {
        return e == null? null :
            new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e);
    }

    // 若“键值对”不为null，则返回KEY；否则，返回null
    static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) {
        return e == null? null : e.key;
    }

    // 若“键值对”不为null，则返回KEY；否则，抛出异常
    static &lt;K&gt; K key(Entry&lt;K,?&gt; e) {
        if (e==null)
            throw new NoSuchElementException();
        return e.key;
    }

    // TreeMap的SubMap，它一个抽象类，实现了公共操作。
    // 它包括了&quot;(升序)AscendingSubMap&quot;和&quot;(降序)DescendingSubMap&quot;两个子类。
    static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
        implements NavigableMap&lt;K,V&gt;, java.io.Serializable {
        // TreeMap的拷贝
        final TreeMap&lt;K,V&gt; m;
        // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”；
        // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记”
        // fromStart是“表示是否从第一个节点开始计算”，
        // toEnd是“表示是否计算到最后一个节点      ”
        final K lo, hi;      
        final boolean fromStart, toEnd;
        final boolean loInclusive, hiInclusive;

        // 构造函数
        NavigableSubMap(TreeMap&lt;K,V&gt; m,
                        boolean fromStart, K lo, boolean loInclusive,
                        boolean toEnd,     K hi, boolean hiInclusive) {
            if (!fromStart &amp;&amp; !toEnd) {
                if (m.compare(lo, hi) &gt; 0)
                    throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;);
            } else {
                if (!fromStart) // type check
                    m.compare(lo, lo);
                if (!toEnd)
                    m.compare(hi, hi);
            }

            this.m = m;
            this.fromStart = fromStart;
            this.lo = lo;
            this.loInclusive = loInclusive;
            this.toEnd = toEnd;
            this.hi = hi;
            this.hiInclusive = hiInclusive;
        }

        // 判断key是否太小
        final boolean tooLow(Object key) {
            // 若该SubMap不包括“起始节点”，
            // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内”
            // 则判断key太小。其余情况都不是太小！
            if (!fromStart) {
                int c = m.compare(key, lo);
                if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive))
                    return true;
            }
            return false;
        }

        // 判断key是否太大
        final boolean tooHigh(Object key) {
            // 若该SubMap不包括“结束节点”，
            // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内”
            // 则判断key太大。其余情况都不是太大！
            if (!toEnd) {
                int c = m.compare(key, hi);
                if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive))
                    return true;
            }
            return false;
        }

        // 判断key是否在“lo和hi”开区间范围内
        final boolean inRange(Object key) {
            return !tooLow(key) &amp;&amp; !tooHigh(key);
        }

        // 判断key是否在封闭区间内
        final boolean inClosedRange(Object key) {
            return (fromStart || m.compare(key, lo) &gt;= 0)
                &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0);
        }

        // 判断key是否在区间内, inclusive是区间开关标志
        final boolean inRange(Object key, boolean inclusive) {
            return inclusive ? inRange(key) : inClosedRange(key);
        }

        // 返回最低的Entry
        final TreeMap.Entry&lt;K,V&gt; absLowest() {
        // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点
        // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry;
        //           否则，调用getHigherEntry(lo)获取大于lo的最小Entry
        TreeMap.Entry&lt;K,V&gt; e =
                (fromStart ?  m.getFirstEntry() :
                 (loInclusive ? m.getCeilingEntry(lo) :
                                m.getHigherEntry(lo)));
            return (e == null || tooHigh(e.key)) ? null : e;
        }

        // 返回最高的Entry
        final TreeMap.Entry&lt;K,V&gt; absHighest() {
        // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点
        // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry;
        //           否则，调用getLowerEntry(hi)获取大于hi的最大Entry
        TreeMap.Entry&lt;K,V&gt; e =
        TreeMap.Entry&lt;K,V&gt; e =
                (toEnd ?  m.getLastEntry() :
                 (hiInclusive ?  m.getFloorEntry(hi) :
                                 m.getLowerEntry(hi)));
            return (e == null || tooLow(e.key)) ? null : e;
        }

        // 返回&quot;大于/等于key的最小的Entry&quot;
        final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) {
            // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry”
            // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！
            if (tooLow(key))
                return absLowest();
            // 获取“大于/等于key的最小Entry”
        TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key);
            return (e == null || tooHigh(e.key)) ? null : e;
        }

        // 返回&quot;大于key的最小的Entry&quot;
        final TreeMap.Entry&lt;K,V&gt; absHigher(K key) {
            // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry”
            // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！
            if (tooLow(key))
                return absLowest();
            // 获取“大于key的最小Entry”
        TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key);
            return (e == null || tooHigh(e.key)) ? null : e;
        }

        // 返回&quot;小于/等于key的最大的Entry&quot;
        final TreeMap.Entry&lt;K,V&gt; absFloor(K key) {
            // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry”
            // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！
            if (tooHigh(key))
                return absHighest();
        // 获取&quot;小于/等于key的最大的Entry&quot;
        TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key);
            return (e == null || tooLow(e.key)) ? null : e;
        }

        // 返回&quot;小于key的最大的Entry&quot;
        final TreeMap.Entry&lt;K,V&gt; absLower(K key) {
            // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry”
            // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！
            if (tooHigh(key))
                return absHighest();
        // 获取&quot;小于key的最大的Entry&quot;
        TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key);
            return (e == null || tooLow(e.key)) ? null : e;
        }

        // 返回“大于最大节点中的最小节点”，不存在的话，返回null
        final TreeMap.Entry&lt;K,V&gt; absHighFence() {
            return (toEnd ? null : (hiInclusive ?
                                    m.getHigherEntry(hi) :
                                    m.getCeilingEntry(hi)));
        }

        // 返回“小于最小节点中的最大节点”，不存在的话，返回null
        final TreeMap.Entry&lt;K,V&gt; absLowFence() {
            return (fromStart ? null : (loInclusive ?
                                        m.getLowerEntry(lo) :
                                        m.getFloorEntry(lo)));
        }

        // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法
        abstract TreeMap.Entry&lt;K,V&gt; subLowest();
        abstract TreeMap.Entry&lt;K,V&gt; subHighest();
        abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key);
        abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key);
        abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key);
        abstract TreeMap.Entry&lt;K,V&gt; subLower(K key);
        // 返回“顺序”的键迭代器
        abstract Iterator&lt;K&gt; keyIterator();
        // 返回“逆序”的键迭代器
        abstract Iterator&lt;K&gt; descendingKeyIterator();

        // 返回SubMap是否为空。空的话，返回true，否则返回false
        public boolean isEmpty() {
            return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty();
        }

        // 返回SubMap的大小
        public int size() {
            return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size();
        }

        // 返回SubMap是否包含键key
        public final boolean containsKey(Object key) {
            return inRange(key) &amp;&amp; m.containsKey(key);
        }

        // 将key-value 插入SubMap中
        public final V put(K key, V value) {
            if (!inRange(key))
                throw new IllegalArgumentException(&quot;key out of range&quot;);
            return m.put(key, value);
        }

        // 获取key对应值
        public final V get(Object key) {
            return !inRange(key)? null :  m.get(key);
        }

        // 删除key对应的键值对
        public final V remove(Object key) {
            return !inRange(key)? null  : m.remove(key);
        }

        // 获取“大于/等于key的最小键值对”
        public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
            return exportEntry(subCeiling(key));
        }

        // 获取“大于/等于key的最小键”
        public final K ceilingKey(K key) {
            return keyOrNull(subCeiling(key));
        }

        // 获取“大于key的最小键值对”
        public final Map.Entry&lt;K,V&gt; higherEntry(K key) {
            return exportEntry(subHigher(key));
        }

        // 获取“大于key的最小键”
        public final K higherKey(K key) {
            return keyOrNull(subHigher(key));
        }

        // 获取“小于/等于key的最大键值对”
        public final Map.Entry&lt;K,V&gt; floorEntry(K key) {
            return exportEntry(subFloor(key));
        }

        // 获取“小于/等于key的最大键”
        public final K floorKey(K key) {
            return keyOrNull(subFloor(key));
        }

        // 获取“小于key的最大键值对”
        public final Map.Entry&lt;K,V&gt; lowerEntry(K key) {
            return exportEntry(subLower(key));
        }

        // 获取“小于key的最大键”
        public final K lowerKey(K key) {
            return keyOrNull(subLower(key));
        }

        // 获取&quot;SubMap的第一个键&quot;
        public final K firstKey() {
            return key(subLowest());
        }

        // 获取&quot;SubMap的最后一个键&quot;
        public final K lastKey() {
            return key(subHighest());
        }

        // 获取&quot;SubMap的第一个键值对&quot;
        public final Map.Entry&lt;K,V&gt; firstEntry() {
            return exportEntry(subLowest());
        }

        // 获取&quot;SubMap的最后一个键值对&quot;
        public final Map.Entry&lt;K,V&gt; lastEntry() {
            return exportEntry(subHighest());
        }

        // 返回&quot;SubMap的第一个键值对&quot;，并从SubMap中删除改键值对
        public final Map.Entry&lt;K,V&gt; pollFirstEntry() {
        TreeMap.Entry&lt;K,V&gt; e = subLowest();
            Map.Entry&lt;K,V&gt; result = exportEntry(e);
            if (e != null)
                m.deleteEntry(e);
            return result;
        }

        // 返回&quot;SubMap的最后一个键值对&quot;，并从SubMap中删除改键值对
        public final Map.Entry&lt;K,V&gt; pollLastEntry() {
        TreeMap.Entry&lt;K,V&gt; e = subHighest();
            Map.Entry&lt;K,V&gt; result = exportEntry(e);
            if (e != null)
                m.deleteEntry(e);
            return result;
        }

        // Views
        transient NavigableMap&lt;K,V&gt; descendingMapView = null;
        transient EntrySetView entrySetView = null;
        transient KeySet&lt;K&gt; navigableKeySetView = null;

        // 返回NavigableSet对象，实际上返回的是当前对象的&quot;Key集合&quot;。 
        public final NavigableSet&lt;K&gt; navigableKeySet() {
            KeySet&lt;K&gt; nksv = navigableKeySetView;
            return (nksv != null) ? nksv :
                (navigableKeySetView = new TreeMap.KeySet(this));
        }

        // 返回&quot;Key集合&quot;对象
        public final Set&lt;K&gt; keySet() {
            return navigableKeySet();
        }

        // 返回“逆序”的Key集合
        public NavigableSet&lt;K&gt; descendingKeySet() {
            return descendingMap().navigableKeySet();
        }

        // 排列fromKey(包含) 到 toKey(不包含) 的子map
        public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
            return subMap(fromKey, true, toKey, false);
        }

        // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey)
        public final SortedMap&lt;K,V&gt; headMap(K toKey) {
            return headMap(toKey, false);
        }

        // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点]
        public final SortedMap&lt;K,V&gt; tailMap(K fromKey) {
            return tailMap(fromKey, true);
        }

        // Map的Entry的集合
        abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
            private transient int size = -1, sizeModCount;

            // 获取EntrySet的大小
            public int size() {
                // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小
                if (fromStart &amp;&amp; toEnd)
                    return m.size();
                // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素
                if (size == -1 || sizeModCount != m.modCount) {
                    sizeModCount = m.modCount;
                    size = 0;
                    Iterator i = iterator();
                    while (i.hasNext()) {
                        size++;
                        i.next();
                    }
                }
                return size;
            }

            // 判断EntrySetView是否为空
            public boolean isEmpty() {
                TreeMap.Entry&lt;K,V&gt; n = absLowest();
                return n == null || tooHigh(n.key);
            }

            // 判断EntrySetView是否包含Object
            public boolean contains(Object o) {
                if (!(o instanceof Map.Entry))
                    return false;
                Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
                K key = entry.getKey();
                if (!inRange(key))
                    return false;
                TreeMap.Entry node = m.getEntry(key);
                return node != null &amp;&amp;
                    valEquals(node.getValue(), entry.getValue());
            }

            // 从EntrySetView中删除Object
            public boolean remove(Object o) {
                if (!(o instanceof Map.Entry))
                    return false;
                Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
                K key = entry.getKey();
                if (!inRange(key))
                    return false;
                TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key);
                if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue())){
                    m.deleteEntry(node);
                    return true;
                }
                return false;
            }
        }

        // SubMap的迭代器
        abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; {
            // 上一次被返回的Entry
            TreeMap.Entry&lt;K,V&gt; lastReturned;
            // 指向下一个Entry
            TreeMap.Entry&lt;K,V&gt; next;
            // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义
            final K fenceKey;
            int expectedModCount;

            // 构造函数
            SubMapIterator(TreeMap.Entry&lt;K,V&gt; first,
                           TreeMap.Entry&lt;K,V&gt; fence) {
                // 每创建一个SubMapIterator时，保存修改次数
                // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。
                // 这就是所说的fast-fail机制的原理！
                expectedModCount = m.modCount;
                lastReturned = null;
                next = first;
                fenceKey = fence == null ? null : fence.key;
            }

            // 是否存在下一个Entry
            public final boolean hasNext() {
                return next != null &amp;&amp; next.key != fenceKey;
            }

            // 返回下一个Entry
            final TreeMap.Entry&lt;K,V&gt; nextEntry() {
                TreeMap.Entry&lt;K,V&gt; e = next;
                if (e == null || e.key == fenceKey)
                    throw new NoSuchElementException();
                if (m.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                // next指向e的后继节点
                next = successor(e);
        lastReturned = e;
                return e;
            }

            // 返回上一个Entry
            final TreeMap.Entry&lt;K,V&gt; prevEntry() {
                TreeMap.Entry&lt;K,V&gt; e = next;
                if (e == null || e.key == fenceKey)
                    throw new NoSuchElementException();
                if (m.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                // next指向e的前继节点
                next = predecessor(e);
        lastReturned = e;
                return e;
            }

            // 删除当前节点(用于“升序的SubMap”)。
            // 删除之后，可以继续升序遍历；红黑树特性没变。
            final void removeAscending() {
                if (lastReturned == null)
                    throw new IllegalStateException();
                if (m.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。
                // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。
                //     根据“红黑树”的特性可知：
                //     当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。
                //     这意味着“当被删除节点有两个儿子时，删除当前节点之后，&apos;新的当前节点&apos;实际上是‘原有的后继节点(即下一个节点)’”。
                //     而此时next仍然指向&quot;新的当前节点&quot;。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。
                if (lastReturned.left != null &amp;&amp; lastReturned.right != null)
                    next = lastReturned;
                m.deleteEntry(lastReturned);
                lastReturned = null;
                expectedModCount = m.modCount;
            }

            // 删除当前节点(用于“降序的SubMap”)。
            // 删除之后，可以继续降序遍历；红黑树特性没变。
            final void removeDescending() {
                if (lastReturned == null)
                    throw new IllegalStateException();
                if (m.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                m.deleteEntry(lastReturned);
                lastReturned = null;
                expectedModCount = m.modCount;
            }

        }

        // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator
        final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
            SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first,
                                TreeMap.Entry&lt;K,V&gt; fence) {
                super(first, fence);
            }
            // 获取下一个节点(升序)
            public Map.Entry&lt;K,V&gt; next() {
                return nextEntry();
            }
            // 删除当前节点(升序)
            public void remove() {
                removeAscending();
            }
        }

        // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator
        final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; {
            SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first,
                              TreeMap.Entry&lt;K,V&gt; fence) {
                super(first, fence);
            }
            // 获取下一个节点(升序)
            public K next() {
                return nextEntry().key;
            }
            // 删除当前节点(升序)
            public void remove() {
                removeAscending();
            }
        }

        // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator
        final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
            DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last,
                                          TreeMap.Entry&lt;K,V&gt; fence) {
                super(last, fence);
            }

            // 获取下一个节点(降序)
            public Map.Entry&lt;K,V&gt; next() {
                return prevEntry();
            }
            // 删除当前节点(降序)
            public void remove() {
                removeDescending();
            }
        }

        // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator
        final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; {
            DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last,
                                        TreeMap.Entry&lt;K,V&gt; fence) {
                super(last, fence);
            }
            // 获取下一个节点(降序)
            public K next() {
                return prevEntry().key;
            }
            // 删除当前节点(降序)
            public void remove() {
                removeDescending();
            }
        }
    }


    // 升序的SubMap，继承于NavigableSubMap
    static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; {
        private static final long serialVersionUID = 912986545866124060L;

        // 构造函数
        AscendingSubMap(TreeMap&lt;K,V&gt; m,
                        boolean fromStart, K lo, boolean loInclusive,
                        boolean toEnd,     K hi, boolean hiInclusive) {
            super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
        }

        // 比较器
        public Comparator&lt;? super K&gt; comparator() {
            return m.comparator();
        }

        // 获取“子Map”。
        // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记
        public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                                        K toKey,   boolean toInclusive) {
            if (!inRange(fromKey, fromInclusive))
                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
            if (!inRange(toKey, toInclusive))
                throw new IllegalArgumentException(&quot;toKey out of range&quot;);
            return new AscendingSubMap(m,
                                       false, fromKey, fromInclusive,
                                       false, toKey,   toInclusive);
        }

        // 获取“Map的头部”。
        // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记
        public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
            if (!inRange(toKey, inclusive))
                throw new IllegalArgumentException(&quot;toKey out of range&quot;);
            return new AscendingSubMap(m,
                                       fromStart, lo,    loInclusive,
                                       false,     toKey, inclusive);
        }

        // 获取“Map的尾部”。
        // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记
        public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive){
            if (!inRange(fromKey, inclusive))
                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
            return new AscendingSubMap(m,
                                       false, fromKey, inclusive,
                                       toEnd, hi,      hiInclusive);
        }

        // 获取对应的降序Map
        public NavigableMap&lt;K,V&gt; descendingMap() {
            NavigableMap&lt;K,V&gt; mv = descendingMapView;
            return (mv != null) ? mv :
                (descendingMapView =
                 new DescendingSubMap(m,
                                      fromStart, lo, loInclusive,
                                      toEnd,     hi, hiInclusive));
        }

        // 返回“升序Key迭代器”
        Iterator&lt;K&gt; keyIterator() {
            return new SubMapKeyIterator(absLowest(), absHighFence());
        }

        // 返回“降序Key迭代器”
        Iterator&lt;K&gt; descendingKeyIterator() {
            return new DescendingSubMapKeyIterator(absHighest(), absLowFence());
        }

        // “升序EntrySet集合”类
        // 实现了iterator()
        final class AscendingEntrySetView extends EntrySetView {
            public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
                return new SubMapEntryIterator(absLowest(), absHighFence());
            }
        }

        // 返回“升序EntrySet集合”
        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
            EntrySetView es = entrySetView;
            return (es != null) ? es : new AscendingEntrySetView();
        }

        TreeMap.Entry&lt;K,V&gt; subLowest()       { return absLowest(); }
        TreeMap.Entry&lt;K,V&gt; subHighest()      { return absHighest(); }
        TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absCeiling(key); }
        TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absHigher(key); }
        TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absFloor(key); }
        TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absLower(key); }
    }

    // 降序的SubMap，继承于NavigableSubMap
    // 相比于升序SubMap，它的实现机制是将“SubMap的比较器反转”！
    static final class DescendingSubMap&lt;K,V&gt;  extends NavigableSubMap&lt;K,V&gt; {
        private static final long serialVersionUID = 912986545866120460L;
        DescendingSubMap(TreeMap&lt;K,V&gt; m,
                        boolean fromStart, K lo, boolean loInclusive,
                        boolean toEnd,     K hi, boolean hiInclusive) {
            super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
        }

        // 反转的比较器：是将原始比较器反转得到的。
        private final Comparator&lt;? super K&gt; reverseComparator =
            Collections.reverseOrder(m.comparator);

        // 获取反转比较器
        public Comparator&lt;? super K&gt; comparator() {
            return reverseComparator;
        }

        // 获取“子Map”。
        // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记
        public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                                        K toKey,   boolean toInclusive) {
            if (!inRange(fromKey, fromInclusive))
                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
            if (!inRange(toKey, toInclusive))
                throw new IllegalArgumentException(&quot;toKey out of range&quot;);
            return new DescendingSubMap(m,
                                        false, toKey,   toInclusive,
                                        false, fromKey, fromInclusive);
        }

        // 获取“Map的头部”。
        // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记
        public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
            if (!inRange(toKey, inclusive))
                throw new IllegalArgumentException(&quot;toKey out of range&quot;);
            return new DescendingSubMap(m,
                                        false, toKey, inclusive,
                                        toEnd, hi,    hiInclusive);
        }

        // 获取“Map的尾部”。
        // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记
        public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive){
            if (!inRange(fromKey, inclusive))
                throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
            return new DescendingSubMap(m,
                                        fromStart, lo, loInclusive,
                                        false, fromKey, inclusive);
        }

        // 获取对应的降序Map
        public NavigableMap&lt;K,V&gt; descendingMap() {
            NavigableMap&lt;K,V&gt; mv = descendingMapView;
            return (mv != null) ? mv :
                (descendingMapView =
                 new AscendingSubMap(m,
                                     fromStart, lo, loInclusive,
                                     toEnd,     hi, hiInclusive));
        }

        // 返回“升序Key迭代器”
        Iterator&lt;K&gt; keyIterator() {
            return new DescendingSubMapKeyIterator(absHighest(), absLowFence());
        }

        // 返回“降序Key迭代器”
        Iterator&lt;K&gt; descendingKeyIterator() {
            return new SubMapKeyIterator(absLowest(), absHighFence());
        }

        // “降序EntrySet集合”类
        // 实现了iterator()
        final class DescendingEntrySetView extends EntrySetView {
            public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
                return new DescendingSubMapEntryIterator(absHighest(), absLowFence());
            }
        }

        // 返回“降序EntrySet集合”
        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
            EntrySetView es = entrySetView;
            return (es != null) ? es : new DescendingEntrySetView();
        }

        TreeMap.Entry&lt;K,V&gt; subLowest()       { return absHighest(); }
        TreeMap.Entry&lt;K,V&gt; subHighest()      { return absLowest(); }
        TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absFloor(key); }
        TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absLower(key); }
        TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absCeiling(key); }
        TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absHigher(key); }
    }

    // SubMap是旧版本的类，新的Java中没有用到。
    private class SubMap extends AbstractMap&lt;K,V&gt;
    implements SortedMap&lt;K,V&gt;, java.io.Serializable {
        private static final long serialVersionUID = -6520786458950516097L;
        private boolean fromStart = false, toEnd = false;
        private K fromKey, toKey;
        private Object readResolve() {
            return new AscendingSubMap(TreeMap.this,
                                       fromStart, fromKey, true,
                                       toEnd, toKey, false);
        }
        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { throw new InternalError(); }
        public K lastKey() { throw new InternalError(); }
        public K firstKey() { throw new InternalError(); }
        public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { throw new InternalError(); }
        public SortedMap&lt;K,V&gt; headMap(K toKey) { throw new InternalError(); }
        public SortedMap&lt;K,V&gt; tailMap(K fromKey) { throw new InternalError(); }
        public Comparator&lt;? super K&gt; comparator() { throw new InternalError(); }
    }


    // 红黑树的节点颜色--红色
    private static final boolean RED   = false;
    // 红黑树的节点颜色--黑色
    private static final boolean BLACK = true;

    // “红黑树的节点”对应的类。
    // 包含了 key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)
    static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        // 键
        K key;
        // 值
        V value;
        // 左孩子
        Entry&lt;K,V&gt; left = null;
        // 右孩子
        Entry&lt;K,V&gt; right = null;
        // 父节点
        Entry&lt;K,V&gt; parent;
        // 当前节点颜色
        boolean color = BLACK;

        // 构造函数
        Entry(K key, V value, Entry&lt;K,V&gt; parent) {
            this.key = key;
            this.value = value;
            this.parent = parent;
        }

        // 返回“键”
        public K getKey() {
            return key;
        }

        // 返回“值”
        public V getValue() {
            return value;
        }

        // 更新“值”，返回旧的值
        public V setValue(V value) {
            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }

        // 判断两个节点是否相等的函数，覆盖equals()函数。
        // 若两个节点的“key相等”并且“value相等”，则两个节点相等
        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;

            return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());
        }

        // 覆盖hashCode函数。
        public int hashCode() {
            int keyHash = (key==null ? 0 : key.hashCode());
            int valueHash = (value==null ? 0 : value.hashCode());
            return keyHash ^ valueHash;
        }

        // 覆盖toString()函数。
        public String toString() {
            return key + &quot;=&quot; + value;
        }
    }

    // 返回“红黑树的第一个节点”
    final Entry&lt;K,V&gt; getFirstEntry() {
        Entry&lt;K,V&gt; p = root;
        if (p != null)
            while (p.left != null)
                p = p.left;
        return p;
    }

    // 返回“红黑树的最后一个节点”
    final Entry&lt;K,V&gt; getLastEntry() {
        Entry&lt;K,V&gt; p = root;
        if (p != null)
            while (p.right != null)
                p = p.right;
        return p;
    }

    // 返回“节点t的后继节点”
    static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {
        if (t == null)
            return null;
        else if (t.right != null) {
            Entry&lt;K,V&gt; p = t.right;
            while (p.left != null)
                p = p.left;
            return p;
        } else {
            Entry&lt;K,V&gt; p = t.parent;
            Entry&lt;K,V&gt; ch = t;
            while (p != null &amp;&amp; ch == p.right) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    // 返回“节点t的前继节点”
    static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) {
        if (t == null)
            return null;
        else if (t.left != null) {
            Entry&lt;K,V&gt; p = t.left;
            while (p.right != null)
                p = p.right;
            return p;
        } else {
            Entry&lt;K,V&gt; p = t.parent;
            Entry&lt;K,V&gt; ch = t;
            while (p != null &amp;&amp; ch == p.left) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    // 返回“节点p的颜色”
    // 根据“红黑树的特性”可知：空节点颜色是黑色。
    private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) {
        return (p == null ? BLACK : p.color);
    }

    // 返回“节点p的父节点”
    private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) {
        return (p == null ? null: p.parent);
    }

    // 设置“节点p的颜色为c”
    private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) {
        if (p != null)
        p.color = c;
    }

    // 设置“节点p的左孩子”
    private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) {
        return (p == null) ? null: p.left;
    }

    // 设置“节点p的右孩子”
    private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) {
        return (p == null) ? null: p.right;
    }

    // 对节点p执行“左旋”操作
    private void rotateLeft(Entry&lt;K,V&gt; p) {
        if (p != null) {
            Entry&lt;K,V&gt; r = p.right;
            p.right = r.left;
            if (r.left != null)
                r.left.parent = p;
            r.parent = p.parent;
            if (p.parent == null)
                root = r;
            else if (p.parent.left == p)
                p.parent.left = r;
            else
                p.parent.right = r;
            r.left = p;
            p.parent = r;
        }
    }

    // 对节点p执行“右旋”操作
    private void rotateRight(Entry&lt;K,V&gt; p) {
        if (p != null) {
            Entry&lt;K,V&gt; l = p.left;
            p.left = l.right;
            if (l.right != null) l.right.parent = p;
            l.parent = p.parent;
            if (p.parent == null)
                root = l;
            else if (p.parent.right == p)
                p.parent.right = l;
            else p.parent.left = l;
            l.right = p;
            p.parent = l;
        }
    }

    // 插入之后的修正操作。
    // 目的是保证：红黑树插入节点之后，仍然是一颗红黑树
    private void fixAfterInsertion(Entry&lt;K,V&gt; x) {
        x.color = RED;

        while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {
            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == rightOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateLeft(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateRight(parentOf(parentOf(x)));
                }
            } else {
                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == leftOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateRight(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateLeft(parentOf(parentOf(x)));
                }
            }
        }
        root.color = BLACK;
    }

    // 删除“红黑树的节点p”
    private void deleteEntry(Entry&lt;K,V&gt; p) {
        modCount++;
        size--;

        // If strictly internal, copy successor&apos;s element to p and then make p
        // point to successor.
        if (p.left != null &amp;&amp; p.right != null) {
            Entry&lt;K,V&gt; s = successor (p);
            p.key = s.key;
            p.value = s.value;
            p = s;
        } // p has 2 children

        // Start fixup at replacement node, if it exists.
        Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);

        if (replacement != null) {
            // Link replacement to parent
            replacement.parent = p.parent;
            if (p.parent == null)
                root = replacement;
            else if (p == p.parent.left)
                p.parent.left  = replacement;
            else
                p.parent.right = replacement;

            // Null out links so they are OK to use by fixAfterDeletion.
            p.left = p.right = p.parent = null;

            // Fix replacement
            if (p.color == BLACK)
                fixAfterDeletion(replacement);
        } else if (p.parent == null) { // return if we are the only node.
            root = null;
        } else { //  No children. Use self as phantom replacement and unlink.
            if (p.color == BLACK)
                fixAfterDeletion(p);

            if (p.parent != null) {
                if (p == p.parent.left)
                    p.parent.left = null;
                else if (p == p.parent.right)
                    p.parent.right = null;
                p.parent = null;
            }
        }
    }

    // 删除之后的修正操作。
    // 目的是保证：红黑树删除节点之后，仍然是一颗红黑树
    private void fixAfterDeletion(Entry&lt;K,V&gt; x) {
        while (x != root &amp;&amp; colorOf(x) == BLACK) {
            if (x == leftOf(parentOf(x))) {
                Entry&lt;K,V&gt; sib = rightOf(parentOf(x));

                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateLeft(parentOf(x));
                    sib = rightOf(parentOf(x));
                }

                if (colorOf(leftOf(sib))  == BLACK &amp;&amp;
                    colorOf(rightOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    if (colorOf(rightOf(sib)) == BLACK) {
                        setColor(leftOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateRight(sib);
                        sib = rightOf(parentOf(x));
                    }
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(rightOf(sib), BLACK);
                    rotateLeft(parentOf(x));
                    x = root;
                }
            } else { // symmetric
                Entry&lt;K,V&gt; sib = leftOf(parentOf(x));

                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateRight(parentOf(x));
                    sib = leftOf(parentOf(x));
                }

                if (colorOf(rightOf(sib)) == BLACK &amp;&amp;
                    colorOf(leftOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    if (colorOf(leftOf(sib)) == BLACK) {
                        setColor(rightOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateLeft(sib);
                        sib = leftOf(parentOf(x));
                    }
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(leftOf(sib), BLACK);
                    rotateRight(parentOf(x));
                    x = root;
                }
            }
        }

        setColor(x, BLACK);
    }

    private static final long serialVersionUID = 919286545866124006L;

    // java.io.Serializable的写入函数
    // 将TreeMap的“容量，所有的Entry”都写入到输出流中
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out the Comparator and any hidden stuff
        s.defaultWriteObject();

        // Write out size (number of Mappings)
        s.writeInt(size);

        // Write out keys and values (alternating)
        for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) {
            Map.Entry&lt;K,V&gt; e = i.next();
            s.writeObject(e.getKey());
            s.writeObject(e.getValue());
        }
    }


    // java.io.Serializable的读取函数：根据写入方式读出
    // 先将TreeMap的“容量、所有的Entry”依次读出
    private void readObject(final java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in the Comparator and any hidden stuff
        s.defaultReadObject();

        // Read in size
        int size = s.readInt();

        buildFromSorted(size, null, s, null);
    }

    // 根据已经一个排好序的map创建一个TreeMap
    private void buildFromSorted(int size, Iterator it,
                 java.io.ObjectInputStream str,
                 V defaultVal)
        throws  java.io.IOException, ClassNotFoundException {
        this.size = size;
        root = buildFromSorted(0, 0, size-1, computeRedLevel(size),
                   it, str, defaultVal);
    }

    // 根据已经一个排好序的map创建一个TreeMap
    // 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。
    private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi,
                         int redLevel,
                         Iterator it,
                         java.io.ObjectInputStream str,
                         V defaultVal)
        throws  java.io.IOException, ClassNotFoundException {

        if (hi &lt; lo) return null;


        // 获取中间元素
        int mid = (lo + hi) / 2;

        Entry&lt;K,V&gt; left  = null;
        // 若lo小于mid，则递归调用获取(middel的)左孩子。
        if (lo &lt; mid)
            left = buildFromSorted(level+1, lo, mid - 1, redLevel,
                   it, str, defaultVal);

        // 获取middle节点对应的key和value
        K key;
        V value;
        if (it != null) {
            if (defaultVal==null) {
                Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next();
                key = entry.getKey();
                value = entry.getValue();
            } else {
                key = (K)it.next();
                value = defaultVal;
            }
        } else { // use stream
            key = (K) str.readObject();
            value = (defaultVal != null ? defaultVal : (V) str.readObject());
        }

        // 创建middle节点
        Entry&lt;K,V&gt; middle =  new Entry&lt;K,V&gt;(key, value, null);

        // 若当前节点的深度=红色节点的深度，则将节点着色为红色。
        if (level == redLevel)
            middle.color = RED;

        // 设置middle为left的父亲，left为middle的左孩子
        if (left != null) {
            middle.left = left;
            left.parent = middle;
        }

        if (mid &lt; hi) {
            // 递归调用获取(middel的)右孩子。
            Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel,
                           it, str, defaultVal);
            // 设置middle为left的父亲，left为middle的左孩子
            middle.right = right;
            right.parent = middle;
        }

        return middle;
    }

    // 计算节点树为sz的最大深度，也是红色节点的深度值。
    private static int computeRedLevel(int sz) {
        int level = 0;
        for (int m = sz - 1; m &gt;= 0; m = m / 2 - 1)
            level++;
        return level;
    }
}</code></pre><p>说明:  </p>
<p>在详细介绍TreeMap的代码之前，我们先建立一个整体概念。<br>TreeMap是通过红黑树实现的，TreeMap存储的是key-value键值对，TreeMap的排序是基于对key的排序。<br>TreeMap提供了操作“key”、“key-value”、“value”等方法，也提供了对TreeMap这颗树进行整体操作的方法，如获取子树、反向树。<br>后面的解说内容分为几部分,<br>&nbsp;&nbsp;首先，介绍TreeMap的核心，即红黑树相关部分；<br>&nbsp;&nbsp;然后，介绍TreeMap的主要函数；<br>&nbsp;&nbsp;再次，介绍TreeMap实现的几个接口；<br>&nbsp;&nbsp;最后，补充介绍TreeMap的其它内容。</p>
<p>TreeMap本质上是一颗红黑树。要彻底理解TreeMap，建议读者先理解红黑树。关于红黑树的原理，可以参考：[红黑树(一) 原理和算法详细介绍][link_rdtree_introduce]</p>
<h2 id="第3-1部分-TreeMap的红黑树相关内容"><a href="#第3-1部分-TreeMap的红黑树相关内容" class="headerlink" title="第3.1部分 TreeMap的红黑树相关内容"></a>第3.1部分 TreeMap的红黑树相关内容</h2><p>TreeMap中于红黑树相关的主要函数有:  </p>
<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h3><p><strong>1.1 红黑树的节点颜色–红色</strong></p>
<pre><code>private static final boolean RED = false;</code></pre><p><strong>1.2 红黑树的节点颜色–黑色</strong></p>
<pre><code>private static final boolean BLACK = true;</code></pre><p><strong>1.3 “红黑树的节点”对应的类</strong></p>
<pre><code>static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { ... }</code></pre><p>Entry包含了6个部分内容：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)<br>Entry节点根据key进行排序，Entry节点包含的内容为value。</p>
<h3 id="2-相关操作"><a href="#2-相关操作" class="headerlink" title="2 相关操作"></a>2 相关操作</h3><p><strong>2.1 左旋</strong></p>
<pre><code>private void rotateLeft(Entry&lt;K,V&gt; p) { ... }</code></pre><p><strong>2.2 右旋</strong></p>
<pre><code>private void rotateRight(Entry&lt;K,V&gt; p) { ... }</code></pre><p><strong>2.3 插入操作</strong></p>
<pre><code>public V put(K key, V value) { ... }</code></pre><p><strong>2.4 插入修正操作</strong></p>
<p>红黑树执行插入操作之后，要执行“插入修正操作”。<br>目的是：保红黑树在进行插入节点之后，仍然是一颗红黑树</p>
<pre><code>private void fixAfterInsertion(Entry&lt;K,V&gt; x) { ... }</code></pre><p><strong>2.5 删除操作</strong></p>
<pre><code>private void deleteEntry(Entry&lt;K,V&gt; p) { ... }</code></pre><p><strong>2.6 删除修正操作</strong></p>
<p>红黑树执行删除之后，要执行“删除修正操作”。<br>目的是保证：红黑树删除节点之后，仍然是一颗红黑树</p>
<pre><code>private void fixAfterDeletion(Entry&lt;K,V&gt; x) { ... }</code></pre><p>关于红黑树部分，这里主要是指出了TreeMap中那些是红黑树的主要相关内容。具体的红黑树相关操作API，这里没有详细说明，因为它们仅仅只是将算法翻译成代码。读者可以参考“[红黑树(一) 原理和算法详细介绍][link_rdtree_introduce]”进行了解。</p>
<h2 id="第3-2部分-TreeMap的构造函数"><a href="#第3-2部分-TreeMap的构造函数" class="headerlink" title="第3.2部分 TreeMap的构造函数"></a>第3.2部分 TreeMap的构造函数</h2><h3 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1 默认构造函数"></a>1 默认构造函数</h3><p>使用默认构造函数构造TreeMap时，使用java的默认的比较器比较Key的大小，从而对TreeMap进行排序。</p>
<pre><code>public TreeMap() {
    comparator = null;
}</code></pre><h3 id="2-带比较器的构造函数"><a href="#2-带比较器的构造函数" class="headerlink" title="2 带比较器的构造函数"></a>2 带比较器的构造函数</h3><pre><code>public TreeMap(Comparator&lt;? super K&gt; comparator) {
    this.comparator = comparator;
}</code></pre><h3 id="3-带Map的构造函数，Map会成为TreeMap的子集"><a href="#3-带Map的构造函数，Map会成为TreeMap的子集" class="headerlink" title="3 带Map的构造函数，Map会成为TreeMap的子集"></a>3 带Map的构造函数，Map会成为TreeMap的子集</h3><pre><code>public TreeMap(Map&lt;? extends K, ? extends V&gt; m) {
    comparator = null;
    putAll(m);
}</code></pre><p>该构造函数会调用putAll()将m中的所有元素添加到TreeMap中。putAll()源码如下：</p>
<pre><code>public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
    for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())
        put(e.getKey(), e.getValue());
}</code></pre><p>从中，我们可以看出putAll()就是将m中的key-value逐个的添加到TreeMap中。</p>
<h3 id="4-带SortedMap的构造函数，SortedMap会成为TreeMap的子集"><a href="#4-带SortedMap的构造函数，SortedMap会成为TreeMap的子集" class="headerlink" title="4 带SortedMap的构造函数，SortedMap会成为TreeMap的子集"></a>4 带SortedMap的构造函数，SortedMap会成为TreeMap的子集</h3><pre><code>public TreeMap(SortedMap&lt;K, ? extends V&gt; m) {
    comparator = m.comparator();
    try {
        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);
    } catch (java.io.IOException cannotHappen) {
    } catch (ClassNotFoundException cannotHappen) {
    }
}</code></pre><p>该构造函数不同于上一个构造函数，在上一个构造函数中传入的参数是Map，Map不是有序的，所以要逐个添加。<br>而该构造函数的参数是SortedMap是一个有序的Map，我们通过buildFromSorted()来创建对应的Map。<br>buildFromSorted涉及到的代码如下：   </p>
<pre><code>// 根据已经一个排好序的map创建一个TreeMap
// 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。
private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi,
                     int redLevel,
                     Iterator it,
                     java.io.ObjectInputStream str,
                     V defaultVal)
    throws  java.io.IOException, ClassNotFoundException {

    if (hi &lt; lo) return null;


    // 获取中间元素
    int mid = (lo + hi) / 2;

    Entry&lt;K,V&gt; left  = null;
    // 若lo小于mid，则递归调用获取(middel的)左孩子。
    if (lo &lt; mid)
        left = buildFromSorted(level+1, lo, mid - 1, redLevel,
               it, str, defaultVal);

    // 获取middle节点对应的key和value
    K key;
    V value;
    if (it != null) {
        if (defaultVal==null) {
            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next();
            key = entry.getKey();
            value = entry.getValue();
        } else {
            key = (K)it.next();
            value = defaultVal;
        }
    } else { // use stream
        key = (K) str.readObject();
        value = (defaultVal != null ? defaultVal : (V) str.readObject());
    }

    // 创建middle节点
    Entry&lt;K,V&gt; middle =  new Entry&lt;K,V&gt;(key, value, null);

    // 若当前节点的深度=红色节点的深度，则将节点着色为红色。
    if (level == redLevel)
        middle.color = RED;

    // 设置middle为left的父亲，left为middle的左孩子
    if (left != null) {
        middle.left = left;
        left.parent = middle;
    }

    if (mid &lt; hi) {
        // 递归调用获取(middel的)右孩子。
        Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel,
                       it, str, defaultVal);
        // 设置middle为left的父亲，left为middle的左孩子
        middle.right = right;
        right.parent = middle;
    }

    return middle;
}</code></pre><p>要理解buildFromSorted，重点说明以下几点：</p>
<p>第一，buildFromSorted是通过递归将SortedMap中的元素逐个关联。<br>第二，buildFromSorted返回middle节点(中间节点)作为root。<br>第三，buildFromSorted添加到红黑树中时，只将level == redLevel的节点设为红色。第level级节点，实际上是buildFromSorted转换成红黑树后的最底端(假设根节点在最上方)的节点；只将红黑树最底端的阶段着色为红色，其余都是黑色。</p>
<h2 id="第3-3部分-TreeMap的Entry相关函数"><a href="#第3-3部分-TreeMap的Entry相关函数" class="headerlink" title="第3.3部分 TreeMap的Entry相关函数"></a>第3.3部分 TreeMap的Entry相关函数</h2><p>TreeMap的 firstEntry()、 lastEntry()、 lowerEntry()、 higherEntry()、 floorEntry()、 ceilingEntry()、 pollFirstEntry() 、 pollLastEntry() 原理都是类似的；下面以firstEntry()来进行详细说明</p>
<p>我们先看看firstEntry()和getFirstEntry()的代码：</p>
<pre><code>public Map.Entry&lt;K,V&gt; firstEntry() {
    return exportEntry(getFirstEntry());
}

final Entry&lt;K,V&gt; getFirstEntry() {
    Entry&lt;K,V&gt; p = root;
    if (p != null)
        while (p.left != null)
            p = p.left;
    return p;
}</code></pre><p>从中，我们可以看出 firstEntry() 和 getFirstEntry() 都是用于获取第一个节点。<br>但是，firstEntry() 是对外接口； getFirstEntry() 是内部接口。而且，firstEntry() 是通过 getFirstEntry() 来实现的。那为什么外界不能直接调用 getFirstEntry()，而需要多此一举的调用 firstEntry() 呢?<br>先告诉大家原因，再进行详细说明。这么做的目的是：防止用户修改返回的Entry。getFirstEntry()返回的Entry是可以被修改的，但是经过firstEntry()返回的Entry不能被修改，只可以读取Entry的key值和value值。下面我们看看到底是如何实现的。<br>(01) getFirstEntry()返回的是Entry节点，而Entry是红黑树的节点，它的源码如下：  </p>
<pre><code>// 返回“红黑树的第一个节点”
final Entry&lt;K,V&gt; getFirstEntry() {
    Entry&lt;K,V&gt; p = root;
    if (p != null)
    while (p.left != null)
            p = p.left;
    return p;
}</code></pre><p>从中，我们可以调用Entry的getKey()、getValue()来获取key和value值，以及调用setValue()来修改value的值。</p>
<p>(02) firstEntry()返回的是exportEntry(getFirstEntry())。下面我们看看exportEntry()干了些什么？</p>
<pre><code>static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) {
    return e == null? null :
        new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e);
}</code></pre><p>实际上，exportEntry() 是新建一个AbstractMap.SimpleImmutableEntry类型的对象，并返回。</p>
<p>SimpleImmutableEntry的实现在AbstractMap.java中，下面我们看看AbstractMap.SimpleImmutableEntry是如何实现的，代码如下：</p>
<pre><code>public static class SimpleImmutableEntry&lt;K,V&gt;
implements Entry&lt;K,V&gt;, java.io.Serializable
{
    private static final long serialVersionUID = 7138329143949025153L;

    private final K key;
    private final V value;

    public SimpleImmutableEntry(K key, V value) {
        this.key   = key;
        this.value = value;
    }

    public SimpleImmutableEntry(Entry&lt;? extends K, ? extends V&gt; entry) {
        this.key   = entry.getKey();
            this.value = entry.getValue();
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    public V setValue(V value) {
            throw new UnsupportedOperationException();
        }

    public boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
        return false;
        Map.Entry e = (Map.Entry)o;
        return eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());
    }

    public int hashCode() {
        return (key   == null ? 0 :   key.hashCode()) ^
           (value == null ? 0 : value.hashCode());
    }

    public String toString() {
        return key + &quot;=&quot; + value;
    }
}</code></pre><p>从中，我们可以看出SimpleImmutableEntry实际上是简化的key-value节点。<br>它只提供了getKey()、getValue()方法类获取节点的值；但不能修改value的值，因为调用 setValue() 会抛出异常UnsupportedOperationException();</p>
<p>再回到我们之前的问题：那为什么外界不能直接调用 getFirstEntry()，而需要多此一举的调用 firstEntry() 呢?<br>现在我们清晰的了解到：<br>(01) firstEntry()是对外接口，而getFirstEntry()是内部接口。<br>(02) 对firstEntry()返回的Entry对象只能进行getKey()、getValue()等读取操作；而对getFirstEntry()返回的对象除了可以进行读取操作之后，还可以通过setValue()修改值。</p>
<h2 id="第3-4部分-TreeMap的key相关函数"><a href="#第3-4部分-TreeMap的key相关函数" class="headerlink" title="第3.4部分 TreeMap的key相关函数"></a>第3.4部分 TreeMap的key相关函数</h2><p>TreeMap的firstKey()、lastKey()、lowerKey()、higherKey()、floorKey()、ceilingKey()原理都是类似的；下面以ceilingKey()来进行详细说明</p>
<p>ceilingKey(K key)的作用是“返回大于/等于key的最小的键值对所对应的KEY，没有的话返回null”，它的代码如下：</p>
<pre><code>public K ceilingKey(K key) {
    return keyOrNull(getCeilingEntry(key));
}</code></pre><p>ceilingKey()是通过getCeilingEntry()实现的。keyOrNull()的代码很简单，它是获取节点的key，没有的话，返回null。</p>
<pre><code>static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) {
    return e == null? null : e.key;
}</code></pre><p>getCeilingEntry(K key)的作用是“获取TreeMap中大于/等于key的最小的节点，若不存在(即TreeMap中所有节点的键都比key大)，就返回null”。它的实现代码如下：</p>
<pre><code>final Entry&lt;K,V&gt; getCeilingEntry(K key) {
    Entry&lt;K,V&gt; p = root;
    while (p != null) {
        int cmp = compare(key, p.key);
        // 情况一：若“p的key” &gt; key。
        // 若 p 存在左孩子，则设 p=“p的左孩子”；
        // 否则，返回p
        if (cmp &lt; 0) {
            if (p.left != null)
                p = p.left;
            else
                return p;
        // 情况二：若“p的key” &lt; key。
        } else if (cmp &gt; 0) {
            // 若 p 存在右孩子，则设 p=“p的右孩子”
            if (p.right != null) {
                p = p.right;
            } else {
                // 若 p 不存在右孩子，则找出 p 的后继节点，并返回
                // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。
                //   理解这一点的核心是，getCeilingEntry是从root开始遍历的。
                //   若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。
                //   能理解上面所说的，那么就很容易明白，为什么“p的后继节点”有2种可能性了。
                Entry&lt;K,V&gt; parent = p.parent;
                Entry&lt;K,V&gt; ch = p;
                while (parent != null &amp;&amp; ch == parent.right) {
                    ch = parent;
                    parent = parent.parent;
                }
                return parent;
            }
        // 情况三：若“p的key” = key。
        } else
            return p;
    }
    return null;
}</code></pre><h2 id="第3-5部分-TreeMap的values-函数"><a href="#第3-5部分-TreeMap的values-函数" class="headerlink" title="第3.5部分 TreeMap的values()函数"></a>第3.5部分 TreeMap的values()函数</h2><p>values() 返回“TreeMap中值的集合”</p>
<p>values()的实现代码如下：</p>
<pre><code>public Collection&lt;V&gt; values() {
    Collection&lt;V&gt; vs = values;
    return (vs != null) ? vs : (values = new Values());
}</code></pre><p>说明：从中，我们可以发现values()是通过 new Values() 来实现 “返回TreeMap中值的集合”。</p>
<p>那么Values()是如何实现的呢？ 没错！由于返回的是值的集合，那么Values()肯定返回一个集合；而Values()正好是集合类Value的构造函数。Values继承于AbstractCollection，它的代码如下：</p>
<pre><code>// ”TreeMap的值的集合“对应的类，它集成于AbstractCollection
class Values extends AbstractCollection&lt;V&gt; {
    // 返回迭代器
    public Iterator&lt;V&gt; iterator() {
        return new ValueIterator(getFirstEntry());
    }

    // 返回个数
    public int size() {
        return TreeMap.this.size();
    }

    // &quot;TreeMap的值的集合&quot;中是否包含&quot;对象o&quot;
    public boolean contains(Object o) {
        return TreeMap.this.containsValue(o);
    }

    // 删除&quot;TreeMap的值的集合&quot;中的&quot;对象o&quot;
    public boolean remove(Object o) {
        for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) {
            if (valEquals(e.getValue(), o)) {
                deleteEntry(e);
                return true;
            }
        }
        return false;
    }

    // 清空删除&quot;TreeMap的值的集合&quot;
    public void clear() {
        TreeMap.this.clear();
    }
}</code></pre><p>说明：从中，我们可以知道Values类就是一个集合。而 AbstractCollection 实现了除 size() 和 iterator() 之外的其它函数，因此只需要在Values类中实现这两个函数即可。<br>size() 的实现非常简单，Values集合中元素的个数=该TreeMap的元素个数。(TreeMap每一个元素都有一个值嘛！)<br>iterator() 则返回一个迭代器，用于遍历Values。下面，我们一起可以看看iterator()的实现：</p>
<pre><code>public Iterator&lt;V&gt; iterator() {
    return new ValueIterator(getFirstEntry());
}</code></pre><p>说明： iterator() 是通过ValueIterator() 返回迭代器的，ValueIterator是一个类。代码如下：</p>
<pre><code>final class ValueIterator extends PrivateEntryIterator&lt;V&gt; {
    ValueIterator(Entry&lt;K,V&gt; first) {
        super(first);
    }
    public V next() {
        return nextEntry().value;
    }
}</code></pre><p>说明：ValueIterator的代码很简单，它的主要实现应该在它的父类PrivateEntryIterator中。下面我们一起看看PrivateEntryIterator的代码：</p>
<pre><code>abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; {
    // 下一节点
    Entry&lt;K,V&gt; next;
    // 上一次返回的节点
    Entry&lt;K,V&gt; lastReturned;
    // 修改次数统计数
    int expectedModCount;

    PrivateEntryIterator(Entry&lt;K,V&gt; first) {
        expectedModCount = modCount;
        lastReturned = null;
        next = first;
    }

    // 是否存在下一个节点
    public final boolean hasNext() {
        return next != null;
    }

    // 返回下一个节点
    final Entry&lt;K,V&gt; nextEntry() {
        Entry&lt;K,V&gt; e = next;
        if (e == null)
            throw new NoSuchElementException();
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        next = successor(e);
        lastReturned = e;
        return e;
    }

    // 返回上一节点
    final Entry&lt;K,V&gt; prevEntry() {
        Entry&lt;K,V&gt; e = next;
        if (e == null)
            throw new NoSuchElementException();
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        next = predecessor(e);
        lastReturned = e;
        return e;
    }

    // 删除当前节点
    public void remove() {
        if (lastReturned == null)
            throw new IllegalStateException();
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        // deleted entries are replaced by their successors
        if (lastReturned.left != null &amp;&amp; lastReturned.right != null)
            next = lastReturned;
        deleteEntry(lastReturned);
        expectedModCount = modCount;
        lastReturned = null;
    }
}</code></pre><p>说明：PrivateEntryIterator是一个抽象类，它的实现很简单，只只实现了Iterator的remove()和hasNext()接口，没有实现next()接口。<br>而我们在ValueIterator中已经实现的next()接口。<br>至此，我们就了解了iterator()的完整实现了。</p>
<h2 id="第3-6部分-TreeMap的entrySet-函数"><a href="#第3-6部分-TreeMap的entrySet-函数" class="headerlink" title="第3.6部分 TreeMap的entrySet()函数"></a>第3.6部分 TreeMap的entrySet()函数</h2><p>entrySet() 返回“键值对集合”。顾名思义，它返回的是一个集合，集合的元素是“键值对”。</p>
<p>下面，我们看看它是如何实现的？entrySet() 的实现代码如下：</p>
<pre><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
    EntrySet es = entrySet;
    return (es != null) ? es : (entrySet = new EntrySet());
}</code></pre><p>说明：entrySet()返回的是一个EntrySet对象。</p>
<p>下面我们看看EntrySet的代码：</p>
<p>// EntrySet是“TreeMap的所有键值对组成的集合”，<br>// EntrySet集合的单位是单个“键值对”。<br>    class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {<br>        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {<br>            return new EntryIterator(getFirstEntry());<br>        }</p>
<pre><code>    // EntrySet中是否包含“键值对Object”
    public boolean contains(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
        V value = entry.getValue();
        Entry&lt;K,V&gt; p = getEntry(entry.getKey());
        return p != null &amp;&amp; valEquals(p.getValue(), value);
    }

    // 删除EntrySet中的“键值对Object”
    public boolean remove(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
        V value = entry.getValue();
        Entry&lt;K,V&gt; p = getEntry(entry.getKey());
        if (p != null &amp;&amp; valEquals(p.getValue(), value)) {
            deleteEntry(p);
            return true;
        }
        return false;
    }

    // 返回EntrySet中元素个数
    public int size() {
        return TreeMap.this.size();
    }

    // 清空EntrySet
    public void clear() {
        TreeMap.this.clear();
    }
}</code></pre><p>说明：<br>EntrySet是“TreeMap的所有键值对组成的集合”，而且它单位是单个“键值对”。<br>EntrySet是一个集合，它继承于AbstractSet。而AbstractSet实现了除size() 和 iterator() 之外的其它函数，因此，我们重点了解一下EntrySet的size() 和 iterator() 函数</p>
<p>size() 的实现非常简单，AbstractSet集合中元素的个数=该TreeMap的元素个数。<br>iterator() 则返回一个迭代器，用于遍历AbstractSet。从上面的源码中，我们可以发现iterator() 是通过EntryIterator实现的；下面我们看看EntryIterator的源码：</p>
<pre><code>final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
    EntryIterator(Entry&lt;K,V&gt; first) {
        super(first);
    }
    public Map.Entry&lt;K,V&gt; next() {
        return nextEntry();
    }
}</code></pre><p>说明：和Values类一样，EntryIterator也继承于PrivateEntryIterator类。</p>
<h2 id="第3-7部分-TreeMap实现的Cloneable接口"><a href="#第3-7部分-TreeMap实现的Cloneable接口" class="headerlink" title="第3.7部分 TreeMap实现的Cloneable接口"></a>第3.7部分 TreeMap实现的Cloneable接口</h2><p>TreeMap实现了Cloneable接口，即实现了clone()方法。<br>clone()方法的作用很简单，就是克隆一个TreeMap对象并返回。</p>
<pre><code>// 克隆一个TreeMap，并返回Object对象
public Object clone() {
    TreeMap&lt;K,V&gt; clone = null;
    try {
        clone = (TreeMap&lt;K,V&gt;) super.clone();
    } catch (CloneNotSupportedException e) {
        throw new InternalError();
    }

    // Put clone into &quot;virgin&quot; state (except for comparator)
    clone.root = null;
    clone.size = 0;
    clone.modCount = 0;
    clone.entrySet = null;
    clone.navigableKeySet = null;
    clone.descendingMap = null;

    // Initialize clone with our mappings
    try {
        clone.buildFromSorted(size, entrySet().iterator(), null, null);
    } catch (java.io.IOException cannotHappen) {
    } catch (ClassNotFoundException cannotHappen) {
    }

    return clone;
}</code></pre><h2 id="第3-8部分-TreeMap实现的Serializable接口"><a href="#第3-8部分-TreeMap实现的Serializable接口" class="headerlink" title="第3.8部分 TreeMap实现的Serializable接口"></a>第3.8部分 TreeMap实现的Serializable接口</h2><p>TreeMap实现java.io.Serializable，分别实现了串行读取、写入功能。<br>串行写入函数是writeObject()，它的作用是将TreeMap的“容量，所有的Entry”都写入到输出流中。<br>而串行读取函数是readObject()，它的作用是将TreeMap的“容量、所有的Entry”依次读出。<br>readObject() 和 writeObject() 正好是一对，通过它们，我能实现TreeMap的串行传输。</p>
<pre><code>// java.io.Serializable的写入函数
// 将TreeMap的“容量，所有的Entry”都写入到输出流中
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException {
    // Write out the Comparator and any hidden stuff
    s.defaultWriteObject();

    // Write out size (number of Mappings)
    s.writeInt(size);

    // Write out keys and values (alternating)
    for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) {
        Map.Entry&lt;K,V&gt; e = i.next();
        s.writeObject(e.getKey());
        s.writeObject(e.getValue());
    }
}


// java.io.Serializable的读取函数：根据写入方式读出
// 先将TreeMap的“容量、所有的Entry”依次读出
private void readObject(final java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    // Read in the Comparator and any hidden stuff
    s.defaultReadObject();

    // Read in size
    int size = s.readInt();

    buildFromSorted(size, null, s, null);
}</code></pre><p>说到这里，就顺便说一下“关键字transient”的作用</p>
<p>transient是Java语言的关键字，它被用来表示一个域不是该对象串行化的一部分。<br>Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。<br>当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。</p>
<h2 id="第3-9部分-TreeMap实现的NavigableMap接口"><a href="#第3-9部分-TreeMap实现的NavigableMap接口" class="headerlink" title="第3.9部分 TreeMap实现的NavigableMap接口"></a>第3.9部分 TreeMap实现的NavigableMap接口</h2><p>firstKey()、lastKey()、lowerKey()、higherKey()、ceilingKey()、floorKey();<br>firstEntry()、 lastEntry()、 lowerEntry()、 higherEntry()、 floorEntry()、 ceilingEntry()、 pollFirstEntry() 、 pollLastEntry();<br>上面已经讲解过这些API了，下面对其它的API进行说明。</p>
<h3 id="1-反向TreeMap"><a href="#1-反向TreeMap" class="headerlink" title="1 反向TreeMap"></a>1 反向TreeMap</h3><p>descendingMap() 的作用是返回当前TreeMap的反向的TreeMap。所谓反向，就是排序顺序和原始的顺序相反。</p>
<p>我们已经知道TreeMap是一颗红黑树，而红黑树是有序的。<br>TreeMap的排序方式是通过比较器，在创建TreeMap的时候，若指定了比较器，则使用该比较器；否则，就使用Java的默认比较器。<br>而获取TreeMap的反向TreeMap的原理就是将比较器反向即可！</p>
<p>理解了descendingMap()的反向原理之后，再讲解一下descendingMap()的代码。</p>
<pre><code>// 获取TreeMap的降序Map
public NavigableMap&lt;K, V&gt; descendingMap() {
    NavigableMap&lt;K, V&gt; km = descendingMap;
    return (km != null) ? km :
        (descendingMap = new DescendingSubMap(this,
                                              true, null, true,
                                              true, null, true));
}</code></pre><p>从中，我们看出descendingMap()实际上是返回DescendingSubMap类的对象。下面，看看DescendingSubMap的源码：</p>
<pre><code>static final class DescendingSubMap&lt;K,V&gt;  extends NavigableSubMap&lt;K,V&gt; {
    private static final long serialVersionUID = 912986545866120460L;
    DescendingSubMap(TreeMap&lt;K,V&gt; m,
                    boolean fromStart, K lo, boolean loInclusive,
                    boolean toEnd,     K hi, boolean hiInclusive) {
        super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
    }

    // 反转的比较器：是将原始比较器反转得到的。
    private final Comparator&lt;? super K&gt; reverseComparator =
        Collections.reverseOrder(m.comparator);

    // 获取反转比较器
    public Comparator&lt;? super K&gt; comparator() {
        return reverseComparator;
    }

    // 获取“子Map”。
    // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记
    public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                                    K toKey,   boolean toInclusive) {
        if (!inRange(fromKey, fromInclusive))
            throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
        if (!inRange(toKey, toInclusive))
            throw new IllegalArgumentException(&quot;toKey out of range&quot;);
        return new DescendingSubMap(m,
                                    false, toKey,   toInclusive,
                                    false, fromKey, fromInclusive);
    }

    // 获取“Map的头部”。
    // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记
    public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
        if (!inRange(toKey, inclusive))
            throw new IllegalArgumentException(&quot;toKey out of range&quot;);
        return new DescendingSubMap(m,
                                    false, toKey, inclusive,
                                    toEnd, hi,    hiInclusive);
    }

    // 获取“Map的尾部”。
    // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记
    public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive){
        if (!inRange(fromKey, inclusive))
            throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
        return new DescendingSubMap(m,
                                    fromStart, lo, loInclusive,
                                    false, fromKey, inclusive);
    }

    // 获取对应的降序Map
    public NavigableMap&lt;K,V&gt; descendingMap() {
        NavigableMap&lt;K,V&gt; mv = descendingMapView;
        return (mv != null) ? mv :
            (descendingMapView =
             new AscendingSubMap(m,
                                 fromStart, lo, loInclusive,
                                 toEnd,     hi, hiInclusive));
    }

    // 返回“升序Key迭代器”
    Iterator&lt;K&gt; keyIterator() {
        return new DescendingSubMapKeyIterator(absHighest(), absLowFence());
    }

    // 返回“降序Key迭代器”
    Iterator&lt;K&gt; descendingKeyIterator() {
        return new SubMapKeyIterator(absLowest(), absHighFence());
    }

    // “降序EntrySet集合”类
    // 实现了iterator()
    final class DescendingEntrySetView extends EntrySetView {
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
            return new DescendingSubMapEntryIterator(absHighest(), absLowFence());
        }
    }

    // 返回“降序EntrySet集合”
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        EntrySetView es = entrySetView;
        return (es != null) ? es : new DescendingEntrySetView();
    }

    TreeMap.Entry&lt;K,V&gt; subLowest()       { return absHighest(); }
    TreeMap.Entry&lt;K,V&gt; subHighest()      { return absLowest(); }
    TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absFloor(key); }
    TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absLower(key); }
    TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absCeiling(key); }
    TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absHigher(key); }
}</code></pre><p>从中，我们看出DescendingSubMap是降序的SubMap，它的实现机制是将“SubMap的比较器反转”。</p>
<p>它继承于NavigableSubMap。而NavigableSubMap是一个继承于AbstractMap的抽象类；它包括2个子类——“(升序)AscendingSubMap”和”(降序)DescendingSubMap”。NavigableSubMap为它的两个子类实现了许多公共API。<br>下面看看NavigableSubMap的源码。</p>
<pre><code>static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements NavigableMap&lt;K,V&gt;, java.io.Serializable {
    // TreeMap的拷贝
    final TreeMap&lt;K,V&gt; m;
    // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”；
    // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记”
    // fromStart是“表示是否从第一个节点开始计算”，
    // toEnd是“表示是否计算到最后一个节点      ”
    final K lo, hi;      
    final boolean fromStart, toEnd;
    final boolean loInclusive, hiInclusive;

    // 构造函数
    NavigableSubMap(TreeMap&lt;K,V&gt; m,
                    boolean fromStart, K lo, boolean loInclusive,
                    boolean toEnd,     K hi, boolean hiInclusive) {
        if (!fromStart &amp;&amp; !toEnd) {
            if (m.compare(lo, hi) &gt; 0)
                throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;);
        } else {
            if (!fromStart) // type check
                m.compare(lo, lo);
            if (!toEnd)
                m.compare(hi, hi);
        }

        this.m = m;
        this.fromStart = fromStart;
        this.lo = lo;
        this.loInclusive = loInclusive;
        this.toEnd = toEnd;
        this.hi = hi;
        this.hiInclusive = hiInclusive;
    }

    // 判断key是否太小
    final boolean tooLow(Object key) {
        // 若该SubMap不包括“起始节点”，
        // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内”
        // 则判断key太小。其余情况都不是太小！
        if (!fromStart) {
            int c = m.compare(key, lo);
            if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive))
                return true;
        }
        return false;
    }

    // 判断key是否太大
    final boolean tooHigh(Object key) {
        // 若该SubMap不包括“结束节点”，
        // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内”
        // 则判断key太大。其余情况都不是太大！
        if (!toEnd) {
            int c = m.compare(key, hi);
            if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive))
                return true;
        }
        return false;
    }

    // 判断key是否在“lo和hi”开区间范围内
    final boolean inRange(Object key) {
        return !tooLow(key) &amp;&amp; !tooHigh(key);
    }

    // 判断key是否在封闭区间内
    final boolean inClosedRange(Object key) {
        return (fromStart || m.compare(key, lo) &gt;= 0)
            &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0);
    }

    // 判断key是否在区间内, inclusive是区间开关标志
    final boolean inRange(Object key, boolean inclusive) {
        return inclusive ? inRange(key) : inClosedRange(key);
    }

    // 返回最低的Entry
    final TreeMap.Entry&lt;K,V&gt; absLowest() {
    // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点
    // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry;
    //           否则，调用getHigherEntry(lo)获取大于lo的最小Entry
    TreeMap.Entry&lt;K,V&gt; e =
            (fromStart ?  m.getFirstEntry() :
             (loInclusive ? m.getCeilingEntry(lo) :
                            m.getHigherEntry(lo)));
        return (e == null || tooHigh(e.key)) ? null : e;
    }

    // 返回最高的Entry
    final TreeMap.Entry&lt;K,V&gt; absHighest() {
    // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点
    // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry;
    //           否则，调用getLowerEntry(hi)获取大于hi的最大Entry
    TreeMap.Entry&lt;K,V&gt; e =
    TreeMap.Entry&lt;K,V&gt; e =
            (toEnd ?  m.getLastEntry() :
             (hiInclusive ?  m.getFloorEntry(hi) :
                             m.getLowerEntry(hi)));
        return (e == null || tooLow(e.key)) ? null : e;
    }

    // 返回&quot;大于/等于key的最小的Entry&quot;
    final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) {
        // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry”
        // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！
        if (tooLow(key))
            return absLowest();
        // 获取“大于/等于key的最小Entry”
    TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key);
        return (e == null || tooHigh(e.key)) ? null : e;
    }

    // 返回&quot;大于key的最小的Entry&quot;
    final TreeMap.Entry&lt;K,V&gt; absHigher(K key) {
        // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry”
        // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！
        if (tooLow(key))
            return absLowest();
        // 获取“大于key的最小Entry”
    TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key);
        return (e == null || tooHigh(e.key)) ? null : e;
    }

    // 返回&quot;小于/等于key的最大的Entry&quot;
    final TreeMap.Entry&lt;K,V&gt; absFloor(K key) {
        // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry”
        // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！
        if (tooHigh(key))
            return absHighest();
    // 获取&quot;小于/等于key的最大的Entry&quot;
    TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key);
        return (e == null || tooLow(e.key)) ? null : e;
    }

    // 返回&quot;小于key的最大的Entry&quot;
    final TreeMap.Entry&lt;K,V&gt; absLower(K key) {
        // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry”
        // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！
        if (tooHigh(key))
            return absHighest();
    // 获取&quot;小于key的最大的Entry&quot;
    TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key);
        return (e == null || tooLow(e.key)) ? null : e;
    }

    // 返回“大于最大节点中的最小节点”，不存在的话，返回null
    final TreeMap.Entry&lt;K,V&gt; absHighFence() {
        return (toEnd ? null : (hiInclusive ?
                                m.getHigherEntry(hi) :
                                m.getCeilingEntry(hi)));
    }

    // 返回“小于最小节点中的最大节点”，不存在的话，返回null
    final TreeMap.Entry&lt;K,V&gt; absLowFence() {
        return (fromStart ? null : (loInclusive ?
                                    m.getLowerEntry(lo) :
                                    m.getFloorEntry(lo)));
    }

    // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法
    abstract TreeMap.Entry&lt;K,V&gt; subLowest();
    abstract TreeMap.Entry&lt;K,V&gt; subHighest();
    abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key);
    abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key);
    abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key);
    abstract TreeMap.Entry&lt;K,V&gt; subLower(K key);
    // 返回“顺序”的键迭代器
    abstract Iterator&lt;K&gt; keyIterator();
    // 返回“逆序”的键迭代器
    abstract Iterator&lt;K&gt; descendingKeyIterator();

    // 返回SubMap是否为空。空的话，返回true，否则返回false
    public boolean isEmpty() {
        return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty();
    }

    // 返回SubMap的大小
    public int size() {
        return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size();
    }

    // 返回SubMap是否包含键key
    public final boolean containsKey(Object key) {
        return inRange(key) &amp;&amp; m.containsKey(key);
    }

    // 将key-value 插入SubMap中
    public final V put(K key, V value) {
        if (!inRange(key))
            throw new IllegalArgumentException(&quot;key out of range&quot;);
        return m.put(key, value);
    }

    // 获取key对应值
    public final V get(Object key) {
        return !inRange(key)? null :  m.get(key);
    }

    // 删除key对应的键值对
    public final V remove(Object key) {
        return !inRange(key)? null  : m.remove(key);
    }

    // 获取“大于/等于key的最小键值对”
    public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
        return exportEntry(subCeiling(key));
    }

    // 获取“大于/等于key的最小键”
    public final K ceilingKey(K key) {
        return keyOrNull(subCeiling(key));
    }

    // 获取“大于key的最小键值对”
    public final Map.Entry&lt;K,V&gt; higherEntry(K key) {
        return exportEntry(subHigher(key));
    }

    // 获取“大于key的最小键”
    public final K higherKey(K key) {
        return keyOrNull(subHigher(key));
    }

    // 获取“小于/等于key的最大键值对”
    public final Map.Entry&lt;K,V&gt; floorEntry(K key) {
        return exportEntry(subFloor(key));
    }

    // 获取“小于/等于key的最大键”
    public final K floorKey(K key) {
        return keyOrNull(subFloor(key));
    }

    // 获取“小于key的最大键值对”
    public final Map.Entry&lt;K,V&gt; lowerEntry(K key) {
        return exportEntry(subLower(key));
    }

    // 获取“小于key的最大键”
    public final K lowerKey(K key) {
        return keyOrNull(subLower(key));
    }

    // 获取&quot;SubMap的第一个键&quot;
    public final K firstKey() {
        return key(subLowest());
    }

    // 获取&quot;SubMap的最后一个键&quot;
    public final K lastKey() {
        return key(subHighest());
    }

    // 获取&quot;SubMap的第一个键值对&quot;
    public final Map.Entry&lt;K,V&gt; firstEntry() {
        return exportEntry(subLowest());
    }

    // 获取&quot;SubMap的最后一个键值对&quot;
    public final Map.Entry&lt;K,V&gt; lastEntry() {
        return exportEntry(subHighest());
    }

    // 返回&quot;SubMap的第一个键值对&quot;，并从SubMap中删除改键值对
    public final Map.Entry&lt;K,V&gt; pollFirstEntry() {
    TreeMap.Entry&lt;K,V&gt; e = subLowest();
        Map.Entry&lt;K,V&gt; result = exportEntry(e);
        if (e != null)
            m.deleteEntry(e);
        return result;
    }

    // 返回&quot;SubMap的最后一个键值对&quot;，并从SubMap中删除改键值对
    public final Map.Entry&lt;K,V&gt; pollLastEntry() {
    TreeMap.Entry&lt;K,V&gt; e = subHighest();
        Map.Entry&lt;K,V&gt; result = exportEntry(e);
        if (e != null)
            m.deleteEntry(e);
        return result;
    }

    // Views
    transient NavigableMap&lt;K,V&gt; descendingMapView = null;
    transient EntrySetView entrySetView = null;
    transient KeySet&lt;K&gt; navigableKeySetView = null;

    // 返回NavigableSet对象，实际上返回的是当前对象的&quot;Key集合&quot;。 
    public final NavigableSet&lt;K&gt; navigableKeySet() {
        KeySet&lt;K&gt; nksv = navigableKeySetView;
        return (nksv != null) ? nksv :
            (navigableKeySetView = new TreeMap.KeySet(this));
    }

    // 返回&quot;Key集合&quot;对象
    public final Set&lt;K&gt; keySet() {
        return navigableKeySet();
    }

    // 返回“逆序”的Key集合
    public NavigableSet&lt;K&gt; descendingKeySet() {
        return descendingMap().navigableKeySet();
    }

    // 排列fromKey(包含) 到 toKey(不包含) 的子map
    public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
        return subMap(fromKey, true, toKey, false);
    }

    // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey)
    public final SortedMap&lt;K,V&gt; headMap(K toKey) {
        return headMap(toKey, false);
    }

    // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点]
    public final SortedMap&lt;K,V&gt; tailMap(K fromKey) {
        return tailMap(fromKey, true);
    }

    // Map的Entry的集合
    abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
        private transient int size = -1, sizeModCount;

        // 获取EntrySet的大小
        public int size() {
            // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小
            if (fromStart &amp;&amp; toEnd)
                return m.size();
            // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素
            if (size == -1 || sizeModCount != m.modCount) {
                sizeModCount = m.modCount;
                size = 0;
                Iterator i = iterator();
                while (i.hasNext()) {
                    size++;
                    i.next();
                }
            }
            return size;
        }

        // 判断EntrySetView是否为空
        public boolean isEmpty() {
            TreeMap.Entry&lt;K,V&gt; n = absLowest();
            return n == null || tooHigh(n.key);
        }

        // 判断EntrySetView是否包含Object
        public boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
            K key = entry.getKey();
            if (!inRange(key))
                return false;
            TreeMap.Entry node = m.getEntry(key);
            return node != null &amp;&amp;
                valEquals(node.getValue(), entry.getValue());
        }

        // 从EntrySetView中删除Object
        public boolean remove(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
            K key = entry.getKey();
            if (!inRange(key))
                return false;
            TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key);
            if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue())){
                m.deleteEntry(node);
                return true;
            }
            return false;
        }
    }

    // SubMap的迭代器
    abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; {
        // 上一次被返回的Entry
        TreeMap.Entry&lt;K,V&gt; lastReturned;
        // 指向下一个Entry
        TreeMap.Entry&lt;K,V&gt; next;
        // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义
        final K fenceKey;
        int expectedModCount;

        // 构造函数
        SubMapIterator(TreeMap.Entry&lt;K,V&gt; first,
                       TreeMap.Entry&lt;K,V&gt; fence) {
            // 每创建一个SubMapIterator时，保存修改次数
            // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。
            // 这就是所说的fast-fail机制的原理！
            expectedModCount = m.modCount;
            lastReturned = null;
            next = first;
            fenceKey = fence == null ? null : fence.key;
        }

        // 是否存在下一个Entry
        public final boolean hasNext() {
            return next != null &amp;&amp; next.key != fenceKey;
        }

        // 返回下一个Entry
        final TreeMap.Entry&lt;K,V&gt; nextEntry() {
            TreeMap.Entry&lt;K,V&gt; e = next;
            if (e == null || e.key == fenceKey)
                throw new NoSuchElementException();
            if (m.modCount != expectedModCount)
                throw new ConcurrentModificationException();
            // next指向e的后继节点
            next = successor(e);
    lastReturned = e;
            return e;
        }

        // 返回上一个Entry
        final TreeMap.Entry&lt;K,V&gt; prevEntry() {
            TreeMap.Entry&lt;K,V&gt; e = next;
            if (e == null || e.key == fenceKey)
                throw new NoSuchElementException();
            if (m.modCount != expectedModCount)
                throw new ConcurrentModificationException();
            // next指向e的前继节点
            next = predecessor(e);
    lastReturned = e;
            return e;
        }

        // 删除当前节点(用于“升序的SubMap”)。
        // 删除之后，可以继续升序遍历；红黑树特性没变。
        final void removeAscending() {
            if (lastReturned == null)
                throw new IllegalStateException();
            if (m.modCount != expectedModCount)
                throw new ConcurrentModificationException();
            // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。
            // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。
            //     根据“红黑树”的特性可知：
            //     当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。
            //     这意味着“当被删除节点有两个儿子时，删除当前节点之后，&apos;新的当前节点&apos;实际上是‘原有的后继节点(即下一个节点)’”。
            //     而此时next仍然指向&quot;新的当前节点&quot;。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。
            if (lastReturned.left != null &amp;&amp; lastReturned.right != null)
                next = lastReturned;
            m.deleteEntry(lastReturned);
            lastReturned = null;
            expectedModCount = m.modCount;
        }

        // 删除当前节点(用于“降序的SubMap”)。
        // 删除之后，可以继续降序遍历；红黑树特性没变。
        final void removeDescending() {
            if (lastReturned == null)
                throw new IllegalStateException();
            if (m.modCount != expectedModCount)
                throw new ConcurrentModificationException();
            m.deleteEntry(lastReturned);
            lastReturned = null;
            expectedModCount = m.modCount;
        }

    }

    // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator
    final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first,
                            TreeMap.Entry&lt;K,V&gt; fence) {
            super(first, fence);
        }
        // 获取下一个节点(升序)
        public Map.Entry&lt;K,V&gt; next() {
            return nextEntry();
        }
        // 删除当前节点(升序)
        public void remove() {
            removeAscending();
        }
    }

    // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator
    final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; {
        SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first,
                          TreeMap.Entry&lt;K,V&gt; fence) {
            super(first, fence);
        }
        // 获取下一个节点(升序)
        public K next() {
            return nextEntry().key;
        }
        // 删除当前节点(升序)
        public void remove() {
            removeAscending();
        }
    }

    // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator
    final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last,
                                      TreeMap.Entry&lt;K,V&gt; fence) {
            super(last, fence);
        }

        // 获取下一个节点(降序)
        public Map.Entry&lt;K,V&gt; next() {
            return prevEntry();
        }
        // 删除当前节点(降序)
        public void remove() {
            removeDescending();
        }
    }

    // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator
    final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; {
        DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last,
                                    TreeMap.Entry&lt;K,V&gt; fence) {
            super(last, fence);
        }
        // 获取下一个节点(降序)
        public K next() {
            return prevEntry().key;
        }
        // 删除当前节点(降序)
        public void remove() {
            removeDescending();
        }
    }
}</code></pre><p>NavigableSubMap源码很多，但不难理解；读者可以通过源码和注释进行理解。</p>
<p>其实，读完NavigableSubMap的源码后，我们可以得出它的核心思想是：它是一个抽象集合类，为2个子类——“(升序)AscendingSubMap”和”(降序)DescendingSubMap”而服务；因为NavigableSubMap实现了许多公共API。它的最终目的是实现下面的一系列函数：</p>
<pre><code>headMap(K toKey, boolean inclusive) 
headMap(K toKey)
subMap(K fromKey, K toKey)
subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
tailMap(K fromKey)
tailMap(K fromKey, boolean inclusive)
navigableKeySet() 
descendingKeySet()</code></pre><h2 id="第3-10部分-TreeMap其它函数"><a href="#第3-10部分-TreeMap其它函数" class="headerlink" title="第3.10部分 TreeMap其它函数"></a>第3.10部分 TreeMap其它函数</h2><h3 id="1-顺序遍历和逆序遍历"><a href="#1-顺序遍历和逆序遍历" class="headerlink" title="1 顺序遍历和逆序遍历"></a>1 顺序遍历和逆序遍历</h3><p>TreeMap的顺序遍历和逆序遍历原理非常简单。<br>由于TreeMap中的元素是从小到大的顺序排列的。因此，顺序遍历，就是从第一个元素开始，逐个向后遍历；而倒序遍历则恰恰相反，它是从最后一个元素开始，逐个往前遍历。</p>
<p>我们可以通过 keyIterator() 和 descendingKeyIterator()来说明！<br>keyIterator()的作用是返回顺序的KEY的集合，<br>descendingKeyIterator()的作用是返回逆序的KEY的集合。</p>
<p>keyIterator() 的代码如下：</p>
<pre><code>Iterator&lt;K&gt; keyIterator() {
    return new KeyIterator(getFirstEntry());
}</code></pre><p>说明：从中我们可以看出keyIterator() 是返回以“第一个节点(getFirstEntry)” 为其实元素的迭代器。</p>
<p>KeyIterator的代码如下：</p>
<pre><code>final class KeyIterator extends PrivateEntryIterator&lt;K&gt; {
    KeyIterator(Entry&lt;K,V&gt; first) {
        super(first);
    }
    public K next() {
        return nextEntry().key;
    }
}</code></pre><p>说明：KeyIterator继承于PrivateEntryIterator。当我们通过next()不断获取下一个元素的时候，就是执行的顺序遍历了。</p>
<p>descendingKeyIterator()的代码如下：</p>
<pre><code>Iterator&lt;K&gt; descendingKeyIterator() {
    return new DescendingKeyIterator(getLastEntry());
}</code></pre><p>说明：从中我们可以看出descendingKeyIterator() 是返回以“最后一个节点(getLastEntry)” 为其实元素的迭代器。<br>再看看DescendingKeyIterator的代码：</p>
<pre><code>final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; {
    DescendingKeyIterator(Entry&lt;K,V&gt; first) {
        super(first);
    }
    public K next() {
        return prevEntry().key;
    }
}</code></pre><p>说明：DescendingKeyIterator继承于PrivateEntryIterator。当我们通过next()不断获取下一个元素的时候，实际上调用的是prevEntry()获取的上一个节点，这样它实际上执行的是逆序遍历了。</p>
<p>至此，TreeMap的相关内容就全部介绍完毕了。若有错误或纰漏的地方，欢迎指正！</p>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-TreeMap遍历方式"><a href="#第4部分-TreeMap遍历方式" class="headerlink" title="第4部分 TreeMap遍历方式"></a>第4部分 TreeMap遍历方式</h1><h2 id="4-1-遍历TreeMap的键值对"><a href="#4-1-遍历TreeMap的键值对" class="headerlink" title="4.1 遍历TreeMap的键值对"></a>4.1 遍历TreeMap的键值对</h2><p>第一步：根据entrySet()获取TreeMap的“键值对”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是TreeMap对象
// map中的key是String类型，value是Integer类型
Integer integ = null;
Iterator iter = map.entrySet().iterator();
while(iter.hasNext()) {
    Map.Entry entry = (Map.Entry)iter.next();
    // 获取key
    key = (String)entry.getKey();
        // 获取value
    integ = (Integer)entry.getValue();
}</code></pre><h2 id="4-2-遍历TreeMap的键"><a href="#4-2-遍历TreeMap的键" class="headerlink" title="4.2 遍历TreeMap的键"></a>4.2 遍历TreeMap的键</h2><p>第一步：根据keySet()获取TreeMap的“键”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是TreeMap对象
// map中的key是String类型，value是Integer类型
String key = null;
Integer integ = null;
Iterator iter = map.keySet().iterator();
while (iter.hasNext()) {
        // 获取key
    key = (String)iter.next();
        // 根据key，获取value
    integ = (Integer)map.get(key);
}</code></pre><h2 id="4-3-遍历TreeMap的值"><a href="#4-3-遍历TreeMap的值" class="headerlink" title="4.3 遍历TreeMap的值"></a>4.3 遍历TreeMap的值</h2><p>第一步：根据value()获取TreeMap的“值”的集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是TreeMap对象
// map中的key是String类型，value是Integer类型
Integer value = null;
Collection c = map.values();
Iterator iter= c.iterator();
while (iter.hasNext()) {
    value = (Integer)iter.next();
}</code></pre><p>TreeMap遍历测试程序如下：</p>
<pre><code>import java.util.Map;
import java.util.Random;
import java.util.Iterator;
import java.util.TreeMap;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Collection;

/*
 * @desc 遍历TreeMap的测试程序。
 *   (01) 通过entrySet()去遍历key、value，参考实现函数：
 *        iteratorTreeMapByEntryset()
 *   (02) 通过keySet()去遍历key、value，参考实现函数：
 *        iteratorTreeMapByKeyset()
 *   (03) 通过values()去遍历value，参考实现函数：
 *        iteratorTreeMapJustValues()
 *
 * @author skywang
 */
public class TreeMapIteratorTest {

    public static void main(String[] args) {
        int val = 0;
        String key = null;
        Integer value = null;
        Random r = new Random();
        TreeMap map = new TreeMap();

        for (int i=0; i&lt;12; i++) {
            // 随机获取一个[0,100)之间的数字
            val = r.nextInt(100);

            key = String.valueOf(val);
            value = r.nextInt(5);
            // 添加到TreeMap中
            map.put(key, value);
            System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value);
        }
        // 通过entrySet()遍历TreeMap的key-value
        iteratorTreeMapByEntryset(map) ;

        // 通过keySet()遍历TreeMap的key-value
        iteratorTreeMapByKeyset(map) ;

        // 单单遍历TreeMap的value
        iteratorTreeMapJustValues(map);        
    }

    /*
     * 通过entry set遍历TreeMap
     * 效率高!
     */
    private static void iteratorTreeMapByEntryset(TreeMap map) {
        if (map == null)
            return ;

        System.out.println(&quot;\niterator TreeMap By entryset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = map.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();

            key = (String)entry.getKey();
            integ = (Integer)entry.getValue();
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }

    /*
     * 通过keyset来遍历TreeMap
     * 效率低!
     */
    private static void iteratorTreeMapByKeyset(TreeMap map) {
        if (map == null)
            return ;

        System.out.println(&quot;\niterator TreeMap By keyset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = map.keySet().iterator();
        while (iter.hasNext()) {
            key = (String)iter.next();
            integ = (Integer)map.get(key);
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }


    /*
     * 遍历TreeMap的values
     */
    private static void iteratorTreeMapJustValues(TreeMap map) {
        if (map == null)
            return ;

        Collection c = map.values();
        Iterator iter= c.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
       }
    }
}</code></pre><p><a name="anchor5"></a></p>
<h1 id="第5部分-TreeMap示例"><a href="#第5部分-TreeMap示例" class="headerlink" title="第5部分 TreeMap示例"></a>第5部分 TreeMap示例</h1><p>下面通过实例来学习如何使用TreeMap</p>
<pre><code>import java.util.*;

/**
 * @desc TreeMap测试程序 
 *
 * @author skywang
 */
public class TreeMapTest  {

    public static void main(String[] args) {
        // 测试常用的API
        testTreeMapOridinaryAPIs();

        // 测试TreeMap的导航函数
        //testNavigableMapAPIs();

        // 测试TreeMap的子Map函数
        //testSubMapAPIs();
    }

    /**
     * 测试常用的API
     */
    private static void testTreeMapOridinaryAPIs() {
        // 初始化随机种子
        Random r = new Random();
        // 新建TreeMap
        TreeMap tmap = new TreeMap();
        // 添加操作
        tmap.put(&quot;one&quot;, r.nextInt(10));
        tmap.put(&quot;two&quot;, r.nextInt(10));
        tmap.put(&quot;three&quot;, r.nextInt(10));

        System.out.printf(&quot;\n ---- testTreeMapOridinaryAPIs ----\n&quot;);
        // 打印出TreeMap
        System.out.printf(&quot;%s\n&quot;,tmap );

        // 通过Iterator遍历key-value
        Iterator iter = tmap.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            System.out.printf(&quot;next : %s - %s\n&quot;, entry.getKey(), entry.getValue());
        }

        // TreeMap的键值对个数        
        System.out.printf(&quot;size: %s\n&quot;, tmap.size());

        // containsKey(Object key) :是否包含键key
        System.out.printf(&quot;contains key two : %s\n&quot;,tmap.containsKey(&quot;two&quot;));
        System.out.printf(&quot;contains key five : %s\n&quot;,tmap.containsKey(&quot;five&quot;));

        // containsValue(Object value) :是否包含值value
        System.out.printf(&quot;contains value 0 : %s\n&quot;,tmap.containsValue(new Integer(0)));

        // remove(Object key) ： 删除键key对应的键值对
        tmap.remove(&quot;three&quot;);

        System.out.printf(&quot;tmap:%s\n&quot;,tmap );

        // clear() ： 清空TreeMap
        tmap.clear();

        // isEmpty() : TreeMap是否为空
        System.out.printf(&quot;%s\n&quot;, (tmap.isEmpty()?&quot;tmap is empty&quot;:&quot;tmap is not empty&quot;) );
    }


    /**
     * 测试TreeMap的子Map函数
     */
    public static void testSubMapAPIs() {
        // 新建TreeMap
        TreeMap tmap = new TreeMap();
        // 添加“键值对”
        tmap.put(&quot;a&quot;, 101);
        tmap.put(&quot;b&quot;, 102);
        tmap.put(&quot;c&quot;, 103);
        tmap.put(&quot;d&quot;, 104);
        tmap.put(&quot;e&quot;, 105);

        System.out.printf(&quot;\n ---- testSubMapAPIs ----\n&quot;);
        // 打印出TreeMap
        System.out.printf(&quot;tmap:\n\t%s\n&quot;, tmap);

        // 测试 headMap(K toKey)
        System.out.printf(&quot;tmap.headMap(\&quot;c\&quot;):\n\t%s\n&quot;, tmap.headMap(&quot;c&quot;));
        // 测试 headMap(K toKey, boolean inclusive) 
        System.out.printf(&quot;tmap.headMap(\&quot;c\&quot;, true):\n\t%s\n&quot;, tmap.headMap(&quot;c&quot;, true));
        System.out.printf(&quot;tmap.headMap(\&quot;c\&quot;, false):\n\t%s\n&quot;, tmap.headMap(&quot;c&quot;, false));

        // 测试 tailMap(K fromKey)
        System.out.printf(&quot;tmap.tailMap(\&quot;c\&quot;):\n\t%s\n&quot;, tmap.tailMap(&quot;c&quot;));
        // 测试 tailMap(K fromKey, boolean inclusive)
        System.out.printf(&quot;tmap.tailMap(\&quot;c\&quot;, true):\n\t%s\n&quot;, tmap.tailMap(&quot;c&quot;, true));
        System.out.printf(&quot;tmap.tailMap(\&quot;c\&quot;, false):\n\t%s\n&quot;, tmap.tailMap(&quot;c&quot;, false));

        // 测试 subMap(K fromKey, K toKey)
        System.out.printf(&quot;tmap.subMap(\&quot;a\&quot;, \&quot;c\&quot;):\n\t%s\n&quot;, tmap.subMap(&quot;a&quot;, &quot;c&quot;));
        // 测试 
        System.out.printf(&quot;tmap.subMap(\&quot;a\&quot;, true, \&quot;c\&quot;, true):\n\t%s\n&quot;, 
                tmap.subMap(&quot;a&quot;, true, &quot;c&quot;, true));
        System.out.printf(&quot;tmap.subMap(\&quot;a\&quot;, true, \&quot;c\&quot;, false):\n\t%s\n&quot;, 
                tmap.subMap(&quot;a&quot;, true, &quot;c&quot;, false));
        System.out.printf(&quot;tmap.subMap(\&quot;a\&quot;, false, \&quot;c\&quot;, true):\n\t%s\n&quot;, 
                tmap.subMap(&quot;a&quot;, false, &quot;c&quot;, true));
        System.out.printf(&quot;tmap.subMap(\&quot;a\&quot;, false, \&quot;c\&quot;, false):\n\t%s\n&quot;, 
                tmap.subMap(&quot;a&quot;, false, &quot;c&quot;, false));

        // 测试 navigableKeySet()
        System.out.printf(&quot;tmap.navigableKeySet():\n\t%s\n&quot;, tmap.navigableKeySet());
        // 测试 descendingKeySet()
        System.out.printf(&quot;tmap.descendingKeySet():\n\t%s\n&quot;, tmap.descendingKeySet());
    }

    /**
     * 测试TreeMap的导航函数
     */
    public static void testNavigableMapAPIs() {
        // 新建TreeMap
        NavigableMap nav = new TreeMap();
        // 添加“键值对”
        nav.put(&quot;aaa&quot;, 111);
        nav.put(&quot;bbb&quot;, 222);
        nav.put(&quot;eee&quot;, 333);
        nav.put(&quot;ccc&quot;, 555);
        nav.put(&quot;ddd&quot;, 444);

        System.out.printf(&quot;\n ---- testNavigableMapAPIs ----\n&quot;);
        // 打印出TreeMap
        System.out.printf(&quot;Whole list:%s%n&quot;, nav);

        // 获取第一个key、第一个Entry
        System.out.printf(&quot;First key: %s\tFirst entry: %s%n&quot;,nav.firstKey(), nav.firstEntry());

        // 获取最后一个key、最后一个Entry
        System.out.printf(&quot;Last key: %s\tLast entry: %s%n&quot;,nav.lastKey(), nav.lastEntry());

        // 获取“小于/等于bbb”的最大键值对
        System.out.printf(&quot;Key floor before bbb: %s%n&quot;,nav.floorKey(&quot;bbb&quot;));

        // 获取“小于bbb”的最大键值对
        System.out.printf(&quot;Key lower before bbb: %s%n&quot;, nav.lowerKey(&quot;bbb&quot;));

        // 获取“大于/等于bbb”的最小键值对
        System.out.printf(&quot;Key ceiling after ccc: %s%n&quot;,nav.ceilingKey(&quot;ccc&quot;));

        // 获取“大于bbb”的最小键值对
        System.out.printf(&quot;Key higher after ccc: %s%n\n&quot;,nav.higherKey(&quot;ccc&quot;));
    }
}</code></pre><p>运行结果：</p>
<pre><code>{one=8, three=4, two=2}
next : one - 8
next : three - 4
next : two - 2
size: 3
contains key two : true
contains key five : false
contains value 0 : false
tmap:{one=8, two=2}
tmap is empty</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>
<p>[link_rdtree_introduce]: </p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/11/java/collection/2012-02-11-collection-11-hashtable/" itemprop="url">Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-11T01:01:00.000Z" itemprop="datePublished">2月 11 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 read (About 9078 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前一章，我们学习了HashMap。这一章，我们对Hashtable进行学习。<br>我们先对Hashtable有个整体认识，然后再学习它的源码，最后再通过实例来学会使用Hashtable。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 Hashtable介绍</a><br><a href="#anchor2">第2部分 Hashtable数据结构</a><br><a href="#anchor3">第3部分 Hashtable源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 Hashtable遍历方式</a><br><a href="#anchor5">第5部分 Hashtable示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-Hashtable介绍"><a href="#第1部分-Hashtable介绍" class="headerlink" title="第1部分 Hashtable介绍"></a>第1部分 Hashtable介绍</h1><p><strong>Hashtable 简介</strong></p>
<p>和HashMap一样，Hashtable 也是一个散列表，它存储的内容是键值对(key-value)映射。<br>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。<br>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。</p>
<p>Hashtable 的实例有两个参数影响其性能：初始容量 和 加载因子。容量 是哈希表中桶 的数量，初始容量 就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数 Hashtable 操作中，包括 get 和 put 操作，都反映了这一点）。</p>
<p><strong>Hashtable的构造函数</strong></p>
<pre><code>// 默认构造函数。
public Hashtable() 

// 指定“容量大小”的构造函数
public Hashtable(int initialCapacity) 

// 指定“容量大小”和“加载因子”的构造函数
public Hashtable(int initialCapacity, float loadFactor) 

// 包含“子Map”的构造函数
public Hashtable(Map&lt;? extends K, ? extends V&gt; t)</code></pre><p><strong>Hashtable的API</strong></p>
<pre><code>synchronized void                clear()
synchronized Object              clone()
             boolean             contains(Object value)
synchronized boolean             containsKey(Object key)
synchronized boolean             containsValue(Object value)
synchronized Enumeration&lt;V&gt;      elements()
synchronized Set&lt;Entry&lt;K, V&gt;&gt;    entrySet()
synchronized boolean             equals(Object object)
synchronized V                   get(Object key)
synchronized int                 hashCode()
synchronized boolean             isEmpty()
synchronized Set&lt;K&gt;              keySet()
synchronized Enumeration&lt;K&gt;      keys()
synchronized V                   put(K key, V value)
synchronized void                putAll(Map&lt;? extends K, ? extends V&gt; map)
synchronized V                   remove(Object key)
synchronized int                 size()
synchronized String              toString()
synchronized Collection&lt;V&gt;       values()</code></pre><p><a name="anchor2"></a></p>
<h1 id="第2部分-Hashtable数据结构"><a href="#第2部分-Hashtable数据结构" class="headerlink" title="第2部分 Hashtable数据结构"></a>第2部分 Hashtable数据结构</h1><p>Hashtable的继承关系</p>
<pre><code>java.lang.Object
   ↳     java.util.Dictionary&lt;K, V&gt;
     ↳     java.util.Hashtable&lt;K, V&gt;</code></pre><p>Hashtable的声明</p>
<pre><code>public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable { }</code></pre><p>Hashtable与Map关系如下图：</p>
<p><img src="/media/pic/java/collection/collection11.jpg" alt="img"></p>
<p>从图中可以看出：<br>(01) Hashtable继承于Dictionary类，实现了Map接口。Map是”key-value键值对”接口，Dictionary是声明了操作”键值对”函数接口的抽象类。<br>(02) Hashtable是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。<br>&nbsp;&nbsp;table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。<br>&nbsp;&nbsp;count是Hashtable的大小，它是Hashtable保存的键值对的数量。<br>&nbsp;&nbsp;threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。<br>&nbsp;&nbsp;loadFactor就是加载因子。<br>&nbsp;&nbsp;modCount是用来实现fail-fast机制的</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-Hashtable源码解析-基于JDK1-6-0-45"><a href="#第3部分-Hashtable源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 Hashtable源码解析(基于JDK1.6.0_45)"></a>第3部分 Hashtable源码解析(基于JDK1.6.0_45)</h1><p>为了更了解Hashtable的原理，下面对Hashtable源码代码作出分析。<br>在阅读源码时，建议参考后面的说明来建立对Hashtable的整体认识，这样更容易理解Hashtable。</p>
<pre><code>package java.util;
import java.io.*;

public class Hashtable&lt;K,V&gt;
    extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable {

    // Hashtable保存key-value的数组。
    // Hashtable是采用拉链法实现的，每一个Entry本质上是一个单向链表
    private transient Entry[] table;

    // Hashtable中元素的实际数量
    private transient int count;

    // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子）
    private int threshold;

    // 加载因子
    private float loadFactor;

    // Hashtable被改变的次数
    private transient int modCount = 0;

    // 序列版本号
    private static final long serialVersionUID = 1421746759512286392L;

    // 指定“容量大小”和“加载因子”的构造函数
    public Hashtable(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);

        if (initialCapacity==0)
            initialCapacity = 1;
        this.loadFactor = loadFactor;
        table = new Entry[initialCapacity];
        threshold = (int)(initialCapacity * loadFactor);
    }

    // 指定“容量大小”的构造函数
    public Hashtable(int initialCapacity) {
        this(initialCapacity, 0.75f);
    }

    // 默认构造函数。
    public Hashtable() {
        // 默认构造函数，指定的容量大小是11；加载因子是0.75
        this(11, 0.75f);
    }

    // 包含“子Map”的构造函数
    public Hashtable(Map&lt;? extends K, ? extends V&gt; t) {
        this(Math.max(2*t.size(), 11), 0.75f);
        // 将“子Map”的全部元素都添加到Hashtable中
        putAll(t);
    }

    public synchronized int size() {
        return count;
    }

    public synchronized boolean isEmpty() {
        return count == 0;
    }

    // 返回“所有key”的枚举对象
    public synchronized Enumeration&lt;K&gt; keys() {
        return this.&lt;K&gt;getEnumeration(KEYS);
    }

    // 返回“所有value”的枚举对象
    public synchronized Enumeration&lt;V&gt; elements() {
        return this.&lt;V&gt;getEnumeration(VALUES);
    }

    // 判断Hashtable是否包含“值(value)”
    public synchronized boolean contains(Object value) {
        // Hashtable中“键值对”的value不能是null，
        // 若是null的话，抛出异常!
        if (value == null) {
            throw new NullPointerException();
        }

        // 从后向前遍历table数组中的元素(Entry)
        // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value
        Entry tab[] = table;
        for (int i = tab.length ; i-- &gt; 0 ;) {
            for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) {
                if (e.value.equals(value)) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean containsValue(Object value) {
        return contains(value);
    }

    // 判断Hashtable是否包含key
    public synchronized boolean containsKey(Object key) {
        Entry tab[] = table;
        int hash = key.hashCode();
        // 计算索引值，
        // % tab.length 的目的是防止数据越界
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素
        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                return true;
            }
        }
        return false;
    }

    // 返回key对应的value，没有的话返回null
    public synchronized V get(Object key) {
        Entry tab[] = table;
        int hash = key.hashCode();
        // 计算索引值，
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素
        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                return e.value;
            }
        }
        return null;
    }

    // 调整Hashtable的长度，将长度变成原来的(2倍+1)
    // (01) 将“旧的Entry数组”赋值给一个临时变量。
    // (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组”
    // (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中
    protected void rehash() {
        int oldCapacity = table.length;
        Entry[] oldMap = table;

        int newCapacity = oldCapacity * 2 + 1;
        Entry[] newMap = new Entry[newCapacity];

        modCount++;
        threshold = (int)(newCapacity * loadFactor);
        table = newMap;

        for (int i = oldCapacity ; i-- &gt; 0 ;) {
            for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) {
                Entry&lt;K,V&gt; e = old;
                old = old.next;

                int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;
                e.next = newMap[index];
                newMap[index] = e;
            }
        }
    }

    // 将“key-value”添加到Hashtable中
    public synchronized V put(K key, V value) {
        // Hashtable中不能插入value为null的元素！！！
        if (value == null) {
            throw new NullPointerException();
        }

        // 若“Hashtable中已存在键为key的键值对”，
        // 则用“新的value”替换“旧的value”
        Entry tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                V old = e.value;
                e.value = value;
                return old;
                }
        }

        // 若“Hashtable中不存在键为key的键值对”，
        // (01) 将“修改统计数”+1
        modCount++;
        // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)
        //  则调整Hashtable的大小
        if (count &gt;= threshold) {
            // Rehash the table if the threshold is exceeded
            rehash();

            tab = table;
            index = (hash &amp; 0x7FFFFFFF) % tab.length;
        }

        // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中
        Entry&lt;K,V&gt; e = tab[index];
        // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。        
        tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e);
        // (05) 将“Hashtable的实际容量”+1
        count++;
        return null;
    }

    // 删除Hashtable中键为key的元素
    public synchronized V remove(Object key) {
        Entry tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        // 找到“key对应的Entry(链表)”
        // 然后在链表中找出要删除的节点，并删除该节点。
        for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                modCount++;
                if (prev != null) {
                    prev.next = e.next;
                } else {
                    tab[index] = e.next;
                }
                count--;
                V oldValue = e.value;
                e.value = null;
                return oldValue;
            }
        }
        return null;
    }

    // 将“Map(t)”的中全部元素逐一添加到Hashtable中
    public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) {
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())
            put(e.getKey(), e.getValue());
    }

    // 清空Hashtable
    // 将Hashtable的table数组的值全部设为null
    public synchronized void clear() {
        Entry tab[] = table;
        modCount++;
        for (int index = tab.length; --index &gt;= 0; )
            tab[index] = null;
        count = 0;
    }

    // 克隆一个Hashtable，并以Object的形式返回。
    public synchronized Object clone() {
        try {
            Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone();
            t.table = new Entry[table.length];
            for (int i = table.length ; i-- &gt; 0 ; ) {
                t.table[i] = (table[i] != null)
                ? (Entry&lt;K,V&gt;) table[i].clone() : null;
            }
            t.keySet = null;
            t.entrySet = null;
            t.values = null;
            t.modCount = 0;
            return t;
        } catch (CloneNotSupportedException e) {
            // this shouldn&apos;t happen, since we are Cloneable
            throw new InternalError();
        }
    }

    public synchronized String toString() {
        int max = size() - 1;
        if (max == -1)
            return &quot;{}&quot;;

        StringBuilder sb = new StringBuilder();
        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator();

        sb.append(&apos;{&apos;);
        for (int i = 0; ; i++) {
            Map.Entry&lt;K,V&gt; e = it.next();
            K key = e.getKey();
            V value = e.getValue();
            sb.append(key   == this ? &quot;(this Map)&quot; : key.toString());
            sb.append(&apos;=&apos;);
            sb.append(value == this ? &quot;(this Map)&quot; : value.toString());

            if (i == max)
                return sb.append(&apos;}&apos;).toString();
            sb.append(&quot;, &quot;);
        }
    }

    // 获取Hashtable的枚举类对象
    // 若Hashtable的实际大小为0,则返回“空枚举类”对象；
    // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)
    private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) {
    if (count == 0) {
        return (Enumeration&lt;T&gt;)emptyEnumerator;
    } else {
        return new Enumerator&lt;T&gt;(type, false);
    }
    }

    // 获取Hashtable的迭代器
    // 若Hashtable的实际大小为0,则返回“空迭代器”对象；
    // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)
    private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) {
        if (count == 0) {
            return (Iterator&lt;T&gt;) emptyIterator;
        } else {
            return new Enumerator&lt;T&gt;(type, true);
        }
    }

    // Hashtable的“key的集合”。它是一个Set，意味着没有重复元素
    private transient volatile Set&lt;K&gt; keySet = null;
    // Hashtable的“key-value的集合”。它是一个Set，意味着没有重复元素
    private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
    // Hashtable的“key-value的集合”。它是一个Collection，意味着可以有重复元素
    private transient volatile Collection&lt;V&gt; values = null;

    // 返回一个被synchronizedSet封装后的KeySet对象
    // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步
    public Set&lt;K&gt; keySet() {
        if (keySet == null)
            keySet = Collections.synchronizedSet(new KeySet(), this);
        return keySet;
    }

    // Hashtable的Key的Set集合。
    // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。
    private class KeySet extends AbstractSet&lt;K&gt; {
        public Iterator&lt;K&gt; iterator() {
            return getIterator(KEYS);
        }
        public int size() {
            return count;
        }
        public boolean contains(Object o) {
            return containsKey(o);
        }
        public boolean remove(Object o) {
            return Hashtable.this.remove(o) != null;
        }
        public void clear() {
            Hashtable.this.clear();
        }
    }

    // 返回一个被synchronizedSet封装后的EntrySet对象
    // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        if (entrySet==null)
            entrySet = Collections.synchronizedSet(new EntrySet(), this);
        return entrySet;
    }

    // Hashtable的Entry的Set集合。
    // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。
    private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
            return getIterator(ENTRIES);
        }

        public boolean add(Map.Entry&lt;K,V&gt; o) {
            return super.add(o);
        }

        // 查找EntrySet中是否包含Object(0)
        // 首先，在table中找到o对应的Entry(Entry是一个单向链表)
        // 然后，查找Entry链表中是否存在Object
        public boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry entry = (Map.Entry)o;
            Object key = entry.getKey();
            Entry[] tab = table;
            int hash = key.hashCode();
            int index = (hash &amp; 0x7FFFFFFF) % tab.length;

            for (Entry e = tab[index]; e != null; e = e.next)
                if (e.hash==hash &amp;&amp; e.equals(entry))
                    return true;
            return false;
        }

        // 删除元素Object(0)
        // 首先，在table中找到o对应的Entry(Entry是一个单向链表)
        // 然后，删除链表中的元素Object
        public boolean remove(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
            K key = entry.getKey();
            Entry[] tab = table;
            int hash = key.hashCode();
            int index = (hash &amp; 0x7FFFFFFF) % tab.length;

            for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null;
                 prev = e, e = e.next) {
                if (e.hash==hash &amp;&amp; e.equals(entry)) {
                    modCount++;
                    if (prev != null)
                        prev.next = e.next;
                    else
                        tab[index] = e.next;

                    count--;
                    e.value = null;
                    return true;
                }
            }
            return false;
        }

        public int size() {
            return count;
        }

        public void clear() {
            Hashtable.this.clear();
        }
    }

    // 返回一个被synchronizedCollection封装后的ValueCollection对象
    // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步
    public Collection&lt;V&gt; values() {
    if (values==null)
        values = Collections.synchronizedCollection(new ValueCollection(),
                                                        this);
        return values;
    }

    // Hashtable的value的Collection集合。
    // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。
    private class ValueCollection extends AbstractCollection&lt;V&gt; {
        public Iterator&lt;V&gt; iterator() {
        return getIterator(VALUES);
        }
        public int size() {
            return count;
        }
        public boolean contains(Object o) {
            return containsValue(o);
        }
        public void clear() {
            Hashtable.this.clear();
        }
    }

    // 重新equals()函数
    // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等
    public synchronized boolean equals(Object o) {
        if (o == this)
            return true;

        if (!(o instanceof Map))
            return false;
        Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o;
        if (t.size() != size())
            return false;

        try {
            // 通过迭代器依次取出当前Hashtable的key-value键值对
            // 并判断该键值对，存在于Hashtable(o)中。
            // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。
            Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();
            while (i.hasNext()) {
                Map.Entry&lt;K,V&gt; e = i.next();
                K key = e.getKey();
                V value = e.getValue();
                if (value == null) {
                    if (!(t.get(key)==null &amp;&amp; t.containsKey(key)))
                        return false;
                } else {
                    if (!value.equals(t.get(key)))
                        return false;
                }
            }
        } catch (ClassCastException unused)   {
            return false;
        } catch (NullPointerException unused) {
            return false;
        }

        return true;
    }

    // 计算Hashtable的哈希值
    // 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。
    // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。
    public synchronized int hashCode() {
        int h = 0;
        if (count == 0 || loadFactor &lt; 0)
            return h;  // Returns zero

        loadFactor = -loadFactor;  // Mark hashCode computation in progress
        Entry[] tab = table;
        for (int i = 0; i &lt; tab.length; i++)
            for (Entry e = tab[i]; e != null; e = e.next)
                h += e.key.hashCode() ^ e.value.hashCode();
        loadFactor = -loadFactor;  // Mark hashCode computation complete

        return h;
    }

    // java.io.Serializable的写入函数
    // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException
    {
        // Write out the length, threshold, loadfactor
        s.defaultWriteObject();

        // Write out length, count of elements and then the key/value objects
        s.writeInt(table.length);
        s.writeInt(count);
        for (int index = table.length-1; index &gt;= 0; index--) {
            Entry entry = table[index];

            while (entry != null) {
            s.writeObject(entry.key);
            s.writeObject(entry.value);
            entry = entry.next;
            }
        }
    }

    // java.io.Serializable的读取函数：根据写入方式读出
    // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出
    private void readObject(java.io.ObjectInputStream s)
         throws IOException, ClassNotFoundException
    {
        // Read in the length, threshold, and loadfactor
        s.defaultReadObject();

        // Read the original length of the array and number of elements
        int origlength = s.readInt();
        int elements = s.readInt();

        // Compute new size with a bit of room 5% to grow but
        // no larger than the original size.  Make the length
        // odd if it&apos;s large enough, this helps distribute the entries.
        // Guard against the length ending up zero, that&apos;s not valid.
        int length = (int)(elements * loadFactor) + (elements / 20) + 3;
        if (length &gt; elements &amp;&amp; (length &amp; 1) == 0)
            length--;
        if (origlength &gt; 0 &amp;&amp; length &gt; origlength)
            length = origlength;

        Entry[] table = new Entry[length];
        count = 0;

        // Read the number of elements and then all the key/value objects
        for (; elements &gt; 0; elements--) {
            K key = (K)s.readObject();
            V value = (V)s.readObject();
                // synch could be eliminated for performance
                reconstitutionPut(table, key, value);
        }
        this.table = table;
    }

    private void reconstitutionPut(Entry[] tab, K key, V value)
        throws StreamCorruptedException
    {
        if (value == null) {
            throw new java.io.StreamCorruptedException();
        }
        // Makes sure the key is not already in the hashtable.
        // This should not happen in deserialized version.
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                throw new java.io.StreamCorruptedException();
            }
        }
        // Creates the new entry.
        Entry&lt;K,V&gt; e = tab[index];
        tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e);
        count++;
    }

    // Hashtable的Entry节点，它本质上是一个单向链表。
    // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表
    private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        // 哈希值
        int hash;
        K key;
        V value;
        // 指向的下一个Entry，即链表的下一个节点
        Entry&lt;K,V&gt; next;

        // 构造函数
        protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        protected Object clone() {
            return new Entry&lt;K,V&gt;(hash, key, value,
                  (next==null ? null : (Entry&lt;K,V&gt;) next.clone()));
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        // 设置value。若value是null，则抛出异常。
        public V setValue(V value) {
            if (value == null)
                throw new NullPointerException();

            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }

        // 覆盖equals()方法，判断两个Entry是否相等。
        // 若两个Entry的key和value都相等，则认为它们相等。
        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;

            return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp;
               (value==null ? e.getValue()==null : value.equals(e.getValue()));
        }

        public int hashCode() {
            return hash ^ (value==null ? 0 : value.hashCode());
        }

        public String toString() {
            return key.toString()+&quot;=&quot;+value.toString();
        }
    }

    private static final int KEYS = 0;
    private static final int VALUES = 1;
    private static final int ENTRIES = 2;

    // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。
    private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
        // 指向Hashtable的table
        Entry[] table = Hashtable.this.table;
        // Hashtable的总的大小
        int index = table.length;
        Entry&lt;K,V&gt; entry = null;
        Entry&lt;K,V&gt; lastReturned = null;
        int type;

        // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志
        // iterator为true，表示它是迭代器；否则，是枚举类。
        boolean iterator;

        // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。
        protected int expectedModCount = modCount;

        Enumerator(int type, boolean iterator) {
            this.type = type;
            this.iterator = iterator;
        }

        // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。
        public boolean hasMoreElements() {
            Entry&lt;K,V&gt; e = entry;
            int i = index;
            Entry[] t = table;
            /* Use locals for faster loop iteration */
            while (e == null &amp;&amp; i &gt; 0) {
                e = t[--i];
            }
            entry = e;
            index = i;
            return e != null;
        }

        // 获取下一个元素
        // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式”
        // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。
        // 然后，依次向后遍历单向链表Entry。
        public T nextElement() {
            Entry&lt;K,V&gt; et = entry;
            int i = index;
            Entry[] t = table;
            /* Use locals for faster loop iteration */
            while (et == null &amp;&amp; i &gt; 0) {
                et = t[--i];
            }
            entry = et;
            index = i;
            if (et != null) {
                Entry&lt;K,V&gt; e = lastReturned = entry;
                entry = e.next;
                return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);
            }
            throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;);
        }

        // 迭代器Iterator的判断是否存在下一个元素
        // 实际上，它是调用的hasMoreElements()
        public boolean hasNext() {
            return hasMoreElements();
        }

        // 迭代器获取下一个元素
        // 实际上，它是调用的nextElement()
        public T next() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            return nextElement();
        }

        // 迭代器的remove()接口。
        // 首先，它在table数组中找出要删除元素所在的Entry，
        // 然后，删除单向链表Entry中的元素。
        public void remove() {
            if (!iterator)
                throw new UnsupportedOperationException();
            if (lastReturned == null)
                throw new IllegalStateException(&quot;Hashtable Enumerator&quot;);
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();

            synchronized(Hashtable.this) {
                Entry[] tab = Hashtable.this.table;
                int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length;

                for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null;
                     prev = e, e = e.next) {
                    if (e == lastReturned) {
                        modCount++;
                        expectedModCount++;
                        if (prev == null)
                            tab[index] = e.next;
                        else
                            prev.next = e.next;
                        count--;
                        lastReturned = null;
                        return;
                    }
                }
                throw new ConcurrentModificationException();
            }
        }
    }


    private static Enumeration emptyEnumerator = new EmptyEnumerator();
    private static Iterator emptyIterator = new EmptyIterator();

    // 空枚举类
    // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。
    private static class EmptyEnumerator implements Enumeration&lt;Object&gt; {

        EmptyEnumerator() {
        }

        // 空枚举类的hasMoreElements() 始终返回false
        public boolean hasMoreElements() {
            return false;
        }

        // 空枚举类的nextElement() 抛出异常
        public Object nextElement() {
            throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;);
        }
    }


    // 空迭代器
    // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。
    private static class EmptyIterator implements Iterator&lt;Object&gt; {

        EmptyIterator() {
        }

        public boolean hasNext() {
            return false;
        }

        public Object next() {
            throw new NoSuchElementException(&quot;Hashtable Iterator&quot;);
        }

        public void remove() {
            throw new IllegalStateException(&quot;Hashtable Iterator&quot;);
        }

    }
}</code></pre><p>说明: 在详细介绍Hashtable的代码之前，我们需要了解：和Hashmap一样，Hashtable也是一个散列表，它也是通过“拉链法”解决哈希冲突的。</p>
<h2 id="第3-1部分-Hashtable的“拉链法”相关内容"><a href="#第3-1部分-Hashtable的“拉链法”相关内容" class="headerlink" title="第3.1部分 Hashtable的“拉链法”相关内容"></a>第3.1部分 Hashtable的“拉链法”相关内容</h2><h3 id="3-1-1-Hashtable数据存储数组"><a href="#3-1-1-Hashtable数据存储数组" class="headerlink" title="3.1.1 Hashtable数据存储数组"></a>3.1.1 Hashtable数据存储数组</h3><pre><code>private transient Entry[] table;</code></pre><p>Hashtable中的key-value都是存储在table数组中的。</p>
<h3 id="3-1-2-数据节点Entry的数据结构"><a href="#3-1-2-数据节点Entry的数据结构" class="headerlink" title="3.1.2 数据节点Entry的数据结构"></a>3.1.2 数据节点Entry的数据结构</h3><pre><code>private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    // 哈希值
    int hash;
    K key;
    V value;
    // 指向的下一个Entry，即链表的下一个节点
    Entry&lt;K,V&gt; next;

    // 构造函数
    protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    protected Object clone() {
        return new Entry&lt;K,V&gt;(hash, key, value,
              (next==null ? null : (Entry&lt;K,V&gt;) next.clone()));
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    // 设置value。若value是null，则抛出异常。
    public V setValue(V value) {
        if (value == null)
            throw new NullPointerException();

        V oldValue = this.value;
        this.value = value;
        return oldValue;
    }

    // 覆盖equals()方法，判断两个Entry是否相等。
    // 若两个Entry的key和value都相等，则认为它们相等。
    public boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;

        return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp;
           (value==null ? e.getValue()==null : value.equals(e.getValue()));
    }

    public int hashCode() {
        return hash ^ (value==null ? 0 : value.hashCode());
    }

    public String toString() {
        return key.toString()+&quot;=&quot;+value.toString();
    }
}</code></pre><p>从中，我们可以看出 Entry 实际上就是一个单向链表。这也是为什么我们说Hashtable是通过拉链法解决哈希冲突的。<br>Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。</p>
<h2 id="第3-2部分-Hashtable的构造函数"><a href="#第3-2部分-Hashtable的构造函数" class="headerlink" title="第3.2部分 Hashtable的构造函数"></a>第3.2部分 Hashtable的构造函数</h2><p>Hashtable共包括4个构造函数</p>
<pre><code>// 默认构造函数。
public Hashtable() {
    // 默认构造函数，指定的容量大小是11；加载因子是0.75
    this(11, 0.75f);
}

// 指定“容量大小”的构造函数
public Hashtable(int initialCapacity) {
    this(initialCapacity, 0.75f);
}

// 指定“容量大小”和“加载因子”的构造函数
public Hashtable(int initialCapacity, float loadFactor) {
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);

    if (initialCapacity==0)
        initialCapacity = 1;
    this.loadFactor = loadFactor;
    table = new Entry[initialCapacity];
    threshold = (int)(initialCapacity * loadFactor);
}

// 包含“子Map”的构造函数
public Hashtable(Map&lt;? extends K, ? extends V&gt; t) {
    this(Math.max(2*t.size(), 11), 0.75f);
    // 将“子Map”的全部元素都添加到Hashtable中
    putAll(t);
}</code></pre><h2 id="第3-3部分-Hashtable的主要对外接口"><a href="#第3-3部分-Hashtable的主要对外接口" class="headerlink" title="第3.3部分 Hashtable的主要对外接口"></a>第3.3部分 Hashtable的主要对外接口</h2><h3 id="3-3-1-clear"><a href="#3-3-1-clear" class="headerlink" title="3.3.1 clear()"></a>3.3.1 clear()</h3><p>clear() 的作用是清空Hashtable。它是将Hashtable的table数组的值全部设为null</p>
<pre><code>public synchronized void clear() {
    Entry tab[] = table;
    modCount++;
    for (int index = tab.length; --index &gt;= 0; )
        tab[index] = null;
    count = 0;
}</code></pre><h3 id="3-3-2-contains-和-containsValue"><a href="#3-3-2-contains-和-containsValue" class="headerlink" title="3.3.2 contains() 和 containsValue()"></a>3.3.2 contains() 和 containsValue()</h3><p>contains() 和 containsValue() 的作用都是判断Hashtable是否包含“值(value)”</p>
<p>public boolean containsValue(Object value) {<br>    return contains(value);<br>}</p>
<pre><code>public synchronized boolean contains(Object value) {
    // Hashtable中“键值对”的value不能是null，
    // 若是null的话，抛出异常!
    if (value == null) {
        throw new NullPointerException();
    }

    // 从后向前遍历table数组中的元素(Entry)
    // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value
    Entry tab[] = table;
    for (int i = tab.length ; i-- &gt; 0 ;) {
        for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) {
            if (e.value.equals(value)) {
                return true;
            }
        }
    }
    return false;
}</code></pre><h3 id="3-3-3-containsKey"><a href="#3-3-3-containsKey" class="headerlink" title="3.3.3 containsKey()"></a>3.3.3 containsKey()</h3><p>containsKey() 的作用是判断Hashtable是否包含key</p>
<pre><code>public synchronized boolean containsKey(Object key) {
    Entry tab[] = table;
    int hash = key.hashCode();
    // 计算索引值，
    // % tab.length 的目的是防止数据越界
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素
    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
            return true;
        }
    }
    return false;
}</code></pre><h3 id="3-3-4-elements"><a href="#3-3-4-elements" class="headerlink" title="3.3.4 elements()"></a>3.3.4 elements()</h3><p>elements() 的作用是返回“所有value”的枚举对象</p>
<pre><code>public synchronized Enumeration&lt;V&gt; elements() {
    return this.&lt;V&gt;getEnumeration(VALUES);
}

// 获取Hashtable的枚举类对象
private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) {
    if (count == 0) {
        return (Enumeration&lt;T&gt;)emptyEnumerator;
    } else {
        return new Enumerator&lt;T&gt;(type, false);
    }
}</code></pre><p>从中，我们可以看出：<br>(01) 若Hashtable的实际大小为0,则返回“空枚举类”对象emptyEnumerator；<br>(02) 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)</p>
<p>我们先看看emptyEnumerator对象是如何实现的</p>
<pre><code>private static Enumeration emptyEnumerator = new EmptyEnumerator();

// 空枚举类
// 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。
private static class EmptyEnumerator implements Enumeration&lt;Object&gt; {

    EmptyEnumerator() {
    }

    // 空枚举类的hasMoreElements() 始终返回false
    public boolean hasMoreElements() {
        return false;
    }

    // 空枚举类的nextElement() 抛出异常
    public Object nextElement() {
        throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;);
    }
}</code></pre><p>我们在来看看Enumeration类</p>
<p>Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。</p>
<pre><code>private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
    // 指向Hashtable的table
    Entry[] table = Hashtable.this.table;
    // Hashtable的总的大小
    int index = table.length;
    Entry&lt;K,V&gt; entry = null;
    Entry&lt;K,V&gt; lastReturned = null;
    int type;

    // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志
    // iterator为true，表示它是迭代器；否则，是枚举类。
    boolean iterator;

    // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。
    protected int expectedModCount = modCount;

    Enumerator(int type, boolean iterator) {
        this.type = type;
        this.iterator = iterator;
    }

    // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。
    public boolean hasMoreElements() {
        Entry&lt;K,V&gt; e = entry;
        int i = index;
        Entry[] t = table;
        /* Use locals for faster loop iteration */
        while (e == null &amp;&amp; i &gt; 0) {
            e = t[--i];
        }
        entry = e;
        index = i;
        return e != null;
    }

    // 获取下一个元素
    // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式”
    // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。
    // 然后，依次向后遍历单向链表Entry。
    public T nextElement() {
        Entry&lt;K,V&gt; et = entry;
        int i = index;
        Entry[] t = table;
        /* Use locals for faster loop iteration */
        while (et == null &amp;&amp; i &gt; 0) {
            et = t[--i];
        }
        entry = et;
        index = i;
        if (et != null) {
            Entry&lt;K,V&gt; e = lastReturned = entry;
            entry = e.next;
            return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);
        }
        throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;);
    }

    // 迭代器Iterator的判断是否存在下一个元素
    // 实际上，它是调用的hasMoreElements()
    public boolean hasNext() {
        return hasMoreElements();
    }

    // 迭代器获取下一个元素
    // 实际上，它是调用的nextElement()
    public T next() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        return nextElement();
    }

    // 迭代器的remove()接口。
    // 首先，它在table数组中找出要删除元素所在的Entry，
    // 然后，删除单向链表Entry中的元素。
    public void remove() {
        if (!iterator)
            throw new UnsupportedOperationException();
        if (lastReturned == null)
            throw new IllegalStateException(&quot;Hashtable Enumerator&quot;);
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();

        synchronized(Hashtable.this) {
            Entry[] tab = Hashtable.this.table;
            int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length;

            for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null;
                 prev = e, e = e.next) {
                if (e == lastReturned) {
                    modCount++;
                    expectedModCount++;
                    if (prev == null)
                        tab[index] = e.next;
                    else
                        prev.next = e.next;
                    count--;
                    lastReturned = null;
                    return;
                }
            }
            throw new ConcurrentModificationException();
        }
    }
}</code></pre><p>entrySet(), keySet(), keys(), values()的实现方法和elements()差不多，而且源码中已经明确的给出了注释。这里就不再做过多说明了。</p>
<h3 id="3-3-5-get"><a href="#3-3-5-get" class="headerlink" title="3.3.5 get()"></a>3.3.5 get()</h3><p>get() 的作用就是获取key对应的value，没有的话返回null</p>
<pre><code>public synchronized V get(Object key) {
    Entry tab[] = table;
    int hash = key.hashCode();
    // 计算索引值，
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素
    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
            return e.value;
        }
    }
    return null;
}</code></pre><h3 id="3-3-6-put"><a href="#3-3-6-put" class="headerlink" title="3.3.6 put()"></a>3.3.6 put()</h3><p>put() 的作用是对外提供接口，让Hashtable对象可以通过put()将“key-value”添加到Hashtable中。</p>
<pre><code>public synchronized V put(K key, V value) {
    // Hashtable中不能插入value为null的元素！！！
    if (value == null) {
        throw new NullPointerException();
    }

    // 若“Hashtable中已存在键为key的键值对”，
    // 则用“新的value”替换“旧的value”
    Entry tab[] = table;
    int hash = key.hashCode();
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
            V old = e.value;
            e.value = value;
            return old;
            }
    }

    // 若“Hashtable中不存在键为key的键值对”，
    // (01) 将“修改统计数”+1
    modCount++;
    // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)
    //  则调整Hashtable的大小
    if (count &gt;= threshold) {
        // Rehash the table if the threshold is exceeded
        rehash();

        tab = table;
        index = (hash &amp; 0x7FFFFFFF) % tab.length;
    }

    // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中
    Entry&lt;K,V&gt; e = tab[index];
    // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。        
    tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e);
    // (05) 将“Hashtable的实际容量”+1
    count++;
    return null;
}</code></pre><h3 id="3-3-7-putAll"><a href="#3-3-7-putAll" class="headerlink" title="3.3.7 putAll()"></a>3.3.7 putAll()</h3><p>putAll() 的作用是将“Map(t)”的中全部元素逐一添加到Hashtable中</p>
<pre><code>public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) {
    for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())
        put(e.getKey(), e.getValue());
}</code></pre><h3 id="3-3-8-remove"><a href="#3-3-8-remove" class="headerlink" title="3.3.8 remove()"></a>3.3.8 remove()</h3><p>remove() 的作用就是删除Hashtable中键为key的元素</p>
<pre><code>public synchronized V remove(Object key) {
    Entry tab[] = table;
    int hash = key.hashCode();
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    // 找到“key对应的Entry(链表)”
    // 然后在链表中找出要删除的节点，并删除该节点。
    for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) {
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
            modCount++;
            if (prev != null) {
                prev.next = e.next;
            } else {
                tab[index] = e.next;
            }
            count--;
            V oldValue = e.value;
            e.value = null;
            return oldValue;
        }
    }
    return null;
}</code></pre><h2 id="第3-4部分-Hashtable实现的Cloneable接口"><a href="#第3-4部分-Hashtable实现的Cloneable接口" class="headerlink" title="第3.4部分 Hashtable实现的Cloneable接口"></a>第3.4部分 Hashtable实现的Cloneable接口</h2><p>Hashtable实现了Cloneable接口，即实现了clone()方法。<br>clone()方法的作用很简单，就是克隆一个Hashtable对象并返回。</p>
<pre><code>// 克隆一个Hashtable，并以Object的形式返回。
public synchronized Object clone() {
    try {
        Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone();
        t.table = new Entry[table.length];
        for (int i = table.length ; i-- &gt; 0 ; ) {
            t.table[i] = (table[i] != null)
            ? (Entry&lt;K,V&gt;) table[i].clone() : null;
        }
        t.keySet = null;
        t.entrySet = null;
        t.values = null;
        t.modCount = 0;
        return t;
    } catch (CloneNotSupportedException e) {
        // this shouldn&apos;t happen, since we are Cloneable
        throw new InternalError();
    }
}</code></pre><h2 id="第3-5部分-Hashtable实现的Serializable接口"><a href="#第3-5部分-Hashtable实现的Serializable接口" class="headerlink" title="第3.5部分 Hashtable实现的Serializable接口"></a>第3.5部分 Hashtable实现的Serializable接口</h2><p>Hashtable实现java.io.Serializable，分别实现了串行读取、写入功能。</p>
<p>串行写入函数就是将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中<br>串行读取函数：根据写入方式读出将Hashtable的“总的容量，实际容量，所有的Entry”依次读出</p>
<pre><code>private synchronized void writeObject(java.io.ObjectOutputStream s)
    throws IOException
{
    // Write out the length, threshold, loadfactor
    s.defaultWriteObject();

    // Write out length, count of elements and then the key/value objects
    s.writeInt(table.length);
    s.writeInt(count);
    for (int index = table.length-1; index &gt;= 0; index--) {
        Entry entry = table[index];

        while (entry != null) {
        s.writeObject(entry.key);
        s.writeObject(entry.value);
        entry = entry.next;
        }
    }
}

private void readObject(java.io.ObjectInputStream s)
     throws IOException, ClassNotFoundException
{
    // Read in the length, threshold, and loadfactor
    s.defaultReadObject();

    // Read the original length of the array and number of elements
    int origlength = s.readInt();
    int elements = s.readInt();

    // Compute new size with a bit of room 5% to grow but
    // no larger than the original size.  Make the length
    // odd if it&apos;s large enough, this helps distribute the entries.
    // Guard against the length ending up zero, that&apos;s not valid.
    int length = (int)(elements * loadFactor) + (elements / 20) + 3;
    if (length &gt; elements &amp;&amp; (length &amp; 1) == 0)
        length--;
    if (origlength &gt; 0 &amp;&amp; length &gt; origlength)
        length = origlength;

    Entry[] table = new Entry[length];
    count = 0;

    // Read the number of elements and then all the key/value objects
    for (; elements &gt; 0; elements--) {
        K key = (K)s.readObject();
        V value = (V)s.readObject();
            // synch could be eliminated for performance
            reconstitutionPut(table, key, value);
    }
    this.table = table;
}</code></pre><p><a name="anchor4"></a></p>
<h1 id="第4部分-Hashtable遍历方式"><a href="#第4部分-Hashtable遍历方式" class="headerlink" title="第4部分 Hashtable遍历方式"></a>第4部分 Hashtable遍历方式</h1><h2 id="4-1-遍历Hashtable的键值对"><a href="#4-1-遍历Hashtable的键值对" class="headerlink" title="4.1 遍历Hashtable的键值对"></a>4.1 遍历Hashtable的键值对</h2><p>第一步：根据entrySet()获取Hashtable的“键值对”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设table是Hashtable对象
// table中的key是String类型，value是Integer类型
Integer integ = null;
Iterator iter = table.entrySet().iterator();
while(iter.hasNext()) {
    Map.Entry entry = (Map.Entry)iter.next();
    // 获取key
    key = (String)entry.getKey();
        // 获取value
    integ = (Integer)entry.getValue();
}</code></pre><h2 id="4-2-通过Iterator遍历Hashtable的键"><a href="#4-2-通过Iterator遍历Hashtable的键" class="headerlink" title="4.2 通过Iterator遍历Hashtable的键"></a>4.2 通过Iterator遍历Hashtable的键</h2><p>第一步：根据keySet()获取Hashtable的“键”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设table是Hashtable对象
// table中的key是String类型，value是Integer类型
String key = null;
Integer integ = null;
Iterator iter = table.keySet().iterator();
while (iter.hasNext()) {
        // 获取key
    key = (String)iter.next();
        // 根据key，获取value
    integ = (Integer)table.get(key);
}</code></pre><h2 id="4-3-通过Iterator遍历Hashtable的值"><a href="#4-3-通过Iterator遍历Hashtable的值" class="headerlink" title="4.3 通过Iterator遍历Hashtable的值"></a>4.3 通过Iterator遍历Hashtable的值</h2><p>第一步：根据value()获取Hashtable的“值”的集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设table是Hashtable对象
// table中的key是String类型，value是Integer类型
Integer value = null;
Collection c = table.values();
Iterator iter= c.iterator();
while (iter.hasNext()) {
    value = (Integer)iter.next();
}</code></pre><h2 id="4-4-通过Enumeration遍历Hashtable的键"><a href="#4-4-通过Enumeration遍历Hashtable的键" class="headerlink" title="4.4 通过Enumeration遍历Hashtable的键"></a>4.4 通过Enumeration遍历Hashtable的键</h2><p>第一步：根据keys()获取Hashtable的集合。</p>
<p>第二步：通过Enumeration遍历“第一步”得到的集合。</p>
<pre><code>Enumeration enu = table.keys();
while(enu.hasMoreElements()) {
    System.out.println(enu.nextElement());
}   </code></pre><h2 id="4-5-通过Enumeration遍历Hashtable的值"><a href="#4-5-通过Enumeration遍历Hashtable的值" class="headerlink" title="4.5 通过Enumeration遍历Hashtable的值"></a>4.5 通过Enumeration遍历Hashtable的值</h2><p>第一步：根据elements()获取Hashtable的集合。</p>
<p>第二步：通过Enumeration遍历“第一步”得到的集合。</p>
<pre><code>Enumeration enu = table.elements();
while(enu.hasMoreElements()) {
    System.out.println(enu.nextElement());
}</code></pre><p>遍历测试程序如下：</p>
<pre><code>import java.util.*;

/*
 * @desc 遍历Hashtable的测试程序。
 *   (01) 通过entrySet()去遍历key、value，参考实现函数：
 *        iteratorHashtableByEntryset()
 *   (02) 通过keySet()去遍历key，参考实现函数：
 *        iteratorHashtableByKeyset()
 *   (03) 通过values()去遍历value，参考实现函数：
 *        iteratorHashtableJustValues()
 *   (04) 通过Enumeration去遍历key，参考实现函数：
 *        enumHashtableKey()
 *   (05) 通过Enumeration去遍历value，参考实现函数：
 *        enumHashtableValue()
 *
 * @author skywang
 */
public class HashtableIteratorTest {

    public static void main(String[] args) {
        int val = 0;
        String key = null;
        Integer value = null;
        Random r = new Random();
        Hashtable table = new Hashtable();

        for (int i=0; i&lt;12; i++) {
            // 随机获取一个[0,100)之间的数字
            val = r.nextInt(100);

            key = String.valueOf(val);
            value = r.nextInt(5);
            // 添加到Hashtable中
            table.put(key, value);
            System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value);
        }
        // 通过entrySet()遍历Hashtable的key-value
        iteratorHashtableByEntryset(table) ;

        // 通过keySet()遍历Hashtable的key-value
        iteratorHashtableByKeyset(table) ;

        // 单单遍历Hashtable的value
        iteratorHashtableJustValues(table);        

        // 遍历Hashtable的Enumeration的key
        enumHashtableKey(table);

        // 遍历Hashtable的Enumeration的value
        //enumHashtableValue(table);
    }

    /*
     * 通过Enumeration遍历Hashtable的key
     * 效率高!
     */
    private static void enumHashtableKey(Hashtable table) {
        if (table == null)
            return ;

        System.out.println(&quot;\nenumeration Hashtable&quot;);
        Enumeration enu = table.keys();
        while(enu.hasMoreElements()) {
            System.out.println(enu.nextElement());
        }
    }


    /*
     * 通过Enumeration遍历Hashtable的value
     * 效率高!
     */
    private static void enumHashtableValue(Hashtable table) {
        if (table == null)
            return ;

        System.out.println(&quot;\nenumeration Hashtable&quot;);
        Enumeration enu = table.elements();
        while(enu.hasMoreElements()) {
            System.out.println(enu.nextElement());
        }
    }

    /*
     * 通过entry set遍历Hashtable
     * 效率高!
     */
    private static void iteratorHashtableByEntryset(Hashtable table) {
        if (table == null)
            return ;

        System.out.println(&quot;\niterator Hashtable By entryset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = table.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();

            key = (String)entry.getKey();
            integ = (Integer)entry.getValue();
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }

    /*
     * 通过keyset来遍历Hashtable
     * 效率低!
     */
    private static void iteratorHashtableByKeyset(Hashtable table) {
        if (table == null)
            return ;

        System.out.println(&quot;\niterator Hashtable By keyset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = table.keySet().iterator();
        while (iter.hasNext()) {
            key = (String)iter.next();
            integ = (Integer)table.get(key);
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }


    /*
     * 遍历Hashtable的values
     */
    private static void iteratorHashtableJustValues(Hashtable table) {
        if (table == null)
            return ;

        Collection c = table.values();
        Iterator iter= c.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
       }
    }
}</code></pre><p><a name="anchor5"></a></p>
<h1 id="第5部分-Hashtable示例"><a href="#第5部分-Hashtable示例" class="headerlink" title="第5部分 Hashtable示例"></a>第5部分 Hashtable示例</h1><p>下面通过一个实例来学习如何使用Hashtable。</p>
<pre><code>import java.util.*;

/*
 * @desc Hashtable的测试程序。
 *
 * @author skywang
 */
public class HashtableTest {
    public static void main(String[] args) {
        testHashtableAPIs();
    }

    private static void testHashtableAPIs() {
        // 初始化随机种子
        Random r = new Random();
        // 新建Hashtable
        Hashtable table = new Hashtable();
        // 添加操作
        table.put(&quot;one&quot;, r.nextInt(10));
        table.put(&quot;two&quot;, r.nextInt(10));
        table.put(&quot;three&quot;, r.nextInt(10));

        // 打印出table
        System.out.println(&quot;table:&quot;+table );

        // 通过Iterator遍历key-value
        Iterator iter = table.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            System.out.println(&quot;next : &quot;+ entry.getKey() +&quot; - &quot;+entry.getValue());
        }

        // Hashtable的键值对个数        
        System.out.println(&quot;size:&quot;+table.size());

        // containsKey(Object key) :是否包含键key
        System.out.println(&quot;contains key two : &quot;+table.containsKey(&quot;two&quot;));
        System.out.println(&quot;contains key five : &quot;+table.containsKey(&quot;five&quot;));

        // containsValue(Object value) :是否包含值value
        System.out.println(&quot;contains value 0 : &quot;+table.containsValue(new Integer(0)));

        // remove(Object key) ： 删除键key对应的键值对
        table.remove(&quot;three&quot;);

        System.out.println(&quot;table:&quot;+table );

        // clear() ： 清空Hashtable
        table.clear();

        // isEmpty() : Hashtable是否为空
        System.out.println((table.isEmpty()?&quot;table is empty&quot;:&quot;table is not empty&quot;) );
    }
}</code></pre><p>(某一次)运行结果：</p>
<pre><code>table:{two=5, one=0, three=6}
next : two - 5
next : one - 0
next : three - 6
size:3
contains key two : true
contains key five : false
contains value 0 : true
table:{two=5, one=0}
table is empty</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/10/java/collection/2012-02-10-collection-10-hashmap/" itemprop="url">Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-10T01:01:00.000Z" itemprop="datePublished">2月 10 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 read (About 10014 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>这一章，我们对HashMap进行学习。<br>我们先对HashMap有个整体认识，然后再学习它的源码，最后再通过实例来学会使用HashMap。内容包括：  </p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 HashMap介绍</a><br><a href="#anchor2">第2部分 HashMap数据结构</a><br><a href="#anchor3">第3部分 HashMap源码解析(基于JDK1.6.0_45)</a><br>&nbsp;&nbsp;<a href="#anchor3_1">第3.1部分 HashMap的“拉链法”相关内容</a><br>&nbsp;&nbsp;<a href="#anchor3_2">第3.2部分 HashMap的构造函数</a><br>&nbsp;&nbsp;<a href="#anchor3_3">第3.3部分 HashMap的主要对外接口</a><br>&nbsp;&nbsp;<a href="#anchor3_4">第3.4部分 HashMap实现的Cloneable接口</a><br>&nbsp;&nbsp;<a href="#anchor3_5">第3.5部分 HashMap实现的Serializable接口</a><br><a href="#anchor4">第4部分 HashMap遍历方式</a><br><a href="#anchor5">第5部分 HashMap示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-HashMap介绍"><a href="#第1部分-HashMap介绍" class="headerlink" title="第1部分 HashMap介绍"></a>第1部分 HashMap介绍</h1><h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p>
<h2 id="HashMap的构造函数"><a href="#HashMap的构造函数" class="headerlink" title="HashMap的构造函数"></a>HashMap的构造函数</h2><p>HashMap共有4个构造函数,如下：</p>
<pre><code>// 默认构造函数。
HashMap()

// 指定“容量大小”的构造函数
HashMap(int capacity)

// 指定“容量大小”和“加载因子”的构造函数
HashMap(int capacity, float loadFactor)

// 包含“子Map”的构造函数
HashMap(Map&lt;? extends K, ? extends V&gt; map)</code></pre><h2 id="HashMap的API"><a href="#HashMap的API" class="headerlink" title="HashMap的API"></a>HashMap的API</h2><pre><code>void                 clear()
Object               clone()
boolean              containsKey(Object key)
boolean              containsValue(Object value)
Set&lt;Entry&lt;K, V&gt;&gt;     entrySet()
V                    get(Object key)
boolean              isEmpty()
Set&lt;K&gt;               keySet()
V                    put(K key, V value)
void                 putAll(Map&lt;? extends K, ? extends V&gt; map)
V                    remove(Object key)
int                  size()
Collection&lt;V&gt;        values()</code></pre><p><a name="anchor2"></a></p>
<h1 id="第2部分-HashMap数据结构"><a href="#第2部分-HashMap数据结构" class="headerlink" title="第2部分 HashMap数据结构"></a>第2部分 HashMap数据结构</h1><p>HashMap的继承关系</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractMap&lt;K, V&gt;
         ↳     java.util.HashMap&lt;K, V&gt;</code></pre><p>HashMap的声明</p>
<pre><code>public class HashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable { }</code></pre><p>HashMap与Map关系如下图：</p>
<p><img src="/media/pic/java/collection/collection10.jpg" alt="img"></p>
<p>从图中可以看出：<br>(01) HashMap继承于AbstractMap类，实现了Map接口。Map是”key-value键值对”接口，AbstractMap实现了”键值对”的通用函数接口。<br>(02) HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。  </p>
<blockquote>
<p>table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。<br>size是HashMap的大小，它是HashMap保存的键值对的数量。<br>threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。<br>loadFactor就是加载因子。<br>modCount是用来实现fail-fast机制的。</p>
</blockquote>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-HashMap源码解析-基于JDK1-6-0-45"><a href="#第3部分-HashMap源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 HashMap源码解析(基于JDK1.6.0_45)"></a>第3部分 HashMap源码解析(基于JDK1.6.0_45)</h1><p>为了更了解HashMap的原理，下面对HashMap源码代码作出分析。<br>在阅读源码时，建议参考后面的说明来建立对HashMap的整体认识，这样更容易理解HashMap。</p>
<pre><code>package java.util;
import java.io.*;

public class HashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable
{

    // 默认的初始容量是16，必须是2的幂。
    static final int DEFAULT_INITIAL_CAPACITY = 16;

    // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    // 默认加载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    // 存储数据的Entry数组，长度是2的幂。
    // HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表
    transient Entry[] table;

    // HashMap的大小，它是HashMap保存的键值对的数量
    transient int size;

    // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）
    int threshold;

    // 加载因子实际大小
    final float loadFactor;

    // HashMap被改变的次数
    transient volatile int modCount;

    // 指定“容量大小”和“加载因子”的构造函数
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        // HashMap的最大容量只能是MAXIMUM_CAPACITY
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);

        // 找出“大于initialCapacity”的最小的2的幂
        int capacity = 1;
        while (capacity &lt; initialCapacity)
            capacity &lt;&lt;= 1;

        // 设置“加载因子”
        this.loadFactor = loadFactor;
        // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。
        threshold = (int)(capacity * loadFactor);
        // 创建Entry数组，用来保存数据
        table = new Entry[capacity];
        init();
    }


    // 指定“容量大小”的构造函数
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    // 默认构造函数。
    public HashMap() {
        // 设置“加载因子”
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。
        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
        // 创建Entry数组，用来保存数据
        table = new Entry[DEFAULT_INITIAL_CAPACITY];
        init();
    }

    // 包含“子Map”的构造函数
    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,
                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);
        // 将m中的全部元素逐个添加到HashMap中
        putAllForCreate(m);
    }

    static int hash(int h) {
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    }

    // 返回索引值
    // h &amp; (length-1)保证返回值的小于length
    static int indexFor(int h, int length) {
        return h &amp; (length-1);
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    // 获取key对应的value
    public V get(Object key) {
        if (key == null)
            return getForNullKey();
        // 获取key的hash值
        int hash = hash(key.hashCode());
        // 在“该hash值对应的链表”上查找“键值等于key”的元素
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))
                return e.value;
        }
        return null;
    }

    // 获取“key为null”的元素的值
    // HashMap将“key为null”的元素存储在table[0]位置！
    private V getForNullKey() {
        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
            if (e.key == null)
                return e.value;
        }
        return null;
    }

    // HashMap是否包含key
    public boolean containsKey(Object key) {
        return getEntry(key) != null;
    }

    // 返回“键为key”的键值对
    final Entry&lt;K,V&gt; getEntry(Object key) {
        // 获取哈希值
        // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值
        int hash = (key == null) ? 0 : hash(key.hashCode());
        // 在“该hash值对应的链表”上查找“键值等于key”的元素
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                return e;
        }
        return null;
    }

    // 将“key-value”添加到HashMap中
    public V put(K key, V value) {
        // 若“key为null”，则将该键值对添加到table[0]中。
        if (key == null)
            return putForNullKey(value);
        // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。
        int hash = hash(key.hashCode());
        int i = indexFor(hash, table.length);
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
            Object k;
            // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        // 若“该key”对应的键值对不存在，则将“key-value”添加到table中
        modCount++;
        addEntry(hash, key, value, i);
        return null;
    }

    // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置
    private V putForNullKey(V value) {
        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
            if (e.key == null) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        // 这里的完全不会被执行到!
        modCount++;
        addEntry(0, null, value, 0);
        return null;
    }

    // 创建HashMap对应的“添加方法”，
    // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap
    // 而put()是对外提供的往HashMap中添加元素的方法。
    private void putForCreate(K key, V value) {
        int hash = (key == null) ? 0 : hash(key.hashCode());
        int i = indexFor(hash, table.length);

        // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
                e.value = value;
                return;
            }
        }

        // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中
        createEntry(hash, key, value, i);
    }

    // 将“m”中的全部元素都添加到HashMap中。
    // 该方法被内部的构造HashMap的方法所调用。
    private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) {
        // 利用迭代器将元素逐个添加到HashMap中
        for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();
            putForCreate(e.getKey(), e.getValue());
        }
    }

    // 重新调整HashMap的大小，newCapacity是调整后的单位
    void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }

        // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，
        // 然后，将“新HashMap”赋值给“旧HashMap”。
        Entry[] newTable = new Entry[newCapacity];
        transfer(newTable);
        table = newTable;
        threshold = (int)(newCapacity * loadFactor);
    }

    // 将HashMap中的全部元素都添加到newTable中
    void transfer(Entry[] newTable) {
        Entry[] src = table;
        int newCapacity = newTable.length;
        for (int j = 0; j &lt; src.length; j++) {
            Entry&lt;K,V&gt; e = src[j];
            if (e != null) {
                src[j] = null;
                do {
                    Entry&lt;K,V&gt; next = e.next;
                    int i = indexFor(e.hash, newCapacity);
                    e.next = newTable[i];
                    newTable[i] = e;
                    e = next;
                } while (e != null);
            }
        }
    }

    // 将&quot;m&quot;的全部元素都添加到HashMap中
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
        // 有效性判断
        int numKeysToBeAdded = m.size();
        if (numKeysToBeAdded == 0)
            return;

        // 计算容量是否足够，
        // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。
        if (numKeysToBeAdded &gt; threshold) {
            int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);
            if (targetCapacity &gt; MAXIMUM_CAPACITY)
                targetCapacity = MAXIMUM_CAPACITY;
            int newCapacity = table.length;
            while (newCapacity &lt; targetCapacity)
                newCapacity &lt;&lt;= 1;
            if (newCapacity &gt; table.length)
                resize(newCapacity);
        }

        // 通过迭代器，将“m”中的元素逐个添加到HashMap中。
        for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();
            put(e.getKey(), e.getValue());
        }
    }

    // 删除“键为key”元素
    public V remove(Object key) {
        Entry&lt;K,V&gt; e = removeEntryForKey(key);
        return (e == null ? null : e.value);
    }

    // 删除“键为key”的元素
    final Entry&lt;K,V&gt; removeEntryForKey(Object key) {
        // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算
        int hash = (key == null) ? 0 : hash(key.hashCode());
        int i = indexFor(hash, table.length);
        Entry&lt;K,V&gt; prev = table[i];
        Entry&lt;K,V&gt; e = prev;

        // 删除链表中“键为key”的元素
        // 本质是“删除单向链表中的节点”
        while (e != null) {
            Entry&lt;K,V&gt; next = e.next;
            Object k;
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
                modCount++;
                size--;
                if (prev == e)
                    table[i] = next;
                else
                    prev.next = next;
                e.recordRemoval(this);
                return e;
            }
            prev = e;
            e = next;
        }

        return e;
    }

    // 删除“键值对”
    final Entry&lt;K,V&gt; removeMapping(Object o) {
        if (!(o instanceof Map.Entry))
            return null;

        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;
        Object key = entry.getKey();
        int hash = (key == null) ? 0 : hash(key.hashCode());
        int i = indexFor(hash, table.length);
        Entry&lt;K,V&gt; prev = table[i];
        Entry&lt;K,V&gt; e = prev;

        // 删除链表中的“键值对e”
        // 本质是“删除单向链表中的节点”
        while (e != null) {
            Entry&lt;K,V&gt; next = e.next;
            if (e.hash == hash &amp;&amp; e.equals(entry)) {
                modCount++;
                size--;
                if (prev == e)
                    table[i] = next;
                else
                    prev.next = next;
                e.recordRemoval(this);
                return e;
            }
            prev = e;
            e = next;
        }

        return e;
    }

    // 清空HashMap，将所有的元素设为null
    public void clear() {
        modCount++;
        Entry[] tab = table;
        for (int i = 0; i &lt; tab.length; i++)
            tab[i] = null;
        size = 0;
    }

    // 是否包含“值为value”的元素
    public boolean containsValue(Object value) {
    // 若“value为null”，则调用containsNullValue()查找
    if (value == null)
            return containsNullValue();

    // 若“value不为null”，则查找HashMap中是否有值为value的节点。
    Entry[] tab = table;
        for (int i = 0; i &lt; tab.length ; i++)
            for (Entry e = tab[i] ; e != null ; e = e.next)
                if (value.equals(e.value))
                    return true;
    return false;
    }

    // 是否包含null值
    private boolean containsNullValue() {
    Entry[] tab = table;
        for (int i = 0; i &lt; tab.length ; i++)
            for (Entry e = tab[i] ; e != null ; e = e.next)
                if (e.value == null)
                    return true;
    return false;
    }

    // 克隆一个HashMap，并返回Object对象
    public Object clone() {
        HashMap&lt;K,V&gt; result = null;
        try {
            result = (HashMap&lt;K,V&gt;)super.clone();
        } catch (CloneNotSupportedException e) {
            // assert false;
        }
        result.table = new Entry[table.length];
        result.entrySet = null;
        result.modCount = 0;
        result.size = 0;
        result.init();
        // 调用putAllForCreate()将全部元素添加到HashMap中
        result.putAllForCreate(this);

        return result;
    }

    // Entry是单向链表。
    // 它是 “HashMap链式存储法”对应的链表。
    // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数
    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final K key;
        V value;
        // 指向下一个节点
        Entry&lt;K,V&gt; next;
        final int hash;

        // 构造函数。
        // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;
        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
            value = v;
            next = n;
            key = k;
            hash = h;
        }

        public final K getKey() {
            return key;
        }

        public final V getValue() {
            return value;
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        // 判断两个Entry是否相等
        // 若两个Entry的“key”和“value”都相等，则返回true。
        // 否则，返回false
        public final boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;
            Object k1 = getKey();
            Object k2 = e.getKey();
            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {
                Object v1 = getValue();
                Object v2 = e.getValue();
                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))
                    return true;
            }
            return false;
        }

        // 实现hashCode()
        public final int hashCode() {
            return (key==null   ? 0 : key.hashCode()) ^
                   (value==null ? 0 : value.hashCode());
        }

        public final String toString() {
            return getKey() + &quot;=&quot; + getValue();
        }

        // 当向HashMap中添加元素时，绘调用recordAccess()。
        // 这里不做任何处理
        void recordAccess(HashMap&lt;K,V&gt; m) {
        }

        // 当从HashMap中删除元素时，绘调用recordRemoval()。
        // 这里不做任何处理
        void recordRemoval(HashMap&lt;K,V&gt; m) {
        }
    }

    // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。
    void addEntry(int hash, K key, V value, int bucketIndex) {
        // 保存“bucketIndex”位置的值到“e”中
        Entry&lt;K,V&gt; e = table[bucketIndex];
        // 设置“bucketIndex”位置的元素为“新Entry”，
        // 设置“e”为“新Entry的下一个节点”
        table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);
        // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小
        if (size++ &gt;= threshold)
            resize(2 * table.length);
    }

    // 创建Entry。将“key-value”插入指定位置，bucketIndex是位置索引。
    // 它和addEntry的区别是：
    // (01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。
    //   例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素；
    // put()是通过addEntry()新增Entry的。
    //   在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”；
    //   因此，需要调用addEntry()
    // (02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。
    //   例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中；
    // 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中
    // 的全部元素添加到HashMap中，都不会超过HashMap的阈值”。
    //   此时，调用createEntry()即可。
    void createEntry(int hash, K key, V value, int bucketIndex) {
        // 保存“bucketIndex”位置的值到“e”中
        Entry&lt;K,V&gt; e = table[bucketIndex];
        // 设置“bucketIndex”位置的元素为“新Entry”，
        // 设置“e”为“新Entry的下一个节点”
        table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);
        size++;
    }

    // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。
    // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。
    private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; {
        // 下一个元素
        Entry&lt;K,V&gt; next;
        // expectedModCount用于实现fast-fail机制。
        int expectedModCount;
        // 当前索引
        int index;
        // 当前元素
        Entry&lt;K,V&gt; current;

        HashIterator() {
            expectedModCount = modCount;
            if (size &gt; 0) { // advance to first entry
                Entry[] t = table;
                // 将next指向table中第一个不为null的元素。
                // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。
                while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)
                    ;
            }
        }

        public final boolean hasNext() {
            return next != null;
        }

        // 获取下一个元素
        final Entry&lt;K,V&gt; nextEntry() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            Entry&lt;K,V&gt; e = next;
            if (e == null)
                throw new NoSuchElementException();

            // 注意！！！
            // 一个Entry就是一个单向链表
            // 若该Entry的下一个节点不为空，就将next指向下一个节点;
            // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。
            if ((next = e.next) == null) {
                Entry[] t = table;
                while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)
                    ;
            }
            current = e;
            return e;
        }

        // 删除当前元素
        public void remove() {
            if (current == null)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            Object k = current.key;
            current = null;
            HashMap.this.removeEntryForKey(k);
            expectedModCount = modCount;
        }

    }

    // value的迭代器
    private final class ValueIterator extends HashIterator&lt;V&gt; {
        public V next() {
            return nextEntry().value;
        }
    }

    // key的迭代器
    private final class KeyIterator extends HashIterator&lt;K&gt; {
        public K next() {
            return nextEntry().getKey();
        }
    }

    // Entry的迭代器
    private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        public Map.Entry&lt;K,V&gt; next() {
            return nextEntry();
        }
    }

    // 返回一个“key迭代器”
    Iterator&lt;K&gt; newKeyIterator()   {
        return new KeyIterator();
    }
    // 返回一个“value迭代器”
    Iterator&lt;V&gt; newValueIterator()   {
        return new ValueIterator();
    }
    // 返回一个“entry迭代器”
    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   {
        return new EntryIterator();
    }

    // HashMap的Entry对应的集合
    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;

    // 返回“key的集合”，实际上返回一个“KeySet对象”
    public Set&lt;K&gt; keySet() {
        Set&lt;K&gt; ks = keySet;
        return (ks != null ? ks : (keySet = new KeySet()));
    }

    // Key对应的集合
    // KeySet继承于AbstractSet，说明该集合中没有重复的Key。
    private final class KeySet extends AbstractSet&lt;K&gt; {
        public Iterator&lt;K&gt; iterator() {
            return newKeyIterator();
        }
        public int size() {
            return size;
        }
        public boolean contains(Object o) {
            return containsKey(o);
        }
        public boolean remove(Object o) {
            return HashMap.this.removeEntryForKey(o) != null;
        }
        public void clear() {
            HashMap.this.clear();
        }
    }

    // 返回“value集合”，实际上返回的是一个Values对象
    public Collection&lt;V&gt; values() {
        Collection&lt;V&gt; vs = values;
        return (vs != null ? vs : (values = new Values()));
    }

    // “value集合”
    // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，
    // Values中的元素能够重复。因为不同的key可以指向相同的value。
    private final class Values extends AbstractCollection&lt;V&gt; {
        public Iterator&lt;V&gt; iterator() {
            return newValueIterator();
        }
        public int size() {
            return size;
        }
        public boolean contains(Object o) {
            return containsValue(o);
        }
        public void clear() {
            HashMap.this.clear();
        }
    }

    // 返回“HashMap的Entry集合”
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        return entrySet0();
    }

    // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象
    private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() {
        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;
        return es != null ? es : (entrySet = new EntrySet());
    }

    // EntrySet对应的集合
    // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。
    private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
            return newEntryIterator();
        }
        public boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;
            Entry&lt;K,V&gt; candidate = getEntry(e.getKey());
            return candidate != null &amp;&amp; candidate.equals(e);
        }
        public boolean remove(Object o) {
            return removeMapping(o) != null;
        }
        public int size() {
            return size;
        }
        public void clear() {
            HashMap.this.clear();
        }
    }

    // java.io.Serializable的写入函数
    // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中
    private void writeObject(java.io.ObjectOutputStream s)
        throws IOException
    {
        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =
            (size &gt; 0) ? entrySet0().iterator() : null;

        // Write out the threshold, loadfactor, and any hidden stuff
        s.defaultWriteObject();

        // Write out number of buckets
        s.writeInt(table.length);

        // Write out size (number of Mappings)
        s.writeInt(size);

        // Write out keys and values (alternating)
        if (i != null) {
            while (i.hasNext()) {
            Map.Entry&lt;K,V&gt; e = i.next();
            s.writeObject(e.getKey());
            s.writeObject(e.getValue());
            }
        }
    }


    private static final long serialVersionUID = 362498820763181265L;

    // java.io.Serializable的读取函数：根据写入方式读出
    // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出
    private void readObject(java.io.ObjectInputStream s)
         throws IOException, ClassNotFoundException
    {
        // Read in the threshold, loadfactor, and any hidden stuff
        s.defaultReadObject();

        // Read in number of buckets and allocate the bucket array;
        int numBuckets = s.readInt();
        table = new Entry[numBuckets];

        init();  // Give subclass a chance to do its thing.

        // Read in size (number of Mappings)
        int size = s.readInt();

        // Read the keys and values, and put the mappings in the HashMap
        for (int i=0; i&lt;size; i++) {
            K key = (K) s.readObject();
            V value = (V) s.readObject();
            putForCreate(key, value);
        }
    }

    // 返回“HashMap总的容量”
    int   capacity()     { return table.length; }
    // 返回“HashMap的加载因子”
    float loadFactor()   { return loadFactor;   }
}</code></pre><p>说明:<br>在详细介绍HashMap的代码之前，我们需要了解：HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的。<br>还需要再补充说明的一点是影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。</p>
<p><a name="anchor3_1"></a></p>
<h2 id="第3-1部分-HashMap的“拉链法”相关内容"><a href="#第3-1部分-HashMap的“拉链法”相关内容" class="headerlink" title="第3.1部分 HashMap的“拉链法”相关内容"></a>第3.1部分 HashMap的“拉链法”相关内容</h2><h3 id="3-1-1-HashMap数据存储数组"><a href="#3-1-1-HashMap数据存储数组" class="headerlink" title="3.1.1 HashMap数据存储数组"></a>3.1.1 HashMap数据存储数组</h3><pre><code>transient Entry[] table;</code></pre><p>HashMap中的key-value都是存储在Entry数组中的。</p>
<h3 id="3-1-2-数据节点Entry的数据结构"><a href="#3-1-2-数据节点Entry的数据结构" class="headerlink" title="3.1.2 数据节点Entry的数据结构"></a>3.1.2 数据节点Entry的数据结构</h3><pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final K key;
    V value;
    // 指向下一个节点
    Entry&lt;K,V&gt; next;
    final int hash;

    // 构造函数。
    // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;
    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    // 判断两个Entry是否相等
    // 若两个Entry的“key”和“value”都相等，则返回true。
    // 否则，返回false
    public final boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;
        Object k1 = getKey();
        Object k2 = e.getKey();
        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {
            Object v1 = getValue();
            Object v2 = e.getValue();
            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))
                return true;
        }
        return false;
    }

    // 实现hashCode()
    public final int hashCode() {
        return (key==null   ? 0 : key.hashCode()) ^
               (value==null ? 0 : value.hashCode());
    }

    public final String toString() {
        return getKey() + &quot;=&quot; + getValue();
    }

    // 当向HashMap中添加元素时，绘调用recordAccess()。
    // 这里不做任何处理
    void recordAccess(HashMap&lt;K,V&gt; m) {
    }

    // 当从HashMap中删除元素时，绘调用recordRemoval()。
    // 这里不做任何处理
    void recordRemoval(HashMap&lt;K,V&gt; m) {
    }
}</code></pre><p>从中，我们可以看出 Entry 实际上就是一个单向链表。这也是为什么我们说HashMap是通过拉链法解决哈希冲突的。<br>Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。</p>
<p><a name="anchor3_2"></a></p>
<h2 id="第3-2部分-HashMap的构造函数"><a href="#第3-2部分-HashMap的构造函数" class="headerlink" title="第3.2部分 HashMap的构造函数"></a>第3.2部分 HashMap的构造函数</h2><p>HashMap共包括4个构造函数</p>
<pre><code>// 默认构造函数。
public HashMap() {
    // 设置“加载因子”
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。
    threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
    // 创建Entry数组，用来保存数据
    table = new Entry[DEFAULT_INITIAL_CAPACITY];
    init();
}

// 指定“容量大小”和“加载因子”的构造函数
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                           initialCapacity);
    // HashMap的最大容量只能是MAXIMUM_CAPACITY
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                           loadFactor);

    // Find a power of 2 &gt;= initialCapacity
    int capacity = 1;
    while (capacity &lt; initialCapacity)
        capacity &lt;&lt;= 1;

    // 设置“加载因子”
    this.loadFactor = loadFactor;
    // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。
    threshold = (int)(capacity * loadFactor);
    // 创建Entry数组，用来保存数据
    table = new Entry[capacity];
    init();
}

// 指定“容量大小”的构造函数
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

// 包含“子Map”的构造函数
public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,
                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);
    // 将m中的全部元素逐个添加到HashMap中
    putAllForCreate(m);
}</code></pre><p><a name="anchor3_3"></a></p>
<h2 id="第3-3部分-HashMap的主要对外接口"><a href="#第3-3部分-HashMap的主要对外接口" class="headerlink" title="第3.3部分 HashMap的主要对外接口"></a>第3.3部分 HashMap的主要对外接口</h2><h3 id="3-3-1-clear"><a href="#3-3-1-clear" class="headerlink" title="3.3.1 clear()"></a>3.3.1 clear()</h3><p>clear() 的作用是清空HashMap。它是通过将所有的元素设为null来实现的。</p>
<pre><code>public void clear() {
    modCount++;
    Entry[] tab = table;
    for (int i = 0; i &lt; tab.length; i++)
        tab[i] = null;
    size = 0;
}</code></pre><h3 id="3-3-2-containsKey"><a href="#3-3-2-containsKey" class="headerlink" title="3.3.2 containsKey()"></a>3.3.2 containsKey()</h3><p>containsKey() 的作用是判断HashMap是否包含key。</p>
<pre><code>public boolean containsKey(Object key) {
    return getEntry(key) != null;
}</code></pre><p>containsKey() 首先通过getEntry(key)获取key对应的Entry，然后判断该Entry是否为null。<br>getEntry()的源码如下：  </p>
<pre><code>final Entry&lt;K,V&gt; getEntry(Object key) {
    // 获取哈希值
    // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值
    int hash = (key == null) ? 0 : hash(key.hashCode());
    // 在“该hash值对应的链表”上查找“键值等于key”的元素
    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            return e;
    }
    return null;
}</code></pre><p>getEntry() 的作用就是返回“键为key”的键值对，它的实现源码中已经进行了说明。<br>这里需要强调的是：HashMap将“key为null”的元素都放在table的位置0处，即table[0]中；“key不为null”的放在table的其余位置！</p>
<h3 id="3-3-3-containsValue"><a href="#3-3-3-containsValue" class="headerlink" title="3.3.3 containsValue()"></a>3.3.3 containsValue()</h3><p>containsValue() 的作用是判断HashMap是否包含“值为value”的元素。</p>
<pre><code>public boolean containsValue(Object value) {
    // 若“value为null”，则调用containsNullValue()查找
    if (value == null)
        return containsNullValue();

    // 若“value不为null”，则查找HashMap中是否有值为value的节点。
    Entry[] tab = table;
    for (int i = 0; i &lt; tab.length ; i++)
        for (Entry e = tab[i] ; e != null ; e = e.next)
            if (value.equals(e.value))
                return true;
    return false;
}</code></pre><p>从中，我们可以看出containsNullValue()分为两步进行处理：第一，若“value为null”，则调用containsNullValue()。第二，若“value不为null”，则查找HashMap中是否有值为value的节点。</p>
<p>containsNullValue() 的作用判断HashMap中是否包含“值为null”的元素。</p>
<pre><code>private boolean containsNullValue() {
    Entry[] tab = table;
    for (int i = 0; i &lt; tab.length ; i++)
        for (Entry e = tab[i] ; e != null ; e = e.next)
            if (e.value == null)
                return true;
    return false;
}</code></pre><h3 id="3-3-4-entrySet-、values-、keySet"><a href="#3-3-4-entrySet-、values-、keySet" class="headerlink" title="3.3.4 entrySet()、values()、keySet()"></a>3.3.4 entrySet()、values()、keySet()</h3><p>它们3个的原理类似，这里以entrySet()为例来说明。<br>entrySet()的作用是返回“HashMap中所有Entry的集合”，它是一个集合。实现代码如下：</p>
<pre><code>// 返回“HashMap的Entry集合”
public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
    return entrySet0();
}

// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象
private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() {
    Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;
    return es != null ? es : (entrySet = new EntrySet());
}

// EntrySet对应的集合
// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。
private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
    public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
        return newEntryIterator();
    }
    public boolean contains(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;
        Entry&lt;K,V&gt; candidate = getEntry(e.getKey());
        return candidate != null &amp;&amp; candidate.equals(e);
    }
    public boolean remove(Object o) {
        return removeMapping(o) != null;
    }
    public int size() {
        return size;
    }
    public void clear() {
        HashMap.this.clear();
    }
}</code></pre><p>HashMap是通过拉链法实现的散列表。表现在HashMap包括许多的Entry，而每一个Entry本质上又是一个单向链表。那么HashMap遍历key-value键值对的时候，是如何逐个去遍历的呢？</p>
<p>下面我们就看看HashMap是如何通过entrySet()遍历的。<br>entrySet()实际上是通过newEntryIterator()实现的。 下面我们看看它的代码：</p>
<pre><code>// 返回一个“entry迭代器”
Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   {
    return new EntryIterator();
}

// Entry的迭代器
private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
    public Map.Entry&lt;K,V&gt; next() {
        return nextEntry();
    }
}

// HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。
// 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。
private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; {
    // 下一个元素
    Entry&lt;K,V&gt; next;
    // expectedModCount用于实现fast-fail机制。
    int expectedModCount;
    // 当前索引
    int index;
    // 当前元素
    Entry&lt;K,V&gt; current;

    HashIterator() {
        expectedModCount = modCount;
        if (size &gt; 0) { // advance to first entry
            Entry[] t = table;
            // 将next指向table中第一个不为null的元素。
            // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。
            while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)
                ;
        }
    }

    public final boolean hasNext() {
        return next != null;
    }

    // 获取下一个元素
    final Entry&lt;K,V&gt; nextEntry() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        Entry&lt;K,V&gt; e = next;
        if (e == null)
            throw new NoSuchElementException();

        // 注意！！！
        // 一个Entry就是一个单向链表
        // 若该Entry的下一个节点不为空，就将next指向下一个节点;
        // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。
        if ((next = e.next) == null) {
            Entry[] t = table;
            while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)
                ;
        }
        current = e;
        return e;
    }

    // 删除当前元素
    public void remove() {
        if (current == null)
            throw new IllegalStateException();
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        Object k = current.key;
        current = null;
        HashMap.this.removeEntryForKey(k);
        expectedModCount = modCount;
    }

}</code></pre><p>当我们通过entrySet()获取到的Iterator的next()方法去遍历HashMap时，实际上调用的是 nextEntry() 。而nextEntry()的实现方式，先遍历Entry(根据Entry在table中的序号，从小到大的遍历)；然后对每个Entry(即每个单向链表)，逐个遍历。</p>
<h3 id="3-3-5-get"><a href="#3-3-5-get" class="headerlink" title="3.3.5 get()"></a>3.3.5 get()</h3><p>get() 的作用是获取key对应的value，它的实现代码如下：</p>
<pre><code>public V get(Object key) {
    if (key == null)
        return getForNullKey();
    // 获取key的hash值
    int hash = hash(key.hashCode());
    // 在“该hash值对应的链表”上查找“键值等于key”的元素
    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))
            return e.value;
    }
    return null;
}</code></pre><h3 id="3-3-6-put"><a href="#3-3-6-put" class="headerlink" title="3.3.6 put()"></a>3.3.6 put()</h3><p>put() 的作用是对外提供接口，让HashMap对象可以通过put()将“key-value”添加到HashMap中。</p>
<pre><code>public V put(K key, V value) {
    // 若“key为null”，则将该键值对添加到table[0]中。
    if (key == null)
        return putForNullKey(value);
    // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。
    int hash = hash(key.hashCode());
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    // 若“该key”对应的键值对不存在，则将“key-value”添加到table中
    modCount++;
    addEntry(hash, key, value, i);
    return null;
}</code></pre><p>若要添加到HashMap中的键值对对应的key已经存在HashMap中，则找到该键值对；然后新的value取代旧的value，并退出！<br>若要添加到HashMap中的键值对对应的key不在HashMap中，则将其添加到该哈希值对应的链表中，并调用addEntry()。<br>下面看看addEntry()的代码：</p>
<pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {
    // 保存“bucketIndex”位置的值到“e”中
    Entry&lt;K,V&gt; e = table[bucketIndex];
    // 设置“bucketIndex”位置的元素为“新Entry”，
    // 设置“e”为“新Entry的下一个节点”
    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);
    // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小
    if (size++ &gt;= threshold)
        resize(2 * table.length);
}</code></pre><p>addEntry() 的作用是新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</p>
<p>说到addEntry()，就不得不说另一个函数createEntry()。createEntry()的代码如下：</p>
<pre><code>void createEntry(int hash, K key, V value, int bucketIndex) {
    // 保存“bucketIndex”位置的值到“e”中
    Entry&lt;K,V&gt; e = table[bucketIndex];
    // 设置“bucketIndex”位置的元素为“新Entry”，
    // 设置“e”为“新Entry的下一个节点”
    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);
    size++;
}</code></pre><p>它们的作用都是将key、value添加到HashMap中。而且，比较addEntry()和createEntry()的代码，我们发现addEntry()多了两句：</p>
<pre><code>if (size++ &gt;= threshold)
    resize(2 * table.length);</code></pre><p>那它们的区别到底是什么呢？<br>阅读代码，我们可以发现，它们的使用情景不同。</p>
<p>(01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。<br>&nbsp;&nbsp;&nbsp;&nbsp; 例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素；put()是通过addEntry()新增Entry的。<br>&nbsp;&nbsp;&nbsp;&nbsp; 在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”；<br>&nbsp;&nbsp;&nbsp;&nbsp; 因此，需要调用addEntry()。<br>(02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。<br>&nbsp;&nbsp;&nbsp;&nbsp; 例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中；<br>&nbsp;&nbsp;&nbsp;&nbsp; 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中的全部元素添加到HashMap中，都不会超过HashMap的阈值”。<br>此时，调用createEntry()即可。</p>
<h3 id="3-3-7-putAll"><a href="#3-3-7-putAll" class="headerlink" title="3.3.7 putAll()"></a>3.3.7 putAll()</h3><p>putAll() 的作用是将”m”的全部元素都添加到HashMap中，它的代码如下：</p>
<pre><code>public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
    // 有效性判断
    int numKeysToBeAdded = m.size();
    if (numKeysToBeAdded == 0)
        return;

    // 计算容量是否足够，
    // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。
    if (numKeysToBeAdded &gt; threshold) {
        int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);
        if (targetCapacity &gt; MAXIMUM_CAPACITY)
            targetCapacity = MAXIMUM_CAPACITY;
        int newCapacity = table.length;
        while (newCapacity &lt; targetCapacity)
            newCapacity &lt;&lt;= 1;
        if (newCapacity &gt; table.length)
            resize(newCapacity);
    }

    // 通过迭代器，将“m”中的元素逐个添加到HashMap中。
    for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) {
        Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();
        put(e.getKey(), e.getValue());
    }
}</code></pre><p>3.3.8 remove()</p>
<p>remove() 的作用是删除“键为key”元素</p>
<pre><code>public V remove(Object key) {
    Entry&lt;K,V&gt; e = removeEntryForKey(key);
    return (e == null ? null : e.value);
}


// 删除“键为key”的元素
final Entry&lt;K,V&gt; removeEntryForKey(Object key) {
    // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算
    int hash = (key == null) ? 0 : hash(key.hashCode());
    int i = indexFor(hash, table.length);
    Entry&lt;K,V&gt; prev = table[i];
    Entry&lt;K,V&gt; e = prev;

    // 删除链表中“键为key”的元素
    // 本质是“删除单向链表中的节点”
    while (e != null) {
        Entry&lt;K,V&gt; next = e.next;
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
            modCount++;
            size--;
            if (prev == e)
                table[i] = next;
            else
                prev.next = next;
            e.recordRemoval(this);
            return e;
        }
        prev = e;
        e = next;
    }

    return e;
}</code></pre><p><a name="anchor3_4"></a></p>
<h1 id="第3-4部分-HashMap实现的Cloneable接口"><a href="#第3-4部分-HashMap实现的Cloneable接口" class="headerlink" title="第3.4部分 HashMap实现的Cloneable接口"></a>第3.4部分 HashMap实现的Cloneable接口</h1><p>HashMap实现了Cloneable接口，即实现了clone()方法。<br>clone()方法的作用很简单，就是克隆一个HashMap对象并返回。</p>
<pre><code>// 克隆一个HashMap，并返回Object对象
public Object clone() {
    HashMap&lt;K,V&gt; result = null;
    try {
        result = (HashMap&lt;K,V&gt;)super.clone();
    } catch (CloneNotSupportedException e) {
        // assert false;
    }
    result.table = new Entry[table.length];
    result.entrySet = null;
    result.modCount = 0;
    result.size = 0;
    result.init();
    // 调用putAllForCreate()将全部元素添加到HashMap中
    result.putAllForCreate(this);

    return result;
}</code></pre><p><a name="anchor3_5"></a></p>
<h1 id="第3-5部分-HashMap实现的Serializable接口"><a href="#第3-5部分-HashMap实现的Serializable接口" class="headerlink" title="第3.5部分 HashMap实现的Serializable接口"></a>第3.5部分 HashMap实现的Serializable接口</h1><p>HashMap实现java.io.Serializable，分别实现了串行读取、写入功能。<br>串行写入函数是writeObject()，它的作用是将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中。<br>而串行读取函数是readObject()，它的作用是将HashMap的“总的容量，实际容量，所有的Entry”依次读出</p>
<pre><code>// java.io.Serializable的写入函数
// 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中
private void writeObject(java.io.ObjectOutputStream s)
    throws IOException
{
    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =
        (size &gt; 0) ? entrySet0().iterator() : null;

    // Write out the threshold, loadfactor, and any hidden stuff
    s.defaultWriteObject();

    // Write out number of buckets
    s.writeInt(table.length);

    // Write out size (number of Mappings)
    s.writeInt(size);

    // Write out keys and values (alternating)
    if (i != null) {
        while (i.hasNext()) {
        Map.Entry&lt;K,V&gt; e = i.next();
        s.writeObject(e.getKey());
        s.writeObject(e.getValue());
        }
    }
}

// java.io.Serializable的读取函数：根据写入方式读出
// 将HashMap的“总的容量，实际容量，所有的Entry”依次读出
private void readObject(java.io.ObjectInputStream s)
     throws IOException, ClassNotFoundException
{
    // Read in the threshold, loadfactor, and any hidden stuff
    s.defaultReadObject();

    // Read in number of buckets and allocate the bucket array;
    int numBuckets = s.readInt();
    table = new Entry[numBuckets];

    init();  // Give subclass a chance to do its thing.

    // Read in size (number of Mappings)
    int size = s.readInt();

    // Read the keys and values, and put the mappings in the HashMap
    for (int i=0; i&lt;size; i++) {
        K key = (K) s.readObject();
        V value = (V) s.readObject();
        putForCreate(key, value);
    }
}</code></pre><p><a name="anchor4"></a></p>
<h1 id="第4部分-HashMap遍历方式"><a href="#第4部分-HashMap遍历方式" class="headerlink" title="第4部分 HashMap遍历方式"></a>第4部分 HashMap遍历方式</h1><h2 id="4-1-遍历HashMap的键值对"><a href="#4-1-遍历HashMap的键值对" class="headerlink" title="4.1 遍历HashMap的键值对"></a>4.1 遍历HashMap的键值对</h2><p>第一步：根据entrySet()获取HashMap的“键值对”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是HashMap对象
// map中的key是String类型，value是Integer类型
Integer integ = null;
Iterator iter = map.entrySet().iterator();
while(iter.hasNext()) {
    Map.Entry entry = (Map.Entry)iter.next();
    // 获取key
    key = (String)entry.getKey();
        // 获取value
    integ = (Integer)entry.getValue();
}</code></pre><h2 id="4-2-遍历HashMap的键"><a href="#4-2-遍历HashMap的键" class="headerlink" title="4.2 遍历HashMap的键"></a>4.2 遍历HashMap的键</h2><p>第一步：根据keySet()获取HashMap的“键”的Set集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是HashMap对象
// map中的key是String类型，value是Integer类型
String key = null;
Integer integ = null;
Iterator iter = map.keySet().iterator();
while (iter.hasNext()) {
        // 获取key
    key = (String)iter.next();
        // 根据key，获取value
    integ = (Integer)map.get(key);
}</code></pre><h2 id="4-3-遍历HashMap的值"><a href="#4-3-遍历HashMap的值" class="headerlink" title="4.3 遍历HashMap的值"></a>4.3 遍历HashMap的值</h2><p>第一步：根据value()获取HashMap的“值”的集合。</p>
<p>第二步：通过Iterator迭代器遍历“第一步”得到的集合。</p>
<pre><code>// 假设map是HashMap对象
// map中的key是String类型，value是Integer类型
Integer value = null;
Collection c = map.values();
Iterator iter= c.iterator();
while (iter.hasNext()) {
    value = (Integer)iter.next();
}</code></pre><p>遍历测试程序如下：</p>
<pre><code>import java.util.Map;
import java.util.Random;
import java.util.Iterator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Collection;

/*
 * @desc 遍历HashMap的测试程序。
 *   (01) 通过entrySet()去遍历key、value，参考实现函数：
 *        iteratorHashMapByEntryset()
 *   (02) 通过keySet()去遍历key、value，参考实现函数：
 *        iteratorHashMapByKeyset()
 *   (03) 通过values()去遍历value，参考实现函数：
 *        iteratorHashMapJustValues()
 *
 * @author skywang
 */
public class HashMapIteratorTest {

    public static void main(String[] args) {
        int val = 0;
        String key = null;
        Integer value = null;
        Random r = new Random();
        HashMap map = new HashMap();

        for (int i=0; i&lt;12; i++) {
            // 随机获取一个[0,100)之间的数字
            val = r.nextInt(100);

            key = String.valueOf(val);
            value = r.nextInt(5);
            // 添加到HashMap中
            map.put(key, value);
            System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value);
        }
        // 通过entrySet()遍历HashMap的key-value
        iteratorHashMapByEntryset(map) ;

        // 通过keySet()遍历HashMap的key-value
        iteratorHashMapByKeyset(map) ;

        // 单单遍历HashMap的value
        iteratorHashMapJustValues(map);        
    }

    /*
     * 通过entry set遍历HashMap
     * 效率高!
     */
    private static void iteratorHashMapByEntryset(HashMap map) {
        if (map == null)
            return ;

        System.out.println(&quot;\niterator HashMap By entryset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = map.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();

            key = (String)entry.getKey();
            integ = (Integer)entry.getValue();
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }

    /*
     * 通过keyset来遍历HashMap
     * 效率低!
     */
    private static void iteratorHashMapByKeyset(HashMap map) {
        if (map == null)
            return ;

        System.out.println(&quot;\niterator HashMap By keyset&quot;);
        String key = null;
        Integer integ = null;
        Iterator iter = map.keySet().iterator();
        while (iter.hasNext()) {
            key = (String)iter.next();
            integ = (Integer)map.get(key);
            System.out.println(key+&quot; -- &quot;+integ.intValue());
        }
    }


    /*
     * 遍历HashMap的values
     */
    private static void iteratorHashMapJustValues(HashMap map) {
        if (map == null)
            return ;

        Collection c = map.values();
        Iterator iter= c.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
       }
    }
}</code></pre><p><a name="anchor5"></a></p>
<h1 id="第5部分-HashMap示例"><a href="#第5部分-HashMap示例" class="headerlink" title="第5部分 HashMap示例"></a>第5部分 HashMap示例</h1><p>下面通过一个实例学习如何使用HashMap</p>
<pre><code>import java.util.Map;
import java.util.Random;
import java.util.Iterator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Collection;

/*
 * @desc HashMap测试程序
 *        
 * @author skywang
 */
public class HashMapTest {

    public static void main(String[] args) {
        testHashMapAPIs();
    }

    private static void testHashMapAPIs() {
        // 初始化随机种子
        Random r = new Random();
        // 新建HashMap
        HashMap map = new HashMap();
        // 添加操作
        map.put(&quot;one&quot;, r.nextInt(10));
        map.put(&quot;two&quot;, r.nextInt(10));
        map.put(&quot;three&quot;, r.nextInt(10));

        // 打印出map
        System.out.println(&quot;map:&quot;+map );

        // 通过Iterator遍历key-value
        Iterator iter = map.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            System.out.println(&quot;next : &quot;+ entry.getKey() +&quot; - &quot;+entry.getValue());
        }

        // HashMap的键值对个数        
        System.out.println(&quot;size:&quot;+map.size());

        // containsKey(Object key) :是否包含键key
        System.out.println(&quot;contains key two : &quot;+map.containsKey(&quot;two&quot;));
        System.out.println(&quot;contains key five : &quot;+map.containsKey(&quot;five&quot;));

        // containsValue(Object value) :是否包含值value
        System.out.println(&quot;contains value 0 : &quot;+map.containsValue(new Integer(0)));

        // remove(Object key) ： 删除键key对应的键值对
        map.remove(&quot;three&quot;);

        System.out.println(&quot;map:&quot;+map );

        // clear() ： 清空HashMap
        map.clear();

        // isEmpty() : HashMap是否为空
        System.out.println((map.isEmpty()?&quot;map is empty&quot;:&quot;map is not empty&quot;) );
    }
}</code></pre><p> (某一次)运行结果： </p>
<pre><code>map:{two=7, one=9, three=6}
next : two - 7
next : one - 9
next : three - 6
size:3
contains key two : true
contains key five : false
contains value 0 : false
map:{two=7, one=9}
map is empty</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/09/java/collection/2012-02-09-collection-09-map/" itemprop="url">Java 集合系列09之 Map架构</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-09T01:01:00.000Z" itemprop="datePublished">2月 9 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            18 分钟 read (About 2735 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面，我们已经系统的对List进行了学习。接下来，我们先学习Map，然后再学习Set；因为Set的实现类都是基于Map来实现的(如，HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的)。</p>
</blockquote>
<p>首先，我们看看Map架构。</p>
<p><img src="/media/pic/java/collection/collection09.jpg" alt="img"></p>
<p>如上图：</p>
<p>(01) Map 是映射接口，Map中存储的内容是键值对(key-value)。<br>(02) AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。<br>(03) SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。<br>(04) NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。<br>(05) TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”！<br>(06) HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“键值对，但不保证次序”！<br>(07) Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“键值对，也不保证次序”。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。<br>(08) WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”。  </p>
<p>在对各个实现类进行详细之前，先来看看各个接口和抽象类的大致介绍。内容包括：  </p>
<blockquote>
<p><a href="#anchor1">1 Map</a><br><a href="#anchor2">2 Map.Entry</a><br><a href="#anchor3">3 AbstractMap</a><br><a href="#anchor4">4 SortedMap</a><br><a href="#anchor5">5 NavigableMap</a><br><a href="#anchor6">6 Dictionary</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Map"><a href="#1-Map" class="headerlink" title="1. Map"></a>1. Map</h1><p>Map的定义如下：</p>
<pre><code>public interface Map&lt;K,V&gt; { }</code></pre><p>Map 是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值。<br>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。<br>Map 映射顺序。有些实现类，可以明确保证其顺序，如 TreeMap；另一些映射实现则不保证顺序，如 HashMap 类。<br>Map 的实现类应该提供2个“标准的”构造方法：第一个，void（无参数）构造方法，用于创建空映射；第二个，带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新映射。实际上，后一个构造方法允许用户复制任意映射，生成所需类的一个等价映射。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的映射实现都遵从它。</p>
<p><strong>Map的API</strong></p>
<pre><code>abstract void                 clear()
abstract boolean              containsKey(Object key)
abstract boolean              containsValue(Object value)
abstract Set&lt;Entry&lt;K, V&gt;&gt;     entrySet()
abstract boolean              equals(Object object)
abstract V                    get(Object key)
abstract int                  hashCode()
abstract boolean              isEmpty()
abstract Set&lt;K&gt;               keySet()
abstract V                    put(K key, V value)
abstract void                 putAll(Map&lt;? extends K, ? extends V&gt; map)
abstract V                    remove(Object key)
abstract int                  size()
abstract Collection&lt;V&gt;        values()</code></pre><p>说明：<br>(01) Map提供接口分别用于返回 键集、值集或键-值映射关系集。  </p>
<blockquote>
<p>entrySet()用于返回键-值集的Set集合<br>keySet()用于返回键集的Set集合<br>values()用户返回值集的Collection集合<br>因为Map中不能包含重复的键；每个键最多只能映射到一个值。所以，键-值集、键集都是Set，值集时Collection。</p>
</blockquote>
<p>(02) Map提供了“键-值对”、“根据键获取值”、“删除键”、“获取容量大小”等方法。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-Map-Entry"><a href="#2-Map-Entry" class="headerlink" title="2. Map.Entry"></a>2. Map.Entry</h1><p>Map.Entry的定义如下：</p>
<pre><code>interface Entry&lt;K,V&gt; { }</code></pre><p>Map.Entry是Map中内部的一个接口，Map.Entry是键值对，Map通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。</p>
<p><strong>Map.Entry的API</strong></p>
<pre><code>abstract boolean     equals(Object object)
abstract K             getKey()
abstract V             getValue()
abstract int         hashCode()
abstract V             setValue(V object)</code></pre><p><a name="anchor3"></a></p>
<h1 id="3-AbstractMap"><a href="#3-AbstractMap" class="headerlink" title="3. AbstractMap"></a>3. AbstractMap</h1><p>AbstractMap的定义如下：</p>
<pre><code>public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; {}</code></pre><p>AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。<br>要实现不可修改的映射，编程人员只需扩展此类并提供 entrySet 方法的实现即可，该方法将返回映射的映射关系 set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 set 不支持 add() 或 remove() 方法，其迭代器也不支持 remove() 方法。</p>
<p>要实现可修改的映射，编程人员必须另外重写此类的 put 方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其 remove 方法。</p>
<p><strong>AbstractMap的API</strong></p>
<pre><code>abstract Set&lt;Entry&lt;K, V&gt;&gt;     entrySet()
         void                 clear()
         boolean              containsKey(Object key)
         boolean              containsValue(Object value)
         boolean              equals(Object object)
         V                    get(Object key)
         int                  hashCode()
         boolean              isEmpty()
         Set&lt;K&gt;               keySet()
         V                    put(K key, V value)
         void                 putAll(Map&lt;? extends K, ? extends V&gt; map)
         V                    remove(Object key)
         int                  size()
         String               toString()
         Collection&lt;V&gt;        values()
         Object               clone()</code></pre><p><a name="anchor4"></a></p>
<h1 id="4-SortedMap"><a href="#4-SortedMap" class="headerlink" title="4. SortedMap"></a>4. SortedMap</h1><p>SortedMap的定义如下：</p>
<pre><code>public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; { }</code></pre><p>SortedMap是一个继承于Map接口的接口。它是一个有序的SortedMap键值映射。<br>SortedMap的排序方式有两种：自然排序 或者 用户指定比较器。 插入有序 SortedMap 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。</p>
<p>另外，所有SortedMap 实现类都应该提供 4 个“标准”构造方法：<br>(01) void（无参数）构造方法，它创建一个空的有序映射，按照键的自然顺序进行排序。<br>(02) 带有一个 Comparator 类型参数的构造方法，它创建一个空的有序映射，根据指定的比较器进行排序。<br>(03) 带有一个 Map 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系与参数相同，按照键的自然顺序进行排序。<br>(04) 带有一个 SortedMap 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系和排序方法与输入的有序映射相同。无法保证强制实施此建议，因为接口不能包含构造方法。</p>
<p><strong>SortedMap的API</strong></p>
<pre><code>// 继承于Map的API
abstract void                 clear()
abstract boolean              containsKey(Object key)
abstract boolean              containsValue(Object value)
abstract Set&lt;Entry&lt;K, V&gt;&gt;     entrySet()
abstract boolean              equals(Object object)
abstract V                    get(Object key)
abstract int                  hashCode()
abstract boolean              isEmpty()
abstract Set&lt;K&gt;               keySet()
abstract V                    put(K key, V value)
abstract void                 putAll(Map&lt;? extends K, ? extends V&gt; map)
abstract V                    remove(Object key)
abstract int                  size()
abstract Collection&lt;V&gt;        values()
// SortedMap新增的API 
abstract Comparator&lt;? super K&gt;     comparator()
abstract K                         firstKey()
abstract SortedMap&lt;K, V&gt;           headMap(K endKey)
abstract K                         lastKey()
abstract SortedMap&lt;K, V&gt;           subMap(K startKey, K endKey)
abstract SortedMap&lt;K, V&gt;           tailMap(K startKey)</code></pre><p><a name="anchor5"></a></p>
<h1 id="5-NavigableMap"><a href="#5-NavigableMap" class="headerlink" title="5 NavigableMap"></a>5 NavigableMap</h1><p>NavigableMap的定义如下：</p>
<pre><code>public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; { }</code></pre><p>NavigableMap是继承于SortedMap的接口。它是一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。<br>NavigableMap分别提供了获取“键”、“键-值对”、“键集”、“键-值对集”的相关方法。</p>
<p><strong>NavigableMap的API</strong></p>
<pre><code>abstract Entry&lt;K, V&gt;             ceilingEntry(K key)
abstract Entry&lt;K, V&gt;             firstEntry()
abstract Entry&lt;K, V&gt;             floorEntry(K key)
abstract Entry&lt;K, V&gt;             higherEntry(K key)
abstract Entry&lt;K, V&gt;             lastEntry()
abstract Entry&lt;K, V&gt;             lowerEntry(K key)
abstract Entry&lt;K, V&gt;             pollFirstEntry()
abstract Entry&lt;K, V&gt;             pollLastEntry()
abstract K                       ceilingKey(K key)
abstract K                       floorKey(K key)
abstract K                       higherKey(K key)
abstract K                       lowerKey(K key)
abstract NavigableSet&lt;K&gt;         descendingKeySet()
abstract NavigableSet&lt;K&gt;         navigableKeySet()
abstract NavigableMap&lt;K, V&gt;      descendingMap()
abstract NavigableMap&lt;K, V&gt;      headMap(K toKey, boolean inclusive)
abstract SortedMap&lt;K, V&gt;         headMap(K toKey)
abstract SortedMap&lt;K, V&gt;         subMap(K fromKey, K toKey)
abstract NavigableMap&lt;K, V&gt;      subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
abstract SortedMap&lt;K, V&gt;         tailMap(K fromKey)
abstract NavigableMap&lt;K, V&gt;      tailMap(K fromKey, boolean inclusive)</code></pre><p>说明：<br>NavigableMap除了继承SortedMap的特性外，它的提供的功能可以分为4类：<br>第1类，提供操作键-值对的方法。<br>&nbsp;&nbsp;lowerEntry、floorEntry、ceilingEntry 和 higherEntry 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象。<br>&nbsp;&nbsp;firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。<br>第2类，提供操作键的方法。这个和第1类比较类似<br>&nbsp;&nbsp;lowerKey、floorKey、ceilingKey 和 higherKey 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键。<br>第3类，获取键集。<br>&nbsp;&nbsp;navigableKeySet、descendingKeySet分别获取正序/反序的键集。<br>第4类，获取键-值对的子集。</p>
<p><a name="anchor6"></a></p>
<h1 id="6-Dictionary"><a href="#6-Dictionary" class="headerlink" title="6. Dictionary"></a>6. Dictionary</h1><p>Dictionary的定义如下：</p>
<pre><code>public abstract class Dictionary&lt;K,V&gt; {}</code></pre><p>NavigableMap是JDK 1.0定义的键值对的接口，它也包括了操作键值对的基本函数。</p>
<p><strong>Dictionary的API</strong></p>
<pre><code>abstract Enumeration&lt;V&gt;     elements()
abstract V                  get(Object key)
abstract boolean            isEmpty()
abstract Enumeration&lt;K&gt;     keys()
abstract V                  put(K key, V value)
abstract V                  remove(Object key)
abstract int                size()</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/08/java/collection/2012-02-08-collection-08-List/" itemprop="url">Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-08T01:01:00.000Z" itemprop="datePublished">2月 8 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            23 分钟 read (About 3465 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面，我们学完了List的全部内容(ArrayList, LinkedList, Vector, Stack)。现在，我们再回头看看总结一下List。内容包括：</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 List概括</a><br><a href="#anchor2">第2部分 List使用场景</a><br><a href="#anchor3">第3部分 LinkedList和ArrayList性能差异分析</a><br><a href="#anchor4">第4部分 Vector和ArrayList比较</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-List概括"><a href="#第1部分-List概括" class="headerlink" title="第1部分 List概括"></a>第1部分 List概括</h1><p>先回顾一下List的框架图</p>
<p><img src="/media/pic/java/collection/collection08.jpg" alt="img"></p>
<p>(01) List 是一个接口，它继承于Collection的接口。它代表着有序的队列。<br>(02) AbstractList 是一个抽象类，它继承于AbstractCollection。AbstractList实现List接口中除size()、get(int location)之外的函数。<br>(03) AbstractSequentialList 是一个抽象类，它继承于AbstractList。AbstractSequentialList 实现了“链表中，根据index索引值操作链表的全部函数”。<br>(04) ArrayList, LinkedList, Vector, Stack是List的4个实现类。  </p>
<blockquote>
<p>ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。<br>LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率低。<br>Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。<br>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</p>
</blockquote>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-List使用场景"><a href="#第2部分-List使用场景" class="headerlink" title="第2部分 List使用场景"></a>第2部分 List使用场景</h1><p>学东西的最终目的是为了能够理解、使用它。下面先概括的说明一下各个List的使用场景，后面再分析原因。</p>
<p>如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍。<br>(01) 对于需要快速插入，删除元素，应该使用LinkedList。<br>(02) 对于需要快速随机访问元素，应该使用ArrayList。<br>(03) 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。<br>   对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。</p>
<p>通过下面的测试程序，我们来验证上面的(01)和(02)结论。参考代码如下：</p>
<pre><code>import java.util.*;
import java.lang.Class;

/*
 * @desc 对比ArrayList和LinkedList的插入、随机读取效率、删除的效率
 *
 * @author skywang
 */
public class ListCompareTest {

    private static final int COUNT = 100000;

    private static LinkedList linkedList = new LinkedList();
    private static ArrayList arrayList = new ArrayList();
    private static Vector vector = new Vector();
    private static Stack stack = new Stack();

    public static void main(String[] args) {
        // 换行符
        System.out.println();
        // 插入
        insertByPosition(stack) ;
        insertByPosition(vector) ;
        insertByPosition(linkedList) ;
        insertByPosition(arrayList) ;

        // 换行符
        System.out.println();
        // 随机读取
        readByPosition(stack);
        readByPosition(vector);
        readByPosition(linkedList);
        readByPosition(arrayList);

        // 换行符
        System.out.println();
        // 删除 
        deleteByPosition(stack);
        deleteByPosition(vector);
        deleteByPosition(linkedList);
        deleteByPosition(arrayList);
    }

    // 获取list的名称
    private static String getListName(List list) {
        if (list instanceof LinkedList) {
            return &quot;LinkedList&quot;;
        } else if (list instanceof ArrayList) {
            return &quot;ArrayList&quot;;
        } else if (list instanceof Stack) {
            return &quot;Stack&quot;;
        } else if (list instanceof Vector) {
            return &quot;Vector&quot;;
        } else {
            return &quot;List&quot;;
        }
    }

    // 向list的指定位置插入COUNT个元素，并统计时间
    private static void insertByPosition(List list) {
        long startTime = System.currentTimeMillis();

        // 向list的位置0插入COUNT个数
        for (int i=0; i&lt;COUNT; i++)
            list.add(0, i);

        long endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(getListName(list) + &quot; : insert &quot;+COUNT+&quot; elements into the 1st position use time：&quot; + interval+&quot; ms&quot;);
    }

    // 从list的指定位置删除COUNT个元素，并统计时间
    private static void deleteByPosition(List list) {
        long startTime = System.currentTimeMillis();

        // 删除list第一个位置元素
        for (int i=0; i&lt;COUNT; i++)
            list.remove(0);

        long endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(getListName(list) + &quot; : delete &quot;+COUNT+&quot; elements from the 1st position use time：&quot; + interval+&quot; ms&quot;);
    }

    // 根据position，不断从list中读取元素，并统计时间
    private static void readByPosition(List list) {
        long startTime = System.currentTimeMillis();

        // 读取list元素
        for (int i=0; i&lt;COUNT; i++)
            list.get(i);

        long endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(getListName(list) + &quot; : read &quot;+COUNT+&quot; elements by position use time：&quot; + interval+&quot; ms&quot;);
    }
}</code></pre><p>运行结果如下：</p>
<pre><code>Stack : insert 100000 elements into the 1st position use time：1640 ms
Vector : insert 100000 elements into the 1st position use time：1607 ms
LinkedList : insert 100000 elements into the 1st position use time：29 ms
ArrayList : insert 100000 elements into the 1st position use time：1617 ms

Stack : read 100000 elements by position use time：9 ms
Vector : read 100000 elements by position use time：6 ms
LinkedList : read 100000 elements by position use time：10809 ms
ArrayList : read 100000 elements by position use time：5 ms

Stack : delete 100000 elements from the 1st position use time：1916 ms
Vector : delete 100000 elements from the 1st position use time：1910 ms
LinkedList : delete 100000 elements from the 1st position use time：15 ms
ArrayList : delete 100000 elements from the 1st position use time：1909 ms</code></pre><p>从中，我们可以发现：<br>插入10万个元素，LinkedList所花时间最短：29ms。<br>删除10万个元素，LinkedList所花时间最短：15ms。<br>遍历10万个元素，LinkedList所花时间最长：10809 ms；而ArrayList、Stack和Vector则相差不多，都只用了几秒。</p>
<p>考虑到Vector是支持同步的，而Stack又是继承于Vector的；因此，得出结论：<br>(01) 对于需要快速插入，删除元素，应该使用LinkedList。<br>(02) 对于需要快速随机访问元素，应该使用ArrayList。<br>(03) 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-LinkedList和ArrayList性能差异分析"><a href="#第3部分-LinkedList和ArrayList性能差异分析" class="headerlink" title="第3部分 LinkedList和ArrayList性能差异分析"></a>第3部分 LinkedList和ArrayList性能差异分析</h1><p>下面我们看看为什么LinkedList中插入元素很快，而ArrayList中插入元素很慢！</p>
<p>LinkedList.java中向指定位置插入元素的代码如下：</p>
<pre><code>// 在index前添加节点，且节点的值为element
public void add(int index, E element) {
    addBefore(element, (index==size ? header : entry(index)));
}

// 获取双向链表中指定位置的节点
private Entry&lt;E&gt; entry(int index) {
    if (index &lt; 0 || index &gt;= size)
        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+
                                            &quot;, Size: &quot;+size);
    Entry&lt;E&gt; e = header;
    // 获取index处的节点。
    // 若index &lt; 双向链表长度的1/2,则从前向后查找;
    // 否则，从后向前查找。
    if (index &lt; (size &gt;&gt; 1)) {
        for (int i = 0; i &lt;= index; i++)
            e = e.next;
    } else {
        for (int i = size; i &gt; index; i--)
            e = e.previous;
    }
    return e;
}

// 将节点(节点数据是e)添加到entry节点之前。
private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) {
    // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e
    Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);
    // 插入newEntry到链表中
    newEntry.previous.next = newEntry;
    newEntry.next.previous = newEntry;
    size++;
    modCount++;
    return newEntry;
}</code></pre><p>从中，我们可以看出：通过add(int index, E element)向LinkedList插入元素时。先是在双向链表中找到要插入节点的位置index；找到之后，再插入一个新节点。<br>双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。</p>
<p>接着，我们看看ArrayList.java中向指定位置插入元素的代码。如下：</p>
<pre><code>// 将e添加到ArrayList的指定位置
public void add(int index, E element) {
    if (index &gt; size || index &lt; 0)
        throw new IndexOutOfBoundsException(
        &quot;Index: &quot;+index+&quot;, Size: &quot;+size);

    ensureCapacity(size+1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1,
         size - index);
    elementData[index] = element;
    size++;
}</code></pre><p>ensureCapacity(size+1) 的作用是“确认ArrayList的容量，若容量不够，则增加容量。”<br>真正耗时的操作是 <code>System.arraycopy(elementData, index, elementData, index + 1, size - index);</code></p>
<p>Sun JDK包的java/lang/System.java中的arraycopy()声明如下：</p>
<pre><code>public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</code></pre><p>arraycopy()是个JNI函数，它是在JVM中实现的。sunJDK中看不到源码，不过可以在OpenJDK包中看到的源码。网上有对arraycopy()的分析说明，请参考：System.arraycopy源码分析<br>实际上，我们只需要了解： <code>System.arraycopy(elementData, index, elementData, index + 1, size - index)</code>; 会移动index之后所有元素即可。这就意味着，ArrayList的<code>add(int index, E element)</code>函数，会引起index之后所有元素的改变！</p>
<p>通过上面的分析，我们就能理解为什么LinkedList中插入元素很快，而ArrayList中插入元素很慢。<br>“删除元素”与“插入元素”的原理类似，这里就不再过多说明。</p>
<p>接下来，我们看看 “为什么LinkedList中随机访问很慢，而ArrayList中随机访问很快”。</p>
<p>先看看LinkedList随机访问的代码</p>
<pre><code>// 返回LinkedList指定位置的元素
public E get(int index) {
    return entry(index).element;
}

// 获取双向链表中指定位置的节点
private Entry&lt;E&gt; entry(int index) {
    if (index &lt; 0 || index &gt;= size)
        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+
                                            &quot;, Size: &quot;+size);
    Entry&lt;E&gt; e = header;
    // 获取index处的节点。
    // 若index &lt; 双向链表长度的1/2,则从前先后查找;
    // 否则，从后向前查找。
    if (index &lt; (size &gt;&gt; 1)) {
        for (int i = 0; i &lt;= index; i++)
            e = e.next;
    } else {
        for (int i = size; i &gt; index; i--)
            e = e.previous;
    }
    return e;
}</code></pre><p>从中，我们可以看出：通过get(int index)获取LinkedList第index个元素时。先是在双向链表中找到要index位置的元素；找到之后再返回。<br>双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。</p>
<p>下面看看ArrayList随机访问的代码 </p>
<pre><code>// 获取index位置的元素值
public E get(int index) {
    RangeCheck(index);

    return (E) elementData[index];
}

private void RangeCheck(int index) {
    if (index &gt;= size)
        throw new IndexOutOfBoundsException(
        &quot;Index: &quot;+index+&quot;, Size: &quot;+size);
}</code></pre><p>从中，我们可以看出：通过get(int index)获取ArrayList第index个元素时。直接返回数组中index位置的元素，而不需要像LinkedList一样进行查找。</p>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-Vector和ArrayList比较"><a href="#第4部分-Vector和ArrayList比较" class="headerlink" title="第4部分 Vector和ArrayList比较"></a>第4部分 Vector和ArrayList比较</h1><h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><p><strong>1 它们都是List</strong></p>
<p>它们都继承于AbstractList，并且实现List接口。ArrayList和Vector的类定义如下：</p>
<pre><code>// ArrayList的定义
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable

// Vector的定义
public class Vector&lt;E&gt; extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}</code></pre><p><strong>2 它们都实现了RandomAccess和Cloneable接口</strong></p>
<p>实现RandomAccess接口，意味着它们都支持快速随机访问；<br>实现Cloneable接口，意味着它们能克隆自己。</p>
<p><strong>3 它们都是通过数组实现的，本质上都是动态数组</strong></p>
<p>ArrayList.java中定义数组elementData用于保存元素</p>
<pre><code>// 保存ArrayList中数据的数组
private transient Object[] elementData;

Vector.java中也定义了数组elementData用于保存元素

// 保存Vector中数据的数组
protected Object[] elementData;</code></pre><p><strong>4 它们的默认数组容量是10</strong></p>
<p>若创建ArrayList或Vector时，没指定容量大小；则使用默认容量大小10。</p>
<p>ArrayList的默认构造函数如下：</p>
<pre><code>// ArrayList构造函数。默认容量是10。
public ArrayList() {
    this(10);
}</code></pre><p>Vector的默认构造函数如下：</p>
<pre><code>// Vector构造函数。默认容量是10。
public Vector() {
    this(10);
} </code></pre><p><strong>5 它们都支持Iterator和listIterator遍历</strong></p>
<p>它们都继承于AbstractList，而AbstractList中分别实现了 “iterator()接口返回Iterator迭代器” 和 “listIterator()返回ListIterator迭代器”。</p>
<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><p><strong>1 线程安全性不一样</strong></p>
<p>ArrayList是非线程安全；<br>而Vector是线程安全的，它的函数都是synchronized的，即都是支持同步的。<br>ArrayList适用于单线程，Vector适用于多线程。</p>
<p><strong>2 对序列化支持不同</strong></p>
<p>ArrayList支持序列化，而Vector不支持；即ArrayList有实现java.io.Serializable接口，而Vector没有实现该接口。</p>
<p><strong>3 构造函数个数不同</strong><br>   ArrayList有3个构造函数，而Vector有4个构造函数。Vector除了包括和ArrayList类似的3个构造函数之外，另外的一个构造函数可以指定容量增加系数。</p>
<p>ArrayList的构造函数如下：</p>
<pre><code>// 默认构造函数
ArrayList()

// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。
ArrayList(int capacity)

// 创建一个包含collection的ArrayList
ArrayList(Collection&lt;? extends E&gt; collection)

Vector的构造函数如下：

// 默认构造函数
Vector()

// capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。
Vector(int capacity)

// 创建一个包含collection的Vector
Vector(Collection&lt;? extends E&gt; collection)

// capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。
Vector(int capacity, int capacityIncrement)</code></pre><p><strong>4 容量增加方式不同</strong></p>
<p>逐个添加元素时，若ArrayList容量不足时，“新的容量”=“(原始容量x3)/2 + 1”。<br>而Vector的容量增长与“增长系数有关”，若指定了“增长系数”，且“增长系数有效(即，大于0)”；那么，每次容量不足时，“新的容量”=“原始容量+增长系数”。若增长系数无效(即，小于/等于0)，则“新的容量”=“原始容量 x 2”。</p>
<p>ArrayList中容量增长的主要函数如下：</p>
<pre><code>public void ensureCapacity(int minCapacity) {
    // 将“修改统计数”+1
    modCount++;
    int oldCapacity = elementData.length;
    // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”
    if (minCapacity &gt; oldCapacity) {
        Object oldData[] = elementData;
        int newCapacity = (oldCapacity * 3)/2 + 1;
        if (newCapacity &lt; minCapacity)
            newCapacity = minCapacity;
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
}</code></pre><p>Vector中容量增长的主要函数如下：</p>
<pre><code>private void ensureCapacityHelper(int minCapacity) {
    int oldCapacity = elementData.length;
    // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。
    // 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement
    // 否则，将容量增大一倍。
    if (minCapacity &gt; oldCapacity) {
        Object[] oldData = elementData;
        int newCapacity = (capacityIncrement &gt; 0) ?
            (oldCapacity + capacityIncrement) : (oldCapacity * 2);
        if (newCapacity &lt; minCapacity) {
            newCapacity = minCapacity;
        }
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
}</code></pre><p><strong>5 对Enumeration的支持不同。Vector支持通过Enumeration去遍历，而List不支持</strong></p>
<p>Vector中实现Enumeration的代码如下：</p>
<pre><code>public Enumeration&lt;E&gt; elements() {
    // 通过匿名类实现Enumeration
    return new Enumeration&lt;E&gt;() {
        int count = 0;

        // 是否存在下一个元素
        public boolean hasMoreElements() {
            return count &lt; elementCount;
        }

        // 获取下一个元素
        public E nextElement() {
            synchronized (Vector.this) {
                if (count &lt; elementCount) {
                    return (E)elementData[count++];
                }
            }
            throw new NoSuchElementException(&quot;Vector Enumeration&quot;);
        }
    };
}</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/07/java/collection/2012-02-07-collection-07-stack/" itemprop="url">Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-07T01:01:00.000Z" itemprop="datePublished">2月 7 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            10 分钟 read (About 1509 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>学完Vector了之后，接下来我们开始学习Stack。Stack很简单，它继承于Vector。学习方式还是和之前一样，先对Stack有个整体认识，然后再学习它的源码；最后再通过实例来学会使用它。内容包括：</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 Stack介绍</a><br><a href="#anchor2">第2部分 Stack源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor3">第3部分 Vector示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-Stack介绍"><a href="#第1部分-Stack介绍" class="headerlink" title="第1部分 Stack介绍"></a>第1部分 Stack介绍</h1><h2 id="Stack简介"><a href="#Stack简介" class="headerlink" title="Stack简介"></a>Stack简介</h2><p>Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。</p>
<p>java工具包中的Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。当然，我们也可以将LinkedList当作栈来使用！在“Java 集合系列06之 Vector详细介绍(源码解析)和使用示例”中，已经详细介绍过Vector的数据结构，这里就不再对Stack的数据结构进行说明了。</p>
<p>Stack的继承关系</p>
<pre><code>java.lang.Object
↳     java.util.AbstractCollection&lt;E&gt;
   ↳     java.util.AbstractList&lt;E&gt;
       ↳     java.util.Vector&lt;E&gt;
           ↳     java.util.Stack&lt;E&gt;</code></pre><p>Stack的声明</p>
<pre><code>public class Stack&lt;E&gt; extends Vector&lt;E&gt; {}</code></pre><p>Stack和Collection的关系如下图：</p>
<p><img src="/media/pic/java/collection/collection07.jpg" alt="img"></p>
<p>Stack的构造函数</p>
<pre><code>Stack()</code></pre><p>Stack的API</p>
<pre><code>         boolean       empty()
synchronized E             peek()
synchronized E             pop()
             E             push(E object)
synchronized int           search(Object o)</code></pre><p>由于Stack和继承于Vector，因此它也包含Vector中的全部API。</p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-Stack源码解析-基于JDK1-6-0-45"><a href="#第2部分-Stack源码解析-基于JDK1-6-0-45" class="headerlink" title="第2部分 Stack源码解析(基于JDK1.6.0_45)"></a>第2部分 Stack源码解析(基于JDK1.6.0_45)</h1><p>Stack的源码非常简单，下面我们对它进行学习。 </p>
<pre><code>package java.util;

public
class Stack&lt;E&gt; extends Vector&lt;E&gt; {
    // 版本ID。这个用于版本升级控制，这里不须理会！
    private static final long serialVersionUID = 1224463164541339165L;

    // 构造函数
    public Stack() {
    }

    // push函数：将元素存入栈顶
    public E push(E item) {
        // 将元素存入栈顶。
        // addElement()的实现在Vector.java中
        addElement(item);

        return item;
    }

    // pop函数：返回栈顶元素，并将其从栈中删除
    public synchronized E pop() {
        E    obj;
        int    len = size();

        obj = peek();
        // 删除栈顶元素，removeElementAt()的实现在Vector.java中
        removeElementAt(len - 1);

        return obj;
    }

    // peek函数：返回栈顶元素，不执行删除操作
    public synchronized E peek() {
        int    len = size();

        if (len == 0)
            throw new EmptyStackException();
        // 返回栈顶元素，elementAt()具体实现在Vector.java中
        return elementAt(len - 1);
    }

    // 栈是否为空
    public boolean empty() {
        return size() == 0;
    }

    // 查找“元素o”在栈中的位置：由栈底向栈顶方向数
    public synchronized int search(Object o) {
        // 获取元素索引，elementAt()具体实现在Vector.java中
        int i = lastIndexOf(o);

        if (i &gt;= 0) {
            return size() - i;
        }
        return -1;
    }
}</code></pre><p>总结：</p>
<p>(01) Stack实际上也是通过数组去实现的。  </p>
<blockquote>
<p>执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。<br>执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。<br>执行pull时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。<br>(02) Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。  </p>
</blockquote>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-Vector示例"><a href="#第3部分-Vector示例" class="headerlink" title="第3部分 Vector示例"></a>第3部分 Vector示例</h1><p>下面我们通过实例学习如何使用Stack</p>
<pre><code>import java.util.Stack;
import java.util.Iterator;
import java.util.List;

/**
 * @desc Stack的测试程序。测试常用API的用法
 *
 * @author skywang
 */
public class StackTest {

    public static void main(String[] args) {
        Stack stack = new Stack();
        // 将1,2,3,4,5添加到栈中
        for(int i=1; i&lt;6; i++) {
            stack.push(String.valueOf(i));
        }

        // 遍历并打印出该栈
        iteratorThroughRandomAccess(stack) ;

        // 查找“2”在栈中的位置，并输出
        int pos = stack.search(&quot;2&quot;);
        System.out.println(&quot;the postion of 2 is:&quot;+pos);

        // pup栈顶元素之后，遍历栈
        stack.pop();
        iteratorThroughRandomAccess(stack) ;

        // peek栈顶元素之后，遍历栈
        String val = (String)stack.peek();
        System.out.println(&quot;peek:&quot;+val);
        iteratorThroughRandomAccess(stack) ;

        // 通过Iterator去遍历Stack
        iteratorThroughIterator(stack) ;
    }

    /**
     * 通过快速访问遍历Stack
     */
    public static void iteratorThroughRandomAccess(List list) {
        String val = null;
        for (int i=0; i&lt;list.size(); i++) {
            val = (String)list.get(i);
            System.out.print(val+&quot; &quot;);
        }
        System.out.println();
    }

    /**
     * 通过迭代器遍历Stack
     */
    public static void iteratorThroughIterator(List list) {

        String val = null;
        for(Iterator iter = list.iterator(); iter.hasNext(); ) {
            val = (String)iter.next();
            System.out.print(val+&quot; &quot;);
        }
        System.out.println();
    }

}</code></pre><p>运行结果： </p>
<pre><code>1 2 3 4 5 
the postion of 2 is:4
1 2 3 4 
peek:4
1 2 3 4 
1 2 3 4 </code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/06/java/collection/2012-02-06-collection-06-vector/" itemprop="url">Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-06T01:01:00.000Z" itemprop="datePublished">2月 6 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            27 分钟 read (About 3984 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>学完ArrayList和LinkedList之后，我们接着学习Vector。学习方式还是和之前一样，先对Vector有个整体认识，然后再学习它的源码；最后再通过实例来学会使用它。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 Vector介绍</a><br><a href="#anchor2">第2部分 Vector数据结构</a><br><a href="#anchor3">第3部分 Vector源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 Vector遍历方式</a><br><a href="#anchor5">第5部分 Vector示例</a> </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-Vector介绍"><a href="#第1部分-Vector介绍" class="headerlink" title="第1部分 Vector介绍"></a>第1部分 Vector介绍</h1><h2 id="Vector简介"><a href="#Vector简介" class="headerlink" title="Vector简介"></a>Vector简介</h2><p>Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。<br>Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。<br>Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。<br>Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。</p>
<p>和ArrayList不同，Vector中的操作是线程安全的。</p>
<h2 id="Vector的构造函数"><a href="#Vector的构造函数" class="headerlink" title="Vector的构造函数"></a>Vector的构造函数</h2><pre><code>Vector共有4个构造函数
// 默认构造函数
Vector()

// capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。
Vector(int capacity)

// capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。
Vector(int capacity, int capacityIncrement)

// 创建一个包含collection的Vector
Vector(Collection&lt;? extends E&gt; collection)</code></pre><h2 id="Vector的API"><a href="#Vector的API" class="headerlink" title="Vector的API"></a>Vector的API</h2><pre><code>synchronized boolean        add(E object)
             void           add(int location, E object)
synchronized boolean        addAll(Collection&lt;? extends E&gt; collection)
synchronized boolean        addAll(int location, Collection&lt;? extends E&gt; collection)
synchronized void           addElement(E object)
synchronized int            capacity()
             void           clear()
synchronized Object         clone()
             boolean        contains(Object object)
synchronized boolean        containsAll(Collection&lt;?&gt; collection)
synchronized void           copyInto(Object[] elements)
synchronized E              elementAt(int location)
             Enumeration&lt;E&gt; elements()
synchronized void           ensureCapacity(int minimumCapacity)
synchronized boolean        equals(Object object)
synchronized E              firstElement()
             E              get(int location)
synchronized int            hashCode()
synchronized int            indexOf(Object object, int location)
             int            indexOf(Object object)
synchronized void           insertElementAt(E object, int location)
synchronized boolean        isEmpty()
synchronized E              lastElement()
synchronized int            lastIndexOf(Object object, int location)
synchronized int            lastIndexOf(Object object)
synchronized E              remove(int location)
             boolean        remove(Object object)
synchronized boolean        removeAll(Collection&lt;?&gt; collection)
synchronized void           removeAllElements()
synchronized boolean        removeElement(Object object)
synchronized void           removeElementAt(int location)
synchronized boolean        retainAll(Collection&lt;?&gt; collection)
synchronized E              set(int location, E object)
synchronized void           setElementAt(E object, int location)
synchronized void           setSize(int length)
synchronized int            size()
synchronized List&lt;E&gt;        subList(int start, int end)
synchronized &lt;T&gt; T[]        toArray(T[] contents)
synchronized Object[]       toArray()
synchronized String         toString()
synchronized void           trimToSize()</code></pre><p><a name="anchor2"></a></p>
<h1 id="第2部分-Vector数据结构"><a href="#第2部分-Vector数据结构" class="headerlink" title="第2部分 Vector数据结构"></a>第2部分 Vector数据结构</h1><p>Vector的继承关系</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractCollection&lt;E&gt;
         ↳     java.util.AbstractList&lt;E&gt;
               ↳     java.util.Vector&lt;E&gt;</code></pre><p>Vector的声明</p>
<pre><code>public class Vector&lt;E&gt;
    extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}</code></pre><p>Vector与Collection关系如下图：</p>
<p><img src="/media/pic/java/collection/collection06.jpg" alt="img"></p>
<p>Vector的数据结构和ArrayList差不多，它包含了3个成员变量：<strong>elementData</strong> , <strong>elementCount</strong>， <strong>capacityIncrement</strong>。</p>
<p>(01) elementData 是”Object[]类型的数组”，它保存了添加到Vector中的元素。elementData是个动态数组，如果初始化Vector时，没指定动态数组的&gt;大小，则使用默认大小10。随着Vector中元素的增加，Vector的容量也会动态增长，capacityIncrement是与容量增长相关的增长系数，具体的增长方式，请参考源码分析中的ensureCapacity()函数。</p>
<p>(02) elementCount 是动态数组的实际大小。</p>
<p>(03) capacityIncrement 是动态数组的增长系数。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-Vector源码解析-基于JDK1-6-0-45"><a href="#第3部分-Vector源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 Vector源码解析(基于JDK1.6.0_45)"></a>第3部分 Vector源码解析(基于JDK1.6.0_45)</h1><p>为了更了解Vector的原理，下面对Vector源码代码作出分析。 </p>
<pre><code>package java.util;

public class Vector&lt;E&gt;
    extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{

    // 保存Vector中数据的数组
    protected Object[] elementData;

    // 实际数据的数量
    protected int elementCount;

    // 容量增长系数
    protected int capacityIncrement;

    // Vector的序列版本号
    private static final long serialVersionUID = -2767605614048989439L;

    // Vector构造函数。默认容量是10。
    public Vector() {
        this(10);
    }

    // 指定Vector容量大小的构造函数
    public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }

    // 指定Vector&quot;容量大小&quot;和&quot;增长系数&quot;的构造函数
    public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        // 新建一个数组，数组容量是initialCapacity
        this.elementData = new Object[initialCapacity];
        // 设置容量增长系数
        this.capacityIncrement = capacityIncrement;
    }

    // 指定集合的Vector构造函数。
    public Vector(Collection&lt;? extends E&gt; c) {
        // 获取“集合(c)”的数组，并将其赋值给elementData
        elementData = c.toArray();
        // 设置数组长度
        elementCount = elementData.length;
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);
    }

    // 将数组Vector的全部元素都拷贝到数组anArray中
    public synchronized void copyInto(Object[] anArray) {
        System.arraycopy(elementData, 0, anArray, 0, elementCount);
    }

    // 将当前容量值设为 =实际元素个数
    public synchronized void trimToSize() {
        modCount++;
        int oldCapacity = elementData.length;
        if (elementCount &lt; oldCapacity) {
            elementData = Arrays.copyOf(elementData, elementCount);
        }
    }

    // 确认“Vector容量”的帮助函数
    private void ensureCapacityHelper(int minCapacity) {
        int oldCapacity = elementData.length;
        // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。
        // 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement
        // 否则，将容量增大一倍。
        if (minCapacity &gt; oldCapacity) {
            Object[] oldData = elementData;
            int newCapacity = (capacityIncrement &gt; 0) ?
                (oldCapacity + capacityIncrement) : (oldCapacity * 2);
            if (newCapacity &lt; minCapacity) {
                newCapacity = minCapacity;
            }
            elementData = Arrays.copyOf(elementData, newCapacity);
        }
    }

    // 确定Vector的容量。
    public synchronized void ensureCapacity(int minCapacity) {
        // 将Vector的改变统计数+1
        modCount++;
        ensureCapacityHelper(minCapacity);
    }

    // 设置容量值为 newSize
    public synchronized void setSize(int newSize) {
        modCount++;
        if (newSize &gt; elementCount) {
            // 若 &quot;newSize 大于 Vector容量&quot;，则调整Vector的大小。
            ensureCapacityHelper(newSize);
        } else {
            // 若 &quot;newSize 小于/等于 Vector容量&quot;，则将newSize位置开始的元素都设置为null
            for (int i = newSize ; i &lt; elementCount ; i++) {
                elementData[i] = null;
            }
        }
        elementCount = newSize;
    }

    // 返回“Vector的总的容量”
    public synchronized int capacity() {
        return elementData.length;
    }

    // 返回“Vector的实际大小”，即Vector中元素个数
    public synchronized int size() {
        return elementCount;
    }

    // 判断Vector是否为空
    public synchronized boolean isEmpty() {
        return elementCount == 0;
    }

    // 返回“Vector中全部元素对应的Enumeration”
    public Enumeration&lt;E&gt; elements() {
        // 通过匿名类实现Enumeration
        return new Enumeration&lt;E&gt;() {
            int count = 0;

            // 是否存在下一个元素
            public boolean hasMoreElements() {
                return count &lt; elementCount;
            }

            // 获取下一个元素
            public E nextElement() {
                synchronized (Vector.this) {
                    if (count &lt; elementCount) {
                        return (E)elementData[count++];
                    }
                }
                throw new NoSuchElementException(&quot;Vector Enumeration&quot;);
            }
        };
    }

    // 返回Vector中是否包含对象(o)
    public boolean contains(Object o) {
        return indexOf(o, 0) &gt;= 0;
    }


    // 从index位置开始向后查找元素(o)。
    // 若找到，则返回元素的索引值；否则，返回-1
    public synchronized int indexOf(Object o, int index) {
        if (o == null) {
            // 若查找元素为null，则正向找出null元素，并返回它对应的序号
            for (int i = index ; i &lt; elementCount ; i++)
            if (elementData[i]==null)
                return i;
        } else {
            // 若查找元素不为null，则正向找出该元素，并返回它对应的序号
            for (int i = index ; i &lt; elementCount ; i++)
            if (o.equals(elementData[i]))
                return i;
        }
        return -1;
    }

    // 查找并返回元素(o)在Vector中的索引值
    public int indexOf(Object o) {
        return indexOf(o, 0);
    }

    // 从后向前查找元素(o)。并返回元素的索引
    public synchronized int lastIndexOf(Object o) {
        return lastIndexOf(o, elementCount-1);
    }

    // 从后向前查找元素(o)。开始位置是从前向后的第index个数；
    // 若找到，则返回元素的“索引值”；否则，返回-1。
    public synchronized int lastIndexOf(Object o, int index) {
        if (index &gt;= elementCount)
            throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot;+ elementCount);

        if (o == null) {
            // 若查找元素为null，则反向找出null元素，并返回它对应的序号
            for (int i = index; i &gt;= 0; i--)
            if (elementData[i]==null)
                return i;
        } else {
            // 若查找元素不为null，则反向找出该元素，并返回它对应的序号
            for (int i = index; i &gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
        }
        return -1;
    }

    // 返回Vector中index位置的元素。
    // 若index月结，则抛出异常
    public synchronized E elementAt(int index) {
        if (index &gt;= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount);
        }

        return (E)elementData[index];
    }

    // 获取Vector中的第一个元素。
    // 若失败，则抛出异常！
    public synchronized E firstElement() {
        if (elementCount == 0) {
            throw new NoSuchElementException();
        }
        return (E)elementData[0];
    }

    // 获取Vector中的最后一个元素。
    // 若失败，则抛出异常！
    public synchronized E lastElement() {
        if (elementCount == 0) {
            throw new NoSuchElementException();
        }
        return (E)elementData[elementCount - 1];
    }

    // 设置index位置的元素值为obj
    public synchronized void setElementAt(E obj, int index) {
        if (index &gt;= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +
                                 elementCount);
        }
        elementData[index] = obj;
    }

    // 删除index位置的元素
    public synchronized void removeElementAt(int index) {
        modCount++;
        if (index &gt;= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +
                                 elementCount);
        } else if (index &lt; 0) {
            throw new ArrayIndexOutOfBoundsException(index);
        }

        int j = elementCount - index - 1;
        if (j &gt; 0) {
            System.arraycopy(elementData, index + 1, elementData, index, j);
        }
        elementCount--;
        elementData[elementCount] = null; /* to let gc do its work */
    }

    // 在index位置处插入元素(obj)
    public synchronized void insertElementAt(E obj, int index) {
        modCount++;
        if (index &gt; elementCount) {
            throw new ArrayIndexOutOfBoundsException(index
                                 + &quot; &gt; &quot; + elementCount);
        }
        ensureCapacityHelper(elementCount + 1);
        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);
        elementData[index] = obj;
        elementCount++;
    }

    // 将“元素obj”添加到Vector末尾
    public synchronized void addElement(E obj) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = obj;
    }

    // 在Vector中查找并删除元素obj。
    // 成功的话，返回true；否则，返回false。
    public synchronized boolean removeElement(Object obj) {
        modCount++;
        int i = indexOf(obj);
        if (i &gt;= 0) {
            removeElementAt(i);
            return true;
        }
        return false;
    }

    // 删除Vector中的全部元素
    public synchronized void removeAllElements() {
        modCount++;
        // 将Vector中的全部元素设为null
        for (int i = 0; i &lt; elementCount; i++)
            elementData[i] = null;

        elementCount = 0;
    }

    // 克隆函数
    public synchronized Object clone() {
        try {
            Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone();
            // 将当前Vector的全部元素拷贝到v中
            v.elementData = Arrays.copyOf(elementData, elementCount);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn&apos;t happen, since we are Cloneable
            throw new InternalError();
        }
    }

    // 返回Object数组
    public synchronized Object[] toArray() {
        return Arrays.copyOf(elementData, elementCount);
    }

    // 返回Vector的模板数组。所谓模板数组，即可以将T设为任意的数据类型
    public synchronized &lt;T&gt; T[] toArray(T[] a) {
        // 若数组a的大小 &lt; Vector的元素个数；
        // 则新建一个T[]数组，数组大小是“Vector的元素个数”，并将“Vector”全部拷贝到新数组中
        if (a.length &lt; elementCount)
            return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());

        // 若数组a的大小 &gt;= Vector的元素个数；
        // 则将Vector的全部元素都拷贝到数组a中。
    System.arraycopy(elementData, 0, a, 0, elementCount);

        if (a.length &gt; elementCount)
            a[elementCount] = null;

        return a;
    }

    // 获取index位置的元素
    public synchronized E get(int index) {
        if (index &gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        return (E)elementData[index];
    }

    // 设置index位置的值为element。并返回index位置的原始值
    public synchronized E set(int index, E element) {
        if (index &gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        Object oldValue = elementData[index];
        elementData[index] = element;
        return (E)oldValue;
    }

    // 将“元素e”添加到Vector最后。
    public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }

    // 删除Vector中的元素o
    public boolean remove(Object o) {
        return removeElement(o);
    }

    // 在index位置添加元素element
    public void add(int index, E element) {
        insertElementAt(element, index);
    }

    // 删除index位置的元素，并返回index位置的原始值
    public synchronized E remove(int index) {
        modCount++;
        if (index &gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);
        Object oldValue = elementData[index];

        int numMoved = elementCount - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                     numMoved);
        elementData[--elementCount] = null; // Let gc do its work

        return (E)oldValue;
    }

    // 清空Vector
    public void clear() {
        removeAllElements();
    }

    // 返回Vector是否包含集合c
    public synchronized boolean containsAll(Collection&lt;?&gt; c) {
        return super.containsAll(c);
    }

    // 将集合c添加到Vector中
    public synchronized boolean addAll(Collection&lt;? extends E&gt; c) {
        modCount++;
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityHelper(elementCount + numNew);
        // 将集合c的全部元素拷贝到数组elementData中
        System.arraycopy(a, 0, elementData, elementCount, numNew);
        elementCount += numNew;
        return numNew != 0;
    }

    // 删除集合c的全部元素
    public synchronized boolean removeAll(Collection&lt;?&gt; c) {
        return super.removeAll(c);
    }

    // 删除“非集合c中的元素”
    public synchronized boolean retainAll(Collection&lt;?&gt; c)  {
        return super.retainAll(c);
    }

    // 从index位置开始，将集合c添加到Vector中
    public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        modCount++;
        if (index &lt; 0 || index &gt; elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityHelper(elementCount + numNew);

        int numMoved = elementCount - index;
        if (numMoved &gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        elementCount += numNew;
        return numNew != 0;
    }

    // 返回两个对象是否相等
    public synchronized boolean equals(Object o) {
        return super.equals(o);
    }

    // 计算哈希值
    public synchronized int hashCode() {
        return super.hashCode();
    }

    // 调用父类的toString()
    public synchronized String toString() {
        return super.toString();
    }

    // 获取Vector中fromIndex(包括)到toIndex(不包括)的子集
    public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) {
        return Collections.synchronizedList(super.subList(fromIndex, toIndex), this);
    }

    // 删除Vector中fromIndex到toIndex的元素
    protected synchronized void removeRange(int fromIndex, int toIndex) {
        modCount++;
        int numMoved = elementCount - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

        // Let gc do its work
        int newElementCount = elementCount - (toIndex-fromIndex);
        while (elementCount != newElementCount)
            elementData[--elementCount] = null;
    }

    // java.io.Serializable的写入函数
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        s.defaultWriteObject();
    }
}</code></pre><p>总结：<br>(01) Vector实际上是通过一个数组去保存数据的。当我们构造Vecotr时；若使用默认构造函数，则Vector的默认容量大小是10。<br>(02) 当Vector容量不足以容纳全部元素时，Vector的容量会增加。若容量增加系数 &gt;0，则将容量的值增加“容量增加系数”；否则，将容量大小增加一倍。<br>(03) Vector的克隆函数，即是将全部元素克隆到一个数组中。</p>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-Vector遍历方式"><a href="#第4部分-Vector遍历方式" class="headerlink" title="第4部分 Vector遍历方式"></a>第4部分 Vector遍历方式</h1><p>Vector支持4种遍历方式。建议使用下面的第二种去遍历Vector，因为效率问题。</p>
<p><strong>(01) 第一种，通过迭代器遍历。即通过Iterator去遍历。</strong></p>
<pre><code>Integer value = null;
int size = vec.size();
for (int i=0; i&lt;size; i++) {
    value = (Integer)vec.get(i);        
}</code></pre><p><strong>(02) 第二种，随机访问，通过索引值去遍历。</strong></p>
<p>由于Vector实现了RandomAccess接口，它支持通过索引值去随机访问元素。</p>
<pre><code>Integer value = null;
int size = vec.size();
for (int i=0; i&lt;size; i++) {
    value = (Integer)vec.get(i);        
}</code></pre><p><strong>(03) 第三种，另一种for循环。</strong></p>
<pre><code>Integer value = null;
for (Integer integ:vec) {
    value = integ;
}</code></pre><p><strong>(04) 第四种，Enumeration遍历。</strong></p>
<pre><code>Integer value = null;
Enumeration enu = vec.elements();
while (enu.hasMoreElements()) {
    value = (Integer)enu.nextElement();
}</code></pre><p>测试这些遍历方式效率的代码如下：</p>
<pre><code>import java.util.*;

/*
 * @desc Vector遍历方式和效率的测试程序。
 *
 * @author skywang
 */
public class VectorRandomAccessTest {

    public static void main(String[] args) {
        Vector vec= new Vector();
        for (int i=0; i&lt;100000; i++)
            vec.add(i);
        iteratorThroughRandomAccess(vec) ;
        iteratorThroughIterator(vec) ;
        iteratorThroughFor2(vec) ;
        iteratorThroughEnumeration(vec) ;

    }

    private static void isRandomAccessSupported(List list) {
        if (list instanceof RandomAccess) {
            System.out.println(&quot;RandomAccess implemented!&quot;);
        } else {
            System.out.println(&quot;RandomAccess not implemented!&quot;);
        }

    }

    public static void iteratorThroughRandomAccess(List list) {

        long startTime;
        long endTime;
        startTime = System.currentTimeMillis();
        for (int i=0; i&lt;list.size(); i++) {
            list.get(i);
        }
        endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(&quot;iteratorThroughRandomAccess：&quot; + interval+&quot; ms&quot;);
    }

    public static void iteratorThroughIterator(List list) {

        long startTime;
        long endTime;
        startTime = System.currentTimeMillis();
        for(Iterator iter = list.iterator(); iter.hasNext(); ) {
            iter.next();
        }
        endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(&quot;iteratorThroughIterator：&quot; + interval+&quot; ms&quot;);
    }


    public static void iteratorThroughFor2(List list) {

        long startTime;
        long endTime;
        startTime = System.currentTimeMillis();
        for(Object obj:list)
            ;
        endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;);
    }

    public static void iteratorThroughEnumeration(Vector vec) {

        long startTime;
        long endTime;
        startTime = System.currentTimeMillis();
        for(Enumeration enu = vec.elements(); enu.hasMoreElements(); ) {
            enu.nextElement();
        }
        endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(&quot;iteratorThroughEnumeration：&quot; + interval+&quot; ms&quot;);
    }
}</code></pre><p>运行结果：</p>
<pre><code>iteratorThroughRandomAccess：6 ms
iteratorThroughIterator：9 ms
iteratorThroughFor2：8 ms
iteratorThroughEnumeration：7 ms</code></pre><p>总结：遍历Vector，使用索引的随机访问方式最快，使用迭代器最慢。</p>
<p><a name="anchor5"></a></p>
<h1 id="第5部分-Vector示例"><a href="#第5部分-Vector示例" class="headerlink" title="第5部分 Vector示例"></a>第5部分 Vector示例</h1><p>下面通过示例学习如何使用Vector</p>
<pre><code>import java.util.Vector;
import java.util.List;
import java.util.Iterator;
import java.util.Enumeration;

/**
 * @desc Vector测试函数：遍历Vector和常用API 
 *
 * @author skywang
 */
public class VectorTest {
    public static void main(String[] args) {
        // 新建Vector
        Vector vec = new Vector();

        // 添加元素
        vec.add(&quot;1&quot;);
        vec.add(&quot;2&quot;);
        vec.add(&quot;3&quot;);
        vec.add(&quot;4&quot;);
        vec.add(&quot;5&quot;);

        // 设置第一个元素为100
        vec.set(0, &quot;100&quot;);
        // 将“500”插入到第3个位置
        vec.add(2, &quot;300&quot;);
        System.out.println(&quot;vec:&quot;+vec);

        // (顺序查找)获取100的索引
        System.out.println(&quot;vec.indexOf(100):&quot;+vec.indexOf(&quot;100&quot;));
        // (倒序查找)获取100的索引
        System.out.println(&quot;vec.lastIndexOf(100):&quot;+vec.lastIndexOf(&quot;100&quot;));
        // 获取第一个元素
        System.out.println(&quot;vec.firstElement():&quot;+vec.firstElement());
        // 获取第3个元素
        System.out.println(&quot;vec.elementAt(2):&quot;+vec.elementAt(2));
        // 获取最后一个元素
        System.out.println(&quot;vec.lastElement():&quot;+vec.lastElement());

        // 获取Vector的大小
        System.out.println(&quot;size:&quot;+vec.size());
        // 获取Vector的总的容量
        System.out.println(&quot;capacity:&quot;+vec.capacity());

        // 获取vector的“第2”到“第4”个元素
        System.out.println(&quot;vec 2 to 4:&quot;+vec.subList(1, 4));

        // 通过Enumeration遍历Vector
        Enumeration enu = vec.elements();
        while(enu.hasMoreElements())
            System.out.println(&quot;nextElement():&quot;+enu.nextElement());

        Vector retainVec = new Vector();
        retainVec.add(&quot;100&quot;);
        retainVec.add(&quot;300&quot;);
        // 获取“vec”中包含在“retainVec中的元素”的集合
        System.out.println(&quot;vec.retain():&quot;+vec.retainAll(retainVec));
        System.out.println(&quot;vec:&quot;+vec);

        // 获取vec对应的String数组
        String[] arr = (String[]) vec.toArray(new String[0]);
        for (String str:arr)
            System.out.println(&quot;str:&quot;+str);

        // 清空Vector。clear()和removeAllElements()一样！
        vec.clear();
//        vec.removeAllElements();

        // 判断Vector是否为空
        System.out.println(&quot;vec.isEmpty():&quot;+vec.isEmpty());
    }   
}</code></pre><p>运行结果：</p>
<pre><code>vec:[100, 2, 300, 3, 4, 5]
vec.indexOf(100):0
vec.lastIndexOf(100):0
vec.firstElement():100
vec.elementAt(2):300
vec.lastElement():5
size:6
capacity:10
vec 2 to 4:[2, 300, 3]
nextElement():100
nextElement():2
nextElement():300
nextElement():3
nextElement():4
nextElement():5
vec.retain():true
vec:[100, 300]
str:100
str:300
vec.isEmpty():true</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/05/java/collection/2012-02-05-collection-05-linkedlist/" itemprop="url">Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-05T01:01:00.000Z" itemprop="datePublished">2月 5 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            42 分钟 read (About 6260 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面，我们已经学习了ArrayList，并了解了fail-fast机制。这一章我们接着学习List的实现类——LinkedList。<br>和学习ArrayList一样，接下来呢，我们先对LinkedList有个整体认识，然后再学习它的源码；最后再通过实例来学会使用LinkedList。内容包括：</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 LinkedList介绍</a><br><a href="#anchor2">第2部分 LinkedList数据结构</a><br><a href="#anchor3">第3部分 LinkedList源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 LinkedList遍历方式</a><br><a href="#anchor5">第5部分 LinkedList示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-LinkedList介绍"><a href="#第1部分-LinkedList介绍" class="headerlink" title="第1部分 LinkedList介绍"></a>第1部分 LinkedList介绍</h1><h2 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a>LinkedList简介</h2><p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。<br>LinkedList 实现 List 接口，能对它进行队列操作。<br>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。<br>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。<br>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。<br>LinkedList 是非同步的。</p>
<h2 id="LinkedList构造函数"><a href="#LinkedList构造函数" class="headerlink" title="LinkedList构造函数"></a>LinkedList构造函数</h2><pre><code>// 默认构造函数
LinkedList()

// 创建一个LinkedList，保护Collection中的全部元素。
LinkedList(Collection&lt;? extends E&gt; collection)</code></pre><h2 id="LinkedList的API"><a href="#LinkedList的API" class="headerlink" title="LinkedList的API"></a>LinkedList的API</h2><pre><code>LinkedList的API
boolean       add(E object)
void          add(int location, E object)
boolean       addAll(Collection&lt;? extends E&gt; collection)
boolean       addAll(int location, Collection&lt;? extends E&gt; collection)
void          addFirst(E object)
void          addLast(E object)
void          clear()
Object        clone()
boolean       contains(Object object)
Iterator&lt;E&gt;   descendingIterator()
E             element()
E             get(int location)
E             getFirst()
E             getLast()
int           indexOf(Object object)
int           lastIndexOf(Object object)
ListIterator&lt;E&gt;     listIterator(int location)
boolean       offer(E o)
boolean       offerFirst(E e)
boolean       offerLast(E e)
E             peek()
E             peekFirst()
E             peekLast()
E             poll()
E             pollFirst()
E             pollLast()
E             pop()
void          push(E e)
E             remove()
E             remove(int location)
boolean       remove(Object object)
E             removeFirst()
boolean       removeFirstOccurrence(Object o)
E             removeLast()
boolean       removeLastOccurrence(Object o)
E             set(int location, E object)
int           size()
&lt;T&gt; T[]       toArray(T[] contents)
Object[]     toArray()</code></pre><h2 id="AbstractSequentialList简介"><a href="#AbstractSequentialList简介" class="headerlink" title="AbstractSequentialList简介"></a>AbstractSequentialList简介</h2><p>在介绍LinkedList的源码之前，先介绍一下AbstractSequentialList。毕竟，LinkedList是AbstractSequentialList的子类。</p>
<p>AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。</p>
<p>此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。</p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-LinkedList数据结构"><a href="#第2部分-LinkedList数据结构" class="headerlink" title="第2部分 LinkedList数据结构"></a>第2部分 LinkedList数据结构</h1><p>LinkedList的继承关系</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractCollection&lt;E&gt;
         ↳     java.util.AbstractList&lt;E&gt;
               ↳     java.util.AbstractSequentialList&lt;E&gt;
                     ↳     java.util.LinkedList&lt;E&gt;</code></pre><p>LinkedList的声明</p>
<pre><code>public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable {}</code></pre><p>LinkedList与Collection关系如下图：</p>
<p><img src="/media/pic/java/collection/collection05.jpg" alt="img"></p>
<p>LinkedList的本质是双向链表。<br>(01) LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。<br>(02) LinkedList包含两个重要的成员：header 和 size。  </p>
<blockquote>
<p>header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。<br>size是双向链表中节点的个数。</p>
</blockquote>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-LinkedList源码解析-基于JDK1-6-0-45"><a href="#第3部分-LinkedList源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 LinkedList源码解析(基于JDK1.6.0_45)"></a>第3部分 LinkedList源码解析(基于JDK1.6.0_45)</h1><p>为了更了解LinkedList的原理，下面对LinkedList源码代码作出分析。</p>
<p>在阅读源码之前，我们先对LinkedList的整体实现进行大致说明：<br>(01) LinkedList实际上是通过双向链表去实现的。既然是双向链表，那么它的顺序访问会非常高效，而随机访问效率比较低。<br>(02) 既然LinkedList是通过双向链表的，但是它也实现了List接口{也就是说，它实现了get(int location)、remove(int location)等“根据索引值来获取、删除节点的函数”}。LinkedList是如何实现List的这些接口的，如何将“双向链表和索引值联系起来的”？<br>(03) 实际原理非常简单，它就是通过一个计数索引值来实现的。例如，当我们调用get(int location)时，首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到location位置；否则，从链表末尾开始先前查找，直到location位置。<br>这就是“双线链表和索引值联系起来”的方法。</p>
<p>好了，接下来开始阅读源码(只要理解双向链表，那么LinkedList的源码很容易理解的)。</p>
<pre><code>package java.util;

public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
{
    // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。
    private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null);

    // LinkedList中元素个数
    private transient int size = 0;

    // 默认构造函数：创建一个空的链表
    public LinkedList() {
        header.next = header.previous = header;
    }

    // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList
    public LinkedList(Collection&lt;? extends E&gt; c) {
        this();
        addAll(c);
    }

    // 获取LinkedList的第一个元素
    public E getFirst() {
        if (size==0)
            throw new NoSuchElementException();

        // 链表的表头header中不包含数据。
        // 这里返回header所指下一个节点所包含的数据。
        return header.next.element;
    }

    // 获取LinkedList的最后一个元素
    public E getLast()  {
        if (size==0)
            throw new NoSuchElementException();

        // 由于LinkedList是双向链表；而表头header不包含数据。
        // 因而，这里返回表头header的前一个节点所包含的数据。
        return header.previous.element;
    }

    // 删除LinkedList的第一个元素
    public E removeFirst() {
        return remove(header.next);
    }

    // 删除LinkedList的最后一个元素
    public E removeLast() {
        return remove(header.previous);
    }

    // 将元素添加到LinkedList的起始位置
    public void addFirst(E e) {
        addBefore(e, header.next);
    }

    // 将元素添加到LinkedList的结束位置
    public void addLast(E e) {
        addBefore(e, header);
    }

    // 判断LinkedList是否包含元素(o)
    public boolean contains(Object o) {
        return indexOf(o) != -1;
    }

    // 返回LinkedList的大小
    public int size() {
        return size;
    }

    // 将元素(E)添加到LinkedList中
    public boolean add(E e) {
        // 将节点(节点数据是e)添加到表头(header)之前。
        // 即，将节点添加到双向链表的末端。
        addBefore(e, header);
        return true;
    }

    // 从LinkedList中删除元素(o)
    // 从链表开始查找，如存在元素(o)则删除该元素并返回true；
    // 否则，返回false。
    public boolean remove(Object o) {
        if (o==null) {
            // 若o为null的删除情况
            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {
                if (e.element==null) {
                    remove(e);
                    return true;
                }
            }
        } else {
            // 若o不为null的删除情况
            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {
                if (o.equals(e.element)) {
                    remove(e);
                    return true;
                }
            }
        }
        return false;
    }

    // 将“集合(c)”添加到LinkedList中。
    // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return addAll(size, c);
    }

    // 从双向链表的index开始，将“集合(c)”添加到双向链表中。
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        if (index &lt; 0 || index &gt; size)
            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+
                                                &quot;, Size: &quot;+size);
        Object[] a = c.toArray();
        // 获取集合的长度
        int numNew = a.length;
        if (numNew==0)
            return false;
        modCount++;

        // 设置“当前要插入节点的后一个节点”
        Entry&lt;E&gt; successor = (index==size ? header : entry(index));
        // 设置“当前要插入节点的前一个节点”
        Entry&lt;E&gt; predecessor = successor.previous;
        // 将集合(c)全部插入双向链表中
        for (int i=0; i&lt;numNew; i++) {
            Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor);
            predecessor.next = e;
            predecessor = e;
        }
        successor.previous = predecessor;

        // 调整LinkedList的实际大小
        size += numNew;
        return true;
    }

    // 清空双向链表
    public void clear() {
        Entry&lt;E&gt; e = header.next;
        // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作：
        // (01) 设置前一个节点为null 
        // (02) 设置当前节点的内容为null 
        // (03) 设置后一个节点为“新的当前节点”
        while (e != header) {
            Entry&lt;E&gt; next = e.next;
            e.next = e.previous = null;
            e.element = null;
            e = next;
        }
        header.next = header.previous = header;
        // 设置大小为0
        size = 0;
        modCount++;
    }

    // 返回LinkedList指定位置的元素
    public E get(int index) {
        return entry(index).element;
    }

    // 设置index位置对应的节点的值为element
    public E set(int index, E element) {
        Entry&lt;E&gt; e = entry(index);
        E oldVal = e.element;
        e.element = element;
        return oldVal;
    }

    // 在index前添加节点，且节点的值为element
    public void add(int index, E element) {
        addBefore(element, (index==size ? header : entry(index)));
    }

    // 删除index位置的节点
    public E remove(int index) {
        return remove(entry(index));
    }

    // 获取双向链表中指定位置的节点
    private Entry&lt;E&gt; entry(int index) {
        if (index &lt; 0 || index &gt;= size)
            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+
                                                &quot;, Size: &quot;+size);
        Entry&lt;E&gt; e = header;
        // 获取index处的节点。
        // 若index &lt; 双向链表长度的1/2,则从前先后查找;
        // 否则，从后向前查找。
        if (index &lt; (size &gt;&gt; 1)) {
            for (int i = 0; i &lt;= index; i++)
                e = e.next;
        } else {
            for (int i = size; i &gt; index; i--)
                e = e.previous;
        }
        return e;
    }

    // 从前向后查找，返回“值为对象(o)的节点对应的索引”
    // 不存在就返回-1
    public int indexOf(Object o) {
        int index = 0;
        if (o==null) {
            for (Entry e = header.next; e != header; e = e.next) {
                if (e.element==null)
                    return index;
                index++;
            }
        } else {
            for (Entry e = header.next; e != header; e = e.next) {
                if (o.equals(e.element))
                    return index;
                index++;
            }
        }
        return -1;
    }

    // 从后向前查找，返回“值为对象(o)的节点对应的索引”
    // 不存在就返回-1
    public int lastIndexOf(Object o) {
        int index = size;
        if (o==null) {
            for (Entry e = header.previous; e != header; e = e.previous) {
                index--;
                if (e.element==null)
                    return index;
            }
        } else {
            for (Entry e = header.previous; e != header; e = e.previous) {
                index--;
                if (o.equals(e.element))
                    return index;
            }
        }
        return -1;
    }

    // 返回第一个节点
    // 若LinkedList的大小为0,则返回null
    public E peek() {
        if (size==0)
            return null;
        return getFirst();
    }

    // 返回第一个节点
    // 若LinkedList的大小为0,则抛出异常
    public E element() {
        return getFirst();
    }

    // 删除并返回第一个节点
    // 若LinkedList的大小为0,则返回null
    public E poll() {
        if (size==0)
            return null;
        return removeFirst();
    }

    // 将e添加双向链表末尾
    public boolean offer(E e) {
        return add(e);
    }

    // 将e添加双向链表开头
    public boolean offerFirst(E e) {
        addFirst(e);
        return true;
    }

    // 将e添加双向链表末尾
    public boolean offerLast(E e) {
        addLast(e);
        return true;
    }

    // 返回第一个节点
    // 若LinkedList的大小为0,则返回null
    public E peekFirst() {
        if (size==0)
            return null;
        return getFirst();
    }

    // 返回最后一个节点
    // 若LinkedList的大小为0,则返回null
    public E peekLast() {
        if (size==0)
            return null;
        return getLast();
    }

    // 删除并返回第一个节点
    // 若LinkedList的大小为0,则返回null
    public E pollFirst() {
        if (size==0)
            return null;
        return removeFirst();
    }

    // 删除并返回最后一个节点
    // 若LinkedList的大小为0,则返回null
    public E pollLast() {
        if (size==0)
            return null;
        return removeLast();
    }

    // 将e插入到双向链表开头
    public void push(E e) {
        addFirst(e);
    }

    // 删除并返回第一个节点
    public E pop() {
        return removeFirst();
    }

    // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点
    // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点
    public boolean removeFirstOccurrence(Object o) {
        return remove(o);
    }

    // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点
    // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点
    public boolean removeLastOccurrence(Object o) {
        if (o==null) {
            for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) {
                if (e.element==null) {
                    remove(e);
                    return true;
                }
            }
        } else {
            for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) {
                if (o.equals(e.element)) {
                    remove(e);
                    return true;
                }
            }
        }
        return false;
    }

    // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器)
    public ListIterator&lt;E&gt; listIterator(int index) {
        return new ListItr(index);
    }

    // List迭代器
    private class ListItr implements ListIterator&lt;E&gt; {
        // 上一次返回的节点
        private Entry&lt;E&gt; lastReturned = header;
        // 下一个节点
        private Entry&lt;E&gt; next;
        // 下一个节点对应的索引值
        private int nextIndex;
        // 期望的改变计数。用来实现fail-fast机制。
        private int expectedModCount = modCount;

        // 构造函数。
        // 从index位置开始进行迭代
        ListItr(int index) {
            // index的有效性处理
            if (index &lt; 0 || index &gt; size)
                throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size);
            // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找；
            // 否则，从最后一个元素往前查找。
            if (index &lt; (size &gt;&gt; 1)) {
                next = header.next;
                for (nextIndex=0; nextIndex&lt;index; nextIndex++)
                    next = next.next;
            } else {
                next = header;
                for (nextIndex=size; nextIndex&gt;index; nextIndex--)
                    next = next.previous;
            }
        }

        // 是否存在下一个元素
        public boolean hasNext() {
            // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。
            return nextIndex != size;
        }

        // 获取下一个元素
        public E next() {
            checkForComodification();
            if (nextIndex == size)
                throw new NoSuchElementException();

            lastReturned = next;
            // next指向链表的下一个元素
            next = next.next;
            nextIndex++;
            return lastReturned.element;
        }

        // 是否存在上一个元素
        public boolean hasPrevious() {
            // 通过元素索引是否等于0，来判断是否达到开头。
            return nextIndex != 0;
        }

        // 获取上一个元素
        public E previous() {
            if (nextIndex == 0)
            throw new NoSuchElementException();

            // next指向链表的上一个元素
            lastReturned = next = next.previous;
            nextIndex--;
            checkForComodification();
            return lastReturned.element;
        }

        // 获取下一个元素的索引
        public int nextIndex() {
            return nextIndex;
        }

        // 获取上一个元素的索引
        public int previousIndex() {
            return nextIndex-1;
        }

        // 删除当前元素。
        // 删除双向链表中的当前节点
        public void remove() {
            checkForComodification();
            Entry&lt;E&gt; lastNext = lastReturned.next;
            try {
                LinkedList.this.remove(lastReturned);
            } catch (NoSuchElementException e) {
                throw new IllegalStateException();
            }
            if (next==lastReturned)
                next = lastNext;
            else
                nextIndex--;
            lastReturned = header;
            expectedModCount++;
        }

        // 设置当前节点为e
        public void set(E e) {
            if (lastReturned == header)
                throw new IllegalStateException();
            checkForComodification();
            lastReturned.element = e;
        }

        // 将e添加到当前节点的前面
        public void add(E e) {
            checkForComodification();
            lastReturned = header;
            addBefore(e, next);
            nextIndex++;
            expectedModCount++;
        }

        // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。
        final void checkForComodification() {
            if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        }
    }

    // 双向链表的节点所对应的数据结构。
    // 包含3部分：上一节点，下一节点，当前节点值。
    private static class Entry&lt;E&gt; {
        // 当前节点所包含的值
        E element;
        // 下一个节点
        Entry&lt;E&gt; next;
        // 上一个节点
        Entry&lt;E&gt; previous;

        /**
         * 链表节点的构造函数。
         * 参数说明：
         *   element  —— 节点所包含的数据
         *   next      —— 下一个节点
         *   previous —— 上一个节点
         */
        Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) {
            this.element = element;
            this.next = next;
            this.previous = previous;
        }
    }

    // 将节点(节点数据是e)添加到entry节点之前。
    private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) {
        // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e
        Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);
        newEntry.previous.next = newEntry;
        newEntry.next.previous = newEntry;
        // 修改LinkedList大小
        size++;
        // 修改LinkedList的修改统计数：用来实现fail-fast机制。
        modCount++;
        return newEntry;
    }

    // 将节点从链表中删除
    private E remove(Entry&lt;E&gt; e) {
        if (e == header)
            throw new NoSuchElementException();

        E result = e.element;
        e.previous.next = e.next;
        e.next.previous = e.previous;
        e.next = e.previous = null;
        e.element = null;
        size--;
        modCount++;
        return result;
    }

    // 反向迭代器
    public Iterator&lt;E&gt; descendingIterator() {
        return new DescendingIterator();
    }

    // 反向迭代器实现类。
    private class DescendingIterator implements Iterator {
        final ListItr itr = new ListItr(size());
        // 反向迭代器是否下一个元素。
        // 实际上是判断双向链表的当前节点是否达到开头
        public boolean hasNext() {
            return itr.hasPrevious();
        }
        // 反向迭代器获取下一个元素。
        // 实际上是获取双向链表的前一个节点
        public E next() {
            return itr.previous();
        }
        // 删除当前节点
        public void remove() {
            itr.remove();
        }
    }


    // 返回LinkedList的Object[]数组
    public Object[] toArray() {
    // 新建Object[]数组
    Object[] result = new Object[size];
        int i = 0;
        // 将链表中所有节点的数据都添加到Object[]数组中
        for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)
            result[i++] = e.element;
    return result;
    }

    // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型
    public &lt;T&gt; T[] toArray(T[] a) {
        // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素)
        // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。
        if (a.length &lt; size)
            a = (T[])java.lang.reflect.Array.newInstance(
                                a.getClass().getComponentType(), size);
        // 将链表中所有节点的数据都添加到数组a中
        int i = 0;
        Object[] result = a;
        for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)
            result[i++] = e.element;

        if (a.length &gt; size)
            a[size] = null;

        return a;
    }


    // 克隆函数。返回LinkedList的克隆对象。
    public Object clone() {
        LinkedList&lt;E&gt; clone = null;
        // 克隆一个LinkedList克隆对象
        try {
            clone = (LinkedList&lt;E&gt;) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError();
        }

        // 新建LinkedList表头节点
        clone.header = new Entry&lt;E&gt;(null, null, null);
        clone.header.next = clone.header.previous = clone.header;
        clone.size = 0;
        clone.modCount = 0;

        // 将链表中所有节点的数据都添加到克隆对象中
        for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)
            clone.add(e.element);

        return clone;
    }

    // java.io.Serializable的写入函数
    // 将LinkedList的“容量，所有的元素值”都写入到输出流中
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out any hidden serialization magic
        s.defaultWriteObject();

        // 写入“容量”
        s.writeInt(size);

        // 将链表中所有节点的数据都写入到输出流中
        for (Entry e = header.next; e != header; e = e.next)
            s.writeObject(e.element);
    }

    // java.io.Serializable的读取函数：根据写入方式反向读出
    // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in any hidden serialization magic
        s.defaultReadObject();

        // 从输入流中读取“容量”
        int size = s.readInt();

        // 新建链表表头节点
        header = new Entry&lt;E&gt;(null, null, null);
        header.next = header.previous = header;

        // 从输入流中将“所有的元素值”并逐个添加到链表中
        for (int i=0; i&lt;size; i++)
            addBefore((E)s.readObject(), header);
    }

}</code></pre><p>总结：<br>(01) LinkedList 实际上是通过双向链表去实现的。<br>        它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。<br>(02) 从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。<br>(03) LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。<br>(04) LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。<br>(05) 由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。</p>
<p>总结起来如下表格： </p>
<table frame="hsides" rules="groups" cellspacing="0" cellpadding="0">

<!-- 表头部分 -->
<thead align="center" style="font-weight:bolder; background-color:#cccccc">
     <tr>
          <td></td>
          <td colspan="2">第一个元素（头部）</td>
          <td colspan="2">最后一个元素（尾部）</td>
     </tr>
</thead>
<tbody>
    <tr>
        <td></td>
        <td>抛出异常</td>
        <td>特殊值</td>
        <td>抛出异常</td>
        <td>特殊值</td>
    </tr>
    <tr>
        <td style="font-weight:bolder">插入</td>
        <td>addFirst(e)</td>
        <td>offerFirst(e)</td>
        <td>addLast(e)</td>
        <td>offerLast(e)</td>
    </tr>
    <tr>
        <td style="font-weight:bolder">移除</td>
        <td>removeFirst()</td>
        <td>pollFirst()</td>
        <td>removeLast()</td>
        <td>pollLast()</td>
    </tr>
    <tr>
        <td style="font-weight:bolder">检查</td>
        <td>getFirst()</td>
        <td>peekFirst()</td>
        <td>getLast()</td>
        <td>peekLast()</td>
    </tr>
</tbody>
</table>


<p>(06) LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价：</p>
<table frame="hsides" rules="groups" cellspacing="0" cellpadding="0">

<!-- 表头部分 -->
<thead align="center" style="font-weight:bolder; background-color:#cccccc">
     <tr>
          <td>队列方法</td>
          <td>等效方法</td>
     </tr>
</thead>

<tbody>
    <tr>
        <td>add(e)</td>
        <td>addLast(e)</td>
    </tr>
    <tr>
        <td>offer(e)</td>
        <td>offerLast(e)</td>
    </tr>
    <tr>
        <td>remove()</td>
        <td>removeFirst()</td>
    </tr>
    <tr>
        <td>poll()</td>
        <td>pollFirst()</td>
    </tr>
    <tr>
        <td>element()</td>
        <td>getFirst()</td>
    </tr>
    <tr>
        <td>peek()</td>
        <td>peekFirst()</td>
    </tr>
</tbody>
</table>


<p>(07) LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价：</p>
<table frame="hsides" rules="groups" cellspacing="0" cellpadding="0">

<!-- 表头部分 -->
<thead align="center" style="font-weight:bolder; background-color:#cccccc">
     <tr>
          <td>栈方法</td>
          <td>等效方法</td>
     </tr>
</thead>

<tbody>
    <tr>
        <td>push(e)</td>
        <td>addFirst(e)</td>
    </tr>
    <tr>
        <td>pop()</td>
        <td>removeFirst()</td>
    </tr>
    <tr>
        <td>peek()</td>
        <td>peekFirst()</td>
    </tr>
</tbody>
</table>

<p><a name="anchor4"></a></p>
<h1 id="第4部分-LinkedList遍历方式"><a href="#第4部分-LinkedList遍历方式" class="headerlink" title="第4部分 LinkedList遍历方式"></a>第4部分 LinkedList遍历方式</h1><h2 id="LinkedList遍历方式"><a href="#LinkedList遍历方式" class="headerlink" title="LinkedList遍历方式"></a>LinkedList遍历方式</h2><p>LinkedList支持多种遍历方式。建议不要采用随机访问的方式去遍历LinkedList，而采用逐个遍历的方式。</p>
<p><strong>(01) 第一种，通过迭代器遍历。即通过Iterator去遍历</strong></p>
<pre><code>for(Iterator iter = list.iterator(); iter.hasNext();)
    iter.next();</code></pre><p><strong>(02) 通过快速随机访问遍历LinkedList</strong></p>
<pre><code>int size = list.size();
for (int i=0; i&lt;size; i++) {
    list.get(i);        
}</code></pre><p><strong>(03) 通过另外一种for循环来遍历LinkedList</strong></p>
<pre><code>for (Integer integ:list) 
    ;</code></pre><p><strong>(04) 通过pollFirst()来遍历LinkedList</strong></p>
<pre><code>while(list.pollFirst() != null)
    ;</code></pre><p><strong>(05) 通过pollLast()来遍历LinkedList</strong></p>
<pre><code>while(list.pollLast() != null)
    ;</code></pre><p><strong>(06) 通过removeFirst()来遍历LinkedList</strong></p>
<pre><code>try {
    while(list.removeFirst() != null)
        ;
} catch (NoSuchElementException e) {
}</code></pre><p><strong>(07) 通过removeLast()来遍历LinkedList</strong></p>
<pre><code>try {
    while(list.removeLast() != null)
        ;
} catch (NoSuchElementException e) {
}</code></pre><p>测试这些遍历方式效率的代码如下：</p>
<pre><code>import java.util.List;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.NoSuchElementException;

/*
 * @desc 测试LinkedList的几种遍历方式和效率
 *
 * @author skywang
 */
public class LinkedListThruTest {
    public static void main(String[] args) {
        // 通过Iterator遍历LinkedList
        iteratorLinkedListThruIterator(getLinkedList()) ;

        // 通过快速随机访问遍历LinkedList
        iteratorLinkedListThruForeach(getLinkedList()) ;

        // 通过for循环的变种来访问遍历LinkedList
        iteratorThroughFor2(getLinkedList()) ;

        // 通过PollFirst()遍历LinkedList
        iteratorThroughPollFirst(getLinkedList()) ;

        // 通过PollLast()遍历LinkedList
        iteratorThroughPollLast(getLinkedList()) ;

        // 通过removeFirst()遍历LinkedList
        iteratorThroughRemoveFirst(getLinkedList()) ;

        // 通过removeLast()遍历LinkedList
        iteratorThroughRemoveLast(getLinkedList()) ;
    }

    private static LinkedList getLinkedList() {
        LinkedList llist = new LinkedList();
        for (int i=0; i&lt;100000; i++)
            llist.addLast(i);

        return llist;
    }
    /**
     * 通过快迭代器遍历LinkedList
     */
    private static void iteratorLinkedListThruIterator(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();

        for(Iterator iter = list.iterator(); iter.hasNext();)
            iter.next();

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorLinkedListThruIterator：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过快速随机访问遍历LinkedList
     */
    private static void iteratorLinkedListThruForeach(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();

        int size = list.size();
        for (int i=0; i&lt;size; i++) {
            list.get(i);        
        }
        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorLinkedListThruForeach：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过另外一种for循环来遍历LinkedList
     */
    private static void iteratorThroughFor2(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();

        for (Integer integ:list) 
            ;

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过pollFirst()来遍历LinkedList
     */
    private static void iteratorThroughPollFirst(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();
        while(list.pollFirst() != null)
            ;

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughPollFirst：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过pollLast()来遍历LinkedList
     */
    private static void iteratorThroughPollLast(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();
        while(list.pollLast() != null)
            ;

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughPollLast：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过removeFirst()来遍历LinkedList
     */
    private static void iteratorThroughRemoveFirst(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();
        try {
            while(list.removeFirst() != null)
                ;
        } catch (NoSuchElementException e) {
        }

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughRemoveFirst：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过removeLast()来遍历LinkedList
     */
    private static void iteratorThroughRemoveLast(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();
        try {
            while(list.removeLast() != null)
                ;
        } catch (NoSuchElementException e) {
        }

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughRemoveLast：&quot; + interval+&quot; ms&quot;);
    }

}</code></pre><p>执行结果：</p>
<pre><code>iteratorLinkedListThruIterator：8 ms
iteratorLinkedListThruForeach：3724 ms
iteratorThroughFor2：5 ms
iteratorThroughPollFirst：8 ms
iteratorThroughPollLast：6 ms
iteratorThroughRemoveFirst：2 ms
iteratorThroughRemoveLast：2 ms</code></pre><p>由此可见，遍历LinkedList时，使用removeFist()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取，而不删除，应该使用第3种遍历方式。<br>无论如何，千万不要通过随机访问去遍历LinkedList！</p>
<p><a name="anchor5"></a></p>
<h1 id="第5部分-LinkedList示例"><a href="#第5部分-LinkedList示例" class="headerlink" title="第5部分 LinkedList示例"></a>第5部分 LinkedList示例</h1><p>下面通过一个示例来学习如何使用LinkedList的常用API </p>
<pre><code>import java.util.List;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.NoSuchElementException;

/*
 * @desc LinkedList测试程序。
 *
 * @author skywang
 * @email  kuiwu-wang@163.com
 */
public class LinkedListTest {
    public static void main(String[] args) {
        // 测试LinkedList的API
        testLinkedListAPIs() ;

        // 将LinkedList当作 LIFO(后进先出)的堆栈
        useLinkedListAsLIFO();

        // 将LinkedList当作 FIFO(先进先出)的队列
        useLinkedListAsFIFO();
    }

    /*
     * 测试LinkedList中部分API
     */
    private static void testLinkedListAPIs() {
        String val = null;
        //LinkedList llist;
        //llist.offer(&quot;10&quot;);
        // 新建一个LinkedList
        LinkedList llist = new LinkedList();
        //---- 添加操作 ----
        // 依次添加1,2,3
        llist.add(&quot;1&quot;);
        llist.add(&quot;2&quot;);
        llist.add(&quot;3&quot;);

        // 将“4”添加到第一个位置
        llist.add(1, &quot;4&quot;);


        System.out.println(&quot;\nTest \&quot;addFirst(), removeFirst(), getFirst()\&quot;&quot;);
        // (01) 将“10”添加到第一个位置。  失败的话，抛出异常！
        llist.addFirst(&quot;10&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，抛出异常！
        System.out.println(&quot;llist.removeFirst():&quot;+llist.removeFirst());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，抛出异常！
        System.out.println(&quot;llist.getFirst():&quot;+llist.getFirst());


        System.out.println(&quot;\nTest \&quot;offerFirst(), pollFirst(), peekFirst()\&quot;&quot;);
        // (01) 将“10”添加到第一个位置。  返回true。
        llist.offerFirst(&quot;10&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，返回null。
        System.out.println(&quot;llist.pollFirst():&quot;+llist.pollFirst());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，返回null。
        System.out.println(&quot;llist.peekFirst():&quot;+llist.peekFirst());


        System.out.println(&quot;\nTest \&quot;addLast(), removeLast(), getLast()\&quot;&quot;);
        // (01) 将“20”添加到最后一个位置。  失败的话，抛出异常！
        llist.addLast(&quot;20&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将最后一个元素删除。        失败的话，抛出异常！
        System.out.println(&quot;llist.removeLast():&quot;+llist.removeLast());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取最后一个元素。          失败的话，抛出异常！
        System.out.println(&quot;llist.getLast():&quot;+llist.getLast());


        System.out.println(&quot;\nTest \&quot;offerLast(), pollLast(), peekLast()\&quot;&quot;);
        // (01) 将“20”添加到第一个位置。  返回true。
        llist.offerLast(&quot;20&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，返回null。
        System.out.println(&quot;llist.pollLast():&quot;+llist.pollLast());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，返回null。
        System.out.println(&quot;llist.peekLast():&quot;+llist.peekLast());



        // 将第3个元素设置300。不建议在LinkedList中使用此操作，因为效率低！
        llist.set(2, &quot;300&quot;);
        // 获取第3个元素。不建议在LinkedList中使用此操作，因为效率低！
        System.out.println(&quot;\nget(3):&quot;+llist.get(2));


        // ---- toArray(T[] a) ----
        // 将LinkedList转行为数组
        String[] arr = (String[])llist.toArray(new String[0]);
        for (String str:arr) 
            System.out.println(&quot;str:&quot;+str);

        // 输出大小
        System.out.println(&quot;size:&quot;+llist.size());
        // 清空LinkedList
        llist.clear();
        // 判断LinkedList是否为空
        System.out.println(&quot;isEmpty():&quot;+llist.isEmpty()+&quot;\n&quot;);

    }

    /**
     * 将LinkedList当作 LIFO(后进先出)的堆栈
     */
    private static void useLinkedListAsLIFO() {
        System.out.println(&quot;\nuseLinkedListAsLIFO&quot;);
        // 新建一个LinkedList
        LinkedList stack = new LinkedList();

        // 将1,2,3,4添加到堆栈中
        stack.push(&quot;1&quot;);
        stack.push(&quot;2&quot;);
        stack.push(&quot;3&quot;);
        stack.push(&quot;4&quot;);
        // 打印“栈”
        System.out.println(&quot;stack:&quot;+stack);

        // 删除“栈顶元素”
        System.out.println(&quot;stack.pop():&quot;+stack.pop());

        // 取出“栈顶元素”
        System.out.println(&quot;stack.peek():&quot;+stack.peek());

        // 打印“栈”
        System.out.println(&quot;stack:&quot;+stack);
    }

    /**
     * 将LinkedList当作 FIFO(先进先出)的队列
     */
    private static void useLinkedListAsFIFO() {
        System.out.println(&quot;\nuseLinkedListAsFIFO&quot;);
        // 新建一个LinkedList
        LinkedList queue = new LinkedList();

        // 将10,20,30,40添加到队列。每次都是插入到末尾
        queue.add(&quot;10&quot;);
        queue.add(&quot;20&quot;);
        queue.add(&quot;30&quot;);
        queue.add(&quot;40&quot;);
        // 打印“队列”
        System.out.println(&quot;queue:&quot;+queue);

        // 删除(队列的第一个元素)
        System.out.println(&quot;queue.remove():&quot;+queue.remove());

        // 读取(队列的第一个元素)
        System.out.println(&quot;queue.element():&quot;+queue.element());

        // 打印“队列”
        System.out.println(&quot;queue:&quot;+queue);
    }
}</code></pre><p>运行结果：</p>
<pre><code>Test &quot;addFirst(), removeFirst(), getFirst()&quot;
llist:[10, 1, 4, 2, 3]
llist.removeFirst():10
llist:[1, 4, 2, 3]
llist.getFirst():1

Test &quot;offerFirst(), pollFirst(), peekFirst()&quot;
llist:[10, 1, 4, 2, 3]
llist.pollFirst():10
llist:[1, 4, 2, 3]
llist.peekFirst():1

Test &quot;addLast(), removeLast(), getLast()&quot;
llist:[1, 4, 2, 3, 20]
llist.removeLast():20
llist:[1, 4, 2, 3]
llist.getLast():3

Test &quot;offerLast(), pollLast(), peekLast()&quot;
llist:[1, 4, 2, 3, 20]
llist.pollLast():20
llist:[1, 4, 2, 3]
llist.peekLast():3

get(3):300
str:1
str:4
str:300
str:3
size:4
isEmpty():true


useLinkedListAsLIFO
stack:[4, 3, 2, 1]
stack.pop():4
stack.peek():3
stack:[3, 2, 1]

useLinkedListAsFIFO
queue:[10, 20, 30, 40]
queue.remove():10
queue.element():20
queue:[20, 30, 40]</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/04/java/collection/2012-02-04-collection-04-fail-fast/" itemprop="url">Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-04T01:01:00.000Z" itemprop="datePublished">2月 4 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            21 分钟 read (About 3097 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面，我们已经学习了ArrayList。接下来，我们以ArrayList为例，对Iterator的fail-fast机制进行了解。内容包括：：</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1 fail-fast简介</a><br><a href="#anchor2">2 fail-fast示例</a><br><a href="#anchor3">3 fail-fast解决办法</a><br><a href="#anchor4">4 fail-fast原理</a><br><a href="#anchor5">5 解决fail-fast的原理</a> </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-fail-fast简介"><a href="#1-fail-fast简介" class="headerlink" title="1. fail-fast简介"></a>1. fail-fast简介</h1><p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。<br>例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>在详细介绍fail-fast机制的原理之前，先通过一个示例来认识fail-fast。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-fail-fast示例"><a href="#2-fail-fast示例" class="headerlink" title="2 fail-fast示例"></a>2 fail-fast示例</h1><p>示例代码：(FastFailTest.java)</p>
<pre><code>import java.util.*;
import java.util.concurrent.*;

/*
 * @desc java集合中Fast-Fail的测试程序。
 *
 *   fast-fail事件产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过iterator去遍历集合时，该集合的内容被其他线程所改变；则会抛出ConcurrentModificationException异常。
 *   fast-fail解决办法：通过util.concurrent集合包下的相应类去处理，则不会产生fast-fail事件。
 *
 *   本例中，分别测试ArrayList和CopyOnWriteArrayList这两种情况。ArrayList会产生fast-fail事件，而CopyOnWriteArrayList不会产生fast-fail事件。
 *   (01) 使用ArrayList时，会产生fast-fail事件，抛出ConcurrentModificationException异常；定义如下：
 *            private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();
 *   (02) 使用时CopyOnWriteArrayList，不会产生fast-fail事件；定义如下：
 *            private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();
 *
 * @author skywang
 */
public class FastFailTest {

    private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    //private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();
    public static void main(String[] args) {

        // 同时启动两个线程对list进行操作！
        new ThreadOne().start();
        new ThreadTwo().start();
    }

    private static void printAll() {
        System.out.println(&quot;&quot;);

        String value = null;
        Iterator iter = list.iterator();
        while(iter.hasNext()) {
            value = (String)iter.next();
            System.out.print(value+&quot;, &quot;);
        }
    }

    /**
     * 向list中依次添加0,1,2,3,4,5，每添加一个数之后，就通过printAll()遍历整个list
     */
    private static class ThreadOne extends Thread {
        public void run() {
            int i = 0;
            while (i&lt;6) {
                list.add(String.valueOf(i));
                printAll();
                i++;
            }
        }
    }

    /**
     * 向list中依次添加10,11,12,13,14,15，每添加一个数之后，就通过printAll()遍历整个list
     */
    private static class ThreadTwo extends Thread {
        public void run() {
            int i = 10;
            while (i&lt;16) {
                list.add(String.valueOf(i));
                printAll();
                i++;
            }
        }
    }

}</code></pre><p><strong>运行结果</strong></p>
<p>运行该代码，抛出异常java.util.ConcurrentModificationException！即，产生fail-fast事件！</p>
<p><strong>结果说明</strong></p>
<p>(01) FastFailTest中通过 new ThreadOne().start() 和 new ThreadTwo().start() 同时启动两个线程去操作list。  </p>
<blockquote>
<p>   ThreadOne线程：向list中依次添加0,1,2,3,4,5。每添加一个数之后，就通过printAll()遍历整个list。<br>   ThreadTwo线程：向list中依次添加10,11,12,13,14,15。每添加一个数之后，就通过printAll()遍历整个list。</p>
</blockquote>
<p>(02) 当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-fail-fast解决办法"><a href="#3-fail-fast解决办法" class="headerlink" title="3. fail-fast解决办法"></a>3. fail-fast解决办法</h1><p>fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。<br>所以，本例中只需要将ArrayList替换成java.util.concurrent包下对应的类即可。<br>即，将代码</p>
<pre><code>private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></pre><p>替换为</p>
<pre><code>private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();</code></pre><p>则可以解决该办法。</p>
<p><a name="anchor4"></a></p>
<h1 id="4-fail-fast原理"><a href="#4-fail-fast原理" class="headerlink" title="4. fail-fast原理"></a>4. fail-fast原理</h1><p>产生fail-fast事件，是通过抛出ConcurrentModificationException异常来触发的。<br>那么，ArrayList是如何抛出ConcurrentModificationException异常的呢?</p>
<p>我们知道，ConcurrentModificationException是在操作Iterator时抛出的异常。我们先看看Iterator的源码。ArrayList的Iterator是在父类AbstractList.java中实现的。代码如下： </p>
<pre><code>package java.util;

public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {

    ...

    // AbstractList中唯一的属性
    // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1
    protected transient int modCount = 0;

    // 返回List对应迭代器。实际上，是返回Itr对象。
    public Iterator&lt;E&gt; iterator() {
        return new Itr();
    }

    // Itr是Iterator(迭代器)的实现类
    private class Itr implements Iterator&lt;E&gt; {
        int cursor = 0;

        int lastRet = -1;

        // 修改数的记录值。
        // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount；
        // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等；
        // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size();
        }

        public E next() {
            // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等；
            // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。
            checkForComodification();
            try {
                E next = get(cursor);
                lastRet = cursor++;
                return next;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }

        public void remove() {
            if (lastRet == -1)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.remove(lastRet);
                if (lastRet &lt; cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }

    ...
}</code></pre><p>从中，我们可以发现在调用 next() 和 remove()时，都会执行 checkForComodification()。若 “modCount 不等于 expectedModCount”，则抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>要搞明白 fail-fast机制，我们就要需要理解什么时候“modCount 不等于 expectedModCount”！<br>从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改为不等于 modCount。所以，需要考证的就是modCount何时会被修改。</p>
<p>接下来，我们查看ArrayList的源码，来看看modCount是如何被修改的。</p>
<pre><code>package java.util;

public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{

    ...

    // list中容量变化时，对应的同步函数
    public void ensureCapacity(int minCapacity) {
        modCount++;
        int oldCapacity = elementData.length;
        if (minCapacity &gt; oldCapacity) {
            Object oldData[] = elementData;
            int newCapacity = (oldCapacity * 3)/2 + 1;
            if (newCapacity &lt; minCapacity)
                newCapacity = minCapacity;
            // minCapacity is usually close to size, so this is a win:
            elementData = Arrays.copyOf(elementData, newCapacity);
        }
    }


    // 添加元素到队列最后
    public boolean add(E e) {
        // 修改modCount
        ensureCapacity(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }


    // 添加元素到指定的位置
    public void add(int index, E element) {
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(
            &quot;Index: &quot;+index+&quot;, Size: &quot;+size);

        // 修改modCount
        ensureCapacity(size+1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
             size - index);
        elementData[index] = element;
        size++;
    }

    // 添加集合
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        Object[] a = c.toArray();
        int numNew = a.length;
        // 修改modCount
        ensureCapacity(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }


    // 删除指定位置的元素 
    public E remove(int index) {
        RangeCheck(index);

        // 修改modCount
        modCount++;
        E oldValue = (E) elementData[index];

        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index, numMoved);
        elementData[--size] = null; // Let gc do its work

        return oldValue;
    }


    // 快速删除指定位置的元素 
    private void fastRemove(int index) {

        // 修改modCount
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // Let gc do its work
    }

    // 清空集合
    public void clear() {
        // 修改modCount
        modCount++;

        // Let gc do its work
        for (int i = 0; i &lt; size; i++)
            elementData[i] = null;

        size = 0;
    }

    ...
}</code></pre><p>从中，我们发现：无论是add()、remove()，还是clear()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。</p>
<p>接下来，我们再系统的梳理一下fail-fast是怎么产生的。步骤如下：<br>(01) 新建了一个ArrayList，名称为arrayList。<br>(02) 向arrayList中添加内容。<br>(03) 新建一个“线程a”，并在“线程a”中通过Iterator反复的读取arrayList的值。<br>(04) 新建一个“线程b”，在“线程b”中删除arrayList中的一个“节点A”。<br>(05) 这时，就会产生有趣的事件了。  </p>
<blockquote>
<p>在某一时刻，“线程a”创建了arrayList的Iterator。此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。<br>在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！<br>“线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
</blockquote>
<p>至此，我们就完全了解了fail-fast是如何产生的！<br>即，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p><a name="anchor5"></a></p>
<h1 id="5-解决fail-fast的原理"><a href="#5-解决fail-fast的原理" class="headerlink" title="5. 解决fail-fast的原理"></a>5. 解决fail-fast的原理</h1><p>上面，说明了“解决fail-fast机制的办法”，也知道了“fail-fast产生的根本原因”。接下来，我们再进一步谈谈java.util.concurrent包中是如何解决fail-fast事件的。<br>还是以和ArrayList对应的CopyOnWriteArrayList进行说明。我们先看看CopyOnWriteArrayList的源码：</p>
<pre><code>package java.util.concurrent;
import java.util.*;
import java.util.concurrent.locks.*;
import sun.misc.Unsafe;

public class CopyOnWriteArrayList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {

    ...

    // 返回集合对应的迭代器
    public Iterator&lt;E&gt; iterator() {
        return new COWIterator&lt;E&gt;(getArray(), 0);
    }

    ...

    private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {
        private final Object[] snapshot;

        private int cursor;

        private COWIterator(Object[] elements, int initialCursor) {
            cursor = initialCursor;
            // 新建COWIterator时，将集合中的元素保存到一个新的拷贝数组中。
            // 这样，当原始集合的数据改变，拷贝数据中的值也不会变化。
            snapshot = elements;
        }

        public boolean hasNext() {
            return cursor &lt; snapshot.length;
        }

        public boolean hasPrevious() {
            return cursor &gt; 0;
        }

        public E next() {
            if (! hasNext())
                throw new NoSuchElementException();
            return (E) snapshot[cursor++];
        }

        public E previous() {
            if (! hasPrevious())
                throw new NoSuchElementException();
            return (E) snapshot[--cursor];
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor-1;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        public void set(E e) {
            throw new UnsupportedOperationException();
        }

        public void add(E e) {
            throw new UnsupportedOperationException();
        }
    }

    ...

}</code></pre><p>从中，我们可以看出:</p>
<p>(01) 和ArrayList继承于AbstractList不同，CopyOnWriteArrayList没有继承于AbstractList，它仅仅只是实现了List接口。<br>(02) ArrayList的iterator()函数返回的Iterator是在AbstractList中实现的；而CopyOnWriteArrayList是自己实现Iterator。<br>(03) ArrayList的Iterator实现类中调用next()时，会“调用checkForComodification()比较‘expectedModCount’和‘modCount’的大小”；但是，CopyOnWriteArrayList的Iterator实现类中，没有所谓的checkForComodification()，更不会抛出ConcurrentModificationException异常！ </p>
<h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/03/java/collection/2012-02-03-collection-03-arraylist/" itemprop="url">Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-03T01:01:00.000Z" itemprop="datePublished">2月 3 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            23 分钟 read (About 3409 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>上一章，我们学习了Collection的架构。这一章开始，我们对Collection的具体实现类进行讲解；首先，讲解List，而List中ArrayList又最为常用。因此，本章我们讲解ArrayList。先对ArrayList有个整体认识，再学习它的源码，最后再通过例子来学习如何使用它。内容包括：</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor2">第1部分 ArrayList简介</a><br><a href="#anchor2">第2部分 ArrayList数据结构</a><br><a href="#anchor2">第3部分 ArrayList源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 ArrayList遍历方式</a><br><a href="#anchor5">第5部分 toArray()异常</a><br><a href="#anchor6">第6部分 ArrayList示例</a> </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-ArrayList介绍"><a href="#第1部分-ArrayList介绍" class="headerlink" title="第1部分 ArrayList介绍"></a>第1部分 ArrayList介绍</h1><h2 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h2><p>ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。</p>
<p>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。<br>ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。</p>
<p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p>
<p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p>
<p>和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。</p>
<h2 id="ArrayList构造函数"><a href="#ArrayList构造函数" class="headerlink" title="ArrayList构造函数"></a>ArrayList构造函数</h2><pre><code>// 默认构造函数
ArrayList()

// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。
ArrayList(int capacity)

// 创建一个包含collection的ArrayList
ArrayList(Collection&lt;? extends E&gt; collection)</code></pre><h2 id="ArrayList的API"><a href="#ArrayList的API" class="headerlink" title="ArrayList的API"></a>ArrayList的API</h2><pre><code>// Collection中定义的API
boolean             add(E object)
boolean             addAll(Collection&lt;? extends E&gt; collection)
void                clear()
boolean             contains(Object object)
boolean             containsAll(Collection&lt;?&gt; collection)
boolean             equals(Object object)
int                 hashCode()
boolean             isEmpty()
Iterator&lt;E&gt;         iterator()
boolean             remove(Object object)
boolean             removeAll(Collection&lt;?&gt; collection)
boolean             retainAll(Collection&lt;?&gt; collection)
int                 size()
&lt;T&gt; T[]             toArray(T[] array)
Object[]            toArray()
// AbstractCollection中定义的API
void                add(int location, E object)
boolean             addAll(int location, Collection&lt;? extends E&gt; collection)
E                   get(int location)
int                 indexOf(Object object)
int                 lastIndexOf(Object object)
ListIterator&lt;E&gt;     listIterator(int location)
ListIterator&lt;E&gt;     listIterator()
E                   remove(int location)
E                   set(int location, E object)
List&lt;E&gt;             subList(int start, int end)
// ArrayList新增的API
Object               clone()
void                 ensureCapacity(int minimumCapacity)
void                 trimToSize()
void                 removeRange(int fromIndex, int toIndex)</code></pre><p><a name="anchor2"></a></p>
<h1 id="第2部分-ArrayList数据结构"><a href="#第2部分-ArrayList数据结构" class="headerlink" title="第2部分 ArrayList数据结构"></a>第2部分 ArrayList数据结构</h1><p>ArrayList的继承关系</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractCollection&lt;E&gt;
         ↳     java.util.AbstractList&lt;E&gt;
               ↳     java.util.ArrayList&lt;E&gt;</code></pre><p>ArrayList类声明</p>
<pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}</code></pre><p>ArrayList与Collection关系如下图：</p>
<p><img src="/media/pic/java/collection/collection03.jpg" alt="img"></p>
<p>ArrayList包含了两个重要的对象：elementData 和 size。</p>
<p>(01) elementData 是”Object[]类型的数组”，它保存了添加到ArrayList中的元素。实际上，elementData是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity)来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数ArrayList()来创建ArrayList，则elementData的容量默认是10。elementData数组的大小会根据ArrayList容量的增长而动态的增长，具体的增长方式，请参考源码分析中的ensureCapacity()函数。</p>
<p>(02) size 则是动态数组的实际大小。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-ArrayList源码解析-基于JDK1-6-0-45"><a href="#第3部分-ArrayList源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 ArrayList源码解析(基于JDK1.6.0_45)"></a>第3部分 ArrayList源码解析(基于JDK1.6.0_45)</h1><p>为了更了解ArrayList的原理，下面对ArrayList源码代码作出分析。ArrayList是通过数组实现的，源码比较容易理解。 </p>
<pre><code>package java.util;

public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    // 序列版本号
    private static final long serialVersionUID = 8683452581122892189L;

    // 保存ArrayList中数据的数组
    private transient Object[] elementData;

    // ArrayList中实际数据的数量
    private int size;

    // ArrayList带容量大小的构造函数。
    public ArrayList(int initialCapacity) {
        super();
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        // 新建一个数组
        this.elementData = new Object[initialCapacity];
    }

    // ArrayList构造函数。默认容量是10。
    public ArrayList() {
        this(10);
    }

    // 创建一个包含collection的ArrayList
    public ArrayList(Collection&lt;? extends E&gt; c) {
        elementData = c.toArray();
        size = elementData.length;
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    }


    // 将当前容量值设为 =实际元素个数
    public void trimToSize() {
        modCount++;
        int oldCapacity = elementData.length;
        if (size &lt; oldCapacity) {
            elementData = Arrays.copyOf(elementData, size);
        }
    }


    // 确定ArrarList的容量。
    // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1”
    public void ensureCapacity(int minCapacity) {
        // 将“修改统计数”+1
        modCount++;
        int oldCapacity = elementData.length;
        // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”
        if (minCapacity &gt; oldCapacity) {
            Object oldData[] = elementData;
            int newCapacity = (oldCapacity * 3)/2 + 1;
            if (newCapacity &lt; minCapacity)
                newCapacity = minCapacity;
            elementData = Arrays.copyOf(elementData, newCapacity);
        }
    }

    // 添加元素e
    public boolean add(E e) {
        // 确定ArrayList的容量大小
        ensureCapacity(size + 1);  // Increments modCount!!
        // 添加e到ArrayList中
        elementData[size++] = e;
        return true;
    }

    // 返回ArrayList的实际大小
    public int size() {
        return size;
    }

    // 返回ArrayList是否包含Object(o)
    public boolean contains(Object o) {
        return indexOf(o) &gt;= 0;
    }

    // 返回ArrayList是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    // 正向查找，返回元素的索引值
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i &lt; size; i++)
            if (elementData[i]==null)
                return i;
            } else {
                for (int i = 0; i &lt; size; i++)
                if (o.equals(elementData[i]))
                    return i;
            }
            return -1;
        }

        // 反向查找，返回元素的索引值
        public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i &gt;= 0; i--)
            if (elementData[i]==null)
                return i;
        } else {
            for (int i = size-1; i &gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
        }
        return -1;
    }

    // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值
    public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i &gt;= 0; i--)
            if (elementData[i]==null)
                return i;
        } else {
            for (int i = size-1; i &gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
        }
        return -1;
    }


    // 返回ArrayList的Object数组
    public Object[] toArray() {
        return Arrays.copyOf(elementData, size);
    }

    // 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型
    public &lt;T&gt; T[] toArray(T[] a) {
        // 若数组a的大小 &lt; ArrayList的元素个数；
        // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中
        if (a.length &lt; size)
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());

        // 若数组a的大小 &gt;= ArrayList的元素个数；
        // 则将ArrayList的全部元素都拷贝到数组a中。
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length &gt; size)
            a[size] = null;
        return a;
    }

    // 获取index位置的元素值
    public E get(int index) {
        RangeCheck(index);

        return (E) elementData[index];
    }

    // 设置index位置的值为element
    public E set(int index, E element) {
        RangeCheck(index);

        E oldValue = (E) elementData[index];
        elementData[index] = element;
        return oldValue;
    }

    // 将e添加到ArrayList中
    public boolean add(E e) {
        ensureCapacity(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }

    // 将e添加到ArrayList的指定位置
    public void add(int index, E element) {
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(
            &quot;Index: &quot;+index+&quot;, Size: &quot;+size);

        ensureCapacity(size+1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
             size - index);
        elementData[index] = element;
        size++;
    }

    // 删除ArrayList指定位置的元素
    public E remove(int index) {
        RangeCheck(index);

        modCount++;
        E oldValue = (E) elementData[index];

        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                 numMoved);
        elementData[--size] = null; // Let gc do its work

        return oldValue;
    }

    // 删除ArrayList的指定元素
    public boolean remove(Object o) {
        if (o == null) {
                for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
        } else {
            for (int index = 0; index &lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
        }
        return false;
    }


    // 快速删除第index个元素
    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        // 从&quot;index+1&quot;开始，用后面的元素替换前面的元素。
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        // 将最后一个元素设为null
        elementData[--size] = null; // Let gc do its work
    }

    // 删除元素
    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
            return true;
            }
        } else {
            // 便利ArrayList，找到“元素o”，则删除，并返回true。
            for (int index = 0; index &lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
            return true;
            }
        }
        return false;
    }

    // 清空ArrayList，将全部的元素设为null
    public void clear() {
        modCount++;

        for (int i = 0; i &lt; size; i++)
            elementData[i] = null;

        size = 0;
    }

    // 将集合c追加到ArrayList中
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacity(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }

    // 从index位置开始，将集合c添加到ArrayList
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(
            &quot;Index: &quot; + index + &quot;, Size: &quot; + size);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacity(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                 numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }

    // 删除fromIndex到toIndex之间的全部元素。
    protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    int numMoved = size - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

    // Let gc do its work
    int newSize = size - (toIndex-fromIndex);
    while (size != newSize)
        elementData[--size] = null;
    }

    private void RangeCheck(int index) {
    if (index &gt;= size)
        throw new IndexOutOfBoundsException(
        &quot;Index: &quot;+index+&quot;, Size: &quot;+size);
    }


    // 克隆函数
    public Object clone() {
        try {
            ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();
            // 将当前ArrayList的全部元素拷贝到v中
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn&apos;t happen, since we are Cloneable
            throw new InternalError();
        }
    }


    // java.io.Serializable的写入函数
    // 将ArrayList的“容量，所有的元素值”都写入到输出流中
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

        // 写入“数组的容量”
        s.writeInt(elementData.length);

    // 写入“数组的每一个元素”
    for (int i=0; i&lt;size; i++)
            s.writeObject(elementData[i]);

    if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }

    }


    // java.io.Serializable的读取函数：根据写入方式读出
    // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // 从输入流中读取ArrayList的“容量”
        int arrayLength = s.readInt();
        Object[] a = elementData = new Object[arrayLength];

        // 从输入流中将“所有的元素值”读出
        for (int i=0; i&lt;size; i++)
            a[i] = s.readObject();
    }
}</code></pre><p>总结：<br>(01) ArrayList 实际上是通过一个数组去保存数据的。当我们构造ArrayList时；若使用默认构造函数，则ArrayList的默认容量大小是10。<br>(02) 当ArrayList容量不足以容纳全部元素时，ArrayList会重新设置容量：新的容量=“(原始容量x3)/2 + 1”。<br>(03) ArrayList的克隆函数，即是将全部元素克隆到一个数组中。<br>(04) ArrayList实现java.io.Serializable的方式。当写入到输出流时，先写入“容量”，再依次写入“每一个元素”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。</p>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-ArrayList遍历方式"><a href="#第4部分-ArrayList遍历方式" class="headerlink" title="第4部分 ArrayList遍历方式"></a>第4部分 ArrayList遍历方式</h1><p>ArrayList支持3种遍历方式</p>
<p><strong>(01) 第一种，通过迭代器遍历。即通过Iterator去遍历。</strong></p>
<pre><code>Integer value = null;
Iterator iter = list.iterator();
while (iter.hasNext()) {
    value = (Integer)iter.next();
}</code></pre><p><strong>(02) 第二种，随机访问，通过索引值去遍历。</strong><br>由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。</p>
<pre><code>Integer value = null;
int size = list.size();
for (int i=0; i&lt;size; i++) {
    value = (Integer)list.get(i);        
}</code></pre><p><strong>(03) 第三种，for循环遍历。如下：</strong></p>
<pre><code>Integer value = null;
for (Integer integ:list) {
    value = integ;
}</code></pre><p>下面通过一个实例，比较这3种方式的效率，实例代码(ArrayListRandomAccessTest.java)如下：</p>
<pre><code>import java.util.*;
import java.util.concurrent.*;

/*
 * @desc ArrayList遍历方式和效率的测试程序。
 *
 * @author skywang
 */
public class ArrayListRandomAccessTest {

    public static void main(String[] args) {
        List list = new ArrayList();
        for (int i=0; i&lt;100000; i++)
            list.add(i);
        //isRandomAccessSupported(list);
        iteratorThroughRandomAccess(list) ;
        iteratorThroughIterator(list) ;
        iteratorThroughFor2(list) ;

    }

    private static void isRandomAccessSupported(List list) {
        if (list instanceof RandomAccess) {
            System.out.println(&quot;RandomAccess implemented!&quot;);
        } else {
            System.out.println(&quot;RandomAccess not implemented!&quot;);
        }

    }

    public static void iteratorThroughRandomAccess(List list) {

        long startTime;
        long endTime;
        startTime = System.currentTimeMillis();
        for (int i=0; i&lt;list.size(); i++) {
            list.get(i);
        }
        endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(&quot;iteratorThroughRandomAccess：&quot; + interval+&quot; ms&quot;);
    }

    public static void iteratorThroughIterator(List list) {

        long startTime;
        long endTime;
        startTime = System.currentTimeMillis();
        for(Iterator iter = list.iterator(); iter.hasNext(); ) {
            iter.next();
        }
        endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(&quot;iteratorThroughIterator：&quot; + interval+&quot; ms&quot;);
    }


    public static void iteratorThroughFor2(List list) {

        long startTime;
        long endTime;
        startTime = System.currentTimeMillis();
        for(Object obj:list)
            ;
        endTime = System.currentTimeMillis();
        long interval = endTime - startTime;
        System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;);
    }
}</code></pre><p>运行结果：</p>
<pre><code>iteratorThroughRandomAccess：3 ms
iteratorThroughIterator：8 ms
iteratorThroughFor2：5 ms</code></pre><p>由此可见，遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低！</p>
<p><a name="anchor5"></a></p>
<h1 id="第5部分-toArray-异常"><a href="#第5部分-toArray-异常" class="headerlink" title="第5部分 toArray()异常"></a>第5部分 toArray()异常</h1><p>当我们调用ArrayList中的 toArray()，可能遇到过抛出“java.lang.ClassCastException”异常的情况。下面我们说说这是怎么回事。</p>
<p>ArrayList提供了2个toArray()函数：</p>
<pre><code>Object[] toArray()
&lt;T&gt; T[] toArray(T[] contents)</code></pre><p>调用 toArray() 函数会抛出“java.lang.ClassCastException”异常，但是调用 toArray(T[] contents) 能正常返回 T[]。</p>
<p>toArray() 会抛出异常是因为 toArray() 返回的是 Object[] 数组，将 Object[] 转换为其它类型(如如，将Object[]转换为的Integer[])则会抛出“java.lang.ClassCastException”异常，因为Java不支持向下转型。具体的可以参考前面ArrayList.java的源码介绍部分的toArray()。<br>解决该问题的办法是调用 <t> T[] toArray(T[] contents) ， 而不是 Object[] toArray()。</t></p>
<p>调用 toArray(T[] contents) 返回T[]的可以通过以下几种方式实现。</p>
<p>// toArray(T[] contents)调用方式一</p>
<pre><code>public static Integer[] vectorToArray1(ArrayList&lt;Integer&gt; v) {
    Integer[] newText = new Integer[v.size()];
    v.toArray(newText);
    return newText;
}</code></pre><p>// toArray(T[] contents)调用方式二。最常用！</p>
<pre><code>public static Integer[] vectorToArray2(ArrayList&lt;Integer&gt; v) {
    Integer[] newText = (Integer[])v.toArray(new Integer[0]);
    return newText;
}</code></pre><p>// toArray(T[] contents)调用方式三</p>
<pre><code>public static Integer[] vectorToArray3(ArrayList&lt;Integer&gt; v) {
    Integer[] newText = new Integer[v.size()];
    Integer[] newStrings = (Integer[])v.toArray(newText);
    return newStrings;
}</code></pre><p><a name="anchor6"></a></p>
<h1 id="第6部分-ArrayList示例"><a href="#第6部分-ArrayList示例" class="headerlink" title="第6部分 ArrayList示例"></a>第6部分 ArrayList示例</h1><p>本文通过一个实例(ArrayListTest.java)，介绍 ArrayList 中常用API的用法。 </p>
<pre><code>import java.util.*;

/*
 * @desc ArrayList常用API的测试程序
 * @author skywang 
 * @email kuiwu-wang@163.com
 */
public class ArrayListTest {

    public static void main(String[] args) {

        // 创建ArrayList
        ArrayList list = new ArrayList();

        // 将“”
        list.add(&quot;1&quot;);
        list.add(&quot;2&quot;);
        list.add(&quot;3&quot;);
        list.add(&quot;4&quot;);
        // 将下面的元素添加到第1个位置
        list.add(0, &quot;5&quot;);

        // 获取第1个元素
        System.out.println(&quot;the first element is: &quot;+ list.get(0));
        // 删除“3”
        list.remove(&quot;3&quot;);
        // 获取ArrayList的大小
        System.out.println(&quot;Arraylist size=: &quot;+ list.size());
        // 判断list中是否包含&quot;3&quot;
        System.out.println(&quot;ArrayList contains 3 is: &quot;+ list.contains(3));
        // 设置第2个元素为10
        list.set(1, &quot;10&quot;);

        // 通过Iterator遍历ArrayList
        for(Iterator iter = list.iterator(); iter.hasNext(); ) {
            System.out.println(&quot;next is: &quot;+ iter.next());
        }

        // 将ArrayList转换为数组
        String[] arr = (String[])list.toArray(new String[0]);
        for (String str:arr)
            System.out.println(&quot;str: &quot;+ str);

        // 清空ArrayList
        list.clear();
        // 判断ArrayList是否为空
        System.out.println(&quot;ArrayList is empty: &quot;+ list.isEmpty());
    }
}</code></pre><p>运行结果：</p>
<pre><code>the first element is: 5
Arraylist size=: 4
ArrayList contains 3 is: false
next is: 5
next is: 10
next is: 2
next is: 4
str: 5
str: 10
str: 2
str: 4
ArrayList is empty: true</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/02/java/collection/2012-02-02-collection-02-framework/" itemprop="url">Java 集合系列02之 Collection架构</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-02T01:01:00.000Z" itemprop="datePublished">2月 2 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            15 分钟 read (About 2241 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>本文，我们将对Collection进行概括。下面先看看Collection的一些框架类的关系图：</p>
<p><img src="/media/pic/java/collection/collection02.jpg" alt="img"></p>
<p>Collection是一个接口，它主要的两个分支是：<strong>List</strong> 和 <strong>Set</strong>。</p>
<p>List和Set都是接口，它们继承于Collection。List是有序的队列，List中可以有重复的元素；而Set是数学概念中的集合，Set中没有重复元素！<br>List和Set都有它们各自的实现类。</p>
<p>  为了方便实现，集合中定义了AbstractCollection抽象类，它实现了Collection中的绝大部分函数；这样，在Collection的实现类中，我们就可以通过继承AbstractCollection省去重复编码。AbstractList和AbstractSet都继承于AbstractCollection，具体的List实现类继承于AbstractList，而Set的实现类则继承于AbstractSet。</p>
<p>  另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。</p>
<p>  接下来，我们看看各个接口和抽象类的介绍；然后，再对实现类进行详细的了解。</p>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Collection简介</a><br><strong>2</strong>. <a href="#anchor2">List简介</a><br><strong>3</strong>. <a href="#anchor3">Set简介</a><br><strong>4</strong>. <a href="#anchor4">AbstractCollection</a><br><strong>5</strong>. <a href="#anchor5">AbstractList</a><br><strong>6</strong>. <a href="#anchor6">AbstractSet</a><br><strong>7</strong>. <a href="#anchor7">Iterator</a><br><strong>8</strong>. <a href="#anchor8">ListIterator</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Collection简介"><a href="#1-Collection简介" class="headerlink" title="1. Collection简介"></a>1. Collection简介</h1><p>Collection的定义如下：</p>
<pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {}</code></pre><p>它是一个接口，是高度抽象出来的集合，它包含了集合的基本操作：添加、删除、清空、遍历(读取)、是否为空、获取大小、是否保护某元素等等。</p>
<p>Collection接口的所有子类(直接子类和间接子类)都必须实现2种构造函数：不带参数的构造函数 和 参数为Collection的构造函数。带参数的构造函数，可以用来转换Collection的类型。</p>
<pre><code>// Collection的API
abstract boolean         add(E object)
abstract boolean         addAll(Collection&lt;? extends E&gt; collection)
abstract void            clear()
abstract boolean         contains(Object object)
abstract boolean         containsAll(Collection&lt;?&gt; collection)
abstract boolean         equals(Object object)
abstract int             hashCode()
abstract boolean         isEmpty()
abstract Iterator&lt;E&gt;     iterator()
abstract boolean         remove(Object object)
abstract boolean         removeAll(Collection&lt;?&gt; collection)
abstract boolean         retainAll(Collection&lt;?&gt; collection)
abstract int             size()
abstract &lt;T&gt; T[]         toArray(T[] array)
abstract Object[]        toArray()</code></pre><p><a name="anchor2"></a></p>
<h1 id="2-List简介"><a href="#2-List简介" class="headerlink" title="2. List简介"></a>2. List简介</h1><p>List的定义如下：</p>
<pre><code>public interface List&lt;E&gt; extends Collection&lt;E&gt; {}</code></pre><p>List是一个继承于Collection的接口，即List是集合中的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。<br>List的官方介绍如下：</p>
<blockquote>
<p>A List is a collection which maintains an ordering for its elements. Every element in the List has an index. Each element can thus be accessed by its index, with the first index being zero. Normally, Lists allow duplicate elements, as compared to Sets, where elements have to be unique.</p>
</blockquote>
<p>关于API方面。既然List是继承于Collection接口，它自然就包含了Collection中的全部函数接口；由于List是有序队列，它也额外的有自己的API接口。主要有“添加、删除、获取、修改指定位置的元素”、“获取List中的子队列”等。</p>
<pre><code>// Collection的API
abstract boolean         add(E object)
abstract boolean         addAll(Collection&lt;? extends E&gt; collection)
abstract void            clear()
abstract boolean         contains(Object object)
abstract boolean         containsAll(Collection&lt;?&gt; collection)
abstract boolean         equals(Object object)
abstract int             hashCode()
abstract boolean         isEmpty()
abstract Iterator&lt;E&gt;     iterator()
abstract boolean         remove(Object object)
abstract boolean         removeAll(Collection&lt;?&gt; collection)
abstract boolean         retainAll(Collection&lt;?&gt; collection)
abstract int             size()
abstract &lt;T&gt; T[]         toArray(T[] array)
abstract Object[]        toArray()
// 相比与Collection，List新增的API：
abstract void                add(int location, E object)
abstract boolean             addAll(int location, Collection&lt;? extends E&gt; collection)
abstract E                   get(int location)
abstract int                 indexOf(Object object)
abstract int                 lastIndexOf(Object object)
abstract ListIterator&lt;E&gt;     listIterator(int location)
abstract ListIterator&lt;E&gt;     listIterator()
abstract E                   remove(int location)
abstract E                   set(int location, E object)
abstract List&lt;E&gt;             subList(int start, int end)</code></pre><p><a name="anchor3"></a></p>
<h1 id="3-Set简介"><a href="#3-Set简介" class="headerlink" title="3. Set简介"></a>3. Set简介</h1><p>Set的定义如下：</p>
<pre><code>public interface Set&lt;E&gt; extends Collection&lt;E&gt; {}</code></pre><p>Set是一个继承于Collection的接口，即Set也是集合中的一种。Set是没有重复元素的集合。</p>
<p>关于API方面。Set的API和Collection完全一样。</p>
<pre><code>// Set的API
abstract boolean         add(E object)
abstract boolean         addAll(Collection&lt;? extends E&gt; collection)
abstract void             clear()
abstract boolean         contains(Object object)
abstract boolean         containsAll(Collection&lt;?&gt; collection)
abstract boolean         equals(Object object)
abstract int             hashCode()
abstract boolean         isEmpty()
abstract Iterator&lt;E&gt;     iterator()
abstract boolean         remove(Object object)
abstract boolean         removeAll(Collection&lt;?&gt; collection)
abstract boolean         retainAll(Collection&lt;?&gt; collection)
abstract int             size()
abstract &lt;T&gt; T[]         toArray(T[] array)
abstract Object[]         toArray()</code></pre><p><a name="anchor4"></a></p>
<h1 id="4-AbstractCollection"><a href="#4-AbstractCollection" class="headerlink" title="4. AbstractCollection"></a>4. AbstractCollection</h1><p>AbstractCollection的定义如下：</p>
<pre><code>public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {}</code></pre><p>AbstractCollection是一个抽象类，它实现了Collection中除iterator()和size()之外的函数。<br>AbstractCollection的主要作用：它实现了Collection接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。</p>
<p><a name="anchor5"></a></p>
<h1 id="5-AbstractList"><a href="#5-AbstractList" class="headerlink" title="5. AbstractList"></a>5. AbstractList</h1><p>AbstractList的定义如下：</p>
<pre><code>public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {}</code></pre><p>AbstractList是一个继承于AbstractCollection，并且实现List接口的抽象类。它实现了List中除size()、get(int location)之外的函数。<br>AbstractList的主要作用：它实现了List接口中的大部分函数。从而方便其它类继承List。<br>另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()接口。</p>
<p><a name="anchor6"></a></p>
<h1 id="6-AbstractSet"><a href="#6-AbstractSet" class="headerlink" title="6. AbstractSet"></a>6. AbstractSet</h1><p>AbstractSet的定义如下： </p>
<pre><code>public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {}</code></pre><p>AbstractSet是一个继承于AbstractCollection，并且实现Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。<br>AbstractSet的主要作用：它实现了Set接口中的大部分函数。从而方便其它类实现Set接口。</p>
<p><a name="anchor7"></a></p>
<h1 id="7-Iterator"><a href="#7-Iterator" class="headerlink" title="7. Iterator"></a>7. Iterator</h1><p>Iterator的定义如下：</p>
<pre><code>public interface Iterator&lt;E&gt; {}</code></pre><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。<br><strong>注意</strong>：Iterator遍历Collection时，是fail-fast机制的。即，当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。关于fail-fast的详细内容，我们会在<a href="/2012/02/04/collection-04-fail-fast">fail-fast总结</a>后面专门进行说明。</p>
<pre><code>// Iterator的API
abstract boolean hasNext()
abstract E next()
abstract void remove()</code></pre><p><a name="anchor8"></a></p>
<h1 id="8-ListIterator"><a href="#8-ListIterator" class="headerlink" title="8. ListIterator"></a>8. ListIterator</h1><p>ListIterator的定义如下：</p>
<pre><code>public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {}</code></pre><p>ListIterator是一个继承于Iterator的接口，它是队列迭代器。专门用于便利List，能提供向前/向后遍历。相比于Iterator，它新增了添加、是否存在上一个元素、获取上一个元素等等API接口。</p>
<pre><code>// ListIterator的API
// 继承于Iterator的接口
abstract boolean hasNext()
abstract E next()
abstract void remove()
// 新增API接口
abstract void add(E object)
abstract boolean hasPrevious()
abstract int nextIndex()
abstract E previous()
abstract int previousIndex()
abstract void set(E object)</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/02/01/java/collection/2012-02-01-collection-01-summary/" itemprop="url">Java 集合系列01之 总体框架</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-01T01:01:00.000Z" itemprop="datePublished">2月 1 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 read (About 1051 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。Java集合工具包位置是java.util.*<br>Java集合主要可以划分为4个部分：List列表、Set集合、Map映射、工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)。  </p>
</blockquote>
<p>Java集合工具包框架如下图。</p>
<p><img src="/media/pic/java/collection/collection01.jpg" alt="img"></p>
<p>说明：看上面的框架图，先抓住它的主干，即Collection和Map。</p>
<ol>
<li><p>Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。</p>
<p>Collection包含了List和Set两大分支。</p>
<p>(01) List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。  </p>
<pre><code>List的实现类有LinkedList, ArrayList, Vector, Stack。</code></pre><p>(02) Set是一个不允许有重复元素的集合。  </p>
<pre><code>Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。</code></pre></li>
<li><p>Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。</p>
<p>AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。<br>Hashtable虽然继承于Dictionary，但它实现了Map接口。</p>
</li>
</ol>
<p>接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。<br>ListIterator是专门为遍历List而存在的。</p>
<p>再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。</p>
<p>最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。</p>
<p>有了上面的整体框架之后，我们接下来对每个类分别进行分析。</p>
<h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/categories/java/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/categories/java/page/3/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/categories/java/">1</a></li>
        
        <li><a class="pagination-link is-current" href="/categories/java/page/2/">2</a></li>
        
        <li><a class="pagination-link" href="/categories/java/page/3/">3</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 炸鸡叔&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>