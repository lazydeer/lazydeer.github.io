<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例 - PillBlog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="java collection">





    <meta name="description" content="java collection">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例">
<meta property="og:url" content="https://apppills.com/2012/02/05/java/collection/2012-02-05-collection-05-linkedlist/index.html">
<meta property="og:site_name" content="PillBlog">
<meta property="og:description" content="java collection">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://apppills.com/media/pic/java/collection/collection05.jpg">
<meta property="og:updated_time" content="2017-04-21T11:54:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例">
<meta name="twitter:description" content="java collection">
<meta name="twitter:image" content="https://apppills.com/media/pic/java/collection/collection05.jpg">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">归档</a>
            
            <a class="navbar-item " href="/about">关于</a>
            
            <a class="navbar-item " href="https://everything.apppills.com">Everything</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            <div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only toc">
                <a class="navbar-item" title="Table of Contents">
                    <i class="fa fa-list"></i>
                </a>
                <div class="navbar-dropdown is-right">
                    
                    
                    
                    
                    <a class="navbar-item" href="#第1部分-LinkedList介绍">1&nbsp;&nbsp;<b>第1部分 LinkedList介绍</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#LinkedList简介">1.1&nbsp;&nbsp;LinkedList简介</a>
                    
                    
                    
                    <a class="navbar-item" href="#LinkedList构造函数">1.2&nbsp;&nbsp;LinkedList构造函数</a>
                    
                    
                    
                    <a class="navbar-item" href="#LinkedList的API">1.3&nbsp;&nbsp;LinkedList的API</a>
                    
                    
                    
                    <a class="navbar-item" href="#AbstractSequentialList简介">1.4&nbsp;&nbsp;AbstractSequentialList简介</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#第2部分-LinkedList数据结构">2&nbsp;&nbsp;<b>第2部分 LinkedList数据结构</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#第3部分-LinkedList源码解析-基于JDK1-6-0-45">3&nbsp;&nbsp;<b>第3部分 LinkedList源码解析(基于JDK1.6.0_45)</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#第4部分-LinkedList遍历方式">4&nbsp;&nbsp;<b>第4部分 LinkedList遍历方式</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#LinkedList遍历方式">4.1&nbsp;&nbsp;LinkedList遍历方式</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#第5部分-LinkedList示例">5&nbsp;&nbsp;<b>第5部分 LinkedList示例</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#更多内容">6&nbsp;&nbsp;<b>更多内容</b></a>
                    
                </div>
            </div>
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-02-05T01:01:00.000Z" itemprop="datePublished">2月 5 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            42 分钟 read (About 6260 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面，我们已经学习了ArrayList，并了解了fail-fast机制。这一章我们接着学习List的实现类——LinkedList。<br>和学习ArrayList一样，接下来呢，我们先对LinkedList有个整体认识，然后再学习它的源码；最后再通过实例来学会使用LinkedList。内容包括：</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 LinkedList介绍</a><br><a href="#anchor2">第2部分 LinkedList数据结构</a><br><a href="#anchor3">第3部分 LinkedList源码解析(基于JDK1.6.0_45)</a><br><a href="#anchor4">第4部分 LinkedList遍历方式</a><br><a href="#anchor5">第5部分 LinkedList示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-LinkedList介绍"><a href="#第1部分-LinkedList介绍" class="headerlink" title="第1部分 LinkedList介绍"></a>第1部分 LinkedList介绍</h1><h2 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a>LinkedList简介</h2><p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。<br>LinkedList 实现 List 接口，能对它进行队列操作。<br>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。<br>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。<br>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。<br>LinkedList 是非同步的。</p>
<h2 id="LinkedList构造函数"><a href="#LinkedList构造函数" class="headerlink" title="LinkedList构造函数"></a>LinkedList构造函数</h2><pre><code>// 默认构造函数
LinkedList()

// 创建一个LinkedList，保护Collection中的全部元素。
LinkedList(Collection&lt;? extends E&gt; collection)</code></pre><h2 id="LinkedList的API"><a href="#LinkedList的API" class="headerlink" title="LinkedList的API"></a>LinkedList的API</h2><pre><code>LinkedList的API
boolean       add(E object)
void          add(int location, E object)
boolean       addAll(Collection&lt;? extends E&gt; collection)
boolean       addAll(int location, Collection&lt;? extends E&gt; collection)
void          addFirst(E object)
void          addLast(E object)
void          clear()
Object        clone()
boolean       contains(Object object)
Iterator&lt;E&gt;   descendingIterator()
E             element()
E             get(int location)
E             getFirst()
E             getLast()
int           indexOf(Object object)
int           lastIndexOf(Object object)
ListIterator&lt;E&gt;     listIterator(int location)
boolean       offer(E o)
boolean       offerFirst(E e)
boolean       offerLast(E e)
E             peek()
E             peekFirst()
E             peekLast()
E             poll()
E             pollFirst()
E             pollLast()
E             pop()
void          push(E e)
E             remove()
E             remove(int location)
boolean       remove(Object object)
E             removeFirst()
boolean       removeFirstOccurrence(Object o)
E             removeLast()
boolean       removeLastOccurrence(Object o)
E             set(int location, E object)
int           size()
&lt;T&gt; T[]       toArray(T[] contents)
Object[]     toArray()</code></pre><h2 id="AbstractSequentialList简介"><a href="#AbstractSequentialList简介" class="headerlink" title="AbstractSequentialList简介"></a>AbstractSequentialList简介</h2><p>在介绍LinkedList的源码之前，先介绍一下AbstractSequentialList。毕竟，LinkedList是AbstractSequentialList的子类。</p>
<p>AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些函数。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。</p>
<p>此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。</p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-LinkedList数据结构"><a href="#第2部分-LinkedList数据结构" class="headerlink" title="第2部分 LinkedList数据结构"></a>第2部分 LinkedList数据结构</h1><p>LinkedList的继承关系</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractCollection&lt;E&gt;
         ↳     java.util.AbstractList&lt;E&gt;
               ↳     java.util.AbstractSequentialList&lt;E&gt;
                     ↳     java.util.LinkedList&lt;E&gt;</code></pre><p>LinkedList的声明</p>
<pre><code>public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable {}</code></pre><p>LinkedList与Collection关系如下图：</p>
<p><img src="/media/pic/java/collection/collection05.jpg" alt="img"></p>
<p>LinkedList的本质是双向链表。<br>(01) LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。<br>(02) LinkedList包含两个重要的成员：header 和 size。  </p>
<blockquote>
<p>header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。<br>size是双向链表中节点的个数。</p>
</blockquote>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-LinkedList源码解析-基于JDK1-6-0-45"><a href="#第3部分-LinkedList源码解析-基于JDK1-6-0-45" class="headerlink" title="第3部分 LinkedList源码解析(基于JDK1.6.0_45)"></a>第3部分 LinkedList源码解析(基于JDK1.6.0_45)</h1><p>为了更了解LinkedList的原理，下面对LinkedList源码代码作出分析。</p>
<p>在阅读源码之前，我们先对LinkedList的整体实现进行大致说明：<br>(01) LinkedList实际上是通过双向链表去实现的。既然是双向链表，那么它的顺序访问会非常高效，而随机访问效率比较低。<br>(02) 既然LinkedList是通过双向链表的，但是它也实现了List接口{也就是说，它实现了get(int location)、remove(int location)等“根据索引值来获取、删除节点的函数”}。LinkedList是如何实现List的这些接口的，如何将“双向链表和索引值联系起来的”？<br>(03) 实际原理非常简单，它就是通过一个计数索引值来实现的。例如，当我们调用get(int location)时，首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到location位置；否则，从链表末尾开始先前查找，直到location位置。<br>这就是“双线链表和索引值联系起来”的方法。</p>
<p>好了，接下来开始阅读源码(只要理解双向链表，那么LinkedList的源码很容易理解的)。</p>
<pre><code>package java.util;

public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
{
    // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。
    private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null);

    // LinkedList中元素个数
    private transient int size = 0;

    // 默认构造函数：创建一个空的链表
    public LinkedList() {
        header.next = header.previous = header;
    }

    // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList
    public LinkedList(Collection&lt;? extends E&gt; c) {
        this();
        addAll(c);
    }

    // 获取LinkedList的第一个元素
    public E getFirst() {
        if (size==0)
            throw new NoSuchElementException();

        // 链表的表头header中不包含数据。
        // 这里返回header所指下一个节点所包含的数据。
        return header.next.element;
    }

    // 获取LinkedList的最后一个元素
    public E getLast()  {
        if (size==0)
            throw new NoSuchElementException();

        // 由于LinkedList是双向链表；而表头header不包含数据。
        // 因而，这里返回表头header的前一个节点所包含的数据。
        return header.previous.element;
    }

    // 删除LinkedList的第一个元素
    public E removeFirst() {
        return remove(header.next);
    }

    // 删除LinkedList的最后一个元素
    public E removeLast() {
        return remove(header.previous);
    }

    // 将元素添加到LinkedList的起始位置
    public void addFirst(E e) {
        addBefore(e, header.next);
    }

    // 将元素添加到LinkedList的结束位置
    public void addLast(E e) {
        addBefore(e, header);
    }

    // 判断LinkedList是否包含元素(o)
    public boolean contains(Object o) {
        return indexOf(o) != -1;
    }

    // 返回LinkedList的大小
    public int size() {
        return size;
    }

    // 将元素(E)添加到LinkedList中
    public boolean add(E e) {
        // 将节点(节点数据是e)添加到表头(header)之前。
        // 即，将节点添加到双向链表的末端。
        addBefore(e, header);
        return true;
    }

    // 从LinkedList中删除元素(o)
    // 从链表开始查找，如存在元素(o)则删除该元素并返回true；
    // 否则，返回false。
    public boolean remove(Object o) {
        if (o==null) {
            // 若o为null的删除情况
            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {
                if (e.element==null) {
                    remove(e);
                    return true;
                }
            }
        } else {
            // 若o不为null的删除情况
            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {
                if (o.equals(e.element)) {
                    remove(e);
                    return true;
                }
            }
        }
        return false;
    }

    // 将“集合(c)”添加到LinkedList中。
    // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return addAll(size, c);
    }

    // 从双向链表的index开始，将“集合(c)”添加到双向链表中。
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        if (index &lt; 0 || index &gt; size)
            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+
                                                &quot;, Size: &quot;+size);
        Object[] a = c.toArray();
        // 获取集合的长度
        int numNew = a.length;
        if (numNew==0)
            return false;
        modCount++;

        // 设置“当前要插入节点的后一个节点”
        Entry&lt;E&gt; successor = (index==size ? header : entry(index));
        // 设置“当前要插入节点的前一个节点”
        Entry&lt;E&gt; predecessor = successor.previous;
        // 将集合(c)全部插入双向链表中
        for (int i=0; i&lt;numNew; i++) {
            Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor);
            predecessor.next = e;
            predecessor = e;
        }
        successor.previous = predecessor;

        // 调整LinkedList的实际大小
        size += numNew;
        return true;
    }

    // 清空双向链表
    public void clear() {
        Entry&lt;E&gt; e = header.next;
        // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作：
        // (01) 设置前一个节点为null 
        // (02) 设置当前节点的内容为null 
        // (03) 设置后一个节点为“新的当前节点”
        while (e != header) {
            Entry&lt;E&gt; next = e.next;
            e.next = e.previous = null;
            e.element = null;
            e = next;
        }
        header.next = header.previous = header;
        // 设置大小为0
        size = 0;
        modCount++;
    }

    // 返回LinkedList指定位置的元素
    public E get(int index) {
        return entry(index).element;
    }

    // 设置index位置对应的节点的值为element
    public E set(int index, E element) {
        Entry&lt;E&gt; e = entry(index);
        E oldVal = e.element;
        e.element = element;
        return oldVal;
    }

    // 在index前添加节点，且节点的值为element
    public void add(int index, E element) {
        addBefore(element, (index==size ? header : entry(index)));
    }

    // 删除index位置的节点
    public E remove(int index) {
        return remove(entry(index));
    }

    // 获取双向链表中指定位置的节点
    private Entry&lt;E&gt; entry(int index) {
        if (index &lt; 0 || index &gt;= size)
            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+
                                                &quot;, Size: &quot;+size);
        Entry&lt;E&gt; e = header;
        // 获取index处的节点。
        // 若index &lt; 双向链表长度的1/2,则从前先后查找;
        // 否则，从后向前查找。
        if (index &lt; (size &gt;&gt; 1)) {
            for (int i = 0; i &lt;= index; i++)
                e = e.next;
        } else {
            for (int i = size; i &gt; index; i--)
                e = e.previous;
        }
        return e;
    }

    // 从前向后查找，返回“值为对象(o)的节点对应的索引”
    // 不存在就返回-1
    public int indexOf(Object o) {
        int index = 0;
        if (o==null) {
            for (Entry e = header.next; e != header; e = e.next) {
                if (e.element==null)
                    return index;
                index++;
            }
        } else {
            for (Entry e = header.next; e != header; e = e.next) {
                if (o.equals(e.element))
                    return index;
                index++;
            }
        }
        return -1;
    }

    // 从后向前查找，返回“值为对象(o)的节点对应的索引”
    // 不存在就返回-1
    public int lastIndexOf(Object o) {
        int index = size;
        if (o==null) {
            for (Entry e = header.previous; e != header; e = e.previous) {
                index--;
                if (e.element==null)
                    return index;
            }
        } else {
            for (Entry e = header.previous; e != header; e = e.previous) {
                index--;
                if (o.equals(e.element))
                    return index;
            }
        }
        return -1;
    }

    // 返回第一个节点
    // 若LinkedList的大小为0,则返回null
    public E peek() {
        if (size==0)
            return null;
        return getFirst();
    }

    // 返回第一个节点
    // 若LinkedList的大小为0,则抛出异常
    public E element() {
        return getFirst();
    }

    // 删除并返回第一个节点
    // 若LinkedList的大小为0,则返回null
    public E poll() {
        if (size==0)
            return null;
        return removeFirst();
    }

    // 将e添加双向链表末尾
    public boolean offer(E e) {
        return add(e);
    }

    // 将e添加双向链表开头
    public boolean offerFirst(E e) {
        addFirst(e);
        return true;
    }

    // 将e添加双向链表末尾
    public boolean offerLast(E e) {
        addLast(e);
        return true;
    }

    // 返回第一个节点
    // 若LinkedList的大小为0,则返回null
    public E peekFirst() {
        if (size==0)
            return null;
        return getFirst();
    }

    // 返回最后一个节点
    // 若LinkedList的大小为0,则返回null
    public E peekLast() {
        if (size==0)
            return null;
        return getLast();
    }

    // 删除并返回第一个节点
    // 若LinkedList的大小为0,则返回null
    public E pollFirst() {
        if (size==0)
            return null;
        return removeFirst();
    }

    // 删除并返回最后一个节点
    // 若LinkedList的大小为0,则返回null
    public E pollLast() {
        if (size==0)
            return null;
        return removeLast();
    }

    // 将e插入到双向链表开头
    public void push(E e) {
        addFirst(e);
    }

    // 删除并返回第一个节点
    public E pop() {
        return removeFirst();
    }

    // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点
    // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点
    public boolean removeFirstOccurrence(Object o) {
        return remove(o);
    }

    // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点
    // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点
    public boolean removeLastOccurrence(Object o) {
        if (o==null) {
            for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) {
                if (e.element==null) {
                    remove(e);
                    return true;
                }
            }
        } else {
            for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) {
                if (o.equals(e.element)) {
                    remove(e);
                    return true;
                }
            }
        }
        return false;
    }

    // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器)
    public ListIterator&lt;E&gt; listIterator(int index) {
        return new ListItr(index);
    }

    // List迭代器
    private class ListItr implements ListIterator&lt;E&gt; {
        // 上一次返回的节点
        private Entry&lt;E&gt; lastReturned = header;
        // 下一个节点
        private Entry&lt;E&gt; next;
        // 下一个节点对应的索引值
        private int nextIndex;
        // 期望的改变计数。用来实现fail-fast机制。
        private int expectedModCount = modCount;

        // 构造函数。
        // 从index位置开始进行迭代
        ListItr(int index) {
            // index的有效性处理
            if (index &lt; 0 || index &gt; size)
                throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size);
            // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找；
            // 否则，从最后一个元素往前查找。
            if (index &lt; (size &gt;&gt; 1)) {
                next = header.next;
                for (nextIndex=0; nextIndex&lt;index; nextIndex++)
                    next = next.next;
            } else {
                next = header;
                for (nextIndex=size; nextIndex&gt;index; nextIndex--)
                    next = next.previous;
            }
        }

        // 是否存在下一个元素
        public boolean hasNext() {
            // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。
            return nextIndex != size;
        }

        // 获取下一个元素
        public E next() {
            checkForComodification();
            if (nextIndex == size)
                throw new NoSuchElementException();

            lastReturned = next;
            // next指向链表的下一个元素
            next = next.next;
            nextIndex++;
            return lastReturned.element;
        }

        // 是否存在上一个元素
        public boolean hasPrevious() {
            // 通过元素索引是否等于0，来判断是否达到开头。
            return nextIndex != 0;
        }

        // 获取上一个元素
        public E previous() {
            if (nextIndex == 0)
            throw new NoSuchElementException();

            // next指向链表的上一个元素
            lastReturned = next = next.previous;
            nextIndex--;
            checkForComodification();
            return lastReturned.element;
        }

        // 获取下一个元素的索引
        public int nextIndex() {
            return nextIndex;
        }

        // 获取上一个元素的索引
        public int previousIndex() {
            return nextIndex-1;
        }

        // 删除当前元素。
        // 删除双向链表中的当前节点
        public void remove() {
            checkForComodification();
            Entry&lt;E&gt; lastNext = lastReturned.next;
            try {
                LinkedList.this.remove(lastReturned);
            } catch (NoSuchElementException e) {
                throw new IllegalStateException();
            }
            if (next==lastReturned)
                next = lastNext;
            else
                nextIndex--;
            lastReturned = header;
            expectedModCount++;
        }

        // 设置当前节点为e
        public void set(E e) {
            if (lastReturned == header)
                throw new IllegalStateException();
            checkForComodification();
            lastReturned.element = e;
        }

        // 将e添加到当前节点的前面
        public void add(E e) {
            checkForComodification();
            lastReturned = header;
            addBefore(e, next);
            nextIndex++;
            expectedModCount++;
        }

        // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。
        final void checkForComodification() {
            if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        }
    }

    // 双向链表的节点所对应的数据结构。
    // 包含3部分：上一节点，下一节点，当前节点值。
    private static class Entry&lt;E&gt; {
        // 当前节点所包含的值
        E element;
        // 下一个节点
        Entry&lt;E&gt; next;
        // 上一个节点
        Entry&lt;E&gt; previous;

        /**
         * 链表节点的构造函数。
         * 参数说明：
         *   element  —— 节点所包含的数据
         *   next      —— 下一个节点
         *   previous —— 上一个节点
         */
        Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) {
            this.element = element;
            this.next = next;
            this.previous = previous;
        }
    }

    // 将节点(节点数据是e)添加到entry节点之前。
    private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) {
        // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e
        Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);
        newEntry.previous.next = newEntry;
        newEntry.next.previous = newEntry;
        // 修改LinkedList大小
        size++;
        // 修改LinkedList的修改统计数：用来实现fail-fast机制。
        modCount++;
        return newEntry;
    }

    // 将节点从链表中删除
    private E remove(Entry&lt;E&gt; e) {
        if (e == header)
            throw new NoSuchElementException();

        E result = e.element;
        e.previous.next = e.next;
        e.next.previous = e.previous;
        e.next = e.previous = null;
        e.element = null;
        size--;
        modCount++;
        return result;
    }

    // 反向迭代器
    public Iterator&lt;E&gt; descendingIterator() {
        return new DescendingIterator();
    }

    // 反向迭代器实现类。
    private class DescendingIterator implements Iterator {
        final ListItr itr = new ListItr(size());
        // 反向迭代器是否下一个元素。
        // 实际上是判断双向链表的当前节点是否达到开头
        public boolean hasNext() {
            return itr.hasPrevious();
        }
        // 反向迭代器获取下一个元素。
        // 实际上是获取双向链表的前一个节点
        public E next() {
            return itr.previous();
        }
        // 删除当前节点
        public void remove() {
            itr.remove();
        }
    }


    // 返回LinkedList的Object[]数组
    public Object[] toArray() {
    // 新建Object[]数组
    Object[] result = new Object[size];
        int i = 0;
        // 将链表中所有节点的数据都添加到Object[]数组中
        for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)
            result[i++] = e.element;
    return result;
    }

    // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型
    public &lt;T&gt; T[] toArray(T[] a) {
        // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素)
        // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。
        if (a.length &lt; size)
            a = (T[])java.lang.reflect.Array.newInstance(
                                a.getClass().getComponentType(), size);
        // 将链表中所有节点的数据都添加到数组a中
        int i = 0;
        Object[] result = a;
        for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)
            result[i++] = e.element;

        if (a.length &gt; size)
            a[size] = null;

        return a;
    }


    // 克隆函数。返回LinkedList的克隆对象。
    public Object clone() {
        LinkedList&lt;E&gt; clone = null;
        // 克隆一个LinkedList克隆对象
        try {
            clone = (LinkedList&lt;E&gt;) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError();
        }

        // 新建LinkedList表头节点
        clone.header = new Entry&lt;E&gt;(null, null, null);
        clone.header.next = clone.header.previous = clone.header;
        clone.size = 0;
        clone.modCount = 0;

        // 将链表中所有节点的数据都添加到克隆对象中
        for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)
            clone.add(e.element);

        return clone;
    }

    // java.io.Serializable的写入函数
    // 将LinkedList的“容量，所有的元素值”都写入到输出流中
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out any hidden serialization magic
        s.defaultWriteObject();

        // 写入“容量”
        s.writeInt(size);

        // 将链表中所有节点的数据都写入到输出流中
        for (Entry e = header.next; e != header; e = e.next)
            s.writeObject(e.element);
    }

    // java.io.Serializable的读取函数：根据写入方式反向读出
    // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in any hidden serialization magic
        s.defaultReadObject();

        // 从输入流中读取“容量”
        int size = s.readInt();

        // 新建链表表头节点
        header = new Entry&lt;E&gt;(null, null, null);
        header.next = header.previous = header;

        // 从输入流中将“所有的元素值”并逐个添加到链表中
        for (int i=0; i&lt;size; i++)
            addBefore((E)s.readObject(), header);
    }

}</code></pre><p>总结：<br>(01) LinkedList 实际上是通过双向链表去实现的。<br>        它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。<br>(02) 从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。<br>(03) LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。<br>(04) LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。<br>(05) 由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。</p>
<p>总结起来如下表格： </p>
<table frame="hsides" rules="groups" cellspacing="0" cellpadding="0">

<!-- 表头部分 -->
<thead align="center" style="font-weight:bolder; background-color:#cccccc">
     <tr>
          <td></td>
          <td colspan="2">第一个元素（头部）</td>
          <td colspan="2">最后一个元素（尾部）</td>
     </tr>
</thead>
<tbody>
    <tr>
        <td></td>
        <td>抛出异常</td>
        <td>特殊值</td>
        <td>抛出异常</td>
        <td>特殊值</td>
    </tr>
    <tr>
        <td style="font-weight:bolder">插入</td>
        <td>addFirst(e)</td>
        <td>offerFirst(e)</td>
        <td>addLast(e)</td>
        <td>offerLast(e)</td>
    </tr>
    <tr>
        <td style="font-weight:bolder">移除</td>
        <td>removeFirst()</td>
        <td>pollFirst()</td>
        <td>removeLast()</td>
        <td>pollLast()</td>
    </tr>
    <tr>
        <td style="font-weight:bolder">检查</td>
        <td>getFirst()</td>
        <td>peekFirst()</td>
        <td>getLast()</td>
        <td>peekLast()</td>
    </tr>
</tbody>
</table>


<p>(06) LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价：</p>
<table frame="hsides" rules="groups" cellspacing="0" cellpadding="0">

<!-- 表头部分 -->
<thead align="center" style="font-weight:bolder; background-color:#cccccc">
     <tr>
          <td>队列方法</td>
          <td>等效方法</td>
     </tr>
</thead>

<tbody>
    <tr>
        <td>add(e)</td>
        <td>addLast(e)</td>
    </tr>
    <tr>
        <td>offer(e)</td>
        <td>offerLast(e)</td>
    </tr>
    <tr>
        <td>remove()</td>
        <td>removeFirst()</td>
    </tr>
    <tr>
        <td>poll()</td>
        <td>pollFirst()</td>
    </tr>
    <tr>
        <td>element()</td>
        <td>getFirst()</td>
    </tr>
    <tr>
        <td>peek()</td>
        <td>peekFirst()</td>
    </tr>
</tbody>
</table>


<p>(07) LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价：</p>
<table frame="hsides" rules="groups" cellspacing="0" cellpadding="0">

<!-- 表头部分 -->
<thead align="center" style="font-weight:bolder; background-color:#cccccc">
     <tr>
          <td>栈方法</td>
          <td>等效方法</td>
     </tr>
</thead>

<tbody>
    <tr>
        <td>push(e)</td>
        <td>addFirst(e)</td>
    </tr>
    <tr>
        <td>pop()</td>
        <td>removeFirst()</td>
    </tr>
    <tr>
        <td>peek()</td>
        <td>peekFirst()</td>
    </tr>
</tbody>
</table>

<p><a name="anchor4"></a></p>
<h1 id="第4部分-LinkedList遍历方式"><a href="#第4部分-LinkedList遍历方式" class="headerlink" title="第4部分 LinkedList遍历方式"></a>第4部分 LinkedList遍历方式</h1><h2 id="LinkedList遍历方式"><a href="#LinkedList遍历方式" class="headerlink" title="LinkedList遍历方式"></a>LinkedList遍历方式</h2><p>LinkedList支持多种遍历方式。建议不要采用随机访问的方式去遍历LinkedList，而采用逐个遍历的方式。</p>
<p><strong>(01) 第一种，通过迭代器遍历。即通过Iterator去遍历</strong></p>
<pre><code>for(Iterator iter = list.iterator(); iter.hasNext();)
    iter.next();</code></pre><p><strong>(02) 通过快速随机访问遍历LinkedList</strong></p>
<pre><code>int size = list.size();
for (int i=0; i&lt;size; i++) {
    list.get(i);        
}</code></pre><p><strong>(03) 通过另外一种for循环来遍历LinkedList</strong></p>
<pre><code>for (Integer integ:list) 
    ;</code></pre><p><strong>(04) 通过pollFirst()来遍历LinkedList</strong></p>
<pre><code>while(list.pollFirst() != null)
    ;</code></pre><p><strong>(05) 通过pollLast()来遍历LinkedList</strong></p>
<pre><code>while(list.pollLast() != null)
    ;</code></pre><p><strong>(06) 通过removeFirst()来遍历LinkedList</strong></p>
<pre><code>try {
    while(list.removeFirst() != null)
        ;
} catch (NoSuchElementException e) {
}</code></pre><p><strong>(07) 通过removeLast()来遍历LinkedList</strong></p>
<pre><code>try {
    while(list.removeLast() != null)
        ;
} catch (NoSuchElementException e) {
}</code></pre><p>测试这些遍历方式效率的代码如下：</p>
<pre><code>import java.util.List;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.NoSuchElementException;

/*
 * @desc 测试LinkedList的几种遍历方式和效率
 *
 * @author skywang
 */
public class LinkedListThruTest {
    public static void main(String[] args) {
        // 通过Iterator遍历LinkedList
        iteratorLinkedListThruIterator(getLinkedList()) ;

        // 通过快速随机访问遍历LinkedList
        iteratorLinkedListThruForeach(getLinkedList()) ;

        // 通过for循环的变种来访问遍历LinkedList
        iteratorThroughFor2(getLinkedList()) ;

        // 通过PollFirst()遍历LinkedList
        iteratorThroughPollFirst(getLinkedList()) ;

        // 通过PollLast()遍历LinkedList
        iteratorThroughPollLast(getLinkedList()) ;

        // 通过removeFirst()遍历LinkedList
        iteratorThroughRemoveFirst(getLinkedList()) ;

        // 通过removeLast()遍历LinkedList
        iteratorThroughRemoveLast(getLinkedList()) ;
    }

    private static LinkedList getLinkedList() {
        LinkedList llist = new LinkedList();
        for (int i=0; i&lt;100000; i++)
            llist.addLast(i);

        return llist;
    }
    /**
     * 通过快迭代器遍历LinkedList
     */
    private static void iteratorLinkedListThruIterator(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();

        for(Iterator iter = list.iterator(); iter.hasNext();)
            iter.next();

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorLinkedListThruIterator：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过快速随机访问遍历LinkedList
     */
    private static void iteratorLinkedListThruForeach(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();

        int size = list.size();
        for (int i=0; i&lt;size; i++) {
            list.get(i);        
        }
        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorLinkedListThruForeach：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过另外一种for循环来遍历LinkedList
     */
    private static void iteratorThroughFor2(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();

        for (Integer integ:list) 
            ;

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughFor2：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过pollFirst()来遍历LinkedList
     */
    private static void iteratorThroughPollFirst(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();
        while(list.pollFirst() != null)
            ;

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughPollFirst：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过pollLast()来遍历LinkedList
     */
    private static void iteratorThroughPollLast(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();
        while(list.pollLast() != null)
            ;

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughPollLast：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过removeFirst()来遍历LinkedList
     */
    private static void iteratorThroughRemoveFirst(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();
        try {
            while(list.removeFirst() != null)
                ;
        } catch (NoSuchElementException e) {
        }

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughRemoveFirst：&quot; + interval+&quot; ms&quot;);
    }

    /**
     * 通过removeLast()来遍历LinkedList
     */
    private static void iteratorThroughRemoveLast(LinkedList&lt;Integer&gt; list) {
        if (list == null)
            return ;

        // 记录开始时间
        long start = System.currentTimeMillis();
        try {
            while(list.removeLast() != null)
                ;
        } catch (NoSuchElementException e) {
        }

        // 记录结束时间
        long end = System.currentTimeMillis();
        long interval = end - start;
        System.out.println(&quot;iteratorThroughRemoveLast：&quot; + interval+&quot; ms&quot;);
    }

}</code></pre><p>执行结果：</p>
<pre><code>iteratorLinkedListThruIterator：8 ms
iteratorLinkedListThruForeach：3724 ms
iteratorThroughFor2：5 ms
iteratorThroughPollFirst：8 ms
iteratorThroughPollLast：6 ms
iteratorThroughRemoveFirst：2 ms
iteratorThroughRemoveLast：2 ms</code></pre><p>由此可见，遍历LinkedList时，使用removeFist()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取，而不删除，应该使用第3种遍历方式。<br>无论如何，千万不要通过随机访问去遍历LinkedList！</p>
<p><a name="anchor5"></a></p>
<h1 id="第5部分-LinkedList示例"><a href="#第5部分-LinkedList示例" class="headerlink" title="第5部分 LinkedList示例"></a>第5部分 LinkedList示例</h1><p>下面通过一个示例来学习如何使用LinkedList的常用API </p>
<pre><code>import java.util.List;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.NoSuchElementException;

/*
 * @desc LinkedList测试程序。
 *
 * @author skywang
 * @email  kuiwu-wang@163.com
 */
public class LinkedListTest {
    public static void main(String[] args) {
        // 测试LinkedList的API
        testLinkedListAPIs() ;

        // 将LinkedList当作 LIFO(后进先出)的堆栈
        useLinkedListAsLIFO();

        // 将LinkedList当作 FIFO(先进先出)的队列
        useLinkedListAsFIFO();
    }

    /*
     * 测试LinkedList中部分API
     */
    private static void testLinkedListAPIs() {
        String val = null;
        //LinkedList llist;
        //llist.offer(&quot;10&quot;);
        // 新建一个LinkedList
        LinkedList llist = new LinkedList();
        //---- 添加操作 ----
        // 依次添加1,2,3
        llist.add(&quot;1&quot;);
        llist.add(&quot;2&quot;);
        llist.add(&quot;3&quot;);

        // 将“4”添加到第一个位置
        llist.add(1, &quot;4&quot;);


        System.out.println(&quot;\nTest \&quot;addFirst(), removeFirst(), getFirst()\&quot;&quot;);
        // (01) 将“10”添加到第一个位置。  失败的话，抛出异常！
        llist.addFirst(&quot;10&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，抛出异常！
        System.out.println(&quot;llist.removeFirst():&quot;+llist.removeFirst());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，抛出异常！
        System.out.println(&quot;llist.getFirst():&quot;+llist.getFirst());


        System.out.println(&quot;\nTest \&quot;offerFirst(), pollFirst(), peekFirst()\&quot;&quot;);
        // (01) 将“10”添加到第一个位置。  返回true。
        llist.offerFirst(&quot;10&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，返回null。
        System.out.println(&quot;llist.pollFirst():&quot;+llist.pollFirst());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，返回null。
        System.out.println(&quot;llist.peekFirst():&quot;+llist.peekFirst());


        System.out.println(&quot;\nTest \&quot;addLast(), removeLast(), getLast()\&quot;&quot;);
        // (01) 将“20”添加到最后一个位置。  失败的话，抛出异常！
        llist.addLast(&quot;20&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将最后一个元素删除。        失败的话，抛出异常！
        System.out.println(&quot;llist.removeLast():&quot;+llist.removeLast());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取最后一个元素。          失败的话，抛出异常！
        System.out.println(&quot;llist.getLast():&quot;+llist.getLast());


        System.out.println(&quot;\nTest \&quot;offerLast(), pollLast(), peekLast()\&quot;&quot;);
        // (01) 将“20”添加到第一个位置。  返回true。
        llist.offerLast(&quot;20&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，返回null。
        System.out.println(&quot;llist.pollLast():&quot;+llist.pollLast());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，返回null。
        System.out.println(&quot;llist.peekLast():&quot;+llist.peekLast());



        // 将第3个元素设置300。不建议在LinkedList中使用此操作，因为效率低！
        llist.set(2, &quot;300&quot;);
        // 获取第3个元素。不建议在LinkedList中使用此操作，因为效率低！
        System.out.println(&quot;\nget(3):&quot;+llist.get(2));


        // ---- toArray(T[] a) ----
        // 将LinkedList转行为数组
        String[] arr = (String[])llist.toArray(new String[0]);
        for (String str:arr) 
            System.out.println(&quot;str:&quot;+str);

        // 输出大小
        System.out.println(&quot;size:&quot;+llist.size());
        // 清空LinkedList
        llist.clear();
        // 判断LinkedList是否为空
        System.out.println(&quot;isEmpty():&quot;+llist.isEmpty()+&quot;\n&quot;);

    }

    /**
     * 将LinkedList当作 LIFO(后进先出)的堆栈
     */
    private static void useLinkedListAsLIFO() {
        System.out.println(&quot;\nuseLinkedListAsLIFO&quot;);
        // 新建一个LinkedList
        LinkedList stack = new LinkedList();

        // 将1,2,3,4添加到堆栈中
        stack.push(&quot;1&quot;);
        stack.push(&quot;2&quot;);
        stack.push(&quot;3&quot;);
        stack.push(&quot;4&quot;);
        // 打印“栈”
        System.out.println(&quot;stack:&quot;+stack);

        // 删除“栈顶元素”
        System.out.println(&quot;stack.pop():&quot;+stack.pop());

        // 取出“栈顶元素”
        System.out.println(&quot;stack.peek():&quot;+stack.peek());

        // 打印“栈”
        System.out.println(&quot;stack:&quot;+stack);
    }

    /**
     * 将LinkedList当作 FIFO(先进先出)的队列
     */
    private static void useLinkedListAsFIFO() {
        System.out.println(&quot;\nuseLinkedListAsFIFO&quot;);
        // 新建一个LinkedList
        LinkedList queue = new LinkedList();

        // 将10,20,30,40添加到队列。每次都是插入到末尾
        queue.add(&quot;10&quot;);
        queue.add(&quot;20&quot;);
        queue.add(&quot;30&quot;);
        queue.add(&quot;40&quot;);
        // 打印“队列”
        System.out.println(&quot;queue:&quot;+queue);

        // 删除(队列的第一个元素)
        System.out.println(&quot;queue.remove():&quot;+queue.remove());

        // 读取(队列的第一个元素)
        System.out.println(&quot;queue.element():&quot;+queue.element());

        // 打印“队列”
        System.out.println(&quot;queue:&quot;+queue);
    }
}</code></pre><p>运行结果：</p>
<pre><code>Test &quot;addFirst(), removeFirst(), getFirst()&quot;
llist:[10, 1, 4, 2, 3]
llist.removeFirst():10
llist:[1, 4, 2, 3]
llist.getFirst():1

Test &quot;offerFirst(), pollFirst(), peekFirst()&quot;
llist:[10, 1, 4, 2, 3]
llist.pollFirst():10
llist:[1, 4, 2, 3]
llist.peekFirst():1

Test &quot;addLast(), removeLast(), getLast()&quot;
llist:[1, 4, 2, 3, 20]
llist.removeLast():20
llist:[1, 4, 2, 3]
llist.getLast():3

Test &quot;offerLast(), pollLast(), peekLast()&quot;
llist:[1, 4, 2, 3, 20]
llist.pollLast():20
llist:[1, 4, 2, 3]
llist.peekLast():3

get(3):300
str:1
str:4
str:300
str:3
size:4
isEmpty():true


useLinkedListAsLIFO
stack:[4, 3, 2, 1]
stack.pop():4
stack.peek():3
stack:[3, 2, 1]

useLinkedListAsFIFO
queue:[10, 20, 30, 40]
queue.remove():10
queue.element():20
queue:[20, 30, 40]</code></pre><h1 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h1><p><a href="/2012/02/01/collection-00-index">00. Java 集合系列目录(Category)</a><br><a href="/2012/02/01/collection-01-summary">01. Java 集合系列01之 总体框架</a><br><a href="/2012/02/02/collection-02-framework">02. Java 集合系列02之 Collection架构</a><br><a href="/2012/02/03/collection-03-arraylist">03. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/04/collection-04-fail-fast">04. Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a><br><a href="/2012/02/05/collection-05-linkedlist">05. Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/06/collection-06-vector">06. Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/07/collection-07-stack">07. Java 集合系列07之 Stack详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/08/collection-08-List">08. Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)</a><br><a href="/2012/02/09/collection-09-map">09. Java 集合系列09之 Map架构</a><br><a href="/2012/02/10/collection-10-hashmap">10. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/11/collection-11-hashtable">11. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/12/collection-12-treemap">12. Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/13/collection-13-weakhashmap">13. Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/14/collection-14-mapsummary">14. Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)</a><br><a href="/2012/02/15/collection-15-set">15. Java 集合系列15之 Set架构</a><br><a href="/2012/02/16/collection-16-hashset">16. Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/17/collection-17-treeset">17. Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a><br><a href="/2012/02/18/collection-18-iterator_enumeration">18. Java 集合系列18之 Iterator和Enumeration比较</a></p>

    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/java/">#java</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2012/02/06/java/collection/2012-02-06-collection-06-vector/">Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2012/02/04/java/collection/2012-02-04-collection-04-fail-fast/">Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 炸鸡叔&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>