<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Tag: android - PillBlog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta property="og:type" content="website">
<meta property="og:title" content="PillBlog">
<meta property="og:url" content="https://apppills.com/tags/android/index.html">
<meta property="og:site_name" content="PillBlog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PillBlog">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">归档</a>
            
            <a class="navbar-item " href="/about">关于</a>
            
            <a class="navbar-item " href="https://everything.apppills.com">Everything</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#android</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-05-ViewGroup/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例5--ViewGroup没拦截但是却消费了触摸事件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T05:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            5 分钟 read (About 759 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>本文的示例是在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>的基础上修改的。与<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>相比，本文的示例对MyViewGroup中的onTouchEvent()进行了修改。修改后的onTouchEvent()代码如下：</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {
    String actionName = Utils.getActionName(event);
    Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
    // boolean ret = super.onTouchEvent(event);
    boolean ret = true;
    Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
    return ret;
}   </code></pre><p>说明：修改后的MyViewGroup没有拦截触摸事件，但是消费了触摸事件。</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>MyViewGroup没有拦截却消费了ACTION_DOWN。由于MyViewGroup没有拦截ACTION_DOWN，因此，该事件会继续分发给MyViewGroup的子类MyView。由于MyViewGroup消费了ACTION_DOWN，因此该事件不会分发给MyActivity的onTouchEvent()。</strong><br>(02) <strong>MyViewGroup没有拦截却消费了ACTION_DOWN。那么，MyViewGroup仍然可以接受到ACTION_MOVE和ACTION_UP这两种触摸触事件。但是对于MyView而言，由于MyView没有接受该事件；因此，MyView不会收到ACTION_MOVE和ACTION_UP。</strong><br>   试想想，如果MyView接受了ACTION_DOWN事件的话；它是否会收到ACTION_MOVE和ACTION_UP事件呢？答案是：会。感兴趣的读者可以自行验证。</p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event05.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event05.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/05_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例5的源码</a></p>
<p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 2950): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2950): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2950): onInterceptTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 2950): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyView( 2950): onTouchEvent(start) :DOWN<br>D/##skywang-MyView( 2950): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 2950): dispatchTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyViewGroup( 2950): onTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2950): onTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyActivity( 2950): dispatchTouchEvent( end ) :DOWN, ret=true</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 2950): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2950): onTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2950): onTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyActivity( 2950): dispatchTouchEvent( end ) :MOVE, ret=true</p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 2950): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2950): onTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2950): onTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyViewGroup( 2950): dispatchTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyActivity( 2950): dispatchTouchEvent( end ) :UP, ret=true</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-04-ViewGroup/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例4--ViewGroup拦截并消费触摸事件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T04:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 read (About 1169 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/03_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例(三)</a>中，MyViewGroup只是拦截了触摸事件，但是并没有消费触摸事件。<br>而在本文的示例中，MyViewGroup将在拦截触摸事件的基础上，同时消费触摸事件。</p>
<p>本文的示例仍然是在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/03_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例(三)</a>的基础上修改的。与<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/03_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例(三)</a>相比，本文的示例对MyViewGroup中的onTouchEvent()进行了修改。修改后的onTouchEvent()代码如下：</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {
    String actionName = Utils.getActionName(event);
    Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
    // boolean ret = super.onTouchEvent(event);
    boolean ret = true;
    Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
    return ret;
}   </code></pre><p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>MyViewGroup拦截并消费了ACTION_DOWN。那么，该事件就不会分发给MyViewGroup的子类，也不会调用MyActivity的onTouchEvent()。</strong><br>(02) <strong>MyViewGroup拦截并消费了ACTION_DOWN。那么，MyViewGroup就会接受到ACTION_MOVE和ACTION_UP这两种触摸触事件。而且对于ACTION_MOVE和ACTION_UP事件，不会再执行拦截操作，即不会调用MyViewGroup.onInterceptTouchEvent()；而是直接调用MyViewGroup.onTouchEvent()对事件进行处理。</strong><br>  为什么在ACTION_MOVE和ACTION_UP中，没有执行MyViewGroup.onInterceptTouchEvent()呢？查看[ViewGroup中的dispatchTouchEvent()源码]即可得到答案，MyViewGroup在分发ACTION_MOVE时，没有执行”第3步”和”第5步”，而是直接执行”第6步”；进而调用View.dispatchTouchEvent()进行的处理。</p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event04.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event04.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/04_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例4的源码</a></p>
<p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 2465): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2465): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2465): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2465): onInterceptTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2465): onTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2465): onTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2465): dispatchTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyActivity( 2465): dispatchTouchEvent( end ) :DOWN, ret=true</p>
<p>说明：很显然，ACTION_DOWN的流程如下：<br>(01) MyActivity收到ACTION_DOWN，<strong>进入MyActivity.dispatchTouchEvent()</strong>。<br>(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，<strong>进入MyViewGroup.dispatchTouchEvent()</strong>。<br>(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先<strong>进入MyViewGroup.onInterceptTouchEvent()</strong>。<br>(04) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onInterceptTouchEvent()</strong>。此时，MyViewGroup.onInterceptTouchEvent()返回true。表示MyViewGroup拦截了该触摸事件。<br>(05) MyViewGroup在得知自己拦截了触摸事件之后，将触摸事件交给自己的onTouchEvent()进行处理，即<strong>进入MyViewGroup.onTouchEvent()</strong>。<br>(06) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onTouchEvent()</strong>，并返回true。表示MyViewGroup消费了该事件。<br>(07) 随后，MyViewGroup会<strong>退出MyViewGroup.dispatchTouchEvent()</strong>，并返回true。表示MyViewGroup接受了该触摸事件。<br>(08) MyActivity得知MyViewGroup接受了该触摸事件之后，就会<strong>退出MyActivity.dispatchTouchEvent()</strong>，并返回true。表示此次触摸事件被消费了。</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 2465): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2465): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2465): onTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2465): onTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyViewGroup( 2465): dispatchTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyActivity( 2465): dispatchTouchEvent( end ) :MOVE, ret=true</p>
<p>说明：由于MyViewGroup接受了ACTION_DOWN；因此，ACTION_MOVE事件会继续分发给MyViewGroup。不过此时，是直接调用onTouchEvent()进行消息处理，而不再需要执行onInterceptTouchEvent()来拦截消息。<br>为什么没有执行MyViewGroup.onInterceptTouchEvent()呢？查看[ViewGroup中的dispatchTouchEvent()源码]即可得到答案，MyViewGroup在分发ACTION_MOVE时，没有执行”第3步”和”第5步”，而是直接执行”第6步”；进而调用View.dispatchTouchEvent()进行的处理。  </p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 2595): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2595): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2595): onTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2595): onTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyViewGroup( 2595): dispatchTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyActivity( 2595): dispatchTouchEvent( end ) :UP, ret=true</p>
<p>说明：ACTION_UP的路径和ACTION_MOVE的路径一样！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-03-ViewGroup/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例3--ViewGroup拦截但不消费触摸事件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T03:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            9 分钟 read (About 1304 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/02_event_view/EventTest" target="_blank" rel="noopener">触摸事件示例(二)</a>中，MyView接受了触摸事件。<br>可是，在有的时候，我们希望MyViewGroup对触摸事件进行拦截；而不希望这个事件发送给MyView进行处理。此时，就需要重载GroupView的onInterceptTouchEvent()来拦截触摸事件。这就是本文要讲到的示例。</p>
<p>本文的示例仍然是在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>的基础上修改的。与<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/02_event_view/EventTest" target="_blank" rel="noopener">触摸事件示例(二)</a>不同，本文的示例仅仅只对MyViewGroup中的onInterceptTouchEvent()进行了修改。修改后的onInterceptTouchEvent()代码如下：</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    String actionName = Utils.getActionName(event);
    Log.d(TAG, &quot;onInterceptTouchEvent(start) :&quot;+actionName);
    // boolean ret = super.onInterceptTouchEvent(event);
    boolean ret = true;
    Log.d(TAG, &quot;onInterceptTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
    return ret;
}   </code></pre><p>这里的onTouchEvent()直接返回true，表示MyView消费了触摸事件。</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>MyViewGroup拦截了ACTION_DOWN，并没有消费该ACTION_DOWN。既然MyViewGroup拦截了ACTION_DOWN，那就意味着该事件就不会分发给MyViewGroup的子类。但是由于MyViewGroup没有消费该事件，即它并没有接受该事件；那么，ACTION_DOWN会继续查找其他对象来消费它自己，这也意味着该触摸事件仍然会发送MyActivity的onTouchEvent()。</strong><br>  如果MyActivity中有和MyViewGroup同级别的GroupView的话，在得知MyViewGroup拦截了ACTION_DOWN，却没有消费该ACTION_DOWN之后；MyActivity仍然能够向这个同级的GroupView分发消息。<br>(02) <strong>MyViewGroup并没有消费ACTION_DOWN，那么，MyViewGroup就不能接受到ACTION_MOVE和ACTION_UP这两种触摸触事件。至于MyViewGroup的子类MyView，就更加不可能接受到ACTION_MOVE和ACTION_UP了。</strong></p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event03.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event03.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/03_event_viewgourp/EventTest" target="_blank" rel="noopener">触摸事件示例3的源码</a></p>
<p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 2371): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2371): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2371): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2371): onInterceptTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2371): onTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2371): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyViewGroup( 2371): dispatchTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyActivity( 2371): onTouchEvent(start) :DOWN<br>D/##skywang-MyActivity( 2371): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyActivity( 2371): dispatchTouchEvent( end ) :DOWN, ret=false</p>
<p>说明：很显然，ACTION_DOWN的流程如下：<br>(01) MyActivity收到ACTION_DOWN，<strong>进入MyActivity.dispatchTouchEvent()</strong>。<br>(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，<strong>进入MyViewGroup.dispatchTouchEvent()</strong>。<br>(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先<strong>进入MyViewGroup.onInterceptTouchEvent()</strong>。<br>(04) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onInterceptTouchEvent()</strong>。此时，MyViewGroup.onInterceptTouchEvent()返回true。表示MyViewGroup拦截了该触摸事件。<br>(05) MyViewGroup在得知自己拦截了触摸事件之后，将触摸事件交给自己的onTouchEvent()进行处理，即<strong>进入MyViewGroup.onTouchEvent()</strong>。<br>(06) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onTouchEvent()</strong>。而MyViewGroup自身并没有消费该事件，因此MyViewGroup.onTouchEvent()返回false。<br>(07) 随后，<strong>退出MyViewGroup.dispatchTouchEvent()</strong>，并返回false。表示MyViewGroup没有接受该触摸事件。<br>(08) MyActivity得知MyViewGroup没有接受该触摸事件之后，就会调用<strong>进入MyActivity.onTouchEvent()</strong>。<br>(09) 紧接着，MyActivity会<strong>退出MyActivity.onTouchEvent()</strong>，并返回false。表示MyActivity也没有消费触摸事件。<br>(10) 最后，MyActivity会<strong>退出MyActivity.dispatchTouchEvent()</strong>，并返回false。表示此次触摸事件没有被消费。</p>
<p>对比，<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>中的ACTION_DOWN路径。在本示例中，MyViewGroup拦截了ACTION_DOWN，但是没有消费ACTION_DOWN事件。 (01) MyViewGroup拦截了ACTION_DOWN事件，意味着该事件不会继续往下分发。 (02) MyViewGroup没有消费该事件，意味着该事件就继续往上分发。</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 2371): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyActivity( 2371): onTouchEvent(start) :MOVE<br>D/##skywang-MyActivity( 2371): onTouchEvent( end ) :MOVE, ret=false<br>D/##skywang-MyActivity( 2371): dispatchTouchEvent( end ) :MOVE, ret=false</p>
<p>说明：由于MyViewGroup拦截了ACTION_DOWN，却没有消费给ACTION_DOWN；导致ACTION_MOVE不会分发给MyViewGroup。既然没有分发给MyViewGroup，就更加谈不上分发给MyView了。</p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 2371): dispatchTouchEvent(start) :UP<br>D/##skywang-MyActivity( 2371): onTouchEvent(start) :UP<br>D/##skywang-MyActivity( 2371): onTouchEvent( end ) :UP, ret=false<br>D/##skywang-MyActivity( 2371): dispatchTouchEvent( end ) :UP, ret=false</p>
<p>说明：ACTION_UP的路径和ACTION_MOVE的路径一样！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-02-View/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例2--View接受触摸事件</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T02:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 read (About 1226 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>本文的示例是在<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>的基础上修改的。即本文的示例仍然是：自定义一个Activity，该Activity中的显示内容是包含一个自定义的ViewGroup，该ViewGroup中包含一个自定义的View。</p>
<p>相比<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>，本示例对MyView中的onTouchEvent()进行了修改。修改后的onTouchEvent()代码如下：</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent event) {
    String actionName = Utils.getActionName(event);
    Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
    // boolean ret = super.onTouchEvent(event);
    boolean ret = true;
    Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
    return ret;
}   </code></pre><p>这里的onTouchEvent()直接返回true，表示MyView消费了触摸事件。</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>如果MyView接受了ACTION_DOWN，那么就不会再再执行其他对象的onTouchEvent()函数的。即，不会执行MyViewGroup的onTouchEvent()和MyActivity的onTouchEvent()。因为MyView接受了ACTION_DOWN，意味着这个事件已经被消费了；就无须其他对象再来消费ACTION_DOWN了。</strong><br>(02) <strong>如果MyView接受了ACTION_DOWN，那么MyView能继续收到ACTION_MOVE和ACTION_UP这两种触摸触事件。并且ACTION_MOVE和ACTION_UP的处理流程和ACTION_DOWN的流程基本一样。</strong></p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event02.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/02_event_view/EventTest" target="_blank" rel="noopener">触摸事件示例2的源码</a></p>
<p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 2273): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 2273): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyView( 2273): onTouchEvent(start) :DOWN<br>D/##skywang-MyView( 2273): onTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyView( 2273): dispatchTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent( end ) :DOWN, ret=true<br>D/##skywang-MyActivity( 2273): dispatchTouchEvent( end ) :DOWN, ret=true</p>
<p>说明：很显然，ACTION_DOWN的流程如下：<br>(01) MyActivity收到ACTION_DOWN，<strong>进入MyActivity.dispatchTouchEvent()</strong>。<br>(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，<strong>进入MyViewGroup.dispatchTouchEvent()</strong>。<br>(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先<strong>进入MyViewGroup.onInterceptTouchEvent()</strong>。<br>(04) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onInterceptTouchEvent()</strong>。因为MyViewGroup没有对触摸事件进行拦截，MyViewGroup会继续分发事件。<br>(05) MyViewGroup将触摸事件分发给MyView，即<strong>进入MyView.dispatchTouchEvent()</strong>。<br>(06) MyView会调用onTouchEvent()对触摸事件进行处理，即<strong>进入MyView.onTouchEvent()</strong>  。<br>(07) 紧接着，MyView会<strong>退出MyView.onTouchEvent()</strong>。此时的，MyView.onTouchEvent()返回的是true；表示MyView消费了此次触摸事件。<br>(08) MyView.dispatchTouchEvent()得知MyView.onTouchEvent()消费此次触摸事件之后；也就返回true，表示MyView接受该此次触摸事件。<br>(09) MyViewGroup则得知MyView接受了该触摸事件之后，就<strong>退出MyViewGroup.dispatchTouchEvent()</strong>，并返回true。<br>(10) MyActivity得知MyViewGroup接受了该触摸事件之后，就会调用<strong>退出MyActivity.dispatchTouchEvent()</strong>，并返回true。</p>
<p>对比，<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例(一)</a>中的ACTION_DOWN路径。在本示例中，MyView消费了ACTION_DOWN事件之后；触摸事件就没有再发送给MyViewGroup.onTouchEvent()以及MyActivity.onTouchEvent()。</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 2273): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent(start) :MOVE<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent( end ) :MOVE, ret=false<br>D/##skywang-MyView( 2273): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyView( 2273): onTouchEvent(start) :MOVE<br>D/##skywang-MyView( 2273): onTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyView( 2273): dispatchTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent( end ) :MOVE, ret=true<br>D/##skywang-MyActivity( 2273): dispatchTouchEvent( end ) :MOVE, ret=true</p>
<p>说明：由于MyView接受了ACTION_DOWN；因此，ACTION_MOVE事件会继续分发给MyView。ACTION_MOVE的分发路径和ACTION_DOWN的路径基本上一样！</p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 2273): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent(start) :UP<br>D/##skywang-MyViewGroup( 2273): onInterceptTouchEvent( end ) :UP, ret=false<br>D/##skywang-MyView( 2273): dispatchTouchEvent(start) :UP<br>D/##skywang-MyView( 2273): onTouchEvent(start) :UP<br>D/##skywang-MyView( 2273): onTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyView( 2273): dispatchTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyViewGroup( 2273): dispatchTouchEvent( end ) :UP, ret=true<br>D/##skywang-MyActivity( 2273): dispatchTouchEvent( end ) :UP, ret=true</p>
<p>说明：由于MyView接受了ACTION_DOWN；因此，ACTION_UP事件会继续分发给MyView。ACTION_UP的分发路径和ACTION_DOWN的路径基本上一样！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/05/android/os/event/2015-01-05-TouchEvent-Sample-01-default/" itemprop="url">Android 触摸事件机制(五) 触摸事件示例1--默认处理方式</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-05T01:01:00.000Z" itemprop="datePublished">1月 5 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 read (About 1914 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将通过示例演示触摸事件的传递流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">示例概述</a><br><strong>1.1</strong>. <a href="#anchor1_1">示例简介</a><br><strong>1.2</strong>. <a href="#anchor1_2">示例结论</a><br><strong>2</strong>. <a href="#anchor2">示例源码</a><br><strong>2.1</strong>. <a href="#anchor2_1">MyActivity的源码</a><br><strong>2.2</strong>. <a href="#anchor2_2">MyViewGroup的源码</a><br><strong>2.3</strong>. <a href="#anchor2_3">MyView的源码</a><br><strong>3</strong>. <a href="#anchor3">运行结果</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-示例概述"><a href="#1-示例概述" class="headerlink" title="1. 示例概述"></a>1. 示例概述</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-示例简介"><a href="#1-1-示例简介" class="headerlink" title="1.1 示例简介"></a>1.1 示例简介</h2><p>本文的示例：自定义一个Activity，该Activity中的显示内容是包含一个自定义的ViewGroup，该ViewGroup中包含一个自定义的View。</p>
<p>(01) 自定义的Activity是MyActivity<br>public boolean dispatchTouchEvent(MotionEvent ev): 调用系统默认的dispatchTouchEvent()<br>public boolean onTouchEvent(MotionEvent ev): 调用系统默认的onTouchEvent()</p>
<p>(02) 自定义ViewGroup是MyViewGroup<br>public boolean dispatchTouchEvent(MotionEvent ev): 调用系统默认的dispatchTouchEvent()<br>public boolean onTouchEvent(MotionEvent ev): 调用系统默认的onTouchEvent()<br>public boolean onInterceptTouchEvent(MotionEvent ev):: 调用系统默认的onInterceptTouchEvent() </p>
<p>(03) 自定义View是MyView<br>public boolean dispatchTouchEvent(MotionEvent ev): 调用系统默认的dispatchTouchEvent()<br>public boolean onTouchEvent(MotionEvent ev): 调用系统默认的onTouchEvent()</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-示例结论"><a href="#1-2-示例结论" class="headerlink" title="1.2 示例结论"></a>1.2 示例结论</h2><p>(01) <strong>MyActivity, ViewGroup和View的触摸事件相关API默认都返回false。即，上面列出的API的默认返回值都是false。</strong><br>(02) <strong>触摸事件的分发顺序是经过MyActivity –&gt; MyViewGroup –&gt; MyView。</strong><br>    它们的触摸事件的入口都是dispatchTouchEvent()，即MyActivity将事件分发给MyViewGroup时，是通过MyActivity.dispatchTouchEvent()去调用MyViewGroup.dispatchTouchEvent()；同样的，MyViewGroup将事件分发给MyView时，也是通过MyViewGroup.dispatchTouchEvent()去调用MyView.dispatchTouchEvent()。<br>    它们的对触摸事件的处理都是在onTouchEvent()中完成的。也就是说，会在它们的dispatchTouchEvent()中，皆会调用(它们各自的)onTouchEvent()来对事件进行处理。onTouchEvent()返回true，就表示消费了个事件，或者说接受了个事件。<br>    前面说过消息的分发顺序是MyActivity –&gt; MyViewGroup –&gt; MyView。如果想在MyActivity中进行消息拦截(即，MyActivity不想将消息分发给它包含的视图)，则需要重载dispatchTouchEvent()。如果想在MyViewGroup中进行消息拦截(即，MyViewGroup收到触摸事件之后，不想分发给它的子视图)，则一般都会通过覆盖onInterceptTouchEvent()，并在onInterceptTouchEvent()返回true来拦截消息。<br>(03) <strong>MyViewGroup和MyView都没有接受ACTION_DOWN事件的话；那么，ACTION_MOVE和ACTION_UP等触摸事件也就不会发送给它们。</strong>  </p>
<p>Activity中ACTION_DOWN的流程图如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/event/event01.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="2-示例源码"><a href="#2-示例源码" class="headerlink" title="2. 示例源码"></a>2. 示例源码</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/events/01_event_default/EventTest" target="_blank" rel="noopener">触摸事件示例1的源码</a></p>
<p><a name="anchor2_1"></a></p>
<h2 id="2-1-MyActivity的源码"><a href="#2-1-MyActivity的源码" class="headerlink" title="2.1 MyActivity的源码"></a>2.1 MyActivity的源码</h2><pre><code>public class MyActivity extends Activity {
    private static final String TAG = &quot;##skywang-MyActivity&quot;;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }   

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;dispatchTouchEvent(start) :&quot;+actionName);
        boolean ret = super.dispatchTouchEvent(event);
        Log.d(TAG, &quot;dispatchTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }   

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
        boolean ret = super.onTouchEvent(event);
        Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }
}</code></pre><p>说明：MyActivity的layout是main.xml。虽然它覆盖了dispatchTouchEvent()和onTouchEvent()方法；但它们都是在调用父类的对应的方法的基础之上，添加了打印信息而已。</p>
<h3 id="2-1-1-getActionName的源码"><a href="#2-1-1-getActionName的源码" class="headerlink" title="2.1.1 getActionName的源码"></a>2.1.1 getActionName的源码</h3><pre><code>public static String getActionName(MotionEvent event) {
    final int action = event.getAction(); 
    if (action == MotionEvent.ACTION_DOWN) {
        return &quot;DOWN&quot;;     
    } else if (action == MotionEvent.ACTION_MOVE) {
        return &quot;MOVE&quot;;     
    } else if (action == MotionEvent.ACTION_UP) {
        return &quot;UP&quot;;       
    } else if (action == MotionEvent.ACTION_CANCEL) { 
        return &quot;CANCEL&quot;;   
    } else {               
        return &quot;NULL&quot;;     
    }
}</code></pre><h3 id="2-1-2-main-xml的源码"><a href="#2-1-2-main-xml的源码" class="headerlink" title="2.1.2 main.xml的源码"></a>2.1.2 main.xml的源码</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;fill_parent&quot; &gt;

    &lt;TextView                  
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Hello World, EventTest-Default&quot; /&gt;

    &lt;com.skw.eventtest.MyViewGroup  
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;400dp&quot;
        android:background=&quot;#cccccc&quot;
        android:layout_gravity=&quot;center&quot;
        android:gravity=&quot;center&quot; &gt;

        &lt;com.skw.eventtest.MyView       
            android:layout_width=&quot;200dp&quot;
            android:layout_height=&quot;100dp&quot;
            android:background=&quot;#451c0a&quot; /&gt;

    &lt;/com.skw.eventtest.MyViewGroup&gt;
&lt;/LinearLayout&gt;</code></pre><p>说明：main.xml中包含了MyViewGroup，而MyViewGroup中又包含了MyView。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-MyViewGroup的源码"><a href="#2-2-MyViewGroup的源码" class="headerlink" title="2.2 MyViewGroup的源码"></a>2.2 MyViewGroup的源码</h2><pre><code>public class MyViewGroup extends LinearLayout {
    private static final String TAG = &quot;##skywang-MyViewGroup&quot;;

    public MyViewGroup(Context context){
        super(context);        
    } 

    public MyViewGroup(Context context, AttributeSet attrs) {
        super(context, attrs); 
    }     

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;dispatchTouchEvent(start) :&quot;+actionName);
        boolean ret = super.dispatchTouchEvent(event);
        Log.d(TAG, &quot;dispatchTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
        boolean ret = super.onTouchEvent(event);
        Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;onInterceptTouchEvent(start) :&quot;+actionName);
        boolean ret = super.onInterceptTouchEvent(event);
        Log.d(TAG, &quot;onInterceptTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }
}</code></pre><p>说明：MyViewGroup继承于ViewGroup。虽然它覆盖了dispatchTouchEvent(), onTouchEvent()和onInterceptTouchEvent()方法；但它们都是在调用父类的对应的方法的基础之上，添加了打印信息而已。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="2-3-MyView的源码"><a href="#2-3-MyView的源码" class="headerlink" title="2.3 MyView的源码"></a>2.3 MyView的源码</h2><pre><code>public class MyView extends View {
    private static final String TAG = &quot;##skywang-MyView&quot;;

    public MyView(Context context) {
        super(context);        
    }

    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs); 
    } 

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;dispatchTouchEvent(start) :&quot;+actionName);
        boolean ret = super.dispatchTouchEvent(event);
        Log.d(TAG, &quot;dispatchTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        String actionName = Utils.getActionName(event);
        Log.d(TAG, &quot;onTouchEvent(start) :&quot;+actionName);
        boolean ret = super.onTouchEvent(event);
        Log.d(TAG, &quot;onTouchEvent( end ) :&quot;+actionName+&quot;, ret=&quot;+ret);
        return ret;
    }
}</code></pre><p><a name="anchor3"></a></p>
<h1 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3. 运行结果"></a>3. 运行结果</h1><h2 id="3-1-ACTION-DOWN事件"><a href="#3-1-ACTION-DOWN事件" class="headerlink" title="3.1 ACTION_DOWN事件"></a>3.1 ACTION_DOWN事件</h2><p>点击MyView所在的区域，ACTION_DOWN相关的log如下：</p>
<p>D/##skywang-MyActivity( 1935): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 1935): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 1935): onInterceptTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 1935): onInterceptTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 1935): dispatchTouchEvent(start) :DOWN<br>D/##skywang-MyView( 1935): onTouchEvent(start) :DOWN<br>D/##skywang-MyView( 1935): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyView( 1935): dispatchTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyViewGroup( 1935): onTouchEvent(start) :DOWN<br>D/##skywang-MyViewGroup( 1935): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyViewGroup( 1935): dispatchTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyActivity( 1935): onTouchEvent(start) :DOWN<br>D/##skywang-MyActivity( 1935): onTouchEvent( end ) :DOWN, ret=false<br>D/##skywang-MyActivity( 1935): dispatchTouchEvent( end ) :DOWN, ret=false</p>
<p>说明：很显然，ACTION_DOWN的流程如下：<br>(01) MyActivity收到ACTION_DOWN，<strong>进入MyActivity.dispatchTouchEvent()</strong>。<br>(02) MyActivity.dispatchTouchEvent()对ACTION_DOWN触摸事件进行分发，将消息传递给MyViewGroup。即，<strong>进入MyViewGroup.dispatchTouchEvent()</strong>。<br>(03) MyViewGroup.dispatchTouchEvent()会调用MyViewGroup.onInterceptTouchEvent()检查自己有没有对触摸事件进行拦截。即先<strong>进入MyViewGroup.onInterceptTouchEvent()</strong>。<br>(04) 紧接着，MyViewGroup会<strong>退出MyViewGroup.onInterceptTouchEvent()</strong>。因为MyViewGroup没有对触摸事件进行拦截，MyViewGroup会继续分发事件。<br>(05) MyViewGroup将触摸事件分发给MyView，即<strong>进入MyView.dispatchTouchEvent()</strong>。<br>(06) MyView会调用onTouchEvent()对触摸事件进行处理，即<strong>进入MyView.onTouchEvent()</strong>  。<br>(07) 紧接着，MyView会<strong>退出MyView.onTouchEvent()</strong>。返回false给MyView.dispatchTouchEvent()。<br>(08) MyView收到MyView.onTouchEvent()的返回值之后，<strong>退出MyView.dispatchTouchEvent()</strong>。返回false给MyViewGroup的MyViewGroup.dispatchTouchEvent()，表示MyView没有接受该触摸事件。<br>(09) MyViewGroup则得知MyView没有接受该触摸事件之后，将自己当作一个View，调用View.dispatchTouchEvent()；View.dispatchTouchEvent()接着就会<strong>进入MyViewGroup.onTouchEvent()</strong>。<br>(10) 紧接着，就会<strong>退出MyViewGroup.onTouchEvent()</strong>。MyViewGroup.onTouchEvent()没有消费该触摸事件，因此返回false。<br>(11) 然后，View.dispatchTouchEvent()就会结束，并返回false。接着，MyViewGroup就会<strong>退出MyViewGroup.dispatchTouchEvent()</strong>。并返回false。<br>(12) MyActivity在得知MyViewGroup没有接受该触摸事件之后，就会调用<strong>进入MyActivity.onTouchEvent</strong>。<br>(13) 紧接着，就会<strong>退出MyActivity.onTouchEvent</strong>，并返回false。<br>(14) 至此，MyActivity.dispatchTouchEvent()才结束。因此，会<strong>退出MyActivity.dispatchTouchEvent()</strong>，并返回false。</p>
<p>说明：触摸事件的分发顺序是经过MyActivity –&gt; MyViewGroup –&gt; MyView。</p>
<h2 id="3-2-ACTION-MOVE事件"><a href="#3-2-ACTION-MOVE事件" class="headerlink" title="3.2 ACTION_MOVE事件"></a>3.2 ACTION_MOVE事件</h2><p>点击MyView所在的区域，ACTION_MOVE相关的log如下：</p>
<p>D/##skywang-MyActivity( 1935): dispatchTouchEvent(start) :MOVE<br>D/##skywang-MyActivity( 1935): onTouchEvent(start) :MOVE<br>D/##skywang-MyActivity( 1935): onTouchEvent( end ) :MOVE, ret=false<br>D/##skywang-MyActivity( 1935): dispatchTouchEvent( end ) :MOVE, ret=false</p>
<p>说明：由于MyViewGroup和MyView都没有接受ACTION_DOWN事件，因此ACTION_MOVE事件就不会再分发给它们。</p>
<h2 id="3-3-ACTION-UP事件"><a href="#3-3-ACTION-UP事件" class="headerlink" title="3.3 ACTION_UP事件"></a>3.3 ACTION_UP事件</h2><p>点击MyView所在的区域，ACTION_UP相关的log如下：</p>
<p>D/##skywang-MyActivity( 1935): dispatchTouchEvent(start) :UP<br>D/##skywang-MyActivity( 1935): onTouchEvent(start) :UP<br>D/##skywang-MyActivity( 1935): onTouchEvent( end ) :UP, ret=false<br>D/##skywang-MyActivity( 1935): dispatchTouchEvent( end ) :UP, ret=false</p>
<p>说明：由于MyViewGroup和MyView都没有接受ACTION_DOWN事件，因此ACTION_UP事件就不会再分发给它们。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/04/android/os/event/2015-01-04-TouchEvent-ViewGroup/" itemprop="url">Android 触摸事件机制(四) ViewGroup中触摸事件详解</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-04T01:01:00.000Z" itemprop="datePublished">1月 4 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            26 分钟 read (About 3837 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将对ViewGroup中触摸事件相关的内容进行介绍。ViewGroup继承于View，所以说，ViewGroup中对触摸事件的处理，很多都继承于View。但是，ViewGroup又有自己对触摸事件的特定处理。本文重点介绍的是dispatchTouchEvent()；理解ViewGroup的dispatchTouchEvent()接口是理解Android触摸事件传递机制的关机。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">ViewGroup中触摸事件的概述</a><br><strong>2</strong>. <a href="#anchor2">ViewGroup中触摸事件的源码解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">ViewGroup中的dispatchTouchEvent</a><br><strong>2.2</strong>. <a href="#anchor2_2">ViewGroup中的onTouchEvent</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-ViewGroup中触摸事件的概述"><a href="#1-ViewGroup中触摸事件的概述" class="headerlink" title="1. ViewGroup中触摸事件的概述"></a>1. ViewGroup中触摸事件的概述</h1><p>ViewGroup继承于View，它中对触摸事件的处理，很多都继承于View。但是，ViewGroup又有自己对触摸事件的特定处理。<br>(01) ViewGroup重载了dispatchTouchEvent()接口。<br>(02) ViewGroup新增了onInterceptTouchEvent()接口。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-ViewGroup中触摸事件的源码解析"><a href="#2-ViewGroup中触摸事件的源码解析" class="headerlink" title="2. ViewGroup中触摸事件的源码解析"></a>2. ViewGroup中触摸事件的源码解析</h1><p><a name="anchor2_1"></a></p>
<h2 id="2-1-ViewGroup中的dispatchTouchEvent"><a href="#2-1-ViewGroup中的dispatchTouchEvent" class="headerlink" title="2.1 ViewGroup中的dispatchTouchEvent"></a>2.1 ViewGroup中的dispatchTouchEvent</h2><pre><code>@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    // mInputEventConsistencyVerifier是调试用的，不会理会
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }

    // 第1步：是否要分发该触摸事件
    //
    // onFilterTouchEventForSecurity()表示是否要分发该触摸事件。 
    // 如果该View不是位于顶部，并且有设置属性使该View不在顶部时不响应触摸事件，则不分发该触摸事件，即返回false。
    // 否则，则对触摸事件进行分发，即返回true。
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

        // 第2步：检测是否需要清空目标和状态
        //
        // 如果是ACTION_DOWN(即按下事件)，则清空之前的触摸事件处理目标和状态。
        // 这里的情况状态包括：
        // (01) 清空mFirstTouchTarget链表，并设置mFirstTouchTarget为null。
        //      mFirstTouchTarget是&quot;接受触摸事件的View&quot;所组成的单链表
        // (02) 清空mGroupFlags的FLAG_DISALLOW_INTERCEPT标记
        //      如果设置了FLAG_DISALLOW_INTERCEPT，则不允许ViewGroup对触摸事件进行拦截。
        // (03) 清空mPrivateFlags的PFLAG_CANCEL_NEXT_UP_EVEN标记
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }    

        // 第3步：检查当前ViewGroup是否想要拦截触摸事件
        // 
        // 是的话，设置intercepted为true；否则intercepted为false。
        // 如果是&quot;按下事件(ACTION_DOWN)&quot; 或者 mFirstTouchTarget不为null；就执行if代码块里面的内容。
        // 否则的话，设置intercepted为true。
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            // 检查禁止拦截标记：FLAG_DISALLOW_INTERCEPT
            // 如果调用了requestDisallowInterceptTouchEvent()标记的话，则FLAG_DISALLOW_INTERCEPT会为true。
            // 例如，ViewPager在处理触摸事件的时候，就会调用requestDisallowInterceptTouchEvent()
            //     ，禁止它的父类对触摸事件进行拦截
            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                // 如果禁止拦截标记为false的话，则调用onInterceptTouchEvent()；并返回拦截状态。
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            } else {
                intercepted = false;
            }    
        } else {
            intercepted = true;
        }    

        // 第4步：检查当前的触摸事件是否被取消
        // 
        // (01) 对于ACTION_DOWN而言，mPrivateFlags的PFLAG_CANCEL_NEXT_UP_EVENT位肯定是0；因此，canceled=false。
        // (02) 当前的View或ViewGroup要被从父View中detach时，PFLAG_CANCEL_NEXT_UP_EVENT就会被设为true；
        //      此时，它就不再接受触摸事情。
        final boolean canceled = resetCancelNextUpFlag(this)
                || actionMasked == MotionEvent.ACTION_CANCEL;

        // 第5步：将触摸事件分发给&quot;当前ViewGroup的子View和子ViewGroup&quot;
        // 
        // 如果触摸&quot;没有被取消&quot;，同时也&quot;没有被拦截&quot;的话，则将触摸事件分发给它的子View和子ViewGroup。  
        //     如果当前ViewGroup的孩子有接受触摸事件的话，则将该孩子添加到mFirstTouchTarget链表中。
        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled &amp;&amp; !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // 这是获取触摸事件的序号 以及 触摸事件的id信息。
                // (01) 对于ACTION_DOWN，actionIndex肯定是0
                // (02) 而getPointerId()是获取的该触摸事件的id，并将该id信息保存到idBitsToAssign中。
                //    这个触摸事件的id是为多指触摸而添加的；对于单指触摸，getActionIndex()返回的肯定是0；
                //    而对于多指触摸，第一个手指的id是0，第二个手指的id是1，第三个手指的id是2，...依次类推。
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                        : TouchTarget.ALL_POINTER_IDS;

                // 清空这个手指之前的TouchTarget链表。
                // 一个TouchTarget，相当于一个可以被触摸的对象；它中记录了接受触摸事件的View
                removePointersFromTouchTargets(idBitsToAssign);

                // 获取该ViewGroup包含的View和ViewGroup的数目，
                // 然后递归遍历ViewGroup的孩子，对触摸事件进行分发。
                // 递归遍历ViewGroup的孩子：是指对于当前ViewGroup的所有孩子，都会逐个遍历，并分发触摸事件；
                //   对于逐个遍历到的每一个孩子，若该孩子是ViewGroup类型的话，则会递归到调用该孩子的孩子，...
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    final View[] children = mChildren;

                    final boolean customOrder = isChildrenDrawingOrderEnabled();
                    for (int i = childrenCount - 1; i &gt;= 0; i--) {
                        final int childIndex = customOrder ?
                                getChildDrawingOrder(childrenCount, i) : i;
                        final View child = children[childIndex];
                        // 如果child可以接受触摸事件，
                        // 并且触摸坐标(x,y)在child的可视范围之内的话；
                        // 则继续往下执行。否则，调用continue。
                        // child可接受触摸事件：是指child的是可见的(VISIBLE)；或者虽然不可见，但是位于动画状态。
                        if (!canViewReceivePointerEvents(child)
                                || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }

                        // getTouchTarget()的作用是查找child是否存在于mFirstTouchTarget的单链表中。
                        // 是的话，返回对应的TouchTarget对象；否则，返回null。
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }

                        // 重置child的mPrivateFlags变量中的PFLAG_CANCEL_NEXT_UP_EVENT位。
                        resetCancelNextUpFlag(child);

                        // 调用dispatchTransformedTouchEvent()将触摸事件分发给child。
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // 如果child能够接受该触摸事件，即child消费或者拦截了该触摸事件的话；
                            // 则调用addTouchTarget()将child添加到mFirstTouchTarget链表的表头，并返回表头对应的TouchTarget
                            // 同时还设置alreadyDispatchedToNewTouchTarget为true。
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = childIndex;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }

                // 如果newTouchTarget为null，并且mFirstTouchTarget不为null；
                // 则设置newTouchTarget为mFirstTouchTarget链表中第一个不为空的节点。
                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }

        // 第6步：进一步的对触摸事件进行分发
        // 
        // (01) 如果mFirstTouchTarget为null，意味着还没有任何View来接受该触摸事件；
        //   此时，将当前ViewGroup看作一个View；
        //   将会调用&quot;当前的ViewGroup的父类View的dispatchTouchEvent()&quot;对触摸事件进行分发处理。
        //   即，会将触摸事件交给当前ViewGroup的onTouch(), onTouchEvent()进行处理。
        // (02) 如果mFirstTouchTarget不为null，意味着有ViewGroup的子View或子ViewGroup中，
        //   有可以接受触摸事件的。那么，就将触摸事件分发给这些可以接受触摸事件的子View或子ViewGroup。
        if (mFirstTouchTarget == null) {
            // 注意：这里的第3个参数是null
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                            || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                            target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }

        // 第7步：再次检查取消标记，并进行相应的处理
        // 
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled
                || actionMasked == MotionEvent.ACTION_UP
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }

    // mInputEventConsistencyVerifier是调试用的，不会理会
    if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}</code></pre><p>说明：该代码定义在frameworks/base/core/java/android/view/ViewGroup.java中。流程比较复杂，但文章已经给出了非常详细的注释，相信根据注释应该能读懂。遇到不懂或有疑惑的地方，还需阅读源码才是！  </p>
<p>注意：<strong>第5步，即ViewGroup尝试将触摸事件分发给它的孩子。这只有在ACTION_DOWN的时候才发生。如果它的孩子接受了触摸事件，则会调用addTouchTarget()将该孩子添加到mFirstTouchTarget链表中。  在ACTION_DOWN之后，传递ACTION_MOVE或ACTION_UP时，ViewGroup不会再执行第5步；而是在第6步中，直接遍历mFirstTouchTarget链表，查找之前接受ACTION_DOWN的孩子，并将触摸事件分配给这些孩子。</strong><br><strong>也就是说，如果ViewGroup的某个孩子没有接受ACTION_DOWN事件；那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！</strong></p>
<h3 id="2-1-1-ViewGroup中的dispatchTransformedTouchEvent"><a href="#2-1-1-ViewGroup中的dispatchTransformedTouchEvent" class="headerlink" title="2.1.1 ViewGroup中的dispatchTransformedTouchEvent()"></a>2.1.1 ViewGroup中的dispatchTransformedTouchEvent()</h3><pre><code>private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {
    final boolean handled;

    // 检测是否需要发送ACTION_CANCEL。
    // 如果cancel为true 或者 action是ACTION_CANCEL;
    // 则设置消息为ACTION_CANCEL，并将ACTION_CANCEL消息分发给对应的对象，并返回。
    // (01) 如果child是空，则将ACTION_CANCEL消息分发给当前ViewGroup；
    //      只不过会将ViewGroup看作它的父类View，调用View的dispatchTouchEvent()接口。
    // (02) 如果child不是空，调用child的dispatchTouchEvent()。
    final int oldAction = event.getAction();
    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL);
        if (child == null) {
            handled = super.dispatchTouchEvent(event);
        } else {
            handled = child.dispatchTouchEvent(event);
        }
        event.setAction(oldAction);
        return handled;
    }

    // 计算触摸事件的id信息
    final int oldPointerIdBits = event.getPointerIdBits();
    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;

    // 如果新的id信息为0，则返回false。
    if (newPointerIdBits == 0) {
        return false;
    }


    // 如果计算得到的前后触摸事件id信息相同，则执行不需要重新计算MotionEvent，直接执行if语句块进行消费分发；
    // 否则，就重新计算MotionEvent之后，再进行消息分发。
    final MotionEvent transformedEvent;
    if (newPointerIdBits == oldPointerIdBits) {
        if (child == null || child.hasIdentityMatrix()) {
            // (01) 如果child是空，则将ViewGroup看作它的父类View，调用View的dispatchTouchEvent()接口。
            // (02) 如果child不是空，调用child的dispatchTouchEvent()。
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                final float offsetX = mScrollX - child.mLeft;
                final float offsetY = mScrollY - child.mTop;
                event.offsetLocation(offsetX, offsetY);

                handled = child.dispatchTouchEvent(event);

                event.offsetLocation(-offsetX, -offsetY);
            }
            return handled;
        }
        transformedEvent = MotionEvent.obtain(event);
    } else {
        transformedEvent = event.split(newPointerIdBits);
    }

    // (01) 如果child是空，则将ViewGroup看作它的父类View，调用View的dispatchTouchEvent()接口。
    // (02) 如果child不是空，调用child的dispatchTouchEvent()。
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        if (! child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }

        handled = child.dispatchTouchEvent(transformedEvent);
    }

    // Done.
    transformedEvent.recycle();
    return handled;
}</code></pre><p>说明：dispatchTransformedTouchEvent()会对触摸事件进行重新打包后再分发。<br>如果它的第三个参数child是null，则会将触摸消息分发给ViewGroup自己，只不过此时是将ViewGroup看作一个View，即调用View的dispatchTouchEvent()进行消息分发。而View的dispatchTouchEvent()在前面一篇文章中已经消息介绍过了，它会触摸事件分发给onTouch(), onTouchEvent()进行处理。<br>如果它的第三个参数child不是null，则会调用child.dispatchTouchEvent()进行消息分发。而如果这个child是ViewGroup对象的话，它则又会递归的将消息分发给它的孩子。</p>
<h3 id="2-1-2-ViewGroup中的cancelAndClearTouchTargets"><a href="#2-1-2-ViewGroup中的cancelAndClearTouchTargets" class="headerlink" title="2.1.2 ViewGroup中的cancelAndClearTouchTargets()"></a>2.1.2 ViewGroup中的cancelAndClearTouchTargets()</h3><pre><code>private TouchTarget mFirstTouchTarget;

private void cancelAndClearTouchTargets(MotionEvent event) {
    // 如果mFirstTouchTarget链表不为空，则清空该链表
    if (mFirstTouchTarget != null) {
        ...

        // 遍历mFirstTouchTarget链表，请清空每一个TouchTarget中View的PFLAG_CANCEL_NEXT_UP_EVENT位
        for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {
            resetCancelNextUpFlag(target.child);
            ...
        }
        // 清空TouchTarget链表本身，并设置mFirstTouchTarget为null
        clearTouchTargets();

        ...
    }
}

private static boolean resetCancelNextUpFlag(View view) {
    // 清空mPrivateFlags中的PFLAG_CANCEL_NEXT_UP_EVENT位
    if ((view.mPrivateFlags &amp; PFLAG_CANCEL_NEXT_UP_EVENT) != 0) {
        view.mPrivateFlags &amp;= ~PFLAG_CANCEL_NEXT_UP_EVENT;
        return true;
    }
    return false;
}

private void clearTouchTargets() {
    TouchTarget target = mFirstTouchTarget;
    // 清空mFirstTouchTarget链表，并设置mFirstTouchTarget为null
    if (target != null) {
        do {
            TouchTarget next = target.next;
            target.recycle();
            target = next;
        } while (target != null);
        mFirstTouchTarget = null;
    }
}</code></pre><p>说明：cancelAndClearTouchTargets()的作用和明显。就是清空mFirstTouchTarget链表中每一个View的PFLAG_CANCEL_NEXT_UP_EVENT标记；然后清空mFirstTouchTarget链表，并设置mFirstTouchTarget为null。<br>mFirstTouchTarget是TouchTarget类的成员。TouchTarget是ViewGroup的内部类，一个TouchTarget对象可以视为一个被触摸对象；即，在ViewGroup中，就通过TouchTarget表示一个可以接受触摸事件的对象。</p>
<pre><code>private static final class TouchTarget {
    ...

    // 被触摸的View
    public View child;

    // pointerIdBits是记录触摸事件的id信息(对于多指触摸而言)
    public int pointerIdBits;

    // TouchTarget指向的下一个节点
    public TouchTarget next;


    private TouchTarget() {
    }

    ...
}</code></pre><h3 id="2-1-3-ViewGroup中的resetTouchState"><a href="#2-1-3-ViewGroup中的resetTouchState" class="headerlink" title="2.1.3 ViewGroup中的resetTouchState()"></a>2.1.3 ViewGroup中的resetTouchState()</h3><pre><code>private void resetTouchState() {
    clearTouchTargets();
    resetCancelNextUpFlag(this);
    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
}</code></pre><p>说明：resetTouchState()是清空当前ViewGroup的点击状态。</p>
<h3 id="2-1-4-ViewGroup中的removePointersFromTouchTargets"><a href="#2-1-4-ViewGroup中的removePointersFromTouchTargets" class="headerlink" title="2.1.4 ViewGroup中的removePointersFromTouchTargets()"></a>2.1.4 ViewGroup中的removePointersFromTouchTargets()</h3><pre><code>private void removePointersFromTouchTargets(int pointerIdBits) {
    TouchTarget predecessor = null;
    TouchTarget target = mFirstTouchTarget;
    while (target != null) {
        final TouchTarget next = target.next;
        if ((target.pointerIdBits &amp; pointerIdBits) != 0) {
            target.pointerIdBits &amp;= ~pointerIdBits;
            if (target.pointerIdBits == 0) {
                if (predecessor == null) {
                    mFirstTouchTarget = next;
                } else {
                    predecessor.next = next;
                }
                target.recycle();
                target = next;
                continue;
            }
        }
        predecessor = target;
        target = next;
    }
}</code></pre><p>说明：理解removePointersFromTouchTargets()的关机，是理解ev.getPointerId()。而getPointerId()是获取的该触摸事件的id。对于多指触摸，第一个手指的id是0，第二个手指的id是1，第三个手指的id是2，…依次类推。<br>而pointerIdBits就是记录的id信息的。第一个手指的pointerIdBits是0x0，第二个手指的的pointerIdBits是0x1，第三个手指的pointerIdBits是0x2，第四个手指的pointerIdBits是0x4，…所有手指的pointerIdBits是0xffffffff。<br>理解了触摸id之后，再看看removePointersFromTouchTargets()就非常容易理解了。它是从mFirstTouchTarget链表中逐个遍历，清空pointerIdBits；如果清空pointerIdBits之后，TouchTarget的pointerIdBits为0，则将该节点从链表中删除。</p>
<h3 id="2-1-5-ViewGroup中的canViewReceivePointerEvents"><a href="#2-1-5-ViewGroup中的canViewReceivePointerEvents" class="headerlink" title="2.1.5 ViewGroup中的canViewReceivePointerEvents()"></a>2.1.5 ViewGroup中的canViewReceivePointerEvents()</h3><pre><code>private static boolean canViewReceivePointerEvents(View child) {
    return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE
            || child.getAnimation() != null;
}</code></pre><p>说明：canViewReceivePointerEvents()是判断child是否可以接受触摸事件。如果child是VISIBLE；或者child是非VISIBLE，但是它处于动画状态；这两种状态都可以接受触摸事件。</p>
<h3 id="2-1-6-ViewGroup中的isTransformedTouchPointInView"><a href="#2-1-6-ViewGroup中的isTransformedTouchPointInView" class="headerlink" title="2.1.6 ViewGroup中的isTransformedTouchPointInView()"></a>2.1.6 ViewGroup中的isTransformedTouchPointInView()</h3><pre><code>protected boolean isTransformedTouchPointInView(float x, float y, View child,
        PointF outLocalPoint) {
    float localX = x + mScrollX - child.mLeft;
    float localY = y + mScrollY - child.mTop;
    if (! child.hasIdentityMatrix() &amp;&amp; mAttachInfo != null) {
        final float[] localXY = mAttachInfo.mTmpTransformLocation;
        localXY[0] = localX;
        localXY[1] = localY;
        child.getInverseMatrix().mapPoints(localXY);
        localX = localXY[0];
        localY = localXY[1];
    }
    final boolean isInView = child.pointInView(localX, localY);
    ...
    return isInView;
}</code></pre><p>说明：isTransformedTouchPointInView()是判断(x,y)是否在child中。</p>
<h3 id="2-1-7-ViewGroup中的getTouchTarget"><a href="#2-1-7-ViewGroup中的getTouchTarget" class="headerlink" title="2.1.7 ViewGroup中的getTouchTarget()"></a>2.1.7 ViewGroup中的getTouchTarget()</h3><pre><code>private TouchTarget getTouchTarget(View child) {
    for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {
        if (target.child == child) {
            return target;
        }
    }
    return null;
}</code></pre><p>说明：getTouchTarget()的作用是查找child是否存在于mFirstTouchTarget的单链表中。是的话，返回对应的TouchTarget对象；否则，返回null。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-ViewGroup中的onTouchEvent"><a href="#2-2-ViewGroup中的onTouchEvent" class="headerlink" title="2.2 ViewGroup中的onTouchEvent"></a>2.2 ViewGroup中的onTouchEvent</h2><p>ViewGroup没有覆盖onTouchEvent()。因此，调用ViewGroup的onTouchEvent()的话；实际上调用的是它的父类View的onTouchEvent()。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="2-3-ViewGroup中的onInterceptTouchEvent"><a href="#2-3-ViewGroup中的onInterceptTouchEvent" class="headerlink" title="2.3 ViewGroup中的onInterceptTouchEvent"></a>2.3 ViewGroup中的onInterceptTouchEvent</h2><pre><code>public boolean onInterceptTouchEvent(MotionEvent ev) {
    return false;
}   </code></pre><p>说明：ViewGroup的onInterceptTouchEvent()默认返回false。而且什么都不会执行！<br>一般来说，若我们自定义ViewGroup时，需要拦截触摸消息；就可以覆盖onInterceptTouchEvent()来进行。</p>
<p>ViewGroup中关于触摸事件的代码就分析至此。总的来说：<br>(01) <strong>ViewGroup中的dispatchTouchEvent()会将触摸事件进行递归遍历传递。ViewGroup会遍历它的所有孩子，对每个孩子都递归的调用dispatchTouchEvent()来分发触摸事件。</strong><br>(02) <strong>如果ViewGroup的某个孩子没有接受(消费或者拦截)ACTION_DOWN事件；那么，ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！</strong><br>(03) <strong>ViewGroup的onInterceptTouchEvent()默认返回false。</strong></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/03/android/os/event/2015-01-03-TouchEvent-View/" itemprop="url">Android 触摸事件机制(三) View中触摸事件详解</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-03T01:01:00.000Z" itemprop="datePublished">1月 3 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            14 分钟 read (About 2054 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将对View中触摸事件相关的内容进行介绍。重点介绍的是dispatchTouchEvent(), onTouchEvent()这两个API以及OnTouchListener接口。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">View中触摸事件的概述</a><br><strong>2</strong>. <a href="#anchor2">View中触摸事件的源码解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">View中的dispatchTouchEvent</a><br><strong>2.2</strong>. <a href="#anchor2_2">View中的onTouchEvent</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-View中触摸事件的概述"><a href="#1-View中触摸事件的概述" class="headerlink" title="1. View中触摸事件的概述"></a>1. View中触摸事件的概述</h1><p>  View中与触摸事件相关的内容可以分为两部分。</p>
<p><strong>第一部分</strong> dispatchTouchEvent()和onTouchEvent()这两个API</p>
<p>dispatchTouchEvent()是传递触摸事件的API，而onTouchEvent()则是View处理触摸事件的API。<br>View中dispatchTouchEvent()将事件传递给”自己的onTouch()”, “自己的onTouchEvent()”进行处理。 onTouch()是OnTouchListener接口中API，属于View提供的，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统提供的，用于处理触摸事件的接口；在onTouchEvent()中会进行一系列的动作，例如获取焦点、设置按下状态，调用onClick()等。</p>
<p><strong>第二部分</strong> OnTouchListener, OnClickListener, OnLongClickListener等接口</p>
<p>这部分主要是接口。但本文主要介绍的是OnTouchListener接口中的onTouch()。为什么呢？<br>这是因为，onTouch()与onTouchEvent()都是用户处理触摸事件的API。<br>但不同的是：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。  如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。</p>
<pre><code>public interface OnTouchListener {
    boolean onTouch(View v, MotionEvent event);
}</code></pre><p><a name="anchor2"></a></p>
<h1 id="2-View中触摸事件的源码解析"><a href="#2-View中触摸事件的源码解析" class="headerlink" title="2. View中触摸事件的源码解析"></a>2. View中触摸事件的源码解析</h1><p><a name="anchor2_1"></a></p>
<h2 id="2-1-View中的dispatchTouchEvent"><a href="#2-1-View中的dispatchTouchEvent" class="headerlink" title="2.1 View中的dispatchTouchEvent"></a>2.1 View中的dispatchTouchEvent</h2><pre><code>public boolean dispatchTouchEvent(MotionEvent event) {
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    // 如果该View被遮蔽，并且该View在被遮蔽时不响应点击事件；
    // 此时，返回false；不会执行onTouch()或onTouchEvent()，即过滤调用该点击事件。
    // 否则，返回true。
    // 被遮蔽的意思是：该View不是位于顶部，有其他的View在它之上。
    if (onFilterTouchEventForSecurity(event)) {
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            return true;
        }

        if (onTouchEvent(event)) {
            return true;
        }
    }

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}</code></pre><p>说明：该代码定义在frameworks/base/core/java/android/view/View.java中。<br>(01) mInputEventConsistencyVerifier是调试用的，这里不用理会。重点看onFilterTouchEventForSecurity()部分。<br>(02) onFilterTouchEventForSecurity()表示是否要分发该触摸事件；如果该View不是位于顶部，并且有设置属性使该View不在顶部时不响应触摸事件，则不分发该触摸事件，即不会执行onTouch()与onTouchEvent()。 否则的话，则将事件分发给onTouch(), onTouchEvent()进行处理。<br>(03) 如果将事件进行分发的话，会先尝试分发给onTouch()；然后才分发给onTouchEvent()。</p>
<h3 id="2-1-1-View中的onFilterTouchEventForSecurity"><a href="#2-1-1-View中的onFilterTouchEventForSecurity" class="headerlink" title="2.1.1 View中的onFilterTouchEventForSecurity()"></a>2.1.1 View中的onFilterTouchEventForSecurity()</h3><pre><code>public boolean onFilterTouchEventForSecurity(MotionEvent event) {
    //noinspection RedundantIfStatement
    if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0
            &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {
        // Window is obscured, drop this touch.
        return false;
    }
    return true;
}</code></pre><p>说明：onFilterTouchEventForSecurity()返回true，表示可以分发该触摸事件；否则，不能分发该触摸事件。不能分发事件的情况，只有mViewFlags&amp;FILTER_TOUCHES_WHEN_OBSCURED!=0，并且event.getFlags()&amp;MotionEvent.FLAG_WINDOW_IS_OBSCURED!=0同时成立。<br>(01) FILTER_TOUCHES_WHEN_OBSCURED是android:filterTouchesWhenObscured属性所对应的位。android:filterTouchesWhenObscured是true的话，则表示其他视图在该视图之上，导致该视图被隐藏时，该视图就不再响应触摸事件。<br>(02) MotionEvent.FLAG_WINDOW_IS_OBSCURED为true的话，则表示该视图的窗口是被隐藏的。  </p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-View中的onTouchEvent"><a href="#2-2-View中的onTouchEvent" class="headerlink" title="2.2 View中的onTouchEvent"></a>2.2 View中的onTouchEvent</h2><pre><code>public boolean onTouchEvent(MotionEvent event) {
    final int viewFlags = mViewFlags;

    // 如果View被禁用的话，则返回它是否可以点击。
    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));
    }

    // 如果该View的mTouchDelegate不为null的话，将触摸消息分发给mTouchDelegate。
    // mTouchDelegate的默认值是null。
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    // 如果View可以被点击的话，则执行if里面的内容。
    // 这其中涉及到的主要是获取焦点，设置按下状态，触发onClick(), onLongClick()事件等等。
    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don&apos;t have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true);
                   }


                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;

            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true);
                    checkForLongClick(0);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                break;

            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();

                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }

    return false;
}</code></pre><p>说明：onTouchEvent()是Android系统实现的View对触摸事件的处理。<br>(01) 如果View被禁用的话，则返回它是否可以点击。当我们调用了setEnabled(false)时，View就被禁用了；默认情况下，View是可用的。当调用setClickable(true)或者android:clickable为true时，View就是可点击状态；默认情况下，View是不可点击的。<br>(02) 如果该View的mTouchDelegate不为null的话，将触摸消息分发给mTouchDelegate。例如，假设有两个视图v1和v2，它们的布局相互之间不重叠；如果设置了v1.setTouchDelegate(v2)的话，v1的触摸事件就会分发给v2。 注意：mTouchDelegate的默认值是null。<br>(03) 如果View可以被点击的话，则执行if里面的内容。if里面涉及的内容很多，这里与本文的主题关联不大，暂且不表；如果要细将的话，估计得好几篇文章。例如，setPressed()是设置View的按下状态，如果用户有设置View在不同状态的图片时，setPressed()时会导致View的图片的更新。</p>
<p>View中关于触摸事件的代码就分析至此。总的来说：<br>(01) <strong>View中的dispatchTouchEvent()会将事件传递给”自己的onTouch()”, “自己的onTouchEvent()”进行处理。而且onTouch()的优先级比onTouchEvent()的优先级要高。</strong><br>(02) <strong>onTouch()与onTouchEvent()都是View中用户处理触摸事件的API。onTouch是OnTouchListener接口中的函数，OnTouchListener接口需要用户自己实现。onTouchEvent()是View自带的接口，Android系统提供了默认的实现；当然，用户可以重载该API。</strong><br>(03) <strong>onTouch()与onTouchEvent()有两个不同之处：(01), onTouch()是View提供给用户，让用户自己处理触摸事件的接口。而onTouchEvent()是Android系统自己实现的接口。(02)，onTouch()的优先级比onTouchEvent()的优先级更高。dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。  如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。</strong></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/02/android/os/event/2015-01-02-TouchEvent-Activity/" itemprop="url">Android 触摸事件机制(二) Activity中触摸事件详解</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-02T01:01:00.000Z" itemprop="datePublished">1月 2 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 read (About 1997 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文将对Activity中触摸事件相关的内容进行介绍，重点介绍的是Activity中与触摸事件相关的两个API：dispatchTouchEvent()和onTouchEvent()。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Activity中触摸事件的概述</a><br><strong>2</strong>. <a href="#anchor2">Activity中触摸事件的源码解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">Activity中的dispatchTouchEvent</a><br><strong>2.2</strong>. <a href="#anchor2_2">Activity中的onTouchEvent</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Activity中触摸事件的概述"><a href="#1-Activity中触摸事件的概述" class="headerlink" title="1. Activity中触摸事件的概述"></a>1. Activity中触摸事件的概述</h1><p>  Activity中与触摸事件相关API主要是dispatchTouchEvent()和onTouchEvent()。dispatchTouchEvent()是传递触摸事件的API，而onTouchEvent()则是Activity处理触摸事件的API。</p>
<p>  Activity就是dispatchTouchEvent()将触摸事件传递给它所包含的根视图，从而实现将触摸事件传递给View或ViewGroup进行处理。<br>  而在onTouchEvent()在是Activity自己对触摸事件的处理。例如，如果Activity是一个Dialog主题，即Activity相当于一个对话框；那么当onTouchEvent()收到点击事件，并且该点击事件的坐标在Activity之外的时候，onTouchEvent()就会结束Activity。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-Activity中触摸事件的源码解析"><a href="#2-Activity中触摸事件的源码解析" class="headerlink" title="2. Activity中触摸事件的源码解析"></a>2. Activity中触摸事件的源码解析</h1><p><a name="anchor2_1"></a></p>
<h2 id="2-1-Activity中的dispatchTouchEvent"><a href="#2-1-Activity中的dispatchTouchEvent" class="headerlink" title="2.1 Activity中的dispatchTouchEvent"></a>2.1 Activity中的dispatchTouchEvent</h2><pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    // onUserInteraction默认不执行任何动作。
    // 它是提供给客户的接口。
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    // 这里会调用到ViewGroup的dispatchTouchEvent()，
    // 即会调用Activity包含的根视图的dispatchTouchEvent()。
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    // 如果superDispatchTouchEvent()返回false，
    // 即Activity的根视图以及根视图的子视图都没有拦截该事件的话，则调用Activity的onTouchEvent()
    return onTouchEvent(ev);
}</code></pre><p>说明：该代码定义在frameworks/base/core/java/android/app/Activity.java中。<br>Activity通过调用dispatchTouchEvent()将触摸事件分发给Activity所包含的视图；如果Activity中的视图都没有对触摸事件进行拦截的话，则调用Activity的onTouchEvent()对触摸事件进行处理。<br>下面，先看看Activity是如何通过superDispatchTouchEvent()将事件分发给它所包含的View的。</p>
<h3 id="2-1-1-Activity中的getWindow"><a href="#2-1-1-Activity中的getWindow" class="headerlink" title="2.1.1 Activity中的getWindow()"></a>2.1.1 Activity中的getWindow()</h3><pre><code>private Window mWindow;

public Window getWindow() {
    return mWindow;
}

final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config) {

    ...

    mWindow = PolicyManager.makeNewWindow(this);

    ...
}</code></pre><p>说明：getWindow()返回的是mWindow对象，而mWindow是在attach()中初始化的。attach()是Activity被加载时调用的，具体是如何attact()的，不是我们关心的重点；这里只需要了解，Activity被加载时，attach()会被执行即可。<br>接着，我们就看看PolicyManager.makeNewWindow()是如何实现的。</p>
<h3 id="2-1-2-PolicyManager中的makeNewWindow"><a href="#2-1-2-PolicyManager中的makeNewWindow" class="headerlink" title="2.1.2 PolicyManager中的makeNewWindow()"></a>2.1.2 PolicyManager中的makeNewWindow()</h3><pre><code>public static Window makeNewWindow(Context context) {
    return sPolicy.makeNewWindow(context);
}   

private static final String POLICY_IMPL_CLASS_NAME =
    &quot;com.android.internal.policy.impl.Policy&quot;;

private static final IPolicy sPolicy;

static {
    // Pull in the actual implementation of the policy at run-time
    try {
        Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME);
        sPolicy = (IPolicy)policyClass.newInstance();
    } catch (ClassNotFoundException ex) {
        throw new RuntimeException(
                POLICY_IMPL_CLASS_NAME + &quot; could not be loaded&quot;, ex);
    } catch (InstantiationException ex) {
        throw new RuntimeException(
                POLICY_IMPL_CLASS_NAME + &quot; could not be instantiated&quot;, ex);
    } catch (IllegalAccessException ex) {
        throw new RuntimeException(
                POLICY_IMPL_CLASS_NAME + &quot; could not be instantiated&quot;, ex);
    }
}   </code></pre><p>说明：该代码定义在frameworks/base/core/java/com/android/internal/policy/PolicyManager.java中。<br>makeNewWindow()是调用的sPolicy.makeNewWindow()，而sPolicy是个静态变量，它的实现也是在静态代码块中。因此，在PolicyManager.java加载的时候，sPolicy就会被初始化为policyClass.newInstance()。而policyClass是通过Class得到的Policy对象。<br>也就是说，PolicyManager中的makeNewWindow()会调用Policy中的makeNewWindow()。</p>
<h3 id="2-1-3-Policy中的makeNewWindow"><a href="#2-1-3-Policy中的makeNewWindow" class="headerlink" title="2.1.3 Policy中的makeNewWindow"></a>2.1.3 Policy中的makeNewWindow</h3><pre><code>public Window makeNewWindow(Context context) {
    return new PhoneWindow(context);
}   </code></pre><p>说明：该代码定义在frameworks/base/policy/src/com/android/internal/policy/impl/Policy.java中。makeNewWindow()会返回PhoneWindow对象。<br>回到Activity的dispatchTouchEvent()中，也就是说getWindow()返回的是PhoneWindow对象。接着，就看看superDispatchTouchEvent()的实现。</p>
<h3 id="2-1-4-PhoneWindow中的superDispatchTouchEvent"><a href="#2-1-4-PhoneWindow中的superDispatchTouchEvent" class="headerlink" title="2.1.4 PhoneWindow中的superDispatchTouchEvent"></a>2.1.4 PhoneWindow中的superDispatchTouchEvent</h3><pre><code>@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
    return mDecor.superDispatchTouchEvent(event);
}    

private DecorView mDecor;

private void installDecor() {
    if (mDecor == null) {
        mDecor = generateDecor();
        ...
    }

    ...
}

protected DecorView generateDecor() {
    return new DecorView(getContext(), -1); 
}    </code></pre><p>说明：该代码定义在frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java中。<br>superDispatchTouchEvent()会调用mDecor.superDispatchTouchEvent()；而mDecor是DecorView对象。mDecor是在installDecor()中被创建的。总之，PhoneWindow中的superDispatchTouchEvent()会调用DecorView中的superDispatchTouchEvent()。DecorView是PhoneWindow中的内部类，下面看看它的实现。</p>
<h3 id="2-1-5-DecorView中的superDispatchTouchEvent"><a href="#2-1-5-DecorView中的superDispatchTouchEvent" class="headerlink" title="2.1.5 DecorView中的superDispatchTouchEvent"></a>2.1.5 DecorView中的superDispatchTouchEvent</h3><pre><code>private final class DecorView extends FrameLayout implements RootViewSurfaceTaker {
    ...

    public boolean superDispatchTouchEvent(MotionEvent event) {
        return super.dispatchTouchEvent(event);
    }

    ...
}</code></pre><p>说明：DecorView中的superDispatchTouchEvent()会调用父类的dispatchTouchEvent()。而DecorView的父类是FrameLayout，FrameLayout的父类又是GroupView；因此superDispatchTouchEvent()最终会调用到GroupView的dispatchTouchEvent()。</p>
<p>关于GroupView中的dispatchTouchEvent()的流程，在后面的文章中再来详细介绍！这里重点需要了解：<strong>Activity在通过dispatchTouchEvent()传递触摸事件的时候，会调用到ViewGroup的dispatchTouchEvent()。从而实现，将Activity中的触摸事件传递给它所包含的View或ViewGroup。</strong></p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-Activity中的onTouchEvent"><a href="#2-2-Activity中的onTouchEvent" class="headerlink" title="2.2 Activity中的onTouchEvent"></a>2.2 Activity中的onTouchEvent</h2><p>回顾一下Activity中dispatchTouchEvent()的内容。</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    // onUserInteraction默认不执行任何动作。
    // 它是提供给客户的接口。
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    // 这里会调用到ViewGroup的dispatchTouchEvent()，
    // 即会调用Activity包含的根视图的dispatchTouchEvent()。
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    // 如果superDispatchTouchEvent()返回false，
    // 即Activity的根视图以及根视图的子视图都没有拦截该事件的话，则调用Activity的onTouchEvent()
    return onTouchEvent(ev);
}</code></pre><p>(01) 如果superDispatchTouchEvent()返回true的话，dispatchTouchEvent()就直接返回true了，不会执行onTouchEvent()。也就是说，如果Activity将触摸事件分发给它所包含的视图的时候，如果有视图拦截或消费了该事件，就不会轮到Activity来处理该事件了；即，不会执行Activity的onTouchEvent()了。<br>(02) 如果superDispatchTouchEvent()返回false的话，意味着，Activity所包含的视图都没有拦截或消费该触摸事件；那么，就会调用Activity的onTouchEvent()来处理触摸事件。</p>
<p>下面就看看onTouchEvent()的代码。</p>
<pre><code>public boolean onTouchEvent(MotionEvent event) {
    if (mWindow.shouldCloseOnTouch(this, event)) {
        finish();
        return true;
    }    

    return false;
}    </code></pre><p>说明：代码很简单。它会先调用mWindow.shouldCloseOnTouch()，如果shouldCloseOnTouch()返回true，则意味着该触摸事件会触发”结束Activity”的动作。那么接下来，就调用finish()来结束Activity，并返回true，表示Activity消费了这个触摸事件。否则的话，就返回false。</p>
<h3 id="2-2-1-Window的shouldCloseOnTouch"><a href="#2-2-1-Window的shouldCloseOnTouch" class="headerlink" title="2.2.1 Window的shouldCloseOnTouch()"></a>2.2.1 Window的shouldCloseOnTouch()</h3><p>前面分析过，mWindow是PhoneWindow对象，而PhoneWindow继承于Window。则mWindow.shouldCloseOnTouch()实际上会调用Window中的shouldCloseOnTouch()。</p>
<pre><code>public boolean shouldCloseOnTouch(Context context, MotionEvent event) {
    if (mCloseOnTouchOutside &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN
            &amp;&amp; isOutOfBounds(context, event) &amp;&amp; peekDecorView() != null) {
        return true;
    }    
    return false;
}    </code></pre><p>说明：该代码定义在frameworks/base/core/java/android/view/Window.java中。<br>(01) mCloseOnTouchOutside是一个boolean变量，它是由Window的android:windowCloseOnTouchOutside属性值决定。<br>(02) isOutOfBounds(context, event)是判断该event的坐标是否在context(对于本文来说就是当前的Activity)之外。是的话，返回true；否则，返回false。<br>(03) peekDecorView()则是返回PhoneWindow的mDecor。<br>也就是说，如果设置了android:windowCloseOnTouchOutside属性为true，并且当前事件是ACTION_DOWN，而且点击发生在Activity之外，同时Activity还包含视图的话，则返回true；表示该点击事件会导致Activity的结束。</p>
<p>至此，Activity中关于触摸事件的代码就分析完毕了。总结来说：<br>(01) <strong>Activity中的dispatchTouchEvent会将触摸事件传递给Activity所包含的视图。具体的实现方式在通过调用到Activity所属Window的superDispatchTouchEvent，进而调用到Window的DecorView的superDispatchTouchEvent，进一步的又调用到ViewGroup的dispatchTouchEvent()。</strong><br> 如果Activity所包含的视图拦截或者消费了该触摸事件的话，就不会再执行Activity的onTouchEvent()；<br> 如果Activity所包含的视图没有拦截或者消费该触摸事件的话，则会执行Activity的onTouchEvent()。<br>(02) <strong>Activity中的onTouchEvent是Activity自身对触摸事件的处理。如果该Activity的android:windowCloseOnTouchOutside属性为true，并且当前触摸事件是ACTION_DOWN，而且该触摸事件的坐标在Activity之外，同时Activity还包含了视图的话；就会导致Activity被结束。</strong></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2015/01/01/android/os/event/2015-01-01-TouchEvent-Introduce/" itemprop="url">Android 触摸事件机制(一) 简介</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2015-01-01T01:01:00.000Z" itemprop="datePublished">1月 1 2015</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 read (About 1007 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本系列文章将介绍Android中触摸事件，即Touch Event的传递机制。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">触摸事件概述</a><br><strong>2</strong>. <a href="#anchor2">Activity, ViewGroup, View中的触摸事件API</a><br><strong>3</strong>. <a href="#anchor3">OnTouchListener接口</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-触摸事件概述"><a href="#1-触摸事件概述" class="headerlink" title="1. 触摸事件概述"></a>1. 触摸事件概述</h1><p>本文介绍的触摸事件API和接口主要是：dispatchTouchEvent(), onTouchEvent(), onInterceptTouchEvent()和OnTouchListener接口。这些内容中，最复杂的莫过于dispatchTouchEvent(), onTouchEvent()和onInterceptTouchEvent()这三者之间的关系。如果你能认真读完本系列文章，相信对它们之间的关系，它们的原理和用法，很有很清晰的认识。</p>
<p>本文先对这些接口做个大致介绍，建立一个整体概念。后续再通过阅读Activity, View和ViewGroup中触摸事件API的源码，来对认识这些API；最后，再通过几个示例来进一步了解它们，同时也了解它们的用法。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-Activity-ViewGroup-View中的触摸事件API"><a href="#2-Activity-ViewGroup-View中的触摸事件API" class="headerlink" title="2. Activity, ViewGroup, View中的触摸事件API"></a>2. Activity, ViewGroup, View中的触摸事件API</h1><p><strong>1. Activity中的触摸事件API</strong><br>public boolean dispatchTouchEvent(MotionEvent ev)；<br>public boolean onTouchEvent(MotionEvent ev); </p>
<p><strong>2. ViewGroup中的触摸事件API</strong><br>public boolean dispatchTouchEvent(MotionEvent ev)；<br>public boolean onTouchEvent(MotionEvent ev);<br>public boolean onInterceptTouchEvent(MotionEvent ev);</p>
<p><strong>3. View中的触摸事件API</strong><br>public boolean dispatchTouchEvent(MotionEvent ev)；<br>public boolean onTouchEvent(MotionEvent ev); </p>
<p>下面简单的说明一下涉及到的三个API的作用。</p>
<p><strong>dispatchTouchEvent</strong>：它是传递触摸事件的接口。<br>(01) Activity将触摸事件传递给ViewGroup，ViewGroup将触摸事件传递给另一个ViewGroup，以及ViewGroup将触摸事件传递给View；这些都是通过dispatchTouchEvent()来传递的。<br>(02) dispatchTouchEvent(), onInterceptTouchEvent(), onTouchEvent()以及onTouch()它们之间的联系，都是通过dispatchTouchEvent()体现的。它们都是在dispatchTouchEvent()中调度的！因此，理解dispatchTouchEvent()是理解Android事件机制的关机；而其中，最关机的就是ViewGroup中的dispatchTouchEvent()<br>(03) 返回值：true，表示触摸事件被消费了；false，则表示触摸事件没有被消费。<br><strong>onTouchEvent</strong>：它是处理触摸事件的接口。<br>(01) 无论是Activity, ViewGroup还是View，对触摸事件的处理，基本上都是在onTouchEvent()中进行的。因此，我们说它是处理触摸事件的接口。<br>(02) 返回值：返回true，表示触摸事件被它处理过了；或者，换句话说，表示它消费了触摸事件。否则，表示它没有消费该触摸事件。<br><strong>onInterceptTouchEvent</strong>：它是拦截触摸事件的接口。<br>(01) 只有ViewGroup中才有该接口。如果ViewGroup不想将触摸事件传递给它的子View，则可以在onInterceptTouchEvent中进行拦截。<br>(02) 返回值：true，表示ViewGroup拦截了该触摸事件；那么，该事件就不会分发给它的子View或者子ViewGroup。否则，表示ViewGroup没有拦截该事件，该事件就会分发给它的子View和子ViewGroup。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-OnTouchListener接口"><a href="#3-OnTouchListener接口" class="headerlink" title="3. OnTouchListener接口"></a>3. OnTouchListener接口</h1><p>OnTouchListener一个interface接口，它是在View中声明的。OnTouchListener中只包含了onTouch()函数。<br>那么，onTouch()和onTouchEvent()有什么相同和不同点呢？</p>
<p><strong>相同点</strong><br>onTouch()与onTouchEvent()都是用户处理触摸事件的API。</p>
<p><strong>不同点</strong><br>(01)，onTouch()是View专门提供给用户的接口，目的是为了方便用户自己处理触摸事件。而onTouchEvent()是Android系统自己实现的接口。<br>(02)，onTouch()的优先级比onTouchEvent()的优先级更高。<br>    dispatchTouchEvent()中分发事件的时候，会先将事件分配给onTouch()进行处理，然后才分配给onTouchEvent()进行处理。  如果onTouch()对触摸事件进行了处理，并且返回true；那么，该触摸事件就不会分配在分配给onTouchEvent()进行处理了。只有当onTouch()没有处理，或者处理了但返回false时，才会分配给onTouchEvent()进行处理。</p>
<p>关于它们之间的内容，在讲解View的dispatchTouchEvent()时，会详细说明。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/08/android/os/binder/2014-09-08-Binder-Java/" itemprop="url">Android Binder机制(十二) Binder机制的Java调用流程</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-08T01:01:00.000Z" itemprop="datePublished">9月 8 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            23 分钟 read (About 3468 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面几篇文章，是基于Binder驱动和C/C++层对Binder机制进行了介绍。本文将从Java引用开始，逐步的分析Client是如何与Server进行交互的。本文的例子还是选取MediaPlayer。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">MediaPlayer的使用示例</a><br><strong>2</strong>. <a href="#anchor2">MediaPlayer示例分析</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-MediaPlayer的使用示例"><a href="#1-MediaPlayer的使用示例" class="headerlink" title="1. MediaPlayer的使用示例"></a>1. MediaPlayer的使用示例</h1><p>下面是一个调用MediaPlayer播放音乐(test.mp3)的示例代码。</p>
<pre><code>public class MainActivity extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.main);
        testMediaPlayer();
    }   

    private void testMediaPlayer() {
        try {
            MediaPlayer mp = new MediaPlayer();
            mp.setDataSource(&quot;/sdcard/test.mp3&quot;);
            mp.setAudioStreamType(AudioManager.STREAM_MUSIC);
            mp.prepare();
            mp.start();
        } catch (Exception e) {
            e.printStackTrace();
        }   
    }   
}</code></pre><p>说明：源码很简单，只需要关注testMediaPlayer()部分即可。首先，新建一个MediaPlayer对象。接着，设置数据源和音频流类型。最后，调用prepare()进行准备之后，再通过start()进行播放。</p>
<p>下面，我们就对该过程进行分析，看看该Binder机制是如何参与其中的。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-MediaPlayer示例分析"><a href="#2-MediaPlayer示例分析" class="headerlink" title="2. MediaPlayer示例分析"></a>2. MediaPlayer示例分析</h1><p>我们将MediaPlayer示例就看作一个MediaPlayer进程，接下来，就看看这个MediaPlayer进程是如何通过Binder机制来和MediaPlayerService通信的。重点需要关注的是mp.setDataSource()的实现。</p>
<p><a name="anchor2_1"></a></p>
<h2 id="2-1-MediaPlayer的构造函数"><a href="#2-1-MediaPlayer的构造函数" class="headerlink" title="2.1 MediaPlayer的构造函数"></a>2.1 MediaPlayer的构造函数</h2><p>先看看MediaPlayer的构造函数。</p>
<pre><code>public MediaPlayer() {

    ...
    native_setup(new WeakReference&lt;MediaPlayer&gt;(this));
}

private static native final void native_init();
private native final void native_setup(Object mediaplayer_this);</code></pre><p>说明：该代码在frameworks/base/media/java/android/media/MediaPlayer.java中。在MediaPlayer中，会调用本地方法native_setup()；而且在native_setup()之前，会调用静态方法native_init()进行初始化。下面就看看native_init()和native_setup()各自的代码。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-native-init-和native-setup-的注册信息"><a href="#2-2-native-init-和native-setup-的注册信息" class="headerlink" title="2.2 native_init()和native_setup()的注册信息"></a>2.2 native_init()和native_setup()的注册信息</h2><pre><code>static JNINativeMethod gMethods[] = {
    ...
    {&quot;_setDataSource&quot;,       &quot;(Ljava/io/FileDescriptor;JJ)V&quot;,    (void *)android_media_MediaPlayer_setDataSourceFD},
    ...
    {&quot;_start&quot;,              &quot;()V&quot;,                              (void *)android_media_MediaPlayer_start},
    ...
    {&quot;native_init&quot;,         &quot;()V&quot;,                              (void *)android_media_MediaPlayer_native_init},
    {&quot;native_setup&quot;,        &quot;(Ljava/lang/Object;)V&quot;,            (void *)android_media_MediaPlayer_native_setup},
    ...
};

static int register_android_media_MediaPlayer(JNIEnv *env)
{
    return AndroidRuntime::registerNativeMethods(env,
                &quot;android/media/MediaPlayer&quot;, gMethods, NELEM(gMethods));
}

jint JNI_OnLoad(JavaVM* vm, void* reserved)
{
    ...
    if (register_android_media_MediaPlayer(env) &lt; 0) {
        ...
    }
    ...
}</code></pre><p>说明：该代码在frameworks/base/media/jni/android_media_MediaPlayer.cpp中。gMethods是JNI本地方法的注册表；在Dalvik虚拟机启动之后，会调用JNI_OnLoad()；进而将上面的方法注册到系统中。<br>这里，我们只需要了解native_init()与android_media_MediaPlayer_native_init()对应，而native_setup()和android_media_MediaPlayer_native_setup()对应即可。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="2-3-native-init-的实现"><a href="#2-3-native-init-的实现" class="headerlink" title="2.3 native_init()的实现"></a>2.3 native_init()的实现</h2><p>由于native_init()与android_media_MediaPlayer_native_init()对应，下面就看看native_init()的实现。</p>
<pre><code>static void
android_media_MediaPlayer_native_init(JNIEnv *env)
{
    jclass clazz;

    clazz = env-&gt;FindClass(&quot;android/media/MediaPlayer&quot;);
    ..

    fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;, &quot;I&quot;);
    ...
}</code></pre><p>说明：该代码在frameworks/base/media/jni/android_media_MediaPlayer.cpp中。<br>env-&gt;FindClass(“android/media/MediaPlayer”)会加载Java层的MediaPlayer类；进而将fields.context初始化为MediaPlayer类中的mNativeContext成员。</p>
<p><a name="anchor2_4"></a></p>
<h2 id="2-4-native-setup-的实现"><a href="#2-4-native-setup-的实现" class="headerlink" title="2.4 native_setup()的实现"></a>2.4 native_setup()的实现</h2><p>由于native_setup()和android_media_MediaPlayer_native_setup()对应，下面就看看native_setup()的实现。</p>
<pre><code>static void
android_media_MediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this)
{
    sp&lt;MediaPlayer&gt; mp = new MediaPlayer();
    ...

    setMediaPlayer(env, thiz, mp);
}</code></pre><p>说明：该函数会新建一个MediaPlayer对象，然后调用setMediaPlayer()来保存该MediaPlayer对象。下面看看setMediaPlayer()是如何保存MediaPlayer对象的。</p>
<p><a name="anchor2_5"></a></p>
<h2 id="2-5-setMediaPlayer"><a href="#2-5-setMediaPlayer" class="headerlink" title="2.5 setMediaPlayer()"></a>2.5 setMediaPlayer()</h2><pre><code>static sp&lt;MediaPlayer&gt; setMediaPlayer(JNIEnv* env, jobject thiz, const sp&lt;MediaPlayer&gt;&amp; player)
{
    sp&lt;MediaPlayer&gt; old = (MediaPlayer*)env-&gt;GetIntField(thiz, fields.context);
    ...
    env-&gt;SetIntField(thiz, fields.context, (int)player.get());
    return old;
}</code></pre><p>说明：通过SetIntField()会将MediaPlayer对象保存到fields.context中。而在前面的，我们将fields.context初始化为MediaPlayer类(Java层)中的mNativeContext成员。这也就意味着，设置了Java层的MediaPlayer中的mNativeContext成员的值为C++层MediaPlayer对象。</p>
<br>
至此，就分析完了MediaPlayer的构造函数。下面继续看Java示例代码中的mp.setDataSource("/sdcard/test.mp3")。


<p><a name="anchor2_6"></a></p>
<h2 id="2-6-setDataSource"><a href="#2-6-setDataSource" class="headerlink" title="2.6 setDataSource()"></a>2.6 setDataSource()</h2><pre><code>public void setDataSource(String path)
        throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
    setDataSource(path, null, null);
}

private void setDataSource(String path, String[] keys, String[] values)
        throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {

    ...
    final File file = new File(path);
    if (file.exists()) {
        FileInputStream is = new FileInputStream(file);
        FileDescriptor fd = is.getFD();
        setDataSource(fd);
        is.close();
    } else {
        ...
    }
    ...
}

public void setDataSource(FileDescriptor fd)
        throws IOException, IllegalArgumentException, IllegalStateException {
    setDataSource(fd, 0, 0x7ffffffffffffffL);
}

public void setDataSource(FileDescriptor fd, long offset, long length)
        throws IOException, IllegalArgumentException, IllegalStateException {
    ...
    _setDataSource(fd, offset, length);
}

private native void _setDataSource(FileDescriptor fd, long offset, long length)
        throws IOException, IllegalArgumentException, IllegalStateException;</code></pre><p>说明：该代码在frameworks/base/media/java/android/media/MediaPlayer.java中。setDataSource()最终会调用到本地方法_setDataSource()。在前面的gMethods本地方法注册表中，将_setDataSource()和android_media_MediaPlayer_setDataSourceFD()匹配。下面，看看_setDataSource()的实现。</p>
<p><a name="anchor2_7"></a></p>
<h2 id="2-7-android-media-MediaPlayer-setDataSourceFD"><a href="#2-7-android-media-MediaPlayer-setDataSourceFD" class="headerlink" title="2.7 android_media_MediaPlayer_setDataSourceFD()"></a>2.7 android_media_MediaPlayer_setDataSourceFD()</h2><pre><code>static void
android_media_MediaPlayer_setDataSourceFD(JNIEnv *env, jobject thiz, jobject fileDescriptor, jlong offset, jlong length)
{
    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);
    ...

    int fd = jniGetFDFromFileDescriptor(env, fileDescriptor);
    ...
    process_media_player_call( env, thiz, mp-&gt;setDataSource(fd, offset, length), &quot;java/io/IOException&quot;, &quot;setDataSourceFD failed.&quot; );
}</code></pre><p>说明：该代码在frameworks/base/media/jni/android_media_MediaPlayer.cpp中。该函数会先通过getMediaPlayer()获取MediaPlayer对象，然后在执行mp-&gt;setDataSource()时会调用MediaPlayer的setDataSource()方法。</p>
<p><a name="anchor2_8"></a></p>
<h2 id="2-8-getMediaPlayer"><a href="#2-8-getMediaPlayer" class="headerlink" title="2.8 getMediaPlayer()"></a>2.8 getMediaPlayer()</h2><pre><code>static sp&lt;MediaPlayer&gt; getMediaPlayer(JNIEnv* env, jobject thiz)
{
    ...
    MediaPlayer* const p = (MediaPlayer*)env-&gt;GetIntField(thiz, fields.context);
    return sp&lt;MediaPlayer&gt;(p);
}</code></pre><p>说明：前面在native_setup()中，将fields.context设置为MediaPlayer对象。这里就是返回fields.context中保存的MediaPlayer对象。</p>
<p><a name="anchor2_9"></a></p>
<h2 id="2-9-MediaPlayer-setDataSource"><a href="#2-9-MediaPlayer-setDataSource" class="headerlink" title="2.9 MediaPlayer::setDataSource"></a>2.9 MediaPlayer::setDataSource</h2><pre><code>status_t MediaPlayer::setDataSource(
        const char *url, const KeyedVector&lt;String8, String8&gt; *headers)
{
    ...
    status_t err = BAD_VALUE;
    if (url != NULL) {
        // 通过getMediaPlayerService()的代理BpMediaPlayerService。
        const sp&lt;IMediaPlayerService&gt;&amp; service(getMediaPlayerService());
        if (service != 0) {
            // 通过BpMediaPlayerService创建一个IMediaPlayer客户端
            sp&lt;IMediaPlayer&gt; player(service-&gt;create(this, mAudioSessionId));
            ...
            // 保存player
            err = attachNewPlayer(player);
        }
    }
    return err;
}</code></pre><p>说明：该代码在frameworks/av/media/libmedia/mediaplayer.cpp中。<br>(01) 它会新建一个service对象，而service是通过getMediaPlayerService()获取到的。getMediaPlayerService()已经在”<a href="/2014/09/07/BinderCommunication-GetService01/">介绍getService请求</a>“时，详细分析过了。它会返回IMediaPlayerService的代理，即BpMediaPlayerService对象。<br>(02) 接着，会调用service-&gt;create()返回一个IMediaPlayer对象。下面看看这个MediaPlayer进程是如何通过BpMediaPlayerService这个远程代理来获取IMediaPlayer对象的。</p>
<p><a name="anchor2_10"></a></p>
<h2 id="2-10-BpMediaPlayerService-create"><a href="#2-10-BpMediaPlayerService-create" class="headerlink" title="2.10 BpMediaPlayerService::create()"></a>2.10 BpMediaPlayerService::create()</h2><pre><code>class BpMediaPlayerService: public BpInterface&lt;IMediaPlayerService&gt;
{
    ...
    virtual sp&lt;IMediaPlayer&gt; create(
            const sp&lt;IMediaPlayerClient&gt;&amp; client, int audioSessionId) {
        Parcel data, reply;
        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());
        data.writeStrongBinder(client-&gt;asBinder());
        data.writeInt32(audioSessionId);

        remote()-&gt;transact(CREATE, data, &amp;reply);
        return interface_cast&lt;IMediaPlayer&gt;(reply.readStrongBinder());
    }
    ...
}</code></pre><p>说明：该代码在frameworks/av/media/libmedia/IMediaPlayerService.cpp中。<br>这里无非是CREATE请求数据打包之后发送给Binder驱动，再由Binder驱动转发给MediaPlayerService进程。数据的发送和解析，在前面介绍”addService”和”getService”时已经多次介绍过了；这里就不再展开说明了。</p>
<p>Binder驱动在收到MediaPlayer的数据之后，会将添加一个事务到MediaPlayerService的待处理事务列表中，然后唤醒MediaPlayerService。下面就从MediaPlayerService被唤醒之后开始说明。</p>
<p><a name="anchor2_11"></a></p>
<h2 id="2-11-Binder驱动中binder-thread-read-的源码"><a href="#2-11-Binder驱动中binder-thread-read-的源码" class="headerlink" title="2.11 Binder驱动中binder_thread_read()的源码"></a>2.11 Binder驱动中binder_thread_read()的源码</h2><p>又回到了熟悉的binder_thread_read()中。</p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是目标节点。
        // 这里，MediaPlayer的CREATE请求的目标是MediaPlayerService，因此target_node是MediaPlayerService对应的节点；
        if (t-&gt;buffer-&gt;target_node) {
            // 事务目标对应的Binder实体(即，MediaPlayerService对应的Binder实体)
            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;
            // Binder实体在用户空间的地址。
            // MediaPlayerService的ptr为本地Binder的弱引用，即BBinder的弱引用
            tr.target.ptr = target_node-&gt;ptr;
            // Binder实体在用户空间的其它数据
            // MediaPlayerService的cookie为本地Binder本身，即BBinder对象
            tr.cookie =  target_node-&gt;cookie;
            t-&gt;saved_priority = task_nice(current);
            if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;
                !(t-&gt;flags &amp; TF_ONE_WAY))
                binder_set_nice(t-&gt;priority);
            else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||
                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)
                binder_set_nice(target_node-&gt;min_priority);
            cmd = BR_TRANSACTION;
        } else {
            ...
        }
        // 交易码，即CREATE
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            tr.sender_pid = 0;
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd(即BR_TRANSACTION)指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        // 设置回复信息
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            t-&gt;to_parent = thread-&gt;transaction_stack;
            t-&gt;to_thread = thread;
            thread-&gt;transaction_stack = t;
        } else {
            ...
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：MediaPlayerService被唤醒之后，binder_has_thread_work()为true。因为MediaPlayerService的待处理事务队列中有个待处理事务(即，MediaPlayer添加的CREATE请求)。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让MediaPlayerService读取后进行处理。  </p>
<p>这里，共添加了两个指令到bwr.read_consumed中：BR_NOOP和BR_TRANSACTION。其中，BR_TRANSACTION指令对应的数据中包含了CREATE请求的数据。</p>
<p>接下来，binder_thread_read()返回到binder_ioctl()中；binder_ioctl()将数据拷贝到用户空间之后，便返回到用户空间继续执行。<br>而在<a href="/2014/09/06/BinderCommunication-ThreadPool/">Android Binder机制(八) MediaPlayerService服务的消息循环</a>中介绍过，MediaPlayerService是通过调用IPCThreadState::joinThreadPool()进入消息循环的，而joinThreadPool()又会通过getAndExecuteCommand()调用到talkWithDriver()来和Binder驱动交互的。因此，Binder驱动返回到用户空间之后，会进入talkWithDriver()。</p>
<p><a name="anchor2_12"></a></p>
<h2 id="2-12-IPCThreadState-talkWithDriver"><a href="#2-12-IPCThreadState-talkWithDriver" class="headerlink" title="2.12 IPCThreadState::talkWithDriver()"></a>2.12 IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：ioctl()返回之后，talkWithDriver()会清除已经发送的数据。然后，便返回到getAndExecuteCommand()中。</p>
<p><a name="anchor2_13"></a></p>
<h2 id="13-IPCThreadState-getAndExecuteCommand"><a href="#13-IPCThreadState-getAndExecuteCommand" class="headerlink" title="13. IPCThreadState::getAndExecuteCommand()"></a>13. IPCThreadState::getAndExecuteCommand()</h2><pre><code>status_t IPCThreadState::getAndExecuteCommand()
{
    status_t result;
    int32_t cmd;

    // 和Binder驱动交互
    result = talkWithDriver();
    if (result &gt;= NO_ERROR) {
        ...
        // 读取mIn中的数据
        cmd = mIn.readInt32();
        ...

        // 调用executeCommand()对数据进行处理。
        result = executeCommand(cmd);
        ...
    }

    return result;
}</code></pre><p>说明：getAndExecuteCommand()会取出Binder反馈的指令，然后再调用executeCommand()根据指令进行解析。前面说过，Binder驱动共反馈了BR_NOOP和BR_TRANSACTION两个指令。而BR_NOOP指令什么也不会做。因此，我们直接分析BR_TRANSACTION指令。</p>
<p><a name="anchor2_14"></a></p>
<h2 id="14-IPCThreadState-executeCommand"><a href="#14-IPCThreadState-executeCommand" class="headerlink" title="14. IPCThreadState::executeCommand()"></a>14. IPCThreadState::executeCommand()</h2><pre><code>status_t IPCThreadState::executeCommand(int32_t cmd) 
{
    BBinder* obj; 
    RefBase::weakref_type* refs;
    status_t result = NO_ERROR;

    switch (cmd) {
        ...
        case BR_TRANSACTION:
        {
            binder_transaction_data tr;
            result = mIn.read(&amp;tr, sizeof(tr));
            ...

            Parcel buffer;
            buffer.ipcSetDataReference(
                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                tr.data_size,
                reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(size_t), freeBuffer, this);

            ...

            Parcel reply;
            ...
            if (tr.target.ptr) {
                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);
                const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
                if (error &lt; NO_ERROR) reply.setError(error);

            } else {
                ...
            }

            if ((tr.flags &amp; TF_ONE_WAY) == 0) {
                sendReply(reply, 0);
            } else {
                ...
            }
            ...

        }
        break;

        ...
    }

    ...
    return result;
}</code></pre><p>说明：进入BR_TRANSACTION分支后，首先通过mIn.read()读取事务数据。接着，调用ipcSetDataReference()将事务数据解析出来。很显然，tr.target.ptr不为空，它的值是”MediaPlayerService的BBinder的弱引用”。然后，就将tr.cookie转换为BBinder*对象b；而b实际上是MediaPlayerService的本地Binder实例，即BnMediaPlayerService的实例。最终，通过b-&gt;transact()进行事务处理。</p>
<p>下面看看BBinder的transact()代码。</p>
<pre><code>status_t BBinder::transact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    data.setDataPosition(0);

    status_t err = NO_ERROR;
    switch (code) {
        case PING_TRANSACTION:
            reply-&gt;writeInt32(pingBinder());
            break;
        default:
            err = onTransact(code, data, reply, flags);
            break;
    }

    if (reply != NULL) {
        reply-&gt;setDataPosition(0);
    }

    return err;
}</code></pre><p>该代码在frameworks/native/libs/binder/Binder.cpp中。此时的code是CREATE，因此，它会调用onTransact()对事务进行处理。而BnMediaPlayerService重写了onTransact()方法；因此会调用到BnMediaPlayerService的onTransact()方法。在Binder机制中也是根据这种方式来实现不同Server的对各自的的请求进行区分处理的：Server的本地Binder实现类，通过覆盖onTransact()方法来处理事务。</p>
<p>下面看看BnMediaPlayerService的onTransact()方法。</p>
<p><a name="anchor2_15"></a></p>
<h2 id="15-BnMediaPlayerService-onTransact"><a href="#15-BnMediaPlayerService-onTransact" class="headerlink" title="15. BnMediaPlayerService::onTransact()"></a>15. BnMediaPlayerService::onTransact()</h2><pre><code>status_t BnMediaPlayerService::onTransact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    switch (code) {
        case CREATE: {
            ...
            sp&lt;IMediaPlayerClient&gt; client =
                interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder());
            int audioSessionId = data.readInt32();
            sp&lt;IMediaPlayer&gt; player = create(client, audioSessionId);
            reply-&gt;writeStrongBinder(player-&gt;asBinder());
            return NO_ERROR;
        } break;
        ...
    }
    ...
}</code></pre><p>说明：该代码在frameworks/av/media/libmedia/IMediaPlayerService.cpp中。<br>(01) 先通过interface_cast宏获取IMediaPlayerClient对象，该对象是BpMediaPlayerClient实例。BpMediaPlayerClient定义在frameworks/av/media/libmedia/IMediaPlayer.cpp中。<br>(02) 接着，通过create()创建IMediaPlayerService对象。该create()的实现是在BnMediaPlayerService的子类MediaPlayerService.cpp中，即在frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp中实现。在create()中会新建一个Client，并返回。<br>(03) 最后，将这个Client通过Binder返回给MediaPlayer。</p>
<p>后面的流程就不再多说了。本文的核心是Binder机制，而不是MediaPlayer的框架，让我们了解MediaPlayer进程是如何与MediaPlayerService交互即可！而目前，通过CREATE请求，我们已经知道了MediaPlayer是如何和MediaPlayerService进行事务交互的。后面的内容更多的涉及到MediaPlayerService的框架，它不是本章的重点；感兴趣的读者可以自行研究。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/07/android/os/binder/2014-09-07-BinderCommunication-GetService03/" itemprop="url">Android Binder机制(十一) getService详解03之 请求的反馈</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-07T01:03:00.000Z" itemprop="datePublished">9月 7 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 read (About 2012 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面两篇文章分别介绍了getService中”请求的发送”和”请求的处理”这两部分，本文将介绍getService请求的最后一部分–请求的反馈。下面就说说MediaPlayer收到请求反馈之后的处理流程。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder驱动中binder-thread-read-的源码"><a href="#1-Binder驱动中binder-thread-read-的源码" class="headerlink" title="1. Binder驱动中binder_thread_read()的源码"></a>1. Binder驱动中binder_thread_read()的源码</h1><p>从MediaPlayer开始唤醒开始说起。</p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是目标节点。
        // 这里，MediaPlayer的getService请求的目标是Service Manager，因此target_node是Service Manager对应的节点；
        if (t-&gt;buffer-&gt;target_node) {
            ...
        } else {
            tr.target.ptr = NULL;
            tr.cookie = NULL;
            cmd = BR_REPLY;
        }
        // 交易码
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            ...
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            ...
        } else {
            t-&gt;buffer-&gt;transaction = NULL;
            kfree(t);
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：MediaPlayer进程被唤醒之后，binder_has_thread_work()为true，因为MediaPlayer进程中有个BINDER_WORK_TRANSACTION类型的待处理事务。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction<em>类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让MediaPlayer读取后进行处理。此时的指令为BR_REPLY！<br>(03) 最后，更新</em>consumed的值，即更新bwr.read_consumed的值。</p>
<p>binder_thread_read()执行完毕之后，共反馈了两个指令到用户空间：BR_NOOP和BR_REPLY。</p>
<p>之后的流程应该都比较熟悉了，首先返回到binder_ioctl()中，接着将ServiceManager反馈的数据拷贝到用户空间。接下来的工作就交给MediaPlayer进程进行处理了。<br>从Binder驱动返回后，首先回到talkWithDriver()中，接着便返回到waitForResponse()中。在waitForResponse()会反馈数据进行解析。  </p>
<p><a name="anchor2"></a></p>
<h1 id="2-IPCThreadState-waitForResponse"><a href="#2-IPCThreadState-waitForResponse" class="headerlink" title="2. IPCThreadState::waitForResponse"></a>2. IPCThreadState::waitForResponse</h1><pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) {
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        ...

        cmd = mIn.readInt32();

        switch (cmd) {
            ...
        case BR_REPLY:
            {
                binder_transaction_data tr;
                err = mIn.read(&amp;tr, sizeof(tr));
                ...

                if (reply) {
                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                        reply-&gt;ipcSetDataReference(
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t),
                            freeBuffer, this);
                    } else {
                        ...
                    }
                } else {
                    ...
                }
            }
            goto finish;
            ...
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：在BR_REPLY分支中，先读取出数据，并保存到tr中。由于reply不为null，并且tr.flags &amp; TF_STATUS_CODE为0；因此，会执行reply-&gt;ipcSetDataReference()。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-Parcel-ipcSetDataReference"><a href="#3-Parcel-ipcSetDataReference" class="headerlink" title="3. Parcel::ipcSetDataReference"></a>3. Parcel::ipcSetDataReference</h1><pre><code>void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,
    const size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)     
{
    freeDataNoInit();                   
    mError = NO_ERROR;
    mData = const_cast&lt;uint8_t*&gt;(data); 
    mDataSize = mDataCapacity = dataSize;
    mDataPos = 0;
    mObjects = const_cast&lt;size_t*&gt;(objects);
    mObjectsSize = mObjectsCapacity = objectsCount;
    mNextObjectHint = 0;
    mOwner = relFunc;
    mOwnerCookie = relCookie;           
    scanForFds();
}</code></pre><p>说明： data就是ServiceManager返回来的数据。数据中包含一个flat_binder_object对象(对应ServiceManager中的binder_object)，因此objectsCount则为1。先通过freeDataNoInit()将原始的数据清空，然后再给mData和mObjects赋值，这样就将数据保存到了Parcel中。<br>为什么objectsCount的值是1呢？请返回查看一下Service Manager在执行binder_send_reply()即可知，这里就不再多说。</p>
<p>waitForResponse()执行完BR_REPLY之后，便返回到IPCThreadState::transact()中；然后层层返回，直到退回到checkService()。  </p>
<p><a name="anchor4"></a></p>
<h1 id="4-BpServiceManager-checkService"><a href="#4-BpServiceManager-checkService" class="headerlink" title="4. BpServiceManager::checkService()"></a>4. BpServiceManager::checkService()</h1><pre><code>virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const
{
    Parcel data, reply;             
    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());               
    data.writeString16(name);       
    remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);
    return reply.readStrongBinder();
}     </code></pre><p>说明：到目前为止，通过transact()来获取MediaPlayerService的事务已经执行完毕！MediaPlayerService的接入点已经保存在replay中。接下来的工作就是调用reply.readStrongBinder()来从replay中解析出所需要的数据，即MediaPlayerService在Biner驱动中的Binder引用描述，也就是C++层的句柄。</p>
<p><a name="anchor5"></a></p>
<h1 id="5-Parcel-readStrongBinder"><a href="#5-Parcel-readStrongBinder" class="headerlink" title="5. Parcel::readStrongBinder"></a>5. Parcel::readStrongBinder</h1><pre><code>sp&lt;IBinder&gt; Parcel::readStrongBinder() const
{
    sp&lt;IBinder&gt; val; 
    unflatten_binder(ProcessState::self(), *this, &amp;val);
    return val; 
}</code></pre><p>说明：readStrongBinder()会调用unflatten_binder()来解析Parcel中的数据。</p>
<p><a name="anchor6"></a></p>
<h1 id="6-Parcel-unflatten-binder"><a href="#6-Parcel-unflatten-binder" class="headerlink" title="6. Parcel::unflatten_binder"></a>6. Parcel::unflatten_binder</h1><pre><code>status_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc,
    const Parcel&amp; in, sp&lt;IBinder&gt;* out)
{
    const flat_binder_object* flat = in.readObject(false);

    if (flat) {
        switch (flat-&gt;type) {
            case BINDER_TYPE_BINDER:
                ...
            case BINDER_TYPE_HANDLE:
                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);
                return finish_unflatten_binder(
                    static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);
        }        
    }
    return BAD_TYPE;
}</code></pre><p>说明：readObject()的作用是从Parcel中读取出它所保存的flat_binder_object类型的对象。该对象的类型是BINDER_TYPE_HANDLE，因此会指向BINDER_TYPE_HANDLE对应的switch分支。<br>(01) 这里的proc是ProcessState对象，执行proc-&gt;getStrongProxyForHandle()会将句柄(MediaPlayerService的Binder引用描述)保存到ProcessState的链表中，然后再创建并返回该句柄的BpBinder对象(即Binder的代理)。在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中有getStrongProxyForHandle()的详细说明，下面只给出getStrongProxyForHandle()代码。<br>(02) finish_unflatten_binder()中只有return NO_ERROR。</p>
<pre><code>sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp&lt;IBinder&gt; result;

    AutoMutex _l(mLock);

    // 在矢量数组中查找&quot;句柄值为handle的handle_entry对象&quot;；
    // 找到的话，则直接返回；找不到的话，则新建handle对应的handle_entry。
    handle_entry* e = lookupHandleLocked(handle);

    if (e != NULL) {
        IBinder* b = e-&gt;binder;
        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
            // 当handle==0(即是Service Manager的句柄)时，尝试去ping Binder驱动。
            if (handle == 0) {
                Parcel data;
                status_t status = IPCThreadState::self()-&gt;transact(
                        0, IBinder::PING_TRANSACTION, data, NULL, 0);
                if (status == DEAD_OBJECT)
                   return NULL;
            }

            // 新建BpBinder代理
            b = new BpBinder(handle);
            e-&gt;binder = b;
            if (b) e-&gt;refs = b-&gt;getWeakRefs();
            result = b;
        } else {
            ...
        }
    }

    return result;
}</code></pre><p>这样，getService()的内容就全部执行完毕。getService()的返回结果IBinder=BpBinder对象，该对象包含了”MediaPlayerService(在Binder驱动)中的Binder引用的描述”，该描述在C++层而言就是个整型句柄。之后，若MediaPlayer要向MediaPlayerService发送请求，就根据该IBinder对象和”MediaPlayerService”进行通信。</p>
<p>上面只是执行完了getService()，它返回了IBinder对象。但是，getMediaPlayerService()并没有执行完毕。下面继续回到getMediaPlayerService()中。</p>
<p><a name="anchor7"></a></p>
<h1 id="7-IMediaDeathNotifier-getMediaPlayerService"><a href="#7-IMediaDeathNotifier-getMediaPlayerService" class="headerlink" title="7. IMediaDeathNotifier::getMediaPlayerService()"></a>7. IMediaDeathNotifier::getMediaPlayerService()</h1><pre><code>const sp&lt;IMediaPlayerService&gt;&amp; IMediaDeathNotifier::getMediaPlayerService()
{
    ...
    if (sMediaPlayerService == 0) {
        sp&lt;IServiceManager&gt; sm = defaultServiceManager();
        sp&lt;IBinder&gt; binder;             
        do {
            binder = sm-&gt;getService(String16(&quot;media.player&quot;));
            ...
            usleep(500000); // 0.5 s    
        } while (true);                 

        ...
        sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);
    }     
    ...
    return sMediaPlayerService;         
}</code></pre><p>说明：在成功获取MediaPlayerService对应的IBinder对象(binder)之后，可以通过interface_cast<imediaplayerservice>(binder)获取它的代理。<br>是不是对interface_cast()很熟悉！不错，在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中就是通过该宏获取IServiceManager的代理的。</imediaplayerservice></p>
<p><a name="anchor8"></a></p>
<h1 id="8-IMediaDeathNotifier-getMediaPlayerService"><a href="#8-IMediaDeathNotifier-getMediaPlayerService" class="headerlink" title="8. IMediaDeathNotifier::getMediaPlayerService()"></a>8. IMediaDeathNotifier::getMediaPlayerService()</h1><pre><code>template&lt;typename INTERFACE&gt;
inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)
{
    return INTERFACE::asInterface(obj);
}   </code></pre><p>下面直接给出IMediaPlayerService::asInterface()的代码。</p>
<pre><code>android::sp&lt;IMediaPlayerService&gt; IMediaPlayerService::asInterface(
        const android::sp&lt;android::IBinder&gt;&amp; obj)
{
    android::sp&lt;IMediaPlayerService&gt; intr;
    if (obj != NULL) {
        intr = static_cast&lt;IMediaPlayerService*&gt;(
            obj-&gt;queryLocalInterface(
                    IMediaPlayerService::descriptor).get());
        if (intr == NULL) {
            intr = new BpServiceManager(obj);
        }
    }
    return intr;
}</code></pre><p>说明：asInterface()会调用new BpMediaPlayerService()新建BpServiceManager对象，并返回给对象。</p>
<p>这样，MediaPlayer进程的getService请求就全部介绍完毕了。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/07/android/os/binder/2014-09-07-BinderCommunication-GetService02/" itemprop="url">Android Binder机制(十) getService详解02之 请求的处理</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-07T01:02:00.000Z" itemprop="datePublished">9月 7 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            28 分钟 read (About 4128 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面介绍了getService请求的发送部分，本文接着介绍请求的处理部分。下面看看ServiceManager被唤醒之后，是如何处理getService请求的</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder驱动中binder-thread-read-的源码"><a href="#1-Binder驱动中binder-thread-read-的源码" class="headerlink" title="1. Binder驱动中binder_thread_read()的源码"></a>1. Binder驱动中binder_thread_read()的源码</h1><p>前面说到，MediaPlayer线程在执行binder_transaction()时，会将一个待处理事务添加到”ServiceManager的待处理事务队列”中；然后，再将ServiceManager进程唤醒。<br>下面，我们就接着看看ServiceManager被唤醒之后做了些什么。</p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是目标节点。
        // 这里，MediaPlayer的getService请求的目标是ServiceManager，因此target_node是Service Manager对应的节点；
        if (t-&gt;buffer-&gt;target_node) {
            // 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体)
            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;
            // Binder实体在用户空间的地址(ServiceManager的ptr为NULL)
            tr.target.ptr = target_node-&gt;ptr;
            // Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL)
            tr.cookie =  target_node-&gt;cookie;
            t-&gt;saved_priority = task_nice(current);
            if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;
                !(t-&gt;flags &amp; TF_ONE_WAY))
                binder_set_nice(t-&gt;priority);
            else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||
                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)
                binder_set_nice(target_node-&gt;min_priority);
            cmd = BR_TRANSACTION;
        } else {
            ...
        }
        // 交易码
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            ...
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            // 将事务t添加到当前线程的事务栈transaction_stack中。
            // 这是因为，Binder驱动需要等待Service Manager的反馈。
            t-&gt;to_parent = thread-&gt;transaction_stack;
            t-&gt;to_thread = thread;
            thread-&gt;transaction_stack = t;
        } else {
            ...
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：ServiceManager进程被唤醒之后，binder_has_thread_work()为true，因为ServiceManager中有个待处理事务(即，MediaPlayer的getService求)。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction<em>类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。此时的指令为BR_TRANSACTION！<br>(03) 最后，更新</em>consumed的值，即更新bwr.read_consumed的值。</p>
<p>然后，binder_thread_read()会返回到binder_ioctl()中。binder_ioctl()在将数据bwr拷贝到用户空间之后会返回。这样，就又回到了ServiceManager守护进程中。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-binder-loop"><a href="#2-binder-loop" class="headerlink" title="2. binder_loop"></a>2. binder_loop</h1><pre><code>void binder_loop(struct binder_state *bs, binder_handler func)
{
    ..

    for (;;) {
        ...
        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);

        ...
        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);
        ...
    }
}   </code></pre><p>说明：该代码在frameworks/native/cmds/servicemanager/binder.c中。Binder驱动共反馈了BR_NOOP和BR_TRANSACTION两个指令给Service Manager守护进程。BR_NOOP什么实质性的工作也不会做，我们直接分析BR_TRANSACTION的处理情况。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-binder-parse"><a href="#3-binder-parse" class="headerlink" title="3. binder_parse"></a>3. binder_parse</h1><pre><code>int binder_parse(struct binder_state *bs, struct binder_io *bio,
                 uint32_t *ptr, uint32_t size, binder_handler func)
{
    int r = 1;
    uint32_t *end = ptr + (size / 4);

    while (ptr &lt; end) {
        uint32_t cmd = *ptr++;

        switch(cmd) {
        case BR_NOOP:
            break;
        ...
        case BR_TRANSACTION: {
            struct binder_txn *txn = (void *) ptr;
            ...
            if (func) {
                unsigned rdata[256/4];
                struct binder_io msg;   // 用于保存&quot;Binder驱动反馈的信息&quot;
                struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot;
                int res;

                // 初始化reply
                bio_init(&amp;reply, rdata, sizeof(rdata), 4);
                // 根据txt(Binder驱动反馈的信息)初始化msg
                bio_init_from_txn(&amp;msg, txn);
                // 消息处理
                res = func(bs, txn, &amp;msg, &amp;reply);
                // 反馈消息给Binder驱动。
                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);
            }
            ptr += sizeof(*txn) / sizeof(uint32_t);
            break;
        }
        ...
        }
    }

    return r;
}</code></pre><p>说明：这里只关注BR_TRANSACTION分支。 首先，用bio_init()初始化reply。然后通过bio_init_from_txn()初始化msg。接着，是通过func函数指针对数据进行处理，func指向svcmgr_handler。处理完毕，再通过binder_send_reply()填写反馈信息给Binder驱动。<br>这里的大部分内容在<a href="/2014/09/05/BinderCommunication-AddService02/">Android Binder机制(六) addService详解02之 请求的处理</a>中都介绍过，这里重点关注svcmgr_handler()处理getService请求的流程。</p>
<p><a name="anchor4"></a></p>
<h1 id="4-svcmgr-handler"><a href="#4-svcmgr-handler" class="headerlink" title="4. svcmgr_handler"></a>4. svcmgr_handler</h1><pre><code>int svcmgr_handler(struct binder_state *bs,
                   struct binder_txn *txn,
                   struct binder_io *msg,
                   struct binder_io *reply)
{
    ...
    // 数据有效性检测(数据头)
    strict_policy = bio_get_uint32(msg);
    s = bio_get_string16(msg, &amp;len);
    if ((len != (sizeof(svcmgr_id) / 2)) ||
        memcmp(svcmgr_id, s, sizeof(svcmgr_id))) {
        ...
    }

    switch(txn-&gt;code) {
        case SVC_MGR_GET_SERVICE:
        case SVC_MGR_CHECK_SERVICE:
            s = bio_get_string16(msg, &amp;len);
            ptr = do_find_service(bs, s, len, txn-&gt;sender_euid);
            if (!ptr)
                break;
            bio_put_ref(reply, ptr);
            return 0;
        ...
    }

    bio_put_uint32(reply, 0);
    return 0;
}</code></pre><p>说明：该代码在frameworks/native/cmds/servicemanager/service_manager.c中。svcmgr_handler()首先读取出getService请求的消息头，进行有效性检测。然后，取出请求的编码；这里请求编码对应是SVC_MGR_CHECK_SERVICE。接着，便进入对应的switch分支。<br>(01) 通过bio_get_string16()获取请求的IBinder对象的名称，即s=”media.player”。<br>(02) 然后，通过do_find_service()查找名称为s的IBinder对象。  </p>
<p><a name="anchor5"></a></p>
<h1 id="5-do-find-service"><a href="#5-do-find-service" class="headerlink" title="5. do_find_service"></a>5. do_find_service</h1><pre><code>void *do_find_service(struct binder_state *bs, uint16_t *s, unsigned len, unsigned uid)
{
    struct svcinfo *si;
    si = find_svc(s, len);

    if (si &amp;&amp; si-&gt;ptr) {
        ...
        return si-&gt;ptr;
    } else {
        return 0;
    }
}

struct svcinfo *find_svc(uint16_t *s16, unsigned len)
{
    struct svcinfo *si;

    for (si = svclist; si; si = si-&gt;next) {
        if ((len == si-&gt;len) &amp;&amp;
            !memcmp(s16, si-&gt;name, len * sizeof(uint16_t))) {
            return si;
        }
    }
    return 0;
}</code></pre><p>说明：<br>(01) do_find_service()会调用find_svc()进行查找。在find_svc()中，会在svclist链表中查找是否有名称等于”media.player”的svcinfo对象。很显然，在<a href="/2014/09/05/BinderCommunication-AddService02/">Android Binder机制(六) addService详解02之 请求的处理</a>中，已经将MediaPlayerService注册到svclist中，而MediaPlayerService的名称就是”media.player”。<br>(02) find_svc()找到svcinfo对象后返回到do_find_service()中。此时，if (si &amp;&amp; si-&gt;ptr)为true，返回si-&gt;ptr。这里的si-&gt;ptr就是MediaPlayerService在Binder驱动中的Binder引用的描述。根据该引用描述，就能找到对应的MediaPlayerService对象。</p>
<p>随后，在成功获取Binder引用的描述之后，svcmgr_handler()会调用bio_put_ref()将该引用信息写入到binder_object中。</p>
<p><a name="anchor6"></a></p>
<h1 id="6-bio-put-ref"><a href="#6-bio-put-ref" class="headerlink" title="6. bio_put_ref()"></a>6. bio_put_ref()</h1><pre><code>void bio_put_ref(struct binder_io *bio, void *ptr)
{
    struct binder_object *obj;

    if (ptr) 
        obj = bio_alloc_obj(bio);
    else
        obj = bio_alloc(bio, sizeof(*obj));

    if (!obj)
        return;

    obj-&gt;flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
    // 类型
    obj-&gt;type = BINDER_TYPE_HANDLE;
    // 句柄地址
    obj-&gt;pointer = ptr;
    obj-&gt;cookie = 0;
}</code></pre><p>说明：bio_put_ref()会将获取到的Binder引用描述打包到结构体binder_object中。而binder_object是与flat_binder_object对应的结构体，Binder驱动在收到个数据之后，就能对flat_binder_object进行解析处理。</p>
<p>在bio_put_ref()将数据打包到reply中之后，svcmgr_handle会调用binder_send_reply()将数据和指令整合到一起。</p>
<p><a name="anchor7"></a></p>
<h1 id="7-binder-send-reply"><a href="#7-binder-send-reply" class="headerlink" title="7. binder_send_reply()"></a>7. binder_send_reply()</h1><pre><code>void binder_send_reply(struct binder_state *bs,
                       struct binder_io *reply,
                       void *buffer_to_free,
                       int status)
{
    struct {
        uint32_t cmd_free;
        void *buffer;
        uint32_t cmd_reply;
        struct binder_txn txn;
    } __attribute__((packed)) data;

    data.cmd_free = BC_FREE_BUFFER;
    data.buffer = buffer_to_free;
    data.cmd_reply = BC_REPLY;
    data.txn.target = 0;
    data.txn.cookie = 0;
    data.txn.code = 0;
    if (status) {
        ...
    } else {
        data.txn.flags = 0;
        data.txn.data_size = reply-&gt;data - reply-&gt;data0;
        data.txn.offs_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0);
        data.txn.data = reply-&gt;data0;
        data.txn.offs = reply-&gt;offs0;
    }
    binder_write(bs, &amp;data, sizeof(data));
}</code></pre><p>说明：binder_send_reply()在<a href="/2014/09/05/BinderCommunication-AddService02/">Android Binder机制(六) addService详解02之 请求的处理</a>中已经介绍过。它共打包了两个指令：BC_FREE_BUFFER和BC_REPLY。在函数最后，它调用binder_write()和Binder驱动交互。</p>
<p><a name="anchor8"></a></p>
<h1 id="8-binder-write"><a href="#8-binder-write" class="headerlink" title="8. binder_write()"></a>8. binder_write()</h1><pre><code>int binder_write(struct binder_state *bs, void *data, unsigned len)
{
    struct binder_write_read bwr;
    int res;
    bwr.write_size = len;
    bwr.write_consumed = 0;
    bwr.write_buffer = (unsigned) data;
    bwr.read_size = 0;
    bwr.read_consumed = 0;
    bwr.read_buffer = 0;
    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
    if (res &lt; 0) {
        fprintf(stderr,&quot;binder_write: ioctl failed (%s)\n&quot;,
                strerror(errno));
    }
    return res;
}</code></pre><p>说明：binder_write()会将数据封装到binder_write_read的变量bwr中；其中，bwr.read_size=0，而bwr.write_size&gt;0。接着，便通过ioctl(,BINDER_WRITE_READ,)和Binder驱动交互，将数据反馈给Binder驱动。</p>
<p>再次回到Binder驱动的binder_ioctl()对应的BINDER_WRITE_READ分支中。此时，由于bwr.read_size=0，而bwr.write_size&gt;0；因此，Binder驱动只调用binder_thread_write进行写操作，而不会进行读。</p>
<p><a name="anchor9"></a></p>
<h1 id="9-Binder驱动中binder-thread-write-的源码"><a href="#9-Binder驱动中binder-thread-write-的源码" class="headerlink" title="9. Binder驱动中binder_thread_write()的源码"></a>9. Binder驱动中binder_thread_write()的源码</h1><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
        case BC_FREE_BUFFER: 
        ...
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p>说明：binder_thread_write()会逐个读出”Service Manager反馈的指令”。<br>(01) 第一个指令是BC_FREE_BUFFER。binder_thread_write()进入BC_FREE_BUFFER对应的分支后后，执行的动作主要是释放”保存MediaPlayer请求数据的缓冲”。<br>(02) 第二个指令是BC_REPLY。binder_thread_write()进入BC_REPLY之后，会将数据拷贝到内核空间，然后调用binder_transaction()进行处理</p>
<p><a name="anchor10"></a></p>
<h1 id="10-Binder驱动中binder-transaction-的源码"><a href="#10-Binder驱动中binder-transaction-的源码" class="headerlink" title="10. Binder驱动中binder_transaction()的源码"></a>10. Binder驱动中binder_transaction()的源码</h1><pre><code>static void binder_transaction(struct binder_proc *proc,
                   struct binder_thread *thread,
                   struct binder_transaction_data *tr, int reply)
{
    struct binder_transaction *t;
    struct binder_work *tcomplete;
    size_t *offp, *off_end;
    struct binder_proc *target_proc;
    struct binder_thread *target_thread = NULL;
    struct binder_node *target_node = NULL;
    struct list_head *target_list;
    wait_queue_head_t *target_wait;
    struct binder_transaction *in_reply_to = NULL;
    struct binder_transaction_log_entry *e;
    uint32_t return_error;

    ...

    if (reply) {
        // 事务栈
        in_reply_to = thread-&gt;transaction_stack;
        ...
        // 设置优先级
        binder_set_nice(in_reply_to-&gt;saved_priority);
        ...
        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;
        // 发起请求的线程，即MediaPlayer所在线程。
        // from的值，是MediaPlayer发起请求时在binder_transaction()中赋值的。
        target_thread = in_reply_to-&gt;from;
        ...
        // MediaPlayer对应的进程
        target_proc = target_thread-&gt;proc;
    } else {
        ...
    }
    if (target_thread) {
        e-&gt;to_thread = target_thread-&gt;pid;
        target_list = &amp;target_thread-&gt;todo;
        target_wait = &amp;target_thread-&gt;wait;
    } else {
        ...
    }
    e-&gt;to_proc = target_proc-&gt;pid;

    // 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
    t = kzalloc(sizeof(*t), GFP_KERNEL);
    if (t == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_alloc_t_failed;
    }

    // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
    if (tcomplete == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_alloc_tcomplete_failed;
    }
    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);

    t-&gt;debug_id = ++binder_last_id;
    e-&gt;debug_id = t-&gt;debug_id;

    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
        t-&gt;from = thread;
    else
        t-&gt;from = NULL;
    // 下面的一些赋值是初始化事务t
    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
    // 事务将交给target_proc进程进行处理
    t-&gt;to_proc = target_proc;
    // 事务将交给target_thread线程进行处理
    t-&gt;to_thread = target_thread;
    // 事务编码
    t-&gt;code = tr-&gt;code;
    // 事务标志
    t-&gt;flags = tr-&gt;flags;
    // 事务优先级
    t-&gt;priority = task_nice(current);

    // 分配空间
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    if (t-&gt;buffer == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_binder_alloc_buf_failed;
    }
    t-&gt;buffer-&gt;allow_user_free = 0;
    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
    // 保存事务
    t-&gt;buffer-&gt;transaction = t;
    // target_node为NULL
    t-&gt;buffer-&gt;target_node = target_node;
    trace_binder_transaction_alloc_buf(t-&gt;buffer);
    if (target_node)
        binder_inc_node(target_node, 1, 0, NULL);

    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));

    // 将&quot;用户传入的数据&quot;保存到事务中
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户传入的数据偏移地址&quot;保存到事务中
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }

    ...
    off_end = (void *)offp + tr-&gt;offsets_size;
    // 将flat_binder_object对象读取出来，
    // 这里就是Service Manager中反馈的MediaPlayerService对象。
    for (; offp &lt; off_end; offp++) {
        struct flat_binder_object *fp;
        ...
        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);

        switch (fp-&gt;type) {
            ...
            case BINDER_TYPE_HANDLE:
            case BINDER_TYPE_WEAK_HANDLE: {
                // 根据handle获取对应的Binder引用，即得到MediaPlayerService的Binder引用
                struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);
                if (ref == NULL) {
                    ...
                }
                // ref-&gt;node-&gt;proc是MediaPlayerService的进程上下文环境，
                // 而target_proc是MediaPlayer的进程上下文环境
                if (ref-&gt;node-&gt;proc == target_proc) {
                    ...
                } else {
                    struct binder_ref *new_ref;
                    // 在MediaPlayer进程中引用&quot;MediaPlayerService&quot;。
                    // 表现为，执行binder_get_ref_for_node()会，会先在MediaPlayer进程中查找是否存在MediaPlayerService对应的Binder引用；
                    // 很显然是不存在的。于是，并新建MediaPlayerService对应的Binder引用，并将其添加到MediaPlayer的Binder引用红黑树中。
                    new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);
                    if (new_ref == NULL) {
                        ...
                    }
                    // 将new_ref的引用描述复制给fp-&gt;handle。
                    fp-&gt;handle = new_ref-&gt;desc;
                    binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL);
                    ...
                }
            } break;

        }
    }

    if (reply) {
        binder_pop_transaction(target_thread, in_reply_to);
    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {
        ...
    } else {
        ...
    }
    // 设置事务的类型为BINDER_WORK_TRANSACTION
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    // 将事务添加到target_list队列中，即target_list的待处理事务中
    list_add_tail(&amp;t-&gt;work.entry, target_list);
    // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
    // 唤醒目标进程
    if (target_wait)
        wake_up_interruptible(target_wait);
    return;
    ...
}</code></pre><p>说明：reply=1，这里只关注reply部分。<br>(01) 此反馈最终是要回复给MediaPlayer的。因此，target_thread被赋值为MediaPlayer所在的线程，target_proc则是MediaPlayer对应的进程，target_node为null。<br>(02) 这里，先看看for循环里面的内容，取出BR_REPLY指令所发送的数据，然后获取数据中的flat_binder_object变量fp。因为fp-&gt;type为BINDER_TYPE_HANDLE，因此进入BINDER_TYPE_HANDLE对应的分支。接着，通过binder_get_ref()获取MediaPlayerService对应的Binder引用；很明显，能够正常获取到MediaPlayerService的Binder引用。因为在MediaPlayerService调用addService请求时，已经创建了它的Binder引用。 binder_get_ref_for_node()的作用是在MediaPlayer进程上下文中添加”MediaPlayerService对应的Binder引用”。这样，后面就可以根据该Binder引用一步步的获取MediaPlayerService对象。 最后，将Binder引用的描述赋值给fp-&gt;handle。<br>(03) 此时，Service Manager已经处理了getService请求。便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayer线程的事务栈中删除该事务。<br>(04) 新建的”待处理事务t”的type为设为BINDER_WORK_TRANSACTION后，会被添加到MediaPlayer的待处理事务队列中。<br>(05) 此时，Service Manager已经处理了getService请求，而Binder驱动在等待它的回复。于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”(作为回复)添加到当前线程(即，Service Manager线程)的待处理事务队列中。<br>(06) 最后，调用wake_up_interruptible()唤醒MediaPlayer。MediaPlayer被唤醒后，会对事务BINDER_WORK_TRANSACTION进行处理。</p>
<p>OK，到现在为止，还有两个待处理事务：(01) ServiceManager待处理事务列表中有个BINDER_WORK_TRANSACTION_COMPLETE类型的事务 (02) MediaPlayer待处理事务列表中有个BINDER_WORK_TRANSACTION事务。</p>
<p>关于BINDER_WORK_TRANSACTION_COMPLETE事务，它是用来告诉ServiceManager，ServiceManager的反馈信息已经处理完毕。下一篇文章，就说说MediaPlayer被唤醒后，执行BINDER_WORK_TRANSACTION的流程。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/07/android/os/binder/2014-09-07-BinderCommunication-GetService01/" itemprop="url">Android Binder机制(九) getService详解01之 请求的发送</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-07T01:01:00.000Z" itemprop="datePublished">9月 7 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            27 分钟 read (About 4109 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面，以MediaPlayerService为例，介绍了Server服务是如何通过addService请求添加到ServiceManager中的。本文，将以MediaPlayer获取MediaPlayerService服务为例，介绍Client是如何通过getService请求从ServiceManager中获取到Server接入点的。<br>在本文的getService请求中，MediaPlayer是Client，它要获取的Server接入点是MediaPlayerService。和addService一样，在分析getService时，会将文章分为请求的发送，请求的处理，和请求的反馈这3部分来进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Android消息机制的架构</a>  </p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="getService概述"><a href="#getService概述" class="headerlink" title="getService概述"></a>getService概述</h1><p>先看看getService的时序图</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/getService.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/getService.jpg" alt></a></p>
<p> 仔细观察，你会发现getService的时序图和”addService的时序图(在<a href="/2014/09/05/BinderCommunication-AddService01/">Android Binder机制(五) addService详解01之 请求的发送</a>中)”几乎是一样的。<br> 先是MediaPlayer进程将getService以BC_TRANSACTION事务的方式发给Binder驱动。Binder驱动收到之后，对内容进行解析；然后唤醒ServiceManager，同时反馈一个BR_TRANSACTION_COMPLETE给MediaPlayer。反馈的BR_TRANSACTION_COMPLETE是告诉MediaPlayer，它的getService请求已经被Binder驱动成功收到。接着，MediaPlayer就进入等待状态，等待ServiceManager的反馈。 ServiceManager被唤醒之后，读取Binder驱动传递给它的BR_TRANSACTION事务。在得知是获取MediaPlayerService的请求之后，就从缓冲中取出MediaPlayerService的相关信息；然后和BC_REPLY指令一起反馈给Binder驱动。Binder驱动收到ServiceManager的反馈之后，将内容进一步反馈给MediaPlayer，并将MediaPlayer唤醒。MediaPlayer被唤醒之后，从Binder驱动反馈的BR_REPLY中解析出MediaPlayerService的相关信息；这样，MediaPlayer就成功获取到了MediaPlayerService的接入点。</p>
<p><a name="anchor2"></a></p>
<h1 id="getService的代码解析"><a href="#getService的代码解析" class="headerlink" title="getService的代码解析"></a>getService的代码解析</h1><p><a name="anchor2_1"></a></p>
<h2 id="1-MediaPlayer的getService入口"><a href="#1-MediaPlayer的getService入口" class="headerlink" title="1. MediaPlayer的getService入口"></a>1. MediaPlayer的getService入口</h2><pre><code>sp&lt;IMediaPlayerService&gt; IMediaDeathNotifier::sMediaPlayerService;
...

const sp&lt;IMediaPlayerService&gt;&amp; IMediaDeathNotifier::getMediaPlayerService()
{
    ...
    if (sMediaPlayerService == 0) {
        sp&lt;IServiceManager&gt; sm = defaultServiceManager();
        sp&lt;IBinder&gt; binder;             
        do {
            binder = sm-&gt;getService(String16(&quot;media.player&quot;));
            ...
            usleep(500000); // 0.5 s    
        } while (true);                 

        ...
        sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);                 
    }     
    ...
    return sMediaPlayerService;         
}</code></pre><p>说明：该代码在frameworks/av/media/libmedia/IMediaDeathNotifier.cpp中。<br>(01) sMediaPlayerService是sp<imediaplayerservice>成员，初始化为null。因此if(sMediaPlayerService==0)为true。<br>(02) 调用defaultServiceManager()获取IServiceManager对象，该对象实际上是BpServiceManager类的实例。defaultServiceManager()的详细流程请参考<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>。<br>(03) 接着就是调用sm-&gt;getService(String16(“media.player”))获取MediaPlayerService对象。</imediaplayerservice></p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-BpServiceManager-getService"><a href="#2-BpServiceManager-getService" class="headerlink" title="2. BpServiceManager::getService()"></a>2. BpServiceManager::getService()</h2><pre><code>virtual sp&lt;IBinder&gt; getService(const String16&amp; name) const
{
    unsigned n;
    for (n = 0; n &lt; 5; n++){
        sp&lt;IBinder&gt; svc = checkService(name);
        if (svc != NULL) return svc;
        sleep(1);
    }
    return NULL;
}

virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const
{
    Parcel data, reply;             
    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());               
    data.writeString16(name);       
    remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);
    return reply.readStrongBinder();
}     </code></pre><p>说明：该代码在frameworks/native/libs/binder/IServiceManager.cpp中。<br>(01) getService()是通过调用checkService()来获取IBinder对象的。如果获取失败，它会调用sleep()休眠1ms之后再次尝试；若尝试5次都失败，则返回null。之所以要尝试5次，是由于可能此时MediaPlayerService服务还没有准备好。<br>(02) 下面看看checkService()，它和”<a href="/2014/09/05/BinderCommunication-AddService01/">Android Binder机制(五) addService详解01之 请求的发送</a>中的addService()”很多内容都相似。 checkService()会先调用writeInterfaceToken()写入一个消息头：”4字节的整型数” + “字符串android.os.IServiceManager”。然后，再调用writeString16(name)将服务名”media.player”写入到data中。 最后，调用remote()-&gt;transact()进行事务交互，其中remote()返回的是BpBinder对象。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="3-BpBinder-transact"><a href="#3-BpBinder-transact" class="headerlink" title="3. BpBinder::transact()"></a>3. BpBinder::transact()</h2><pre><code>status_t BpBinder::transact(            
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // mAlive的初始值为1
    if (mAlive) {
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }

    return DEAD_OBJECT;
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/BpBinder.cpp中。它会调用IPCThreadState::transact()。</p>
<p><a name="anchor2_4"></a></p>
<h2 id="4-IPCThreadState-transact"><a href="#4-IPCThreadState-transact" class="headerlink" title="4. IPCThreadState::transact()"></a>4. IPCThreadState::transact()</h2><pre><code>status_t IPCThreadState::transact(int32_t handle,
                                  uint32_t code, const Parcel&amp; data,
                                  Parcel* reply, uint32_t flags)
{
    status_t err = data.errorCheck();

    flags |= TF_ACCEPT_FDS;

    ...
    if (err == NO_ERROR) {
        ...
        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
    }

    ...

    if ((flags &amp; TF_ONE_WAY) == 0) {
        if (reply) {
            err = waitForResponse(reply);
        } else {
            ...
        }
    } else {
        ...
    }

    return err;
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/IPCThreadState.cpp中。它会先通过writeTransactionData()将要发送的指令和数据打包到binder_transaction_data中，然后调用waitForResponse()和Binder驱动进行通信。</p>
<p><a name="anchor2_5"></a></p>
<h2 id="5-IPCThreadState-writeTransactionData"><a href="#5-IPCThreadState-writeTransactionData" class="headerlink" title="5. IPCThreadState::writeTransactionData()"></a>5. IPCThreadState::writeTransactionData()</h2><pre><code>status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,
    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)
{
    binder_transaction_data tr;

    tr.target.handle = handle;
    tr.code = code;
    tr.flags = binderFlags;
    tr.cookie = 0;
    tr.sender_pid = 0;
    tr.sender_euid = 0;

    const status_t err = data.errorCheck();
    if (err == NO_ERROR) {
        tr.data_size = data.ipcDataSize();
        tr.data.ptr.buffer = data.ipcData();
        tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t);
        tr.data.ptr.offsets = data.ipcObjects();
    } else if (statusBuffer) {
        ..
    } else {
        ...
    }

    mOut.writeInt32(cmd);
    mOut.write(&amp;tr, sizeof(tr));

    return NO_ERROR;
}</code></pre><p>说明：该函数会读取Parcel中的数据，然后将其打包到tr中，tr是binder_transaction_data结构体的对象。之后，将”指令”+”数据”写入到mOut中。指令(cmd)=BC_TRANSACTION，数据就是tr。</p>
<p><a name="anchor2_6"></a></p>
<h2 id="6-IPCThreadState-waitForResponse"><a href="#6-IPCThreadState-waitForResponse" class="headerlink" title="6. IPCThreadState::waitForResponse()"></a>6. IPCThreadState::waitForResponse()</h2><pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) {
        // 先通过talkWithDriver()和Binder驱动交互
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        ...
        if (mIn.dataAvail() == 0) continue;

        // 然后读取返回结果，再根据结果进行处理
        cmd = mIn.readInt32();

        switch (cmd) {
        case BR_TRANSACTION_COMPLETE:
            ...
        case BR_DEAD_REPLY:
            ...
        case BR_FAILED_REPLY:
            ...
        case BR_ACQUIRE_RESULT:
            ...
        case BR_REPLY:
            ...
        default:
            err = executeCommand(cmd);
            if (err != NO_ERROR) goto finish;
            break;
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：waitForResponse()会先调用talkWithDriver()和Binder驱动交互，然后根据反馈结果来进行处理。</p>
<p><a name="anchor2_7"></a></p>
<h2 id="7-IPCThreadState-talkWithDriver"><a href="#7-IPCThreadState-talkWithDriver" class="headerlink" title="7. IPCThreadState::talkWithDriver()"></a>7. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    binder_write_read bwr;

    // Is the read buffer empty?
    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();
    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we&apos;ll read.
    if (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
        bwr.read_buffer = 0;
    }

    ...
    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    status_t err;
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：talkWithDriver()会先初始化bwr(binder_write_read类型的变量)，然后将bwr通过ioctl()发送给Binder驱动。初始化之后的bwr各个成员的值如下：  </p>
<pre><code>bwr.write_size = outAvail;                          // mOut中数据大小，大于0
bwr.write_buffer = (long unsigned int)mOut.data();  // mOut中数据的地址
bwr.write_consumed = 0;
bwr.read_size = mIn.dataCapacity();                 // 256
bwr.read_buffer = (long unsigned int)mIn.data();    // mIn.mData，实际上为空
bwr.read_consumed = 0;</code></pre><p>bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。</p>
<p><a name="anchor2_8"></a></p>
<h2 id="8-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#8-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="8. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>8. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h2><pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：首先，会将binder_write_read从用户空间拷贝到内核空间之后。拷贝之后，读取出来的bwr.write_size和bwr.read_size都&gt;0，因此先写后读。即，先执行binder_thread_write()，然后执行binder_thread_read()。</p>
<p><a name="anchor2_9"></a></p>
<h2 id="9-Binder驱动中binder-thread-write-的源码"><a href="#9-Binder驱动中binder-thread-write-的源码" class="headerlink" title="9. Binder驱动中binder_thread_write()的源码"></a>9. Binder驱动中binder_thread_write()的源码</h2><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
      ...
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p>说明：MediaPlayer发送的指令是BC_TRANSACTION，这里只关心与BC_TRANSACTION相关的部分。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。</p>
<p><a name="anchor2_10"></a></p>
<h2 id="10-Binder驱动中binder-transaction-的源码"><a href="#10-Binder驱动中binder-transaction-的源码" class="headerlink" title="10. Binder驱动中binder_transaction()的源码"></a>10. Binder驱动中binder_transaction()的源码</h2><pre><code>static void binder_transaction(struct binder_proc *proc,
                   struct binder_thread *thread,
                   struct binder_transaction_data *tr, int reply)
{
    struct binder_transaction *t;
    struct binder_work *tcomplete;
    size_t *offp, *off_end;
    struct binder_proc *target_proc;
    struct binder_thread *target_thread = NULL;
    struct binder_node *target_node = NULL;
    struct list_head *target_list;
    wait_queue_head_t *target_wait;
    struct binder_transaction *in_reply_to = NULL;
    struct binder_transaction_log_entry *e;
    uint32_t return_error;

    ...

    if (reply) {
        ...
    } else {
        if (tr-&gt;target.handle) {
            ...
        } else {
            // 该getService是从ServiceManager中获取MediaPlayer；
            // 因此事务目标对象是ServiceManager的binder实体。
            target_node = binder_context_mgr_node;
            ...
        }
        ...
        // 设置处理事务的目标进程
        target_proc = target_node-&gt;proc;
        ...
    }

    if (target_thread) {
        ...
    } else {
        target_list = &amp;target_proc-&gt;todo;
        target_wait = &amp;target_proc-&gt;wait;
    }
    ...

    // 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
    t = kzalloc(sizeof(*t), GFP_KERNEL);
    ...

    // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
    ...

    t-&gt;debug_id = ++binder_last_id;
    ...

    // 设置from，表示该事务是MediaPlayer线程发起的
    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
        t-&gt;from = thread;
    else
        t-&gt;from = NULL;
    // 下面的一些赋值是初始化事务t
    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
    // 事务将交给target_proc进程进行处理
    t-&gt;to_proc = target_proc;
    // 事务将交给target_thread线程进行处理
    t-&gt;to_thread = target_thread;
    // 事务编码
    t-&gt;code = tr-&gt;code;
    // 事务标志
    t-&gt;flags = tr-&gt;flags;
    // 事务优先级
    t-&gt;priority = task_nice(current);

    ...

    // 分配空间
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    ...
    t-&gt;buffer-&gt;allow_user_free = 0;
    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
    // 保存事务
    t-&gt;buffer-&gt;transaction = t;
    // 保存事务的目标对象(即处理该事务的binder对象)
    t-&gt;buffer-&gt;target_node = target_node;
    trace_binder_transaction_alloc_buf(t-&gt;buffer);
    if (target_node)
        binder_inc_node(target_node, 1, 0, NULL);

    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));

    // 将&quot;用户空间的数据&quot;拷贝到内核中
    // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户空间的数据中所含对象的偏移地址&quot;拷贝到内核中
    // MediaPlayer中不包含对象, offp=null
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }
    ...
    // MediaPlayer中不包含对象, off_end为null
    off_end = (void *)offp + tr-&gt;offsets_size;
    // MediaPlayer中不包含对象, offp=off_end
    for (; offp &lt; off_end; offp++) {
        ...
    }
    if (reply) {
        ..
    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {
        BUG_ON(t-&gt;buffer-&gt;async_transaction != 0);
        t-&gt;need_reply = 1;
        t-&gt;from_parent = thread-&gt;transaction_stack;
        // 将当前事务添加到当前线程的事务栈中
        thread-&gt;transaction_stack = t;
    } else {
        ...
    }
    // 设置事务的类型为BINDER_WORK_TRANSACTION
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    // 将事务添加到target_list队列中，即target_list的待处理事务中
    list_add_tail(&amp;t-&gt;work.entry, target_list);
    // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
    // 唤醒目标进程
    if (target_wait)
        wake_up_interruptible(target_wait);
    return;

    ...
}</code></pre><p>说明：参数reply=0，表明这是个请求事务，而不是反馈。binder_transaction新建会新建”一个待处理事务t”和”待完成的工作tcomplete”，并根据请求的数据对它们进行初始化。<br>(01) MediaPlayer的getService请求是提交给ServiceManager进行处理的，因此，”待处理事务t”会被添加到ServiceManager的待处理事务队列中。此时的target_thread是ServiceManager对应的线程，而target_proc则是ServiceManager对应的进程上下文环境。<br>(02) 此时，Binder驱动已经收到了MediaPlayer的getService请求；于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”添加到当前线程(即，MediaPlayer线程)的待处理事务队列中。目的是告诉MediaPlayer，Binder驱动已经收到它的getService请求了。<br>(03) 最后，调用wake_up_interruptible(target_wait)将Service Manager唤醒。</p>
<p>接下来，还是先分析完MediaPlayer线程，再看ServiceManager被唤醒后做了些什么。</p>
<p>binder_transaction()执行完毕之后，就会返回到binder_thread_write()中。binder_thread_write()更新bwr.write_consumed的值后，就返回到binder_ioctl()继续执行”读”动作。即执行binder_thread_read()。</p>
<p><a name="anchor2_11"></a></p>
<h2 id="11-Binder驱动中binder-thread-read-的源码"><a href="#11-Binder驱动中binder-thread-read-的源码" class="headerlink" title="11. Binder驱动中binder_thread_read()的源码"></a>11. Binder驱动中binder_thread_read()的源码</h2><pre><code>static int binder_thread_read(struct binder_proc *proc,
                  struct binder_thread *thread,
                  void  __user *buffer, int size,
                  signed long *consumed, int non_block)
{
    void __user *ptr = buffer + *consumed;
    void __user *end = buffer + size;

    int ret = 0;
    int wait_for_proc_work;

    // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区
    if (*consumed == 0) {
        if (put_user(BR_NOOP, (uint32_t __user *)ptr))
            return -EFAULT;
        ptr += sizeof(uint32_t);
    }

retry:
    // 等待proc进程的事务标记。
    // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。
    wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;
                list_empty(&amp;thread-&gt;todo);

    ...

    if (wait_for_proc_work) {
        ...
    } else {
        if (non_block) {
            ...
        } else
            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));
    }

    ...

    while (1) {
        uint32_t cmd;
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */
                goto retry;
            break;
        }

        ...

        switch (w-&gt;type) {
        ...
        case BINDER_WORK_TRANSACTION_COMPLETE: {
            cmd = BR_TRANSACTION_COMPLETE;
            // 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中
            if (put_user(cmd, (uint32_t __user *)ptr))
                return -EFAULT;
            ptr += sizeof(uint32_t);

            ...
            // 待完成事务已经处理完毕，将其从待完成事务队列中删除。
            list_del(&amp;w-&gt;entry);
            kfree(w);
            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
        } break;
        ...
        }

        if (!t)
            continue;

        ...
    }

    ...
    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：<br>(01) bwr.read_consumed=0，即if (*consumed == 0)为true。因此，会将BR_NOOP写入到bwr.read_buffer中。<br>(02) thread-&gt;transaction_stack不为空，thread-&gt;todo也不为空。因为，前面在binder_transaction()中有将一个BINDER_WORK_TRANSACTION_COMPLETE类型的待完成工作添加到thread的待完成工作队列中。因此，wait_for_proc_work为false。<br>(03) binder_has_thread_work(thread)为true。因此，在调用wait_event_interruptible()时，不会进入等待状态，而是继续运行。<br>(04) 进入while循环后，通过list_first_entry()取出待完成工作w。w的类型w-&gt;type=BINDER_WORK_TRANSACTION_COMPLETE，进入到对应的switch分支。随后，将BR_TRANSACTION_COMPLETE写入到bwr.read_buffer中。此时，待处理工作已经完成，将其从当前线程的待处理工作队列中删除。<br>(05) 最后，更新bwr.read_consumed的值。  </p>
<p>经过binder_thread_read()处理之后，bwr.read_buffer中包含了两个指令：BR_NOOP和BR_TRANSACTION_COMPLETE。</p>
<p>再回到binder_ioctl()中，在将bwr拷贝到用户空间之后，binder_ioctl()的工作就完成了。于是就返回到talkWithDriver()中。</p>
<p><a name="anchor2_12"></a></p>
<h2 id="12-IPCThreadState-talkWithDriver"><a href="#12-IPCThreadState-talkWithDriver" class="headerlink" title="12. IPCThreadState::talkWithDriver()"></a>12. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                ...
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：<br>(01) 从Binder驱动返回后，bwr.write_consumed&gt;0，因此调用mOut.setDataSize(0)将mOut中的数据清空。这意味着，MediaPlayer的请求Binder驱动已经收到，并且已经将请求数据读取完毕。<br>(02) bwr.read_consumed也&gt;0，因此会执行if(bwr.read_consumed&gt;0)中的代码，更新mIn中的mDataSize和mDataPos。这意味着，Binder驱动反馈给MediaPlayer的数据不为空。接下来，MediaPlayer线程肯定会读取Binder驱动反馈的数据(BR_NOOP和BR_TRANSACTION_COMPLETE)。在读取完这些数据之后，MediaPlayer线程会再次调用ioctl(,BINDER_WRITE_READ,)进行读动作；而当执行到binder_thread_read()时，由于此时MediaPlayer线程的待处理工作队列为空，因此MediaPlayer线程会进入中断等待状态。待ServiceManager守护进程处理完MediaPlayer的请求之后，就会将MediaPlayer唤醒。</p>
<br>
至此，getService请求的发送部分就介绍完了。下面，就看看ServiceManager被唤醒后是如何获取MediaPlayerService进入点，然后再将该进入点反馈给MediaPlayer的。





    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/06/android/os/binder/2014-09-06-BinderCommunication-ThreadPool/" itemprop="url">Android Binder机制(八) MediaPlayerService服务的消息循环</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-06T01:01:00.000Z" itemprop="datePublished">9月 6 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 read (About 1598 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>在前面的3篇文章中，我们以MediaPlayerService为例，介绍了C-S中的Server服务是如何通过addService请求添加到ServiceManager中的。但是，在<a href="/2014/09/05/BinderCommunication-AddService03/">Android Binder机制(七) addService详解03之 请求的反馈</a>的结尾，我们提到过：MediaPlayerService仅仅只是将自己注册到了ServiceManager中，它还没有进入消息循环等待Client的请求。<br>本文，就接着介绍MediaPlayerService是如何进入消息循环的。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-MediaPlayerService的main-函数"><a href="#1-MediaPlayerService的main-函数" class="headerlink" title="1. MediaPlayerService的main()函数"></a>1. MediaPlayerService的main()函数</h1><pre><code>int main(int argc, char** argv)
{
    ...

    if (doLog &amp;&amp; (childPid = fork()) != 0) {
        ...
    } else {
        ...
        MediaPlayerService::instantiate();
        ...
        ProcessState::self()-&gt;startThreadPool();
        IPCThreadState::self()-&gt;joinThreadPool();
    }
}</code></pre><p>说明：该代码在frameworks/av/media/mediaserver/main_mediaserver.cpp中。对于MediaPlayerService::instantiate()，已经详细介绍过了；它的作用是将MediaPlayerService已经注册到ServiceManager中。下面看看startThreadPool()的流程。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-ProcessState-startThreadPool"><a href="#2-ProcessState-startThreadPool" class="headerlink" title="2. ProcessState::startThreadPool();"></a>2. ProcessState::startThreadPool();</h1><pre><code>void ProcessState::startThreadPool()
{
    AutoMutex _l(mLock);
    if (!mThreadPoolStarted) {
        mThreadPoolStarted = true;
        spawnPooledThread(true);
    }
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中。<br>mThreadPoolStarted的初始值为false，因此这里设置mThreadPoolStarted=true之后，就调用spawnPooledThread()。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-ProcessState-spawnPooledThread"><a href="#2-ProcessState-spawnPooledThread" class="headerlink" title="2. ProcessState::spawnPooledThread()"></a>2. ProcessState::spawnPooledThread()</h1><pre><code>void ProcessState::spawnPooledThread(bool isMain)
{
    if (mThreadPoolStarted) {
        String8 name = makeBinderThreadName();
        ALOGV(&quot;Spawning new pooled thread, name=%s\n&quot;, name.string());
        sp&lt;Thread&gt; t = new PoolThread(isMain);
        t-&gt;run(name.string());
    }
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中。 此时mThreadPoolStarted=true，因此会先调用makeBinderThreadName()为线程取一个名称；然后新建PoolThread线程，并运行。<br>makeBinderThreadName()的代码比较简单，这里就不列出了。线程的名称是”Binder_X”(其实X是16进制数)，每新建一个线程X的值都会+1。下面看看PoolThread。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-ProcessState-spawnPooledThread"><a href="#3-ProcessState-spawnPooledThread" class="headerlink" title="3. ProcessState::spawnPooledThread()"></a>3. ProcessState::spawnPooledThread()</h1><pre><code>class PoolThread : public Thread
{
public:
    PoolThread(bool isMain)
        : mIsMain(isMain)
    {
    }

protected:
    virtual bool threadLoop()
    {
        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);
        return false;
    }

    const bool mIsMain;
};</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中。PoolThread继承于Thread，在线程启动之后，会调用threadLoop()进入消息循环中。 </p>
<p>下面简单说说，当PoolThread启动之后，是如何调用到threadLoop()的。PoolThread继承于Thread，先看看Thread的构造函数，然后再看看run()的代码。</p>
<p><a name="anchor4"></a></p>
<h1 id="4-Thread-Thread"><a href="#4-Thread-Thread" class="headerlink" title="4. Thread::Thread"></a>4. Thread::Thread</h1><pre><code>Thread::Thread(bool canCallJava)
    :   mCanCallJava(canCallJava),
        mThread(thread_id_t(-1)),
        mLock(&quot;Thread::mLock&quot;),
        mStatus(NO_ERROR),
        mExitPending(false), mRunning(false)
        , mTid(-1)
{
}   </code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。新建Thread对象时，会进行一些列初始化。这里设置mCanCallJava=true。</p>
<p><a name="anchor5"></a></p>
<h1 id="5-Thread-run"><a href="#5-Thread-run" class="headerlink" title="5. Thread::run"></a>5. Thread::run</h1><pre><code>status_t Thread::run(const char* name, int32_t priority, size_t stack)
{   
    Mutex::Autolock _l(mLock);

    ...

    // 初始化
    mStatus = NO_ERROR;
    mExitPending = false;
    mThread = thread_id_t(-1);
    mHoldSelf = this;
    mRunning = true;            

    bool res;
    if (mCanCallJava) {
        res = createThreadEtc(_threadLoop,
                this, name, priority, stack, &amp;mThread);
    } else {
        ...
    }

    ...
    return NO_ERROR;
}</code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。<br>(01) 先看看函数参数。name是spawnPooledThread()中创建的Binder线程名称，形式是”Binder_X”。priority是优先级(默认值为PRIORITY_DEFAULT)，stack是线程栈数量(默认是0)；它们都是使用默认值，在system/core/include/utils/Thread.h中定义。<br>(02) 先进行初始化；mCanCallJava的值在构造函数中被初始化为true。因此，会调用createThreadEtc()。</p>
<p><a name="anchor6"></a></p>
<h1 id="6-createThreadEtc"><a href="#6-createThreadEtc" class="headerlink" title="6. createThreadEtc"></a>6. createThreadEtc</h1><pre><code>// Create thread with lots of parameters
inline bool createThreadEtc(thread_func_t entryFunction,
                            void *userData,
                            const char* threadName = &quot;android:unnamed_thread&quot;,             
                            int32_t threadPriority = PRIORITY_DEFAULT,                     
                            size_t threadStackSize = 0,                                    
                            thread_id_t *threadId = 0)
{
    return androidCreateThreadEtc(entryFunction, userData, threadName,
        threadPriority, threadStackSize, threadId) ? true : false;
}</code></pre><p>说明：该代码定义在system/core/include/utils/AndroidThreads.h中。它会调用androidCreateThreadEtc()。</p>
<p><a name="anchor7"></a></p>
<h1 id="7-androidCreateThreadEtc"><a href="#7-androidCreateThreadEtc" class="headerlink" title="7. androidCreateThreadEtc"></a>7. androidCreateThreadEtc</h1><pre><code>static android_create_thread_fn gCreateThreadFn = androidCreateRawThreadEtc;

int androidCreateThreadEtc(android_thread_func_t entryFunction,
                            void *userData,
                            const char* threadName,
                            int32_t threadPriority,
                            size_t threadStackSize,
                            android_thread_id_t *threadId)
{
    return gCreateThreadFn(entryFunction, userData, threadName,
        threadPriority, threadStackSize, threadId);
}

void androidSetCreateThreadFunc(android_create_thread_fn func)
{
    gCreateThreadFn = func;
}</code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。 androidCreateThreadEtc()会调用gCreateThreadFn()。gCreateThreadFn()是个函数指针，它的值是androidCreateRawThreadEtc。</p>
<p><a name="anchor8"></a></p>
<h1 id="8-androidCreateRawThreadEtc"><a href="#8-androidCreateRawThreadEtc" class="headerlink" title="8. androidCreateRawThreadEtc"></a>8. androidCreateRawThreadEtc</h1><pre><code>int androidCreateRawThreadEtc(android_thread_func_t entryFunction,
                               void *userData,
                               const char* threadName,
                               int32_t threadPriority,
                               size_t threadStackSize,
                               android_thread_id_t *threadId)
{
    ...
    int result = pthread_create(&amp;thread, &amp;attr,
                    (android_pthread_entry)entryFunction, userData);

    ...
    return 1;
}</code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。 该函数会调用pthread_create()，而pthread_create()则是我们非常熟悉的Linux的标准接口，它的作用就是创建线程。线程创建成功之后运行时，会以执行entryFunction对应的函数。而entryFunction这个函数指针的值是_threadLoop。因此，当线程启动之后，会执行_threadLoop。</p>
<p><a name="anchor9"></a></p>
<h1 id="9-threadLoop"><a href="#9-threadLoop" class="headerlink" title="9. _threadLoop"></a>9. _threadLoop</h1><pre><code>int Thread::_threadLoop(void* user)
{
    ...

    bool first = true;

    do {
        bool result;
        if (first) {
            first = false;
            self-&gt;mStatus = self-&gt;readyToRun();
            result = (self-&gt;mStatus == NO_ERROR);

            if (result &amp;&amp; !self-&gt;exitPending()) {
                result = self-&gt;threadLoop();
            }
        } else {
            ...
        }

        ...
    } while(strong != 0);

    return 0;
}</code></pre><p>说明：该代码定义在system/core/libutils/Threads.cpp中。first的初始值为true，因此进入到if(first)中。  readyToRun()的实现在Threads.cpp中，返回NO_ERROR。因此result为true，而mExitPending的默认值为false，即self0&gt;exitPending()返回false。因此会执行self-&gt;threadLoop()。由于PoolThread重载了threadLoop()，因此，这里的self-&gt;threadLoop()会调用PoolThread中的threadLoop()。</p>
<p><a name="anchor10"></a></p>
<h1 id="10-PoolThread-threadLoop"><a href="#10-PoolThread-threadLoop" class="headerlink" title="10. PoolThread::threadLoop()"></a>10. PoolThread::threadLoop()</h1><pre><code>virtual bool threadLoop()
{
    IPCThreadState::self()-&gt;joinThreadPool(mIsMain);
    return false;
}</code></pre><p>说明：这是PoolThread中实现的threadLoop()函数。它会先通过IPCThreadState::self()获取IPCThreadState对象，然后调用IPCThreadState::joinThreadPool(mIsMain)，其中mIsMain为true。</p>
<p><a name="anchor11"></a></p>
<h1 id="11-IPCThreadState-joinThreadPool"><a href="#11-IPCThreadState-joinThreadPool" class="headerlink" title="11. IPCThreadState::joinThreadPool()"></a>11. IPCThreadState::joinThreadPool()</h1><pre><code>void IPCThreadState::joinThreadPool(bool isMain)
{
    ...

    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);

    ...
    do {  
        ...
        result = getAndExecuteCommand();

        if (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) {
            ...
            abort();
        } 

        if(result == TIMED_OUT &amp;&amp; !isMain) {
            break;
        } 
    } while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);

    ...

    mOut.writeInt32(BC_EXIT_LOOPER);    
    talkWithDriver(false);              
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/IPCThreadState.cpp中。在该函数中，便进入了消息循环！<br>(01) isMain=true，因此会先将BC_ENTER_LOOPER指令写入到mOut中。<br>(02) 接着调用getAndExecuteCommand()。  </p>
<p><a name="anchor12"></a></p>
<h1 id="12-IPCThreadState-getAndExecuteCommand"><a href="#12-IPCThreadState-getAndExecuteCommand" class="headerlink" title="12. IPCThreadState::getAndExecuteCommand()"></a>12. IPCThreadState::getAndExecuteCommand()</h1><pre><code>status_t IPCThreadState::getAndExecuteCommand()
{
    status_t result;
    int32_t cmd;

    // 和Binder驱动交互
    result = talkWithDriver();
    if (result &gt;= NO_ERROR) {
        ...
        // 读取mIn中的数据
        cmd = mIn.readInt32();
        ...

        // 调用executeCommand()对数据进行处理。
        result = executeCommand(cmd);
        ...
    }

    return result;
}</code></pre><p>说明：该函数会调用talkWithDriver()和Binder驱动进行交互。对于talkWithDriver()，前面已经多次提到。在此，talkWithDriver()会将BC_ENTER_LOOPER指令发送给Binder驱动，告诉Binder驱动，MediaPlayerService进入了消息循环状态。BC_ENTER_LOOPER的流程在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中已经介绍过了。<br>当BC_ENTER_LOOPER处理完毕，MediaPlayerService再次调用ioctl()和Binder驱动通信时，由于MediaPlayerService对应的待处理事务列表为空，因此MediaPlayerService线程会进入中断等待状态。当有Client向MediaPlayerService发送请求时，MediaPlayerService就会被唤醒。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/05/android/os/binder/2014-09-05-BinderCommunication-AddService03/" itemprop="url">Android Binder机制(七) addService详解03之 请求的反馈</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-05T01:03:00.000Z" itemprop="datePublished">9月 5 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            9 分钟 read (About 1331 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面两篇文章分别介绍了addService中”请求的发送”和”请求的处理”这两部分，本文将介绍addService请求的最后一部分–请求的反馈。<br>ServiceManager在处理完addService请求之后，添加了一个待处理事务到MediaPlayerService的事务列表中，并将MediaPlayerService唤醒。我们从上次MediaPlayerService休眠的地方开始，看看它被唤醒之后干了些什么。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder驱动中binder-thread-read-的源码"><a href="#1-Binder驱动中binder-thread-read-的源码" class="headerlink" title="1. Binder驱动中binder_thread_read()的源码"></a>1. Binder驱动中binder_thread_read()的源码</h1><pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是NULL
        if (t-&gt;buffer-&gt;target_node) {
            ...
        } else {
            tr.target.ptr = NULL;
            tr.cookie = NULL;
            cmd = BR_REPLY;
        }
        // 交易码
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            tr.sender_pid = 0;
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        // 设置回复信息
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            ...
        } else {
            t-&gt;buffer-&gt;transaction = NULL;
            kfree(t);
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：MediaPlayerService进程被Service Manager唤醒，同时它的待处理事务队列中有ServiceManager添加的事务；此时，binder_has_thread_work()为true。因此，MediaPlayerService会继续往下执行。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让MediaPlayerService读取后进行处理。此时的指令是BR_REPLY。</p>
<p>binder_thread_read()执行完毕之后，共反馈了两个指令到用户空间：BR_NOOP和BR_REPLY</p>
<p>现在回到MediaPlayerService位于用户空间的进程。它会逐个解析Binder驱动反馈的指令。<br>对于BR_NOOP，MediaPlayerService不会做任何实质性的动作。<br>对于BR_REPLY，看看MediaPlayerService的处理流程。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-IPCThreadState-waitForResponse"><a href="#2-IPCThreadState-waitForResponse" class="headerlink" title="2. IPCThreadState::waitForResponse"></a>2. IPCThreadState::waitForResponse</h1><pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) {
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        ...

        cmd = mIn.readInt32();

        switch (cmd) {
            ...
        case BR_REPLY:
            {
                binder_transaction_data tr;
                err = mIn.read(&amp;tr, sizeof(tr));
                ...

                if (reply) {
                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                        reply-&gt;ipcSetDataReference(
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t),
                            freeBuffer, this);
                    } else {
                        ...
                    }
                } else {
                    ...
                }
            }
            goto finish;
            ...
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：在BR_REPLY分支中，先读取出数据，并保存到tr中。由于reply不为null，并且tr.flags &amp; TF_STATUS_CODE为0；因此，会执行reply-&gt;ipcSetDataReference()。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-Parcel-ipcSetDataReference"><a href="#3-Parcel-ipcSetDataReference" class="headerlink" title="3. Parcel::ipcSetDataReference"></a>3. Parcel::ipcSetDataReference</h1><pre><code>void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,
    const size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)     
{
    freeDataNoInit();                   
    mError = NO_ERROR;
    mData = const_cast&lt;uint8_t*&gt;(data); 
    mDataSize = mDataCapacity = dataSize;
    mDataPos = 0;
    mObjects = const_cast&lt;size_t*&gt;(objects);
    mObjectsSize = mObjectsCapacity = objectsCount;
    mNextObjectHint = 0;
    mOwner = relFunc;
    mOwnerCookie = relCookie;           
    scanForFds();
}</code></pre><p>说明：ipcSetDataReference()是根据参数的值重新初始化Parcel的数据和对象。<br>(01) freeDataNoInit()的目的是释放原有的内存。为接下来保存Binder驱动反馈的数据做准备。<br>(02) 在<a href="/2014/09/05/BinderCommunication-AddService02/">Android Binder机制(六) addService详解02之 请求的处理</a>中，ServiceManager反馈数据时，我们知道它对应的BR_REPLY的数据实际上是空的！因此，这里的mDataSize和mObjectsSize都是0。</p>
<p>实际上，Binder驱动反馈给MediaPlayerService的指令就是告诉它addService已经成功处理完毕！</p>
<p>在MediaPlayerService解析完Binder驱动反馈的数据之后，它会层层向上返回。这样，MediaPlayerService::instantiate()也就正式执行完了！<br>MediaPlayerService::instantiate()执行完毕，但是MediaPlayerService进程似乎还没有进入消息循环中等到Client的请求！那么，它是何时进入消息循环的呢？回到MediaPlayerService进程的main()函数入口中，它后面是通过startThreadPool()进入消息循环的。这部分的内容，我们下一章再来介绍。</p>
<pre><code>int main(int argc, char** argv)
{
    ...

    if (doLog &amp;&amp; (childPid = fork()) != 0) {
        ...
    } else {
        ...
        MediaPlayerService::instantiate();
        ...
        ProcessState::self()-&gt;startThreadPool();
        IPCThreadState::self()-&gt;joinThreadPool();
    }
}</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/05/android/os/binder/2014-09-05-BinderCommunication-AddService02/" itemprop="url">Android Binder机制(六) addService详解02之 请求的处理</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-05T01:02:00.000Z" itemprop="datePublished">9月 5 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            42 分钟 read (About 6341 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p><a href="/2014/09/05/BinderCommunication-AddService01/">前面一文</a>介绍了addService的请求发送部分，Binder驱动在处理addService请求时，将一个待处理事务添加到ServiceManager中，然后将ServiceManager唤醒。在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>的末尾，我们说过ServiceManager启动之后，由于没有事务可处理，就进入了等待状态。这里，从ServiceManager被唤醒后开始讲解。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Android消息机制的架构</a>  </p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder驱动中binder-thread-read-的源码"><a href="#1-Binder驱动中binder-thread-read-的源码" class="headerlink" title="1. Binder驱动中binder_thread_read()的源码"></a>1. Binder驱动中binder_thread_read()的源码</h1><p>下面，就接着<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中的休眠部分进行讲解，看看Service Manager被唤醒后，会干些什么。</p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
    ...
    if (wait_for_proc_work) {
      ...
      if (non_block) {
          ...
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } else {
      ...
    }
    ...

    while (1) {
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            ...
        }

        ...

        switch (w-&gt;type) {
            case BINDER_WORK_TRANSACTION: {
                t = container_of(w, struct binder_transaction, work);
            } break;
            ...
        }

        if (!t)
            continue;

        // t-&gt;buffer-&gt;target_node是目标节点。
        // 这里，addService请求的目标是ServiceManager，因此target_node是ServiceManager对应的节点；
        // 它的值在事务交互时(binder_transaction中)，被赋值为ServiceManager对应的Binder实体。  
        if (t-&gt;buffer-&gt;target_node) {
            // 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体)
            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;
            // Binder实体在用户空间的地址(ServiceManager的ptr为NULL)
            tr.target.ptr = target_node-&gt;ptr;
            // Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL)
            tr.cookie =  target_node-&gt;cookie;
            t-&gt;saved_priority = task_nice(current);
            if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;
                !(t-&gt;flags &amp; TF_ONE_WAY))
                binder_set_nice(t-&gt;priority);
            else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||
                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)
                binder_set_nice(target_node-&gt;min_priority);
            cmd = BR_TRANSACTION;
        } else {
            tr.target.ptr = NULL;
            tr.cookie = NULL;
            cmd = BR_REPLY;
        }
        // 交易码
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        if (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } else {
            tr.sender_pid = 0;
        }

        // 数据大小
        tr.data_size = t-&gt;buffer-&gt;data_size;
        // 数据中对象的偏移数组的大小(即对象的个数)
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        // 数据
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
                    proc-&gt;user_buffer_offset;
        // 数据中对象的偏移数组
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size,
                        sizeof(void *));

        // 将cmd指令写入到ptr，即传递到用户空间
        if (put_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        // 将tr数据拷贝到用户空间
        ptr += sizeof(uint32_t);
        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            return -EFAULT;
        ptr += sizeof(tr);

        ...
        // 删除已处理的事务
        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = 1;
        // 设置回复信息
        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            // 该事务会发送给Service Manager守护进程进行处理。
            // Service Manager处理之后，还需要给Binder驱动回复处理结果。
            // 这里设置Binder驱动回复信息。
            t-&gt;to_parent = thread-&gt;transaction_stack;
            // to_thread表示Service Manager反馈后，将反馈结果交给当前thread进行处理
            t-&gt;to_thread = thread;
            // transaction_stack交易栈保存当前事务。用于之处反馈是针对哪个事务的。
            thread-&gt;transaction_stack = t;
        } else {
            ...
        }
        break;
    }

done:

    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：ServiceManager进程在调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))进入等待之后，被MediaPlayerService进程唤醒。唤醒之后，binder_has_thread_work()为true，因为ServiceManager的待处理事务队列中有个待处理事务(即，MediaPlayerService添加服务的请求)。<br>(01) 进入while循环后，首先取出待处理事务。<br>(02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。<br>下面列举比较重要的几个部分进行说明。</p>
<pre><code>// 数据大小
tr.data_size = t-&gt;buffer-&gt;data_size;
// 数据中对象的偏移数组的大小(即对象的个数)
tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
// 数据
tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +
            proc-&gt;user_buffer_offset;
// 数据中对象的偏移数组
tr.data.ptr.offsets = tr.data.ptr.buffer +
            ALIGN(t-&gt;buffer-&gt;data_size,
                    sizeof(void *));</code></pre><p>这里着重强调一下地址的赋值方式，因为它涉及到Binder机制的数据拷贝原理！<br>t-&gt;buffer是在binder_transaction()中，通过binder_alloc_buf()分配的内核空间地址。现在要将数据返回给Service Manager守护进程，需要将内核空间的数据拷贝到用户空间。如果你还记得的话，前面在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>的mmap()中，我们将内核虚拟地址和进程虚拟地址映射到同一个物理存储区；现在，已知内核虚拟地址(即t-&gt;buffer-&gt;data)。那么，只需要将t-&gt;buffer-&gt;data加上proc-&gt;user_buffer_offset(内核虚拟地址和进程虚拟地址的偏移)即可得到在用户空间的地址。  </p>
<p>在tr赋值完毕之后，就将完整数据拷贝到用户空间。此时，该事务已经在Binder驱动中被处理，于是将事务从Service Manager的待处理事务队列中删除。Binder驱动随后会将该事务发送给Service Manager守护进程，Service Manager守护进程在处理完事务之后，需要反馈结果给Binder驱动。因此，接下来会设置t-&gt;to_thread和t-&gt;transaction_stack等成员。最后，修改*consumed的值，即bwr.read_consumed的值，表示待读取内容的大小。<br>执行完binder_thread_read()之后，回到binder_ioctl()中，执行copy_to_user()将数据拷贝到用户空间。接下来，就回到了Service Manager的守护进程当中，即回到binder_loop()中。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-binder-loop"><a href="#2-binder-loop" class="headerlink" title="2. binder_loop()"></a>2. binder_loop()</h1><pre><code>void binder_loop(struct binder_state *bs, binder_handler func)
{
    struct binder_write_read bwr;
    unsigned readbuf[32];
    ...

    for (;;) {
        bwr.read_size = sizeof(readbuf);
        bwr.read_consumed = 0;
        bwr.read_buffer = (unsigned) readbuf;

        bwr.read_buffer = (unsigned) readbuf;

        // 向Kernel中发送消息(先写后读)。
        // 先将消息传递给Kernel，然后再从Kernel读取消息反馈
        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);

        ...

        // 解析读取的消息反馈
        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);
        ...
    }
}</code></pre><p>说明：binder_loop()会将ioctl()反馈的数据发送给binder_parse()进行解析。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-binder-parse"><a href="#3-binder-parse" class="headerlink" title="3. binder_parse()"></a>3. binder_parse()</h1><pre><code>int binder_parse(struct binder_state *bs, struct binder_io *bio,
                 uint32_t *ptr, uint32_t size, binder_handler func)
{
    int r = 1;
    uint32_t *end = ptr + (size / 4);

    while (ptr &lt; end) {
        uint32_t cmd = *ptr++;

        switch(cmd) {
        case BR_NOOP:
            break;
        ...
        case BR_TRANSACTION: {
            struct binder_txn *txn = (void *) ptr;
            ...
            if (func) {
                unsigned rdata[256/4];
                struct binder_io msg;   // 用于保存&quot;Binder驱动反馈的信息&quot;
                struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot;
                int res;

                // 初始化reply
                bio_init(&amp;reply, rdata, sizeof(rdata), 4);
                // 根据txt(Binder驱动反馈的信息)初始化msg
                bio_init_from_txn(&amp;msg, txn);
                // 消息处理
                res = func(bs, txn, &amp;msg, &amp;reply);
                // 反馈消息给Binder驱动。
                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);
            }
            ptr += sizeof(*txn) / sizeof(uint32_t);
            break;
        }
        ...
        }
    }

    return r;
}</code></pre><p>说明：此处里的cmd就是bwr.read_buffer指针。而在Binder驱动的binder_thread_read()中，反馈的第一个指令是BR_NOOP；因此这里的cmd=BR_NOOP，不执行任何动作，继续取出下一个指令cmd=BR_TRANSACTION。在BR_TRANSACTION中，会先取出消息，在对消息处理之后，再将反馈信息发送给Binder驱动。下面是BR_TRANSACTION的详细内容。<br>(01) 首先，将ptr转换成struct binder_txn结构体指针。struct binder_txn是与binder_transaction_datad对应的结构体，在<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>中有它的详细介绍。<br>(02) 此处的func是函数指针svcmgr_handler，不为空；因此，先调用bio_init()初始化reply，再调用bio_init_from_txn()来初始化msg。<br>(03) 初始化完毕之后，就调用svcmgr_handler()对消息进行处理。<br>(04) 消息处理完毕，就通过binder_send_reply()将处理结果反馈给Binder驱动。  </p>
<p><a name="anchor4"></a></p>
<h1 id="4-bio-init"><a href="#4-bio-init" class="headerlink" title="4. bio_init()"></a>4. bio_init()</h1><pre><code>void bio_init(struct binder_io *bio, void *data,
              uint32_t maxdata, uint32_t maxoffs)
{               
    uint32_t n = maxoffs * sizeof(uint32_t);

    if (n &gt; maxdata) {
        bio-&gt;flags = BIO_F_OVERFLOW;
        bio-&gt;data_avail = 0;
        bio-&gt;offs_avail = 0;            
        return;
    }       

    bio-&gt;data = bio-&gt;data0 = (char *) data + n;
    bio-&gt;offs = bio-&gt;offs0 = data;
    bio-&gt;data_avail = maxdata - n;
    bio-&gt;offs_avail = maxoffs;
    bio-&gt;flags = 0;
}</code></pre><p>说明：bio_init()就是对struct binder_io的各个成员赋值。</p>
<p><a name="anchor5"></a></p>
<h1 id="5-bio-init-from-txn"><a href="#5-bio-init-from-txn" class="headerlink" title="5. bio_init_from_txn()"></a>5. bio_init_from_txn()</h1><pre><code>void bio_init_from_txn(struct binder_io *bio, struct binder_txn *txn)
{           
    bio-&gt;data = bio-&gt;data0 = txn-&gt;data;    // 数据起始地址
    bio-&gt;offs = bio-&gt;offs0 = txn-&gt;offs;    // 数据中对象的偏移数组的起始地址
    bio-&gt;data_avail = txn-&gt;data_size;      // 数据大小
    bio-&gt;offs_avail = txn-&gt;offs_size / 4;  // 对象个数
    bio-&gt;flags = BIO_F_SHARED;
}</code></pre><p>说明：bio_init_from_txn()就是根据已有的数据txn初始化struct binder_io的各个成员。 </p>
<p><a name="anchor6"></a></p>
<h1 id="6-svcmgr-handler"><a href="#6-svcmgr-handler" class="headerlink" title="6. svcmgr_handler()"></a>6. svcmgr_handler()</h1><pre><code>int svcmgr_handler(struct binder_state *bs,
                   struct binder_txn *txn,
                   struct binder_io *msg,
                   struct binder_io *reply)
{
    struct svcinfo *si;
    uint16_t *s;
    unsigned len;
    void *ptr;  
    uint32_t strict_policy;
    int allow_isolated;

    if (txn-&gt;target != svcmgr_handle)
        return -1;

    ...
    // 数据有效性检测(数据头)
    strict_policy = bio_get_uint32(msg);
    s = bio_get_string16(msg, &amp;len);
    if ((len != (sizeof(svcmgr_id) / 2)) ||
        memcmp(svcmgr_id, s, sizeof(svcmgr_id))) {
        ...
    }

    switch(txn-&gt;code) {
        case SVC_MGR_GET_SERVICE:
        case SVC_MGR_CHECK_SERVICE:
            ...

        case SVC_MGR_ADD_SERVICE:
            s = bio_get_string16(msg, &amp;len);
            ptr = bio_get_ref(msg);
            allow_isolated = bio_get_uint32(msg) ? 1 : 0;
            if (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated))
                return -1;
            break;
        case SVC_MGR_LIST_SERVICES:
            ...
    }

    bio_put_uint32(reply, 0);
    return 0;
}</code></pre><p>说明：<br>(01) txt-&gt;target对应tr.target.ptr，而tr.target.ptr是Binder驱动的在binder_thread_read()中赋值的，它指向Service Manager的Binder实体在用户空间的句柄，是NULL。而svcmgr_handle=BINDER_SERVICE_MANAGER=((void*) 0)。显然，txt-&gt;target=svcmgr_handler。<br>(02) 接下来，先通过bio_get_uint32(msg)和bio_get_string16(msg, &amp;len)进行有效性检测。通过bio_get_uint32()从msg中取出32位的整型数，就是MediaPlayerService请求数据中的STRICT_MODE_PENALTY_GATHER。然后，通过bio_get_string16(msg, &amp;len)获取数据中字符串，也就是”android.os.IServiceManager”。接着，将该字符串和svcmgr_id进行比较(依次比较长度和内容)；很显然，这里是相当的。<br>(03) 在通过有效性检测之后，就根据相应的事务编码进行处理。这里txt-&gt;code的值是SVC_MGR_ADD_SERVICE。先通过bio_get_string16()获取MediaPlayerService的名称，也就是s=”media.player”，然后就通过bio_get_ref()获取MediaPlayerService对象的引用。  </p>
<p><a name="anchor7"></a></p>
<h1 id="7-svcmgr-handler"><a href="#7-svcmgr-handler" class="headerlink" title="7. svcmgr_handler()"></a>7. svcmgr_handler()</h1><pre><code>void *bio_get_ref(struct binder_io *bio)
{   
    struct binder_object *obj;

    obj = _bio_get_obj(bio);
    if (!obj)
        return 0;

    if (obj-&gt;type == BINDER_TYPE_HANDLE)
        return obj-&gt;pointer;

    return 0;
}       </code></pre><p>说明：binder_object是与flat_binder_object对应的结构体，关于它的详细介绍可以参考<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。<br>(01) _bio_get_obj(bio)的代码就不展开了，它是根据bio创建binder_object对象。实际上，obj就是MediaPlayerService打包成的flat_binder_object对象。<br>(02) obj-&gt;type的值是BINDER_TYPE_HANDLE。原来MediaPlayerService对应的type是BINDER_TYPE_BINDER，但在Binder驱动的binder_transaction()中，将type修改成了BINDER_TYPE_HANDLE。因此，返回obj-&gt;pointer，而obj-&gt;pointer实际上是flat_binder_object中的handle，而该handle在Binder驱动中被赋值为”MediaPlayerService对应的Binder引用的描述，即binder_ref-&gt;desc”。根据该引用描述，可以在Binder驱动中找到MediaPlayerService对应的Binder实体以及MediaPlayerService对应的进程上下文信息，进而可以给MediaPlayerService发送消息。  </p>
<p><a name="anchor8"></a></p>
<h1 id="8-svcmgr-handler"><a href="#8-svcmgr-handler" class="headerlink" title="8. svcmgr_handler()"></a>8. svcmgr_handler()</h1><p>接下来，回到svcmgr_handler()中，继续执行do_add_service()。</p>
<pre><code>int do_add_service(struct binder_state *bs,
                   uint16_t *s, unsigned len,
                   void *ptr, unsigned uid, int allow_isolated)
{
    struct svcinfo *si;
    ...

    if (!svc_can_register(uid, s)) {
        ...
    }

    si = find_svc(s, len);
    if (si) {
        ...
    } else {
        si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t));
        if (!si) { 
            ...
        }
        si-&gt;ptr = ptr;
        si-&gt;len = len;
        memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t));
        si-&gt;name[len] = &apos;\0&apos;;
        si-&gt;death.func = svcinfo_death;
        si-&gt;death.ptr = si;
        si-&gt;allow_isolated = allow_isolated;
        si-&gt;next = svclist;
        svclist = si;
    }

    binder_acquire(bs, ptr);
    binder_link_to_death(bs, ptr, &amp;si-&gt;death);
    return 0;
}</code></pre><p>说明：do_add_service()是将该MediaPlayerService<br>(01) 先看看参数。bs是struct binder_state类型，它在保存了打开”/dev/binder”文件的相关信息。s是IBinder对象的名称，即”media.player”。len是s的长度。ptr是MediaPlayerService在Binder驱动中的引用描述。uid是MediaPlayerService的uid。allow_isolated是flase。<br>(02) svc_can_register()是检测能否将uid线程的信息注册到Service Manager中。这里，返回true。<br>(03) find_svc(s, len)是在Service Manager的服务队列svclist中，查找是否有名称为s的服务。由于之前没有将MediaPlayerService注册到Service Manager中，这里返回的si=null；接下来，就将MediaPlayerService的信息保存到si中，然后再将si注册到svclist中。<br>这样，MediaPlayerService就注册到Service Manager中了。</p>
<p><a name="anchor9"></a></p>
<h1 id="9-svcmgr-handler"><a href="#9-svcmgr-handler" class="headerlink" title="9. svcmgr_handler()"></a>9. svcmgr_handler()</h1><p>接下来，回到svcmgr_handler()中，调用bio_put_uint32(reply, 0)。这里就不对bio_put_uint32()的代码进行展开了，bio_put_uint32(reply, val)的作用是将val写入到reply中。但是，当val=0时，不会写入任何数据；也就是说bio_put_uint32(reply, 0)不会写入任何数据到reply中！</p>
<pre><code>int svcmgr_handler(struct binder_state *bs,
                   struct binder_txn *txn,
                   struct binder_io *msg,
                   struct binder_io *reply)
{
    ...

    switch(txn-&gt;code) {

        case SVC_MGR_ADD_SERVICE:
            s = bio_get_string16(msg, &amp;len);
            ptr = bio_get_ref(msg);
            allow_isolated = bio_get_uint32(msg) ? 1 : 0;
            if (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid, allow_isolated))
                return -1;
            break;
            ...
    }

    bio_put_uint32(reply, 0);
    return 0;
}</code></pre><p>接着，回到binder_parse()中，调用binder_send_reply()写入到即将发送Binder的缓冲区中。</p>
<p><a name="anchor10"></a></p>
<h1 id="10-svcmgr-handler"><a href="#10-svcmgr-handler" class="headerlink" title="10. svcmgr_handler()"></a>10. svcmgr_handler()</h1><pre><code>void binder_send_reply(struct binder_state *bs,
                       struct binder_io *reply,
                       void *buffer_to_free,
                       int status)
{   
    struct {
        uint32_t cmd_free;
        void *buffer;
        uint32_t cmd_reply;
        struct binder_txn txn;
    } __attribute__((packed)) data;

    data.cmd_free = BC_FREE_BUFFER;
    data.buffer = buffer_to_free;
    data.cmd_reply = BC_REPLY;
    data.txn.target = 0;
    data.txn.cookie = 0;
    data.txn.code = 0;
    if (status) {
        ...
    } else {
        data.txn.flags = 0;
        data.txn.data_size = reply-&gt;data - reply-&gt;data0;
        data.txn.offs_size = ((char*) reply-&gt;offs) - ((char*) reply-&gt;offs0);
        data.txn.data = reply-&gt;data0;
        data.txn.offs = reply-&gt;offs0;
    }
    binder_write(bs, &amp;data, sizeof(data));
}   </code></pre><p>说明：<br>(01) 先看看参数。bs是struct binder_state，它保存了打开”/dev/binder”文件的相关信息。reply没有任何数据。buffer_to_free是对应binder_transaction_data中保存请求数据的buffer缓冲区，它是在Binder驱动的binder_transaction()中分配的。status_t=0。<br>(02) 该函数中的私有结构体struct是用来描述返回给Binder驱动的数据。我们知道，Binder机制的交互数据的格式是”指令+数据”。这里，返回的指令有两个BC_FREE_BUFFER和BC_REPLY，BC_FREE_BUFFER是告诉Binder驱动，请求处理完毕，让Binder驱动释放数据缓冲；而BC_REPLY是告诉Binder驱动，这是回复，回复的内容是data.txt.data，实际上，这里的回复内容是空！<br>(03) 最后，调用binder_write()将数据打包。</p>
<p><a name="anchor11"></a></p>
<h1 id="11-binder-write-的源码"><a href="#11-binder-write-的源码" class="headerlink" title="11. binder_write()的源码"></a>11. binder_write()的源码</h1><pre><code>int binder_write(struct binder_state *bs, void *data, unsigned len)
{
    struct binder_write_read bwr;
    int res;
    bwr.write_size = len;                // 数据长度
    bwr.write_consumed = 0;             
    bwr.write_buffer = (unsigned) data;  // 数据是BINDER_WRITE_READ
    bwr.read_size = 0;
    bwr.read_consumed = 0;
    bwr.read_buffer = 0;
    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
    if (res &lt; 0) {
        fprintf(stderr,&quot;binder_write: ioctl failed (%s)\n&quot;,
                strerror(errno));
    }
    return res;
}</code></pre><p>说明：binder_write()单单只是向Binder驱动发送一个消息，而不会去读取消息反馈。</p>
<p><a name="anchor12"></a></p>
<h2 id="12-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#12-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="12. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>12. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h2><p>下面我们看看Binder驱动部分的对应代码。</p>
<pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：bwr.write_size&gt;0，而bwr.read_size=0；因此，只会执行写动作，而不会进行读取动作。下面看看binder_thread_write()到底写了些什么。</p>
<p><a name="anchor13"></a></p>
<h2 id="13-Binder驱动中binder-thread-write-的源码"><a href="#13-Binder驱动中binder-thread-write-的源码" class="headerlink" title="13. Binder驱动中binder_thread_write()的源码"></a>13. Binder驱动中binder_thread_write()的源码</h2><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
            void __user *buffer, int size, signed long *consumed)
{
    uint32_t cmd; 
    void __user *ptr = buffer + *consumed;
    void __user *end = buffer + size;

    // 读取binder_write_read.write_buffer中的内容。
    // 每次读取32bit(即4个字节)
    while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
        if (get_user(cmd, (uint32_t __user *)ptr))
            return -EFAULT;
        ptr += sizeof(uint32_t);

        ...
        switch (cmd) {

        case BC_FREE_BUFFER: {
            void __user *data_ptr;
            struct binder_buffer *buffer;

            // 获取要释放的内存地址
            if (get_user(data_ptr, (void * __user *)ptr))
                return -EFAULT;
            ptr += sizeof(void *);

            // 根据用户空间地址，得到进程空间地址；
            // 再根据进程空间地址，在proc-&gt;allocated_buffers红黑树中进行查找该地址对应的binder_buffer对象。
            buffer = binder_buffer_lookup(proc, data_ptr);
            ...
            // 释放内存
            trace_binder_transaction_buffer_release(buffer);
            binder_transaction_buffer_release(proc, buffer, NULL);
            binder_free_buf(proc, buffer);
            break;
        }
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
        ...
        }
        // 更新bwr.write_consumed的值
        *consumed = ptr - buffer;
    }
    return 0;
}</code></pre><p>说明：在Service Manager中，反馈给Binder驱动的指令有两个，分别是BC_FREE_BUFFER和BC_REPLY。<br>(01) binder_write_read()先读出BC_FREE_BUFFER指令，然后释放内存。代码中给出了相应的注释，这里就不再详细说明了。<br>(02) 接着，读出BC_REPLY指令，将数据拷贝到内核空间之后，便执行binder_transaction()对数据进行处理。</p>
<p><a name="anchor14"></a></p>
<h2 id="14-Binder驱动中binder-transaction-的源码"><a href="#14-Binder驱动中binder-transaction-的源码" class="headerlink" title="14. Binder驱动中binder_transaction()的源码"></a>14. Binder驱动中binder_transaction()的源码</h2><pre><code>static void binder_transaction(struct binder_proc *proc,
                   struct binder_thread *thread,
                   struct binder_transaction_data *tr, int reply)
{
    struct binder_transaction *t;
    struct binder_work *tcomplete;
    size_t *offp, *off_end;
    struct binder_proc *target_proc;
    struct binder_thread *target_thread = NULL;
    struct binder_node *target_node = NULL;
    struct list_head *target_list;
    wait_queue_head_t *target_wait;
    struct binder_transaction *in_reply_to = NULL;
    struct binder_transaction_log_entry *e;
    uint32_t return_error;

    ...

    if (reply) {
        // 事务栈
        in_reply_to = thread-&gt;transaction_stack;
        ...
        // 设置优先级
        binder_set_nice(in_reply_to-&gt;saved_priority);
        ...
        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;
        // 发起请求的线程，即MediaPlayerService所在线程。
        // from的值，是MediaPlayerService发起请求时在binder_transaction()中赋值的。
        target_thread = in_reply_to-&gt;from;
        ...
        // MediaPlayerService对应的进程
        target_proc = target_thread-&gt;proc;
    } else {
        ...
    }
    if (target_thread) {
        e-&gt;to_thread = target_thread-&gt;pid;
        target_list = &amp;target_thread-&gt;todo;
        target_wait = &amp;target_thread-&gt;wait;
    } else {
        ...
    }
    e-&gt;to_proc = target_proc-&gt;pid;

    // 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
    t = kzalloc(sizeof(*t), GFP_KERNEL);
    if (t == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_alloc_t_failed;
    }

    // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
    if (tcomplete == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_alloc_tcomplete_failed;
    }
    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);

    t-&gt;debug_id = ++binder_last_id;
    e-&gt;debug_id = t-&gt;debug_id;

    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
        t-&gt;from = thread;
    else
        t-&gt;from = NULL;
    // 下面的一些赋值是初始化事务t
    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
    // 事务将交给target_proc进程进行处理
    t-&gt;to_proc = target_proc;
    // 事务将交给target_thread线程进行处理
    t-&gt;to_thread = target_thread;
    // 事务编码
    t-&gt;code = tr-&gt;code;
    // 事务标志
    t-&gt;flags = tr-&gt;flags;
    // 事务优先级
    t-&gt;priority = task_nice(current);

    // 分配空间
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    if (t-&gt;buffer == NULL) {
        return_error = BR_FAILED_REPLY;
        goto err_binder_alloc_buf_failed;
    }
    t-&gt;buffer-&gt;allow_user_free = 0;
    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
    // 保存事务
    t-&gt;buffer-&gt;transaction = t;
    // target_node为NULL
    t-&gt;buffer-&gt;target_node = target_node;
    trace_binder_transaction_alloc_buf(t-&gt;buffer);
    if (target_node)
        binder_inc_node(target_node, 1, 0, NULL);

    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));

    // 将&quot;用户传入的数据&quot;保存到事务中
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户传入的数据偏移地址&quot;保存到事务中
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }

    ...
    off_end = (void *)offp + tr-&gt;offsets_size;
    for (; offp &lt; off_end; offp++) {
        ...
    }
    if (reply) {
        binder_pop_transaction(target_thread, in_reply_to);
    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {
        ...
    } else {
        ...
    }
    // 设置事务的类型为BINDER_WORK_TRANSACTION
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    // 将事务添加到target_list队列中，即target_list的待处理事务中
    list_add_tail(&amp;t-&gt;work.entry, target_list);
    // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
    // 唤醒目标进程
    if (target_wait)
        wake_up_interruptible(target_wait);
    return;
    ...
}</code></pre><p>说明：<br>(01) reply=1。这里只关注reply部分。target_thread被赋值为MediaPlayerService所在的线程，而target_proc则是MediaPlayerService对应的进程。<br>(02) 接着，会新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。这部分前面已经介绍过了；这里就不再重复说明了。从Service Manager反馈的信息中，仅仅包含了数据0，而没有flat_binder_object对象；因此，off_end=offp，不会执行for循环。<br>(03) 此时，MediaPlayerService已经成功的添加到了Server Manager守护进程中，接下来便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayerService线程的事务栈中删除该事务。<br>(04) 之后，便是设置事务的类型为BINDER_WORK_TRANSACTION，然后将其添加到target_list队列中。即，将事务添加到MediaPlayerService的待处理事务队列中。<br>(05) 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE，然后将其添加到thread-&gt;todo中。即，将其添加到当前线程(Service Manager守护进程的线程)的待处理事务队列中。<br>(06) 最后，调用wake_up_interruptible()唤醒MediaPlayerService进程。 </p>
<p>此时，Binder驱动就将addService的反馈内容以待处理事务t的方式添加到MediaPlayerService的待处理事务队列当中，并将MediaPlayerService进程唤醒了。而对于待完成工作tcomplete，肯定是告诉ServiceManager进程，它的反馈已经被Binder驱动收到。</p>
<p>下面，还是先说完ServiceManager的流程，然后再来看MediaPlayerService被唤醒后做了什么。</p>
<p>ServiceManager执行完binder_transaction()后，回到binder_thread_write()中；此时，数据已经处理完毕，便返回到binder_ioctl()中。binder_ioctl()将数据拷贝到用户空间后，Binder驱动的工作就结束了。<br>于是，又回到ServiceManager守护进程中，binder_write()执行完ioctl()后，返回到binder_send_reply()中，binder_send_reply()则进一步返回到binder_parse()。binder_parse()已经解析完请求数据，于是进一步返回到binder_loop()中。而binder_loop()会再次开始循环，调用ioctl(,BINDER_WRITE_READ,)到Binder驱动执行读操作。<br>当ServiceManager再次进入到Binder驱动，并通过binder_ioctl()调用到binder_thread_read()时。由于此时的ServiceManager线程中有一个类型为BINDER_WORK_TRANSACTION_COMPLETE的待处理事务；于是，便取出该事务进行执行。执行完毕之后，将该事务从Service Manager的待处理事务队列中删除，并反馈cmd=BR_TRANSACTION_COMPLETE信息给ServiceManager守护进程。ServiceManager守护进程收到Binder驱动的反馈后，解析出BR_TRANSACTION_COMPLETE，该指令什么也不做；它的目的是让ServiceManager知道，此次addService的反馈已经顺利完成！<br>于是，ServiceManager继续它的循环；当它再次调用ioctl()，进而进入到Binder驱动中读取请求时；由于此时的待处理事务队列为空，因此，ServiceManager会再次进入中断等待状态，等待Client的请求。</p>
<br>
至此，MediaPlayerService进程的addService的请求处理部分就讲解完了。在继续了解请求的反馈之前，先回顾一下本部分的内容。

<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService02_deal.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService02_deal.jpg" alt></a></p>
<p>MediaPlayerService将addService请求发送到Binder驱动，Binder驱动将addService转换成一个待处理事务并添加到ServiceManager的事务队列中，并将ServiceManager唤醒。ServiceManager被唤醒后，取出该处理；接着，Binder驱动将BR_TRANSACTION发送到ServiceManager守护进程中。ServiceManager通过BR_TRANSACTION解析出addService请求；在从请求数据中解析出MediaPlayerService的相关信息后，并将这些信息存储在一个链表中。接着，ServiceManager守护进程反馈BC_FREE_BUFFER和BC_REPLY给Binder驱动。Binder驱动收到BC_FREE_BUFFER后，释放保存事务数据的内存；在收到BC_REPLY之后，得知ServiceManager已经处理完addService请求。于是，将一个待处理事务添加到MediaPlayerService的事务队列中；然后将MediaPlayerService唤醒。目的是告诉MediaPlayerService，它已经处理完了addService请求。  最后，Binder驱动还需要反馈一个BR_TRANSACTION_COMPLETE给ServiceManager进程，目的是告诉ServiceManager，Binder驱动已经收到了它的回复。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/05/android/os/binder/2014-09-05-BinderCommunication-AddService01/" itemprop="url">Android Binder机制(五) addService详解01之 请求的发送</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-05T01:01:00.000Z" itemprop="datePublished">9月 5 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 read (About 13173 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>终于要开始讲解Client-Server交互了，若标题所示，本文要讲解的是addService请求，即添加服务请求。本文选取的题材是MediaPlayerService服务通过addService请求注册到ServiceManager中。<br>在这个addService请求中，MediaPlayerService是Client，而ServiceManager是Server。由于涉及到的过程比较复杂，这里会将addService请求分为3篇进行说明，这3篇的主题分别是：请求的发送，请求的处理，以及请求的反馈。和以往一样，在讲解详细的代码之前，先做个整体介绍。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-addService流程的时序图"><a href="#1-addService流程的时序图" class="headerlink" title="1. addService流程的时序图"></a>1. addService流程的时序图</h1><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService_01_flow.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService_01_flow.jpg" alt></a></p>
<p>上面是addService流程的时序图。理解这个图的前提是理解图中的三种角色之间的关系：<br>(01) MediaPlayerService和ServiceManager是两个不同的进程。它们都位于用户空间，都有各自的内存单元，两者之间不能直接进行通信；因此，需要Binder驱动的帮助才能通信。<br>(02) Binder驱动位于内核空间，它映射到节点”/dev/binder”上。MediaPlayerService和ServiceManager都有通过open(“/dev/binder”)打开该节点，并通过mmap()将内存映射到各自所在的进程中；这也就是说MediaPlayerService能和Binder驱动通信，而且ServiceManager也能和Binder驱动通信。而在Binder驱动中，有一个全局变量，依靠这个全局变量，就能实现MediaPlayerService和ServiceManager之间的通信。  依靠的这个全局变量，就是<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中介绍过的binder_context_mgr_node变量，它是ServiceManager的Binder实体。</p>
<p>搞清楚它们三者之间的关系之后，再回到上面的时序图中。  </p>
<ol>
<li><p>WAIT<br>这表示ServiceManager进入了中断等待状态。它进入等待状态的详细流程，在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>有介绍过。  </p>
</li>
<li><p>BC_TRANSACTION<br>这是MediaPlayerService向ServiceManager发送addService请求对应的事务。这个事务是请求，而不是回复；因此是BC开发，B代表Binder，而C代表Command。如果是回复，则会以BR开发，R表示Reply。Binder驱动在收到BC_TRANSACTION之后，会将分配内存，将请求数据保存到所分配的内存中。</p>
</li>
<li><p>WAKE_UP<br>MediaPlayerService通过BC_TRANSACTION提交一个请求，该请求是交给ServiceManager来处理的。因此，Binder驱动在收到该请求后，会将其发送到ServiceManager的待处理事务队列中，并将ServiceManager唤醒。</p>
</li>
<li><p>BR_TRANSACTION_COMPLETE<br>MediaPlayerService在发起了一个请求之后，它需要知道该请求是否发送成功。因此，Binder驱动在将该请求提交给ServiceManager之后，会反馈一个BR_TRANSACTION_COMPLETE给MediaPlayerService，表示MediaPlayerService发送的请求已经被Binder驱动收到了。</p>
</li>
<li><p>WAIT<br>MediaPlayerService在知道自己的请求已经发送成功之后，就进入等待状态，等待请求的反馈结果。</p>
</li>
<li><p>BR_NOOP和BR_TRANSACTION<br>ServiceManager被唤醒之后，收到Binder驱动的BR_NOOP和BR_TRANSACTION指令。BR_NOOP指令什么也不会做；而对于BR_TRANSACTION指令时，ServiceManager在解析出该事务是添加服务请求，会将MediaPlayerService的相关信息保存到一个链表中。</p>
</li>
<li><p>BC_FREE_BUFFER和BC_REPLY<br>ServiceManager在保存了MediaPlayerService的相关信息之后，便处理完毕了MediaPlayerService的请求。此时，它便反馈BC_FREE_BUFFER和BC_REPLY给Binder驱动。Binder驱动在收到BC_FREE_BUFFER之后，会释放保存请求数据所申请的内存；收到BC_REPLY之后，Binder驱动则知道ServiceManager已经处理完了MediaPlayerService的请求。<br>接着，Binder驱动便会唤醒MediaPlayerService，并发送BR_NOOP和BR_REPLY给MediaPlayerService，告诉MediaPlayerService请求已经处理完毕。同时，它还会发送一个BR_TRANSACTION_COMPLETE给ServiceManager，告诉ServiceManager该事务已经处理完毕。 MediaPlayerService在收到BR_REPLY反馈之后，知道addService请求已经成功处理；接着，它会再次进入等待状态，等待Client的请求。<br>最后，ServiceManager处理MediaPlayerService的请求之后，没有其他事务可处理，也再次进入了等待状态。</p>
</li>
</ol>
<p><a name="anchor2"></a></p>
<h1 id="2-IMediaPlayerService的类图"><a href="#2-IMediaPlayerService的类图" class="headerlink" title="2. IMediaPlayerService的类图"></a>2. IMediaPlayerService的类图</h1><p>本文是以MediaPlayerService为例，对addService进行解析。下面看看MediaPlayerService相关联的类图。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/IMediaPlayerService_leitu.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/IMediaPlayerService_leitu.jpg" alt></a></p>
<p>IMediaPlayerService的类图和”<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>“中IServiceManager的类图类似。这里就不再逐一对每个类进行介绍了。</p>
<p>需要知道的是，对于一个MediaPlayerService而言，它存在一个”远程BpBinder对象”和”本地BBinder对象”。<br>(01) 远程BpBinder对象的作用，是和Binder驱动进行交互。例如，当本文所讲到的addService请求，就是通过defaultServiceManager()调用到远程BpBinder对象的transact()方法，而该方法又会调用到IPCThreadState::transact()接口，通过IPCThreadState类来和Binder驱动交互。<br>(02) MediaPlayerService是”本地BBinder的子类”。当Client向MediaPlayerService发起请求时，会调用BBinder的onTransact()方法，而BnServiceManager又重写了该方法，从而调用onTransact()完成对请求的处理。</p>
<p><a name="anchor3"></a></p>
<h1 id="addService请求发送的代码解析"><a href="#addService请求发送的代码解析" class="headerlink" title="addService请求发送的代码解析"></a>addService请求发送的代码解析</h1><p>下面通过代码来查看addService请求的发送流程。</p>
<p><a name="anchor3_1"></a></p>
<h2 id="1-MediaPlayerService的main-函数"><a href="#1-MediaPlayerService的main-函数" class="headerlink" title="1. MediaPlayerService的main()函数"></a>1. MediaPlayerService的main()函数</h2><p>先看看MediaPlayerService的main()函数代码。</p>
<pre><code>int main(int argc, char** argv)
{
    signal(SIGPIPE, SIG_IGN);
    char value[PROPERTY_VALUE_MAX];
    bool doLog = (property_get(&quot;ro.test_harness&quot;, value, &quot;0&quot;) &gt; 0) &amp;&amp; (atoi(value) == 1);
    pid_t childPid;

    if (doLog &amp;&amp; (childPid = fork()) != 0) {
        ...
    } else {
        // all other services
        ...
        sp&lt;ProcessState&gt; proc(ProcessState::self());
        sp&lt;IServiceManager&gt; sm = defaultServiceManager();
        ...
        MediaPlayerService::instantiate();
        ...
        ProcessState::self()-&gt;startThreadPool();
        IPCThreadState::self()-&gt;joinThreadPool();
    }
}</code></pre><p>说明：该代码在frameworks/av/media/mediaserver/main_mediaserver.cpp中。<br>(01) property_get(“ro.test_harness”, value, “0”)是获取”ro.test_harness”属性，为false。<br>(02) ProcessState:self()是获取ProcessState对象，并赋值给proc。ProcessState::self()在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中已经介绍过了。<br>(03) defaultServiceManager()是获取IServiceManager对象，它的实现在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中也有详细介绍。<br>(04) MediaPlayerService::instantiate()是初始化MediaPlayerService服务。  </p>
<p><a name="anchor3_2"></a></p>
<h2 id="2-MediaPlayerService-instantiate"><a href="#2-MediaPlayerService-instantiate" class="headerlink" title="2. MediaPlayerService::instantiate()"></a>2. MediaPlayerService::instantiate()</h2><pre><code>void MediaPlayerService::instantiate() {
    defaultServiceManager()-&gt;addService(
            String16(&quot;media.player&quot;), new MediaPlayerService());
}</code></pre><p>说明：该代码在frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp中。它会新建MediaPlayerService对象；然后调用defaultServiceManager()获取到的BpServiceManager的实例；最后，调用BpServiceManager的addService()方法，将MediaPlayerService对象添加到Service Manager中。MediaPlayerService服务的名称是”media.player”。</p>
<p><a name="anchor3_3"></a></p>
<h2 id="3-MediaPlayerService-MediaPlayerService"><a href="#3-MediaPlayerService-MediaPlayerService" class="headerlink" title="3. MediaPlayerService::MediaPlayerService()"></a>3. MediaPlayerService::MediaPlayerService()</h2><pre><code>MediaPlayerService::MediaPlayerService()
{
    ALOGV(&quot;MediaPlayerService created&quot;);
    mNextConnId = 1; 

    mBatteryAudio.refCount = 0; 
    for (int i = 0; i &lt; NUM_AUDIO_DEVICES; i++) {
        mBatteryAudio.deviceOn[i] = 0; 
        mBatteryAudio.lastTime[i] = 0; 
        mBatteryAudio.totalTime[i] = 0; 
    }    
    // speaker is on by default
    mBatteryAudio.deviceOn[SPEAKER] = 1; 
    mOOMKilling = false;
    MediaPlayerFactory::registerBuiltinFactories();
}</code></pre><p>说明：MediaPlayerService的构造函数比较简单，就是进行一些变量的初始化。</p>
<p><a name="anchor3_4"></a></p>
<h2 id="4-BpServiceManager-addService"><a href="#4-BpServiceManager-addService" class="headerlink" title="4. BpServiceManager::addService()"></a>4. BpServiceManager::addService()</h2><pre><code>class BpServiceManager : public BpInterface&lt;IServiceManager&gt;
{
public:
    ...

    virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service,          
            bool allowIsolated)         
    {     
        Parcel data, reply;             
        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
        data.writeString16(name);       
        data.writeStrongBinder(service);
        data.writeInt32(allowIsolated ? 1 : 0);
        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);          
        return err == NO_ERROR ? reply.readExceptionCode() : err;
    }     

    ...
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/IServiceManager.cpp中。addService()会现将MediaPlayerService服务的名称(“media.player”)以及它的实例等参数保存到data(Parcel对象)中，然后再调用remote()返回的BpBinder对象的transact()与Binder驱动进行交互。<br>(01) 先看看addService()的各个参数。name=”media.player”，即MediaPlayerService服务的名称；service就是MediaPlayerService对象，而IBinder是MediaPlayerService的父类；allowIsolated这个值默认为false，默认值的定义在frameworks/native/include/binder/IServiceManager.h的addService()函数声明中。<br>(02) Parcel是Binder通信的数据存储结构，它的各个成员和函数在<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>中有详细说明。<br>在向data中写入数据时，先通过writeInterfaceToken()写入数据头，这里的数据头是：int32的整形数+字符串(字符串是”android.os.IServiceManager”)。writeString16(name)写入的是服务的名称，即”media.player”。writeStrongBinder(service)是将MediaPlayerService封装到flat_binder_object结构体中。最后的writeInt32()暂时不用关心。<br>下面，我们逐个对data的赋值进行介绍。</p>
<p><a name="anchor3_5"></a></p>
<h2 id="5-Parcel-Parcel"><a href="#5-Parcel-Parcel" class="headerlink" title="5. Parcel::Parcel()"></a>5. Parcel::Parcel()</h2><p>先看看Parcel的构造函数。</p>
<pre><code>Parcel::Parcel()
{   
    initState(); 
}   </code></pre><p>说明：该代码在frameworks/native/libs/binder/Parcel.cpp中。  </p>
<p><a name="anchor3_6"></a></p>
<h2 id="6-Parcel-initState"><a href="#6-Parcel-initState" class="headerlink" title="6. Parcel::initState()"></a>6. Parcel::initState()</h2><pre><code>void Parcel::initState()
{
    mError = NO_ERROR;
    mData = 0;              // 数据的地址指针
    mDataSize = 0;          // 数据的大小
    mDataCapacity = 0;      // 数据的容量
    mDataPos = 0;           // 数据的位置
    mObjects = NULL;        // 保存对象的地址指针
    mObjectsSize = 0;       // 对象的个数
    mObjectsCapacity = 0;   // 对象的容量
    mNextObjectHint = 0;
    mHasFds = false;
    mFdsKnown = true;
    mAllowFds = true;
    mOwner = NULL;
}</code></pre><p>说明：该函数对Parcel的成员进行了初始化。</p>
<p><a name="anchor3_7"></a></p>
<h2 id="7-Parcel-writeInterfaceToken"><a href="#7-Parcel-writeInterfaceToken" class="headerlink" title="7. Parcel::writeInterfaceToken()"></a>7. Parcel::writeInterfaceToken()</h2><pre><code>下面看看data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor())的实现。getInterfaceDescriptor()是通过宏IMPLEMENT_META_INTERFACE()实现的，该宏已经在[Android Binder机制(四) defaultServiceManager()的实现][link_binder_04_defaultServiceManager]中介绍过了；getInterfaceDescriptor()的返回值是&quot;android.os.IServiceManager&quot;。  
即data.writeInterfaceToken(&quot;android.os.IServiceManager&quot;)。下面看看writeInterfaceToken()的实现。

status_t Parcel::writeInterfaceToken(const String16&amp; interface)
{       
    writeInt32(IPCThreadState::self()-&gt;getStrictModePolicy() |
               STRICT_MODE_PENALTY_GATHER);
    // currently the interface identification token is just its name as a string
    return writeString16(interface);
}   </code></pre><p>说明：该函数先通过writeInt32()写入一个32位的int数到Parcel中，然后再通过writeString16()将字符串写入到Parcel中。它所写入的是数据头，ServiceManager中收到该数据之后，会先获取数据头，并根据数据头来判断数据的有效性！<br>(01) IPCThreadState::self()返回IPCThreadState对象；然后，调用IPCThreadState::getStrictModePolicy()，返回的是mStrictModePolicy，mStrictModePolicy的初始值是0。因此，writeInt32()就可以简化为writeInt32(STRICT_MODE_PENALTY_GATHER)。<br>(02) writeString16(interface)是writeString16(“android.os.IServiceManager”)。</p>
<p><a name="anchor3_8"></a></p>
<h2 id="8-Parcel-writeInt32"><a href="#8-Parcel-writeInt32" class="headerlink" title="8. Parcel::writeInt32()"></a>8. Parcel::writeInt32()</h2><pre><code>status_t Parcel::writeInt32(int32_t val)
{   
    return writeAligned(val);
}   </code></pre><p>说明：该函数调用writeAligned()。</p>
<p><a name="anchor3_9"></a></p>
<h2 id="9-Parcel-writeAligned"><a href="#9-Parcel-writeAligned" class="headerlink" title="9. Parcel::writeAligned()"></a>9. Parcel::writeAligned()</h2><pre><code>template&lt;class T&gt;
status_t Parcel::writeAligned(T val) {
    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));

    if ((mDataPos+sizeof(val)) &lt;= mDataCapacity) {
restart_write:
        *reinterpret_cast&lt;T*&gt;(mData+mDataPos) = val;
        return finishWrite(sizeof(val));
    }

    status_t err = growData(sizeof(val));
    if (err == NO_ERROR) goto restart_write;
    return err;
}</code></pre><p>说明：writeAligned()的作用是是写入数据，比同步相应的变量。<br>(01) mDataPos的初始值=0，sizeof(val)=4，mDataCapacity的初始值=0。因此，if((mDataPos+sizeof(val)) &lt;= mDataCapacity)为false。<br>(02) 接下来，会先调用growData(sizeof(val))来增加容量，然后再将数据写入到mData中。  </p>
<p><a name="anchor3_10"></a></p>
<h2 id="10-Parcel-growData"><a href="#10-Parcel-growData" class="headerlink" title="10. Parcel::growData()"></a>10. Parcel::growData()</h2><pre><code>status_t Parcel::growData(size_t len)
{
    size_t newSize = ((mDataSize+len)*3)/2;
    return (newSize &lt;= mDataSize)
            ? (status_t) NO_MEMORY
            : continueWrite(newSize);
}</code></pre><p>说明：Parcel增加容量时，是按1.5倍进行增长。mDataSize=0，而len=4；因此会执行continueWrite(6)。  </p>
<p><a name="anchor3_11"></a></p>
<h2 id="11-Parcel-continueWrite"><a href="#11-Parcel-continueWrite" class="headerlink" title="11. Parcel::continueWrite()"></a>11. Parcel::continueWrite()</h2><pre><code>status_t Parcel::continueWrite(size_t desired)
{
    size_t objectsSize = mObjectsSize;

    ...

    if (mOwner) {
        ...
    } else if (mData) {
        ...

        // We own the data, so we can just do a realloc().
        if (desired &gt; mDataCapacity) {
            uint8_t* data = (uint8_t*)realloc(mData, desired);
            if (data) {
                mData = data;
                mDataCapacity = desired;
            } else if (desired &gt; mDataCapacity) {
                ...
            }
        } else {
            ...
        }

    } else {
        ...
    }

    return NO_ERROR;
}</code></pre><p>说明：mObjectsSize的初始值为0，mOwner的初始值为NULL，mData非空；并且，desired=6，mDataCapacity=0。因此，会调用realloc()给mData重新分配内存大小为6字节。分配成功后，更新”数据地址mData”和”数据容量mDataCapacity=6”。  </p>
<p>接下来，回到writeAligned()中，它会跳转到restart_write标签处。先将int32_t的整形数保存到mData中，然后再调用finishWrite()进行同步。</p>
<p><a name="anchor3_12"></a></p>
<h2 id="12-Parcel-finishWrite"><a href="#12-Parcel-finishWrite" class="headerlink" title="12. Parcel::finishWrite()"></a>12. Parcel::finishWrite()</h2><pre><code>status_t Parcel::finishWrite(size_t len)
{
    mDataPos += len;
    if (mDataPos &gt; mDataSize) {
        mDataSize = mDataPos;
        ...
    }
    return NO_ERROR;
}</code></pre><p>说明：前面已经将数据写入到mData中，现在就通过finishWrite()来改变数据的当前指针位置(方便下一次写入)和数据的大小。<br>(01) len是int32_t的大小，很显然是4个字节，len=4。所以，mDataPos=4。<br>(02) mDataPos=4，mDataSize=0；因此if(mDataPos&gt;mDataSize)为true，所以，mDataSize=4。  </p>
<p>此时，就分析完了writeInterfaceToken()中的writeInt32()就分析完毕了.<br><strong>mData</strong>：它的第0~3个字节保存了int32_t类型的数据STRICT_MODE_PENALTY_GATHER。<br><strong>mDataPos</strong>：值为4，即下一个写入mData中的数据从第4个字节开始。<br><strong>mDataSize</strong>：值为4，即mData中数据的大小。<br><strong>mDataCapacity</strong>：值为6，即mData的数据容量为6字节。<br>此时，mData的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add01.jpg" alt></a></p>
<p>接下来，看看再writeString16(“android.os.IServiceManager”)如何将字符串写入到Parcel中。</p>
<p><a name="anchor3_13"></a></p>
<h2 id="13-Parcel-writeString16"><a href="#13-Parcel-writeString16" class="headerlink" title="13. Parcel::writeString16()"></a>13. Parcel::writeString16()</h2><pre><code>status_t Parcel::writeString16(const String16&amp; str)
{
    return writeString16(str.string(), str.size());
}

status_t Parcel::writeString16(const char16_t* str, size_t len)
{
    if (str == NULL) return writeInt32(-1);

    // 将字符串长度写入到Parcel中
    status_t err = writeInt32(len);
    if (err == NO_ERROR) {
        len *= sizeof(char16_t);
        // 在将字符串写入之前，增加mData的容量
        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));
        if (data) {
            // 将字符串拷贝到mData中
            memcpy(data, str, len);
            // 字符串结束符
            *reinterpret_cast&lt;char16_t*&gt;(data+len) = 0;
            return NO_ERROR;
        }
        err = mError;
    }
    return err;
}</code></pre><p>说明：writeString16()是重载函数。<br>(01) writeString16(str, len)中，str=”android.os.IServiceManager”；len是由str.size()得来，虽然这里的字符串是String16类型(即每个字符占2个字节)，但是str.size()是获取str中有效数据的个数(不包含字符串结束符)，因此，len=26。<br>(02) 首先调用writeInt32(len)将字符串的长度写入到Parcel中，writeInt32()在前面已经介绍过了。当再次写入int32_t类型的数据时，数据容量不够，会再次增长为12，即mDataCapacity=12；而写入int32_t类型的数据之后，mDataPos和mDataSize都增长为8。 此时，mData的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add02.jpg" alt></a></p>
<p>在通过writeInt32(len)写入数据长度之后，再重新计算len=52；接着，通过writeInplace()写入数据。  </p>
<p><a name="anchor3_14"></a></p>
<h2 id="14-Parcel-writeInplace"><a href="#14-Parcel-writeInplace" class="headerlink" title="14. Parcel::writeInplace()"></a>14. Parcel::writeInplace()</h2><pre><code>#define PAD_SIZE(s) (((s)+3)&amp;~3)

void* Parcel::writeInplace(size_t len)
{   
    // 4字节对齐
    const size_t padded = PAD_SIZE(len);

    ...

    if ((mDataPos+padded) &lt;= mDataCapacity) {
restart_write:                        
        uint8_t* const data = mData+mDataPos;

        // 如果padded!=len，则根据大端法还是小端法进行地址对齐设置。
        if (padded != len) {
            ...
        }

        finishWrite(padded);
        return data;
    }   

    status_t err = growData(padded);
    if (err == NO_ERROR) goto restart_write;
    return NULL;
}</code></pre><p>说明：参数len=54。<br>(01) PAD_SIZE()是4字节对齐的宏，PAD_SIZE(54)=56。<br>(02) 函数的初始值为padded=56，mDataPos=8，mDataCapacity=12。因此，会先调用growData(padded)来增加数据容量。growData()在前面已经介绍过；此时，它会将容量mDataCapacity增加至96。<br>(03) 接着会跳转到restart_write标签处，然后调用finishWrite(padded)来更新mDataPos和mDataSize。</p>
<p>至此，writeInplace()就分析完了，它的作用就是增加mData的容量，并返回即将写入数据的地址。接着，回到writeString16()中，执行mmap(data, str, len)将数据拷贝到mData中；拷贝完毕之后，设置字符串的结束符为0。</p>
<pre><code>status_t Parcel::writeString16(const char16_t* str, size_t len)
{
    if (str == NULL) return writeInt32(-1);

    // 将字符串长度写入到Parcel中
    status_t err = writeInt32(len);
    if (err == NO_ERROR) {
        len *= sizeof(char16_t);
        // 在将字符串写入之前，增加mData的容量
        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));
        if (data) {
            // 将字符串拷贝到mData中
            memcpy(data, str, len);
            // 字符串结束符
            *reinterpret_cast&lt;char16_t*&gt;(data+len) = 0;
            return NO_ERROR;
        }
        err = mError;
    }
    return err;
}</code></pre><br>
这样，data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor())就分析完了。此时，mData中数据如下图所示：

<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add03.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add03.jpg" alt></a></p>
<p><a name="anchor3_15"></a></p>
<h2 id="15-Parcel-writeString16"><a href="#15-Parcel-writeString16" class="headerlink" title="15. Parcel::writeString16()"></a>15. Parcel::writeString16()</h2><p>继续回到addService()中，接着会通过data.writeString16(name)将MediaPlayerService服务的名称写入到data中，此处的name=”media.player”。在前面已经详细介绍过writeString16()，这里执行完该语句后，mData中的数据如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add04.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add04.jpg" alt></a></p>
<p>接着，addService()会调用data.writeStrongBinder(service)将MediaPlayerService对象写入到data中。这个数据最重要，下面分析下writeStrongBinder()的实现。  </p>
<p><a name="anchor3_16"></a></p>
<h2 id="16-Parcel-writeStrongBinder"><a href="#16-Parcel-writeStrongBinder" class="headerlink" title="16. Parcel::writeStrongBinder()"></a>16. Parcel::writeStrongBinder()</h2><pre><code>status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)
{
    return flatten_binder(ProcessState::self(), val, this);
}</code></pre><p>说明：该函数调用flatten_binder()将数据打包。</p>
<p><a name="anchor3_17"></a></p>
<h2 id="17-Parcel-flatten-binder"><a href="#17-Parcel-flatten-binder" class="headerlink" title="17. Parcel::flatten_binder()"></a>17. Parcel::flatten_binder()</h2><pre><code>status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; proc,
    const sp&lt;IBinder&gt;&amp; binder, Parcel* out)
{       
    flat_binder_object obj;

    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
    if (binder != NULL) {
        IBinder *local = binder-&gt;localBinder();
        if (!local) {
            ...
        } else {
            obj.type = BINDER_TYPE_BINDER;
            obj.binder = local-&gt;getWeakRefs();
            obj.cookie = local;
        }       
    } else {
        ...
    }

    return finish_flatten_binder(binder, obj, out);
}</code></pre><p>说明：该函数是将MediaPlayerService对象封装到结构体flat_binder_object中。Binder驱动认识flat_binder_object结构体类型的数据，在C++层将数据发送给Binder驱动后，Binder驱动能够解析该结构体。<br>(01) 先看看参数，proc是ProcessState对象，binder是MediaPlayerService对象，out是Parcel自己。<br>(02) binder不为NULL，因此，执行if(binder!=NULL)中的语句。binder-&gt;localBinder()返回的BBinder对象，即本地Binder对象。(BBinder是MediaPlayerService的父类，localBinder()函数在frameworks/native/libs/binder/Binder.cpp中实现)。因此，local不为NULL。  </p>
<pre><code>obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;    // 标记
obj.type = BINDER_TYPE_BINDER;                      // 类型
obj.binder = local-&gt;getWeakRefs();                  // MediaPlayerService的弱引用
obj.cookie = local;                                 // MediaPlayerService自身</code></pre><p>注意：从这里就可以看出，MediaPlayerService添加服务时，发送给驱动的数据是MediaPlayerService的本地Binder对象，即BBinder实例。准确的来说，该数据是保存在obj.cookie中的，该数据的类型是BINDER_TYPE_BINDER。</p>
<p>(03) 调用finish_flatten_binder()将数据写入到Parcel中。</p>
<p><a name="anchor3_18"></a></p>
<h2 id="18-Parcel-finish-flatten-binder"><a href="#18-Parcel-finish-flatten-binder" class="headerlink" title="18. Parcel::finish_flatten_binder()"></a>18. Parcel::finish_flatten_binder()</h2><pre><code>inline static status_t finish_flatten_binder(
    const sp&lt;IBinder&gt;&amp; binder, const flat_binder_object&amp; flat, Parcel* out)
{       
    return out-&gt;writeObject(flat, false);
}       </code></pre><p>说明：该函数是flat_binder_object对象写入到Parcel中。 </p>
<p><a name="anchor3_19"></a></p>
<h2 id="19-Parcel-writeObject"><a href="#19-Parcel-writeObject" class="headerlink" title="19. Parcel::writeObject()"></a>19. Parcel::writeObject()</h2><pre><code>status_t Parcel::writeObject(const flat_binder_object&amp; val, bool nullMetaData)
{   
    const bool enoughData = (mDataPos+sizeof(val)) &lt;= mDataCapacity;
    const bool enoughObjects = mObjectsSize &lt; mObjectsCapacity;
    if (enoughData &amp;&amp; enoughObjects) {
restart_write:
        *reinterpret_cast&lt;flat_binder_object*&gt;(mData+mDataPos) = val;

        // val.binder非空
        if (nullMetaData || val.binder != NULL) {
            // 将地址偏移位置保存到mObjects[0]中
            mObjects[mObjectsSize] = mDataPos;
            acquire_object(ProcessState::self(), val, this);
            // 增加mObjectsSize的值
            mObjectsSize++;
        }

        ...

        return finishWrite(sizeof(flat_binder_object));
    }

    if (!enoughData) {
        const status_t err = growData(sizeof(val));
        if (err != NO_ERROR) return err;
    }
    if (!enoughObjects) {
        // 增加容量
        size_t newSize = ((mObjectsSize+2)*3)/2;
        // 分配内存
        size_t* objects = (size_t*)realloc(mObjects, newSize*sizeof(size_t));
        if (objects == NULL) return NO_MEMORY;
        // 设置mObjects的内存地址起始地址
        mObjects = objects;
        // 设置mObjects对象的容量
        mObjectsCapacity = newSize;
    }

    goto restart_write;
}</code></pre><p>说明：<br>(01) 此时，mDataPos=96, sizeof(val)=32, mDataCapacity=96；因此，enoughData=false。mObjectsSize和mObjectsCapacity的初始值=0，因此，enoughObjects=false。<br>(02) 首先，执行if(!enoughData)部分，通过growData()将数据的容量增加至192。即，mDataCapacity=192。<br>(03) 接着，执行if(!enoughObjects)部分，该部分的目的是分配对象空间，并修改mObjects和mObjectsCapacity的值。增加之后的容量mObjectsCapacity=3。<br>(04) 然后，跳转到restart_write标签处。 <em>reinterpret_cast&lt;flat_binder_object</em>&gt;(mData+mDataPos) = val是保存val对象到mDataPos+mDataPos所指的地址中。<br>(04) mObjects[mObjectsSize]=mDataPos，此处的mObjectsSize=0；这里是将对象的地址偏移mDataPos保存到mObjects[0]中。随后执行mObjectsSize++增加mObjectsSize的值为1。<br>(05) 最后，调用finishWrite()更新mDataPos和mDataSize的值。</p>
<p><br>至此，data.writeStrongBinder()就分析完了。将MediaPlayerService写入data之后，它的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add05.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add05.jpg" alt></a></p>
<p>最后，调用data.writeInt32(allowIsolated ? 1 : 0)。allowIsolated为false，因此，data.writeInt32(0)。执行该函数之后，data的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add06.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/parcel_add06.jpg" alt></a></p>
<p>以上就是addService()中的data的数据。接下来执行remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply)。前面已经说过，remote()返回的是BpBinder对象，该BpBinder对象是在<a href="/2014/09/04/Binder-defaultServiceManager/">Android Binder机制(四) defaultServiceManager()的实现</a>中调用defaultServiceManager()时初始化的。下面查看BpBinder的transact()。</p>
<p><a name="anchor3_20"></a></p>
<h2 id="20-BpBinder-transact"><a href="#20-BpBinder-transact" class="headerlink" title="20. BpBinder::transact()"></a>20. BpBinder::transact()</h2><pre><code>status_t BpBinder::transact(            
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // mAlive的初始值为1
    if (mAlive) {
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }

    return DEAD_OBJECT;
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/BpBinder.cpp中。由于mAlive的初始值为1，因此该函数会调用IPCThreadState::self()-&gt;transact()。我们知道，IPCThreadState::self()是获取全局IPCThreadState对象，因此最终会调用IPCThreadState::transact()。</p>
<p><a name="anchor3_21"></a></p>
<h2 id="21-IPCThreadState-transact"><a href="#21-IPCThreadState-transact" class="headerlink" title="21. IPCThreadState::transact()"></a>21. IPCThreadState::transact()</h2><pre><code>status_t IPCThreadState::transact(int32_t handle,
                                  uint32_t code, const Parcel&amp; data,
                                  Parcel* reply, uint32_t flags)
{
    status_t err = data.errorCheck();

    flags |= TF_ACCEPT_FDS;

    ...

    if (err == NO_ERROR) {
        ...
        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
    }

    ...

    if ((flags &amp; TF_ONE_WAY) == 0) {
        if (reply) {
            err = waitForResponse(reply);
        } else {
            ...
        }
    } else {
        ...
    }

    return err;
}</code></pre><p>说明：该代码在frameworks/native/libs/binder/IPCThreadState.cpp中。<br>(01) 先看看函数的参数。handle是BpBinder中的mHandle对象，BpBinder中的mHandle是ServiceManager的句柄，值为0。code=ADD_SERVICE_TRANSACTION。data就是在addService中设置的Parcel对象。reply是用来接收Binder驱动反馈数据的Parcel对象。flags是默认值0。<br>(02) 该函数会先通过writeTransactionData()将数据打包。<br>(03) flags的初始化为0，并且reply非空。因此，将数据打包号之后，会调用waitForResponse()将数据发送给Binder驱动，然后等待Binder驱动反馈。</p>
<p><a name="anchor3_22"></a></p>
<h2 id="22-IPCThreadState-writeTransactionData"><a href="#22-IPCThreadState-writeTransactionData" class="headerlink" title="22. IPCThreadState::writeTransactionData()"></a>22. IPCThreadState::writeTransactionData()</h2><pre><code>status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,
    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)
{
    binder_transaction_data tr;

    tr.target.handle = handle;
    tr.code = code;
    tr.flags = binderFlags;
    tr.cookie = 0;
    tr.sender_pid = 0;
    tr.sender_euid = 0;

    const status_t err = data.errorCheck();
    if (err == NO_ERROR) {
        tr.data_size = data.ipcDataSize();
        tr.data.ptr.buffer = data.ipcData();
        tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t);
        tr.data.ptr.offsets = data.ipcObjects();
    } else if (statusBuffer) {
        ..
    } else {
        ...
    }

    mOut.writeInt32(cmd);
    mOut.write(&amp;tr, sizeof(tr));

    return NO_ERROR;
}</code></pre><p>说明：该函数会读取Parcel中的数据，然后将其打包到binder_transaction_data结构体中。binder_transaction_data结构体是Binder驱动能够识别并对之进行解析的数据结构。<br>  ipcDataSize()是返回mDataSize，ipcData()是返回mData，ipcObjectsCount()是返回mObjectsSize，而ipcObjects则是返回mObjects。这些数据就是前面我们在addService中分析的Parcel对象的数据。下面给出初始化之后tr的值。  </p>
<pre><code>tr.target.handle = handle;  // 0，即Service Manager的句柄
tr.code = code;             // ADD_SERVICE_TRANSACTION
tr.flags = binderFlags;     // TF_ACCEPT_FDS
tr.cookie = 0;
tr.sender_pid = 0;

tr.data_size = data.ipcDataSize();      // 数据大小(对应mDataSize)
tr.data.ptr.buffer = data.ipcData();    // 数据的起始地址(对应mData)
tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t); // data中保存的对象个数(对应mObjectsSize)
tr.data.ptr.offsets = data.ipcObjects();                 // data中保存的对象的偏移地址数组(对应mObjects)</code></pre><p>初始化tr之后，将cmd=BC_TRANSACTION和tr重新打包到mOut中。mOut中的数据将来会被以请求的方式发送给Binder驱动。重新打包后的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/data_01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/data_01.jpg" alt></a></p>
<p>在上图中，mOut包含了”事务指令”+”binder_transaction_data”结构体对象。而具体的MediaPlayerService对象，则包含在binder_transaction_data的data数据区域；它是被封装在flat_binder_object结构体中的。</p>
<p><a name="anchor3_23"></a></p>
<h2 id="23-IPCThreadState-waitForResponse"><a href="#23-IPCThreadState-waitForResponse" class="headerlink" title="23. IPCThreadState::waitForResponse()"></a>23. IPCThreadState::waitForResponse()</h2><p>writeTransactionData()分析完毕之后，再看看waitForResponse()的代码。</p>
<pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) {
        // 先通过talkWithDriver()和Binder驱动交互
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        ...
        if (mIn.dataAvail() == 0) continue;

        // 然后读取返回结果，再根据结果进行处理
        cmd = mIn.readInt32();

        switch (cmd) {
        case BR_TRANSACTION_COMPLETE:
            ...
        case BR_DEAD_REPLY:
            ...
        case BR_FAILED_REPLY:
            ...
        case BR_ACQUIRE_RESULT:
            ...
        case BR_REPLY:
            ...
        default:
            err = executeCommand(cmd);
            if (err != NO_ERROR) goto finish;
            break;
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：waitForResponse()会先调用talkWithDriver()和Binder驱动交互，然后根据反馈结果来进行处理。</p>
<p><a name="anchor3_24"></a></p>
<h2 id="24-IPCThreadState-talkWithDriver"><a href="#24-IPCThreadState-talkWithDriver" class="headerlink" title="24. IPCThreadState::talkWithDriver()"></a>24. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    binder_write_read bwr;

    // Is the read buffer empty?
    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();
    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we&apos;ll read.
    if (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
        bwr.read_buffer = 0;
    }

    ...
    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    status_t err;
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：talkWithDriver()会先初始化bwr(binder_write_read类型的变量)，然后将bwr变量通过ioctl()发送给Binder驱动。该函数的参数doReceive的默认值为true。<br>(01) 现在，mIn中还没有被写入数据，因此它的值都是初始值。那么，mIn.dataPosition()返回mDataPos，它的值为0；mIn.dataSize()返回mDataSize，它的初始值也为0。因此，needRead=true。<br>(02) doReceive=true，但是needRead=true；因此，outAvail=mOut.dataSize，outAvail不为0。接下来，就对bwr进行初始化，关于bwr的介绍，请参考<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。bwr初始化完毕之后，各个成员的值如下：  </p>
<pre><code>bwr.write_size = outAvail;                          // mOut中数据大小，大于0
bwr.write_buffer = (long unsigned int)mOut.data();  // mOut中数据的地址
bwr.write_consumed = 0;
bwr.read_size = mIn.dataCapacity();                 // 256
bwr.read_buffer = (long unsigned int)mIn.data();    // mIn.mData，实际上为空
bwr.read_consumed = 0;</code></pre><p>(03) bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。</p>
<p>通过binder_write_read再次打包后的数据如下图所示：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/data_02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/data_02.jpg" alt></a></p>
<p>如上图所示，ioctl()传输的数据包含”BINDER_WRITE_READ”+”binder_write_read结构体对象”。在binder_write_read的write_buffer中包含了事务数据；而在数据数据的data中又包含了flat_binder_object等数据。在flat_binder_object中就包含了需要传输的MediaPlayerService对象。<br>总体来看，数据经过了三次封装。下面看看在Binder驱动中是如何一层层将它们剖析开来的。</p>
<p><a name="anchor3_25"></a></p>
<h2 id="25-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#25-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="25. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>25. Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h2><pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  // 中断等待函数。
  // 1. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。
  // 2. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。
  //    当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时；
  //    则继续执行；否则，再进入等待状态。
  ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);

  binder_lock(__func__);
  // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。
  thread = binder_get_thread(proc);
  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：关于该函数在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中已经介绍过了。这里将binder_write_read从用户空间拷贝到内核空间之后，读取bwr.write_size和bwr.read_size都&gt;0，因此先写后读。</p>
<p><a name="anchor3_26"></a></p>
<h2 id="26-Binder驱动中binder-thread-write-的源码"><a href="#26-Binder驱动中binder-thread-write-的源码" class="headerlink" title="26. Binder驱动中binder_thread_write()的源码"></a>26. Binder驱动中binder_thread_write()的源码</h2><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
      ...
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p>说明：读取出来的交易码是BC_TRANSACTION。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。  </p>
<p><a name="anchor3_27"></a></p>
<h2 id="27-Binder驱动中binder-transaction-的源码"><a href="#27-Binder驱动中binder-transaction-的源码" class="headerlink" title="27. Binder驱动中binder_transaction()的源码"></a>27. Binder驱动中binder_transaction()的源码</h2><pre><code>static void binder_transaction(struct binder_proc *proc,
                   struct binder_thread *thread,
                   struct binder_transaction_data *tr, int reply)
{
    struct binder_transaction *t;
    struct binder_work *tcomplete;
    size_t *offp, *off_end;
    struct binder_proc *target_proc;
    struct binder_thread *target_thread = NULL;
    struct binder_node *target_node = NULL;
    struct list_head *target_list;
    wait_queue_head_t *target_wait;
    struct binder_transaction *in_reply_to = NULL;
    struct binder_transaction_log_entry *e;
    uint32_t return_error;

    ...

    if (reply) {
        ...
    } else {
        if (tr-&gt;target.handle) {
            ...
        } else {
            // 事务目标对象是ServiceManager的binder实体
            // 即，该事务是交给Service Manager来处理的。
            target_node = binder_context_mgr_node;
            ...
        }
        ...
        // 设置处理事务的目标进程
        target_proc = target_node-&gt;proc;
        ...
    }

    if (target_thread) {
        ...
    } else {
        target_list = &amp;target_proc-&gt;todo;
        target_wait = &amp;target_proc-&gt;wait;
    }
    ...

    // 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
    t = kzalloc(sizeof(*t), GFP_KERNEL);
    ...

    // 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
    ...

    t-&gt;debug_id = ++binder_last_id;
    ...

    // 设置from，表示该事务是MediaPlayerService发起的
    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
        t-&gt;from = thread;
    else
        t-&gt;from = NULL;
    // 下面的一些赋值是初始化事务t
    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
    // 事务将交给target_proc进程进行处理
    t-&gt;to_proc = target_proc;
    // 事务将交给target_thread线程进行处理
    t-&gt;to_thread = target_thread;
    // 事务编码
    t-&gt;code = tr-&gt;code;
    // 事务标志
    t-&gt;flags = tr-&gt;flags;
    // 事务优先级
    t-&gt;priority = task_nice(current);

    ...

    // 分配空间
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    ...
    t-&gt;buffer-&gt;allow_user_free = 0;
    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
    // 保存事务
    t-&gt;buffer-&gt;transaction = t;
    // 保存事务的目标对象(即处理该事务的binder对象)
    t-&gt;buffer-&gt;target_node = target_node;
    trace_binder_transaction_alloc_buf(t-&gt;buffer);
    if (target_node)
        binder_inc_node(target_node, 1, 0, NULL);

    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));

    // 将&quot;用户空间的数据&quot;拷贝到内核中
    // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户空间的数据中所含对象的偏移地址&quot;拷贝到内核中
    // tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数
    // 拷贝之后，offp就是flat_binder_object对象数组在内核空间的偏移数组的起始地址
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }
    ...
    // off_end就是flat_binder_object对象数组在内核空间的偏移地址的结束地址
    off_end = (void *)offp + tr-&gt;offsets_size;
    // 将所有的flat_binder_object对象读取出来
    // 对MediaPlayerService而言，只有一个flat_binder_object对象。
    for (; offp &lt; off_end; offp++) {
        struct flat_binder_object *fp;
        ...
        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);

        switch (fp-&gt;type) {
        case BINDER_TYPE_BINDER:
        case BINDER_TYPE_WEAK_BINDER: {
            struct binder_ref *ref;
            // 在proc中查找binder实体对应的binder_node
            struct binder_node *node = binder_get_node(proc, fp-&gt;binder);
            // 若找不到，则新建一个binder_node；下次就可以直接使用了。
            if (node == NULL) {
                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);
                if (node == NULL) {
                    ...
                }
                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;
                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);
            }
            ...
            // 在target_proc(即，ServiceManager的进程上下文)中查找是否包行&quot;该Binder实体的引用&quot;，
            // 如果没有找到的话，则将&quot;该binder实体的引用&quot;添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该
Binder实体进行管理了。
            ref = binder_get_ref_for_node(target_proc, node);
            if (ref == NULL) {
                ...
            }
            // 修改type
            if (fp-&gt;type == BINDER_TYPE_BINDER)
                fp-&gt;type = BINDER_TYPE_HANDLE;
            else
                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;
            // 修改handle。handle和binder是联合体，这里将handle设为引用的描述。
            // 根据该handle可以找到&quot;该binder实体在target_proc中的binder引用&quot;；
            // 即，可以根据该handle，可以从Service Manager找到对应的Binder实体的引用，从而获取Binder实体。
            fp-&gt;handle = ref-&gt;desc;
            // 增加引用计数，防止&quot;该binder实体&quot;在使用过程中被销毁。
            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,
                       &amp;thread-&gt;todo);

            trace_binder_transaction_node_to_ref(t, node, ref);
            ...
        } break;
        ...
        }
    }
    if (reply) {
        ..
    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {
        BUG_ON(t-&gt;buffer-&gt;async_transaction != 0);
        t-&gt;need_reply = 1;
        t-&gt;from_parent = thread-&gt;transaction_stack;
        // 将当前事务添加到当前线程的事务栈中
        thread-&gt;transaction_stack = t;
    } else {
        ...
    }
    // 设置事务的类型为BINDER_WORK_TRANSACTION
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    // 将事务添加到target_list队列中，即target_list的待处理事务中
    list_add_tail(&amp;t-&gt;work.entry, target_list);
    // 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    // 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
    // 唤醒目标进程
    if (target_wait)
        wake_up_interruptible(target_wait);
    return;

    ...
}</code></pre><p>说明：这里的tr-&gt;target.handle=0，因此，会设置target_node为ServiceManager对应的Binder实体。下面是target_node,target_proc等值初始化之后的值。  </p>
<pre><code>target_node = binder_context_mgr_node; // 目标节点为Service Manager对应的Binder实体
target_proc = target_node-&gt;proc;       // 目标进程为Service Manager对应的binder_proc进程上下文信息
target_list = &amp;target_thread-&gt;todo;    // 待处理事务队列
target_wait = &amp;target_thread-&gt;wait;    // 等待队列</code></pre><p>目标节点是Service Manager对应的Binder实体。这是指MediaPlayerService的addService()这个指令是来提交给Service Manager进行处理的，它最终会发送给Service Manager进行处理。。</p>
<p>在初始化完target_node等目标节点之后，会新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。待处理事务t会被提交给目标(即ServiceManager对应的Binder实体)进行处理；而待完成的工作tcomplete则是为了反馈给MediaPlayerService服务，告诉MediaPlayerService它的请求Binder驱动已经收到了。注意，这里仅仅是告诉MediaPlayerService该请求已经被收到，而不是处理完毕！待ServiceManager处理完毕该请求之后，Binder驱动会再次反馈相应的消息给MediaPlayerService。</p>
<pre><code>// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)
t = kzalloc(sizeof(*t), GFP_KERNEL);
...

// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。
tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
...

t-&gt;debug_id = ++binder_last_id;
...

if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
    t-&gt;from = thread;
else
    t-&gt;from = NULL;
// 下面的一些赋值是初始化事务t
t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
// 事务将交给target_proc进程进行处理
t-&gt;to_proc = target_proc;
// 事务将交给target_thread线程进行处理
t-&gt;to_thread = target_thread;
// 事务编码
t-&gt;code = tr-&gt;code;
// 事务标志
t-&gt;flags = tr-&gt;flags;
// 事务优先级
t-&gt;priority = task_nice(current);

...

// 分配空间
t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
    tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
...
t-&gt;buffer-&gt;allow_user_free = 0;
t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
// 保存事务
t-&gt;buffer-&gt;transaction = t;
// 保存事务的目标对象(即处理该事务的binder对象)
t-&gt;buffer-&gt;target_node = target_node;
trace_binder_transaction_alloc_buf(t-&gt;buffer);
if (target_node)
    binder_inc_node(target_node, 1, 0, NULL);</code></pre><p>在初始化完待处理事务t之后，接着将MediaPlayerService请求的数据拷贝到内核空间并解析出来。从数据中解析出MediaPlayerService请求数据中的flat_binder_object对象，只有一个flat_binder_object对象。该flat_binder_object对象的类型是BINDER_TYPE_BINDER，然后调用binder_get_node()在当前进程的上下文环境proc中查找fp-&gt;binder对应的Binder实体，fp-&gt;binder是Android的flatten_binder()中赋值的，它是MediaPlayerService对象的本地引用的描述(即MediaPlayerService对应的BBinder对象的描述)；此外，在MediaPlayerService是初次与Binder驱动通信，因此肯定找不到该对象fp-&gt;binder对应的Binder实体；因此node=NULL。  接下来，就调用binder_new_node()新建fp-&gt;binder对应的Binder实体，这也就是MediaPlayerService对应的Binder实体。然后，调用binder_get_ref_for_node(target_proc, node)获取该Binder实体在target_proc(即ServiceManager的进程上下文环境)中的Binder引用，此时，在target_proc中肯定也找不到该Binder实体对应的引用；那么，就新建Binder实体的引用，并将其添加到target_proc-&gt;refs_by_node红黑树 和 target_proc-&gt;refs_by_desc红黑树中。 这样，Service Manager的进程上下文中就存在MediaPlayerService的Binder引用，Service Manager也就可以对MediaPlayerService进行管理了！<br>  然后，修改fp-&gt;type=BINDER_TYPE_HANDLE，并使fp-&gt;handle = ref-&gt;desc。</p>
<p>这样，就将MediaPlayerService的请求数据解析出来，并且在Binder驱动中创建了MediaPlayerService对应的Binder实体，而且将该Binder实体添加到MediaPlayerService的进程上下文proc中。更重要的是，在ServiceManager的refs_by_node和refs_by_desc这两颗红黑树中创建了”MediaPlayerService对应的Binder实体的Binder引用”。这意味着，在Binder驱动中，已经能在ServiceManager的进程上下文中找到MediaPlayerService。</p>
<pre><code>    // 将&quot;用户空间的数据&quot;拷贝到内核中
    // tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小
    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
        ...
    }
    // 将&quot;用户空间的数据中所含对象的偏移地址&quot;拷贝到内核中
    // tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数
    // 拷贝之后，offp就是flat_binder_object对象数组在内核空间的起始地址
    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
        ...
    }
    ...
    // off_end就是flat_binder_object对象数组在内核空间的结束地址
    off_end = (void *)offp + tr-&gt;offsets_size;
    // 将所有的flat_binder_object对象读取出来
    // 对MediaPlayerService而言，只有一个flat_binder_object对象。
    for (; offp &lt; off_end; offp++) {
        struct flat_binder_object *fp;
        ...
        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);

        switch (fp-&gt;type) {
        case BINDER_TYPE_BINDER:
        case BINDER_TYPE_WEAK_BINDER: {
            struct binder_ref *ref;
            // 在proc中查找binder实体对应的binder_node
            struct binder_node *node = binder_get_node(proc, fp-&gt;binder);
            // 若找不到，则新建一个binder_node；下次就可以直接使用了。
            if (node == NULL) {
                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);
                if (node == NULL) {
                    ...
                }
                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;
                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);
            }
            ...
            // 在target_proc(即，Service Manager的进程上下文)中查找是否包行&quot;该binder实体的引用&quot;，
            // 如果没有找到的话，则将&quot;该binder实体的引用&quot;添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该
Binder实体进行管理了。
            ref = binder_get_ref_for_node(target_proc, node);
            if (ref == NULL) {
                ...
            }
            // 修改type
            if (fp-&gt;type == BINDER_TYPE_BINDER)
                fp-&gt;type = BINDER_TYPE_HANDLE;
            else
                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;
            // 修改handle。handle和binder是联合体，这里将handle设为引用的描述。
            // 根据该handle可以找到&quot;该binder实体在target_proc中的binder引用&quot;；
            // 即，可以根据该handle，可以从Service Manager找到对应的binder实体的引用，从而获取binder实体。
            fp-&gt;handle = ref-&gt;desc;
            // 增加引用计数，防止&quot;该binder实体&quot;在使用过程中被销毁。
            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,
                       &amp;thread-&gt;todo);

            trace_binder_transaction_node_to_ref(t, node, ref);
            ...
        } break;
        ...
        }
    }</code></pre><p>然后，设置待处理事务的类型为BINDER_WORK_TRANSACTION，并将其添加到target_list中。即，添加事务到Service Manager对应的待处理事务队列中。<br>设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE，并将其添加到当前线程的待完成工作中。此时，Binder驱动已经收到了MediaPlayerService的请求，这个所谓的待完成工作，就是用来让Binder驱动告诉MediaPlayerService，它的请求已经被处理了。<br>最后，target_wait是ServiceManager的等待队列，肯定不为空(因为前面刚刚将BINDER_WORK_TRANSACTION事务添加到待处理事务中)。因此，便会执行wake_up_interruptible(target_wait)唤醒Service Manager进程。<br><strong>注意</strong>，此时都是运行在MediaPlayerService的进程中的！</p>
<pre><code>// 设置事务的类型为BINDER_WORK_TRANSACTION
t-&gt;work.type = BINDER_WORK_TRANSACTION;
// 将事务添加到target_list队列中，即target_list的待处理事务中
list_add_tail(&amp;t-&gt;work.entry, target_list);
// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE
tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。
list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
// 唤醒目标进程
if (target_wait)
    wake_up_interruptible(target_wait);
return;</code></pre><p>此时，MediaPlayerService进程还会继续运行，而且它也通过wake_up_interruptible()唤醒了ServiceManager进程。ServiceManager被唤醒后，所做的工作就是将MediaPlayerService注册到它的服务队列中进行管理；它的具体流程稍候再分析，现在还是先分析完MediaPlayerService进程。</p>
<p>至此，binder_transaction()就分析完了。在binder_transaction()中，我们主要进行了以下工作：<br>(01) 解析出来MediaPlayerService的请求数据。<br>(02) 新建MediaPlayerService对应的Binder实体和Binder引用，并将ServiceManager的进程上下文中存在MediaPlayerService的Binder引用。<br>(03) 新建了待处理事务，并将该事务添加到了ServiceManager的待处理事务队列中。然后，唤醒ServiceManager来处理该事务。<br>(04) 新建了待完成工作，并将待完成工作添加到了当前线程的待完成工作队列中。  </p>
<p><a name="anchor3_28"></a></p>
<h2 id="28-Binder驱动中binder-thread-write-的源码"><a href="#28-Binder驱动中binder-thread-write-的源码" class="headerlink" title="28. Binder驱动中binder_thread_write()的源码"></a>28. Binder驱动中binder_thread_write()的源码</h2><p>接着分析MediaPlayerService进程的工作。binder_thread_write()中执行binder_transaction()后，会更新*consumed的值，即bwr.write_consumed的值。意味着，Binder驱动已经驱动完成MediaPlayerService的请求数据。</p>
<pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
      ...
        case BC_TRANSACTION:
        case BC_REPLY: {
            struct binder_transaction_data tr;

            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
                return -EFAULT;
            ptr += sizeof(tr);
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            break;
        }
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p><a name="anchor3_29"></a></p>
<h2 id="29-Binder驱动中binder-thread-read-的源码"><a href="#29-Binder驱动中binder-thread-read-的源码" class="headerlink" title="29. Binder驱动中binder_thread_read()的源码"></a>29. Binder驱动中binder_thread_read()的源码</h2><p>接下来，ioctl()会执行binder_thread_read()来设置反馈数据给MediaPlayerService进程。  </p>
<pre><code>static int binder_thread_read(struct binder_proc *proc,
                  struct binder_thread *thread,
                  void  __user *buffer, int size,
                  signed long *consumed, int non_block)
{
    void __user *ptr = buffer + *consumed;
    void __user *end = buffer + size;

    int ret = 0;
    int wait_for_proc_work;

    // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区
    if (*consumed == 0) {
        if (put_user(BR_NOOP, (uint32_t __user *)ptr))
            return -EFAULT;
        ptr += sizeof(uint32_t);
    }

retry:
    // 等待proc进程的事务标记。
    // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。
    wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;
                list_empty(&amp;thread-&gt;todo);

    ...

    if (wait_for_proc_work) {
        ...
    } else {
        if (non_block) {
            ...
        } else
            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));
    }

    ...

    while (1) {
        uint32_t cmd;
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = NULL;

        // 如果当前线程的&quot;待完成工作&quot;不为空，则取出待完成工作。
        if (!list_empty(&amp;thread-&gt;todo))
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
            ...
        else {
            if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */
                goto retry;
            break;
        }

        ...

        switch (w-&gt;type) {
        ...
        case BINDER_WORK_TRANSACTION_COMPLETE: {
            cmd = BR_TRANSACTION_COMPLETE;
            // 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中
            if (put_user(cmd, (uint32_t __user *)ptr))
                return -EFAULT;
            ptr += sizeof(uint32_t);

            binder_stat_br(proc, thread, cmd);
            ...

            // 待完成事务已经处理完毕，将其从待完成事务队列中删除。
            list_del(&amp;w-&gt;entry);
            kfree(w);
            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
        } break;
        ...
        }

        if (!t)
            continue;

        ...
    }

    ...
    // 更新bwr.read_consumed的值
    *consumed = ptr - buffer;

    ...
    return 0;
}</code></pre><p>说明：<br>(01) 先看看函数的参数，buffer是bwr.read_buffer，是反馈数据缓冲区。size是bwr.read_size，是缓冲区大小，为256字节；而consumed是指向bwr.read_consumed的，它的值是0，表示反馈数据还没有被MediaPlayerService读取过。non_block为0。<br>(02) <em>consumed=0，因此会先将BR_NOOP从内核空间拷贝到用户空间，即拷贝到bwr.read_buffer中。<br>(03) 在binder_transaction()中，我们有添加待完成工作到thread的待完成工作队列中。因此，wait_for_proc_work是false。<br>(04) binder_has_thread_work(thread)为ture，因此wait_event_interruptible()不会进入中断等待状态，而是继续往下运行。<br>(05) 接着，进入while循环。list_empty(&amp;thread-&gt;todo)为flase，执行list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry)从thread的待完成工作队列中取出待完成的工作t。<br>(06) 根据binder_transaction()中的分析可知，t-&gt;type的值为BINDER_WORK_TRANSACTION_COMPLETE。执行对应的case分支，会将数据cmd=BR_TRANSACTION_COMPLETE拷贝到用户空间，即bwr.read_buffer中。拷贝之后，即代表该工作已完成，然后从当前线程的工作队列中将该工作删除，并释放所分配的空间。<br>(07) 由于t=null，因此，会再次从头开始执行while循环。而此时，list_empty(&amp;thread-&gt;todo)为true，并且list_empty(&amp;proc-&gt;todo)也为true；因此会执行break跳出while循环。<br>(08) 在跳出while循环之后，会更新</em>consumed的值。即，更新bwr.read_consumed的值。此时，由于写入了BR_NOOP和BR_TRANSACTION_COMPLETE两个指令，bwr.read_consumed=8。</p>
<br>
接下来，回到binder_ioctl()中。将bwr数据拷贝到用户空间后返回。此时，bwr中各个参数的值如下：

<pre><code>bwr.write_size = outAvail;                          
bwr.write_buffer = (long unsigned int)mOut.data();
bwr.write_consumed = outAvail;                      // 等于write_size
bwr.read_size = mIn.dataCapacity();
bwr.read_buffer = (long unsigned int)mIn.data();    // 存储了BR_NOOP和BR_TRANSACTION_COMPLETE两个返回指令
bwr.read_consumed = 8;                              // 等于write_size</code></pre><p>bwr中的write_<em>参数是保存”MediaPlayerService发送给Binder驱动的请求内容的”，而read_</em>则是保存”Binder驱动反馈给MediaPlayerService的内容的”。此时，write_consumed和write_size相同，意味着”Binder驱动已经将请求的内容都处理完毕了”；而read_consumed&gt;0，则意味着”Binder驱动有反馈内容给MediaPlayerService”。<br>回到talkWithDriver()中，看看ioctl()之后做了些什么？</p>
<p><a name="anchor3_30"></a></p>
<h2 id="30-IPCThreadState-talkWithDriver"><a href="#30-IPCThreadState-talkWithDriver" class="headerlink" title="30. IPCThreadState::talkWithDriver()"></a>30. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                ...
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：ioctl()返回值为0，err=NO_ERROR，退出while循环。<br>(01) bwr.write_consumed&gt;0，并且bwr.write_consumed=mOut.dataSize。因此，调用mOut.setDataSize(0)将释放mOut的内存，并且将mOut的mDataSize和mObjectsSize设为0。<br>(02) bwr.read_consumed&gt;0，因此调用mIn.setDataSize()为mIn分配空间，并将mIn的mDataSize设为=bwr.read_consumed。然后，将位置mDataPos初始化为0。<br>之后，跳出talkWithDriver()，返回到waitForResponse()中。</p>
<p><a name="anchor3_31"></a></p>
<h2 id="31-IPCThreadState-waitForResponse"><a href="#31-IPCThreadState-waitForResponse" class="headerlink" title="31. IPCThreadState::waitForResponse()"></a>31. IPCThreadState::waitForResponse()</h2><pre><code>status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{       
    int32_t cmd;
    int32_t err;

    while (1) {
        // 先通过talkWithDriver()和Binder驱动交互
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        err = mIn.errorCheck();
        if (err &lt; NO_ERROR) break;
        if (mIn.dataAvail() == 0) continue;

        // 然后读取返回结果，再根据结果进行处理
        cmd = mIn.readInt32();

        switch (cmd) {
        case BR_TRANSACTION_COMPLETE:
            ...
        case BR_DEAD_REPLY:
            ...
        case BR_FAILED_REPLY:
            ...
        case BR_ACQUIRE_RESULT:
            ...
        case BR_REPLY:
            ...
        default:
            err = executeCommand(cmd);
            if (err != NO_ERROR) goto finish;
            break;
        }
    }

finish:
    ...

    return err;
}</code></pre><p>说明：从talkWithDriver()正常返回之后，会读取mIn中的数据。而mIn中的数据就是Binder驱动返回的”BR_NOOP和BR_TRANSACTION_COMPLETE两个指令”。先读出的指令是BR_NOOP，因此这里执行executeCommand(cmd)。</p>
<p><a name="anchor3_32"></a></p>
<h2 id="32-IPCThreadState-executeCommand"><a href="#32-IPCThreadState-executeCommand" class="headerlink" title="32. IPCThreadState::executeCommand()"></a>32. IPCThreadState::executeCommand()</h2><pre><code>status_t IPCThreadState::executeCommand(int32_t cmd)
{
    BBinder* obj;
    RefBase::weakref_type* refs;
    status_t result = NO_ERROR;

    switch (cmd) {
    case BR_ERROR:
        ...
    case BR_OK:
        ...
    case BR_NOOP:
        break;
    default:
        ...
    }

    if (result != NO_ERROR) {
        mLastError = result;
    }

    return result;
}</code></pre><p>说明：BR_NOOP没有进行任何操作，直接返回。继续回到waitForResponse()中，重新开始while循环，执行talkWithDriver()。</p>
<p><a name="anchor3_33"></a></p>
<h2 id="33-IPCThreadState-talkWithDriver"><a href="#33-IPCThreadState-talkWithDriver" class="headerlink" title="33. IPCThreadState::talkWithDriver()"></a>33. IPCThreadState::talkWithDriver()</h2><pre><code>status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ...
    binder_write_read bwr;

    // Is the read buffer empty?
    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();
    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we&apos;ll read.
    if (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
        bwr.read_buffer = 0;
    }

    ...
    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    status_t err;
    do {
        ...
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            ...
        ...
    } while (err == -EINTR);

    ...

    if (err &gt;= NO_ERROR) {
        // 清空已写的数据
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        // 设置已读数据
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        ...
        return NO_ERROR;
    }

    return err;
}</code></pre><p>说明：<br>(01) 此时，因为在waitForResponse()中已经通过mIn.readInt32()读取了4个字节，因此mIn.dataPosition()=4，而mIn.dataSize()=8；因此，needRead=false。<br>(02) needRead=false，而doReceive=true；因此，outAvail=0。<br>最终，由于 bwr.write_size和bwr.read_size都为0，因此直接返回NO_ERROR。</p>
<p>再次回到waitForResponse()中，此时读出的cmd为BR_TRANSACTION_COMPLETE。此时，由于reply不为NULL，因此再次重新执行while循环，调用talkWithDriver()。</p>
<p>(01) 此时，已经读取了mIn中的全部数据，因此mIn.dataPosition()=8，而mIn.dataSize()=8；因此，needRead=true。<br>(02) outAvail=mOut.dataSize()，前面已经将mOut清空，因此outAvail=0。bwr初始化完毕之后，各个成员的值如下：</p>
<pre><code>bwr.write_size = 0;
bwr.write_buffer = (long unsigned int)mOut.data();
bwr.write_consumed = 0;
bwr.read_size = mIn.dataCapacity();                 // 256字节
bwr.read_buffer = (long unsigned int)mIn.data();
bwr.read_consumed = 0;</code></pre><p>其实，此时MediaPlayerService已经处理完”addService()这个请求，包括已经处理完了该请求的反馈”。对MediaPlayerService而言，它已经成功的注册到Service Manager中；接下来，就是等待Client的请求了。<br>那么如何去等待Client的请求呢？这和前面分析Service Manager服务启动之后等待Client的请求类似。MediaPlayerService服务，会通过ioctl()给Binder驱动发送读写请求，而此时的bwr.write_size=0，意味着不会进行写；bwr.read_size&gt;0，意味着会进行读。这样，Binder驱动就会执行读取动作，进而去查看”MediaPlayerService在Binder驱动中的待处理事务队列”是否有事务需要处理，有的话，就进行事务处理；否则，就进入中断等待状态，等待Client的请求。</p>
<p>下面，看看它到底是如何做到的。</p>
<pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>此时，bwr.write_size=0，因此不会执行binder_thread_write()。而bwr.read_size&gt;0，因此会调用binder_thread_read()进行读取动作。</p>
<p><a name="anchor3_34"></a></p>
<h2 id="34-Binder驱动中binder-thread-read-的源码"><a href="#34-Binder驱动中binder-thread-read-的源码" class="headerlink" title="34. Binder驱动中binder_thread_read()的源码"></a>34. Binder驱动中binder_thread_read()的源码</h2><pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  int ret = 0;
  int wait_for_proc_work;

  // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区
  if (*consumed == 0) {
      if (put_user(BR_NOOP, (uint32_t __user *)ptr))
          return -EFAULT;
      // 修改指针位置
      ptr += sizeof(uint32_t);
  }

retry:
  // 等待proc进程的事务标记。
  // 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。
  wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;
              list_empty(&amp;thread-&gt;todo);

  ...
  if (wait_for_proc_work) {
      ...
      // 设置当前线程的优先级=proc-&gt;default_priority。
      // 即，当前线程要处理proc的事务，所以设置优先级和proc一样。
      binder_set_nice(proc-&gt;default_priority);
      if (non_block) {
          ...
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
  } else {
      ...
  }
  ...
}</code></pre><p>(01) 此时，bwr.read_consumed=0，意味着*consumed=0。因此，还是会先将BR_NOOP写入到bwr.read_buffer中。<br>(02) 此时，当前线程的事务栈和待处理事务队列都是空，因此wait_for_proc_work=true。<br>(03) 在调用binder_set_nice()设置当前线程的优先级之后，就会调用wait_event_interruptible()。而此时binder_has_proc_work()为false，因此当前线程会进入中断等待状态。当Service Manager处理完MediaPlayerService的请求之后，就会将其唤醒。</p>
<br>
至此，MediaPlayerService进程的addService的请求发送部分就讲解完了。在继续了解请求的处理之前，先回顾一下本部分的内容。

<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService01_send.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/addService01_send.jpg" alt></a></p>
<p>如上图所示，MediaPlayerService发送一个BC_TRANSACTION事务给Binder驱动。Binder驱动收到该事务之后，对请求数据进行解析，在Kernel中新建了MediaPlayerService对应的Binder实体，并将在ServiceManager的进程上下文中添加了该Binder实体的Binder引用。解析完数据之后，新增一个待处理事务并提交到ServiceManager的待处理事务列表中；接着，就唤醒了ServiceManager。与此同时，Binder驱动还反馈了一个BR_TRANSACTION_COMPLETE给MediaPlayerService，告诉MediaPlayerService它的addService请求已经发送成功；MediaPlayerService在解析完BR_TRANSACTION_COMPLETE之后，就进入等待状态，等待ServiceManager的处理完请求之后反馈结果给它。</p>
<p>下面一篇文章，就看看ServiceManager被唤醒之后，具体都做了些什么工作！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/04/android/os/binder/2014-09-04-Binder-defaultServiceManager/" itemprop="url">Android Binder机制(四) defaultServiceManager()的实现</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-04T01:04:00.000Z" itemprop="datePublished">9月 4 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            32 分钟 read (About 4732 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文介绍defaultServiceManager()的流程。这里的defaultServiceManager()返回的是”IServiceManager对象”，获取”IServiceManager对象”的目的是为了和”ServiceManager进程”进行通信。例如，Server要通过”IServiceManager对象”发送请求指令注册到”ServiceManager进程”中，Client要通过”IServiceManager对象”发送请求来获取”Server对象”。<br>这里要搞清楚：<strong>defaultServiceManager()获取到的，不是”ServiceManager进程”，而是”IServiceManager对象”</strong>。”ServiceManager进程”是一个守护进程，而defaultServiceManager()获取到的是C++层的IServiceManager类的一个实例。当然，通过该defaultServiceManager()返回的”IServiceManager对象”是可以和ServiceManager进行通信的。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">defaultServiceManager概述</a><br><strong>2</strong>. <a href="#anchor2">defaultServiceManager流程详解</a><br><strong>2.1</strong>. <a href="#anchor2_1">defaultServiceManager()</a><br><strong>2.2</strong>. <a href="#anchor2_2">ProcessState::self()</a><br><strong>2.3</strong>. <a href="#anchor2_3">ProcessState::ProcessState()</a><br><strong>2.4</strong>. <a href="#anchor2_4">ProcessState::open_driver()</a><br><strong>2.5</strong>. <a href="#anchor2_5">mmap()</a><br><strong>2.6</strong>. <a href="#anchor2_6">ProcessState::getContextObject()</a><br><strong>2.7</strong>. <a href="#anchor2_7">ProcessState::getStrongProxyForHandle()</a><br><strong>2.8</strong>. <a href="#anchor2_8">ProcessState::lookupHandleLocked()</a><br><strong>2.9</strong>. <a href="#anchor2_9">BpBinder::BpBinder</a><br><strong>2.10</strong>. <a href="#anchor2_10">IPCThreadState::self()</a><br><strong>2.11</strong>. <a href="#anchor2_11">IPCThreadState::IPCThreadState()</a><br><strong>2.12</strong>. <a href="#anchor2_12">interface_cast()</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="defaultServiceManager概述"><a href="#defaultServiceManager概述" class="headerlink" title="defaultServiceManager概述"></a>defaultServiceManager概述</h1><h2 id="1-defaultServiceManager流程图"><a href="#1-defaultServiceManager流程图" class="headerlink" title="1. defaultServiceManager流程图"></a>1. defaultServiceManager流程图</h2><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/defaultServiceManager.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/defaultServiceManager.jpg" alt></a></p>
<p>上面是defaultServiceManager()的时序图。<br>defaultServiceManager()会返回一个sp<iservicemanager>类型的对象。IServiceManager提供了addService()供MediaPlayerService等服务注册到ServiceManager中，提供了getService()供MediaPlayer等MediaPlayer等客户端获取服务。<br>它首先会调用ProcessState::self()获取到ProcessState对象，该ProcessState对象是采用单例模式创建的；因此，当ProcessState::self()第一次被调用时，会新建ProcessState对象。在ProcessState的构造函数中，会先通过open_driver()打开”/dev/binder”，接着调用mmap()映射内存到当前进程中。此时，ProcessState就初始化完毕，它将”/dev/binder”的文件句柄以及映射内存都保存在自己的私有成员中。<br>在获取到ProcessState对象之后，会通过该对象调用getContextObject()来获取一个IBinder对象。getContextObject()会调用getStrongProxyForHandle(0)来获取”句柄0的强引用代理对象”，这里的句柄0被赋予了特殊意义；它就是ServiceManager的句柄，在Binder驱动中，若获取到句柄的值是0，则会将其目标当作是ServiceManager。getStrongProxyForHandle(0)会先通过lookupHandleLocked()在”ProcessState的矢量数组mHandleToObject”中查找句柄为0的对象；找不到的话，则新建句柄为0的对象，并将其添加到mHandleToObject矢量数组中；这样，下次再通过getStrongProxyForHandle()查找时，就能快速的找到。由此可见，mHandleToObject是ProcessState中保存句柄的缓冲数组。  随后，会新建句柄0对应的BpBinder对象，BpBinder是IBinder的代理；这里就获取到了ServiceManager的BpBinder代理对象。简而言之，getContextObject()的目的就是获取ServiceManager对应的BpBinder代理对象。 在新建BpBinder时，会通过IPCThreadState::self()获取IPCThreadState对象；因为，需要通过IPCThreadState对象来与Binder驱动进行交互。<br>前面已经成功获取到了ServiceManager的BpBinder代理，而defaultServiceManager()返回的是IServiceManager对象。这里，使用了一个技巧，通过宏interface_cast而调用asInterface()函数，从而返回IServiceManager的代理BpServiceManager。这样，defaultServiceManager()就执行完毕了。</iservicemanager></p>
<p>在上面的流程中，涉及到了比较多的类。下面通过类图理清它们之间的关系。</p>
<h2 id="2-defaultServiceManager相关类的类图"><a href="#2-defaultServiceManager相关类的类图" class="headerlink" title="2. defaultServiceManager相关类的类图"></a>2. defaultServiceManager相关类的类图</h2><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/defaultServiceManager_leitu.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/defaultServiceManager_leitu.jpg" alt></a></p>
<p>上面是获取defaultServiceManager()时涉及到的类的类图。defaultServiceManager()虽然在IServiceManager.cpp中实现，但它并不属于IServiceManager的成员方法，而是一个全局方法。</p>
<ol>
<li><p>RefBase<br>它定义在system/core/include/utils/RefBase.h中。RefBase是一个公共父类，它声明了许多常用的接口。包括增加引用计数，获取引用计数，新增对象的弱引用等接口。</p>
</li>
<li><p>IInterface<br>它定义在frameworks/native/include/binder/IInterface.h中。和RefBase类似，它也是一个公共父类，IInterface中声明了asBinder()方法，用于获取对象的IBinder对象。</p>
</li>
<li><p>IBinder<br>它定义在frameworks/native/include/binder/IBinder.h中。IBinder也是一个抽象出来的类，它包括了localBinder(), remoteBinder()和transact()等非常重要的接口。IBinder有两个直接子类类：BpBinder和BBinder。<br>BpBinder是Binder代理类。通过remoteBinder()可以获取BpBinder对象；而且，对于C++层而言，它相当于一个远程Binder。BpBinder的事务接口transact()会调用IPCThreadState的transact()，进而实现与Binder驱动的事务交互。此外，BpBinder中有一个mHandle句柄成员，它用来保存Server位于Binder驱动中的”Binder引用的描述”。句柄0是ServiceManager的句柄。<br>BBinder是本地Binder。通过localBinder()可以获取BBinder对象。当Server收到请求之后，会调用BBinder的onTransact()函数进行处理。而不同的Server会重载onTransact()函数，从而可以根据各自的情况对事务进行处理。</p>
</li>
</ol>
<ol start="4">
<li><p>BpInterface<br>它定义在frameworks/native/include/binder/IInterface.h中。实际上，BpInterface是一个<interface>模板类，同时继承了BpRefBase和INTERFACE，这里的INTERFACE是模板。像IServiceManager，IMediaPlayerService等Server都是通过继承模板类是实现的。  </interface></p>
</li>
<li><p>BnInterface<br>它定义在frameworks/native/include/binder/IInterface.h中。和BpInterface类似，BnInterface也是一个<interface>模板类，它同时继承了BBinder和INTERFACE。像BnServiceManager，BnMediaPlayerService等本地Server都是通过继承模板类是实现的。  </interface></p>
</li>
<li><p>BpRefBase<br>它定义在frameworks/native/include/binder/Binder.h中。BpRefBase继承于RefBase，它有一个IBinder*类型的成员mRemote，同时提供了获取该mRemote的方法。实际上，该mRemote就是BpBinder对象。</p>
</li>
<li><p>ProcessState<br>它定义在frameworks/native/libs/binder/ProcessState.cpp中中。ProcessState的实例是采用单例模式实现的，它拥有两个非常重要的成员：mDriverFD和mHandleToObject。<br>mDriverFD是文件”/dev/binder”的句柄，而mHandleToObject是一个Vector矢量数组，矢量数组中的每个元素都保存了两个变量：Server的句柄，以及Server对应的BpBinder对象。实际上，Server的句柄是”Server在Binder驱动中的Binder引用的描述”；句柄0是ServiceManager的句柄。 关于Binder引用，可以回顾<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。</p>
</li>
<li><p>IPCThreadState<br>它定义在frameworks/native/libs/binder/IPCThreadState.cpp中中。IPCThreadState的实例也是采用单例模式实现的，它是正在与Binder驱动进行交互的类。  </p>
</li>
</ol>
<br>
理解上面几个类的基本概念之后，现在在从整体上对它们进行一下介绍！  
对于一个Server而言，它都会存在一个"远程BpBinder对象"和"本地BBinder对象"。   
(01) 远程BpBinder对象的作用，是和Binder驱动进行交互。具体的方式是，当Server要向Binder发起事务请求时，会调用BpBinder的transact()接口，而该接口会调用到IPCThreadState::transact()接口，通过IPCThreadState类来和Binder驱动交互。此外，该BpBinder在Binder驱动中的Binder引用的描述会被保存到ProcessState的mHandleToObject矢量缓冲数组中。  
(02) 本地BBinder对象的作用，是Server响应Client请求的类。当Client有请求发送给Server时，都会调用到BBinder的onTransact()函数，而每个Server都会覆盖onTransact()函数。这样，每个Server就可以在onTransact()中根据自己的情况对请求进行处理。



<p><a name="anchor2"></a></p>
<h1 id="defaultServiceManager流程详解"><a href="#defaultServiceManager流程详解" class="headerlink" title="defaultServiceManager流程详解"></a>defaultServiceManager流程详解</h1><p>接下来通过源码来查看defaultServiceManager()的实现。通过源码分析，会对上面的类图有更清楚的认识！</p>
<p><a name="anchor2_1"></a></p>
<h2 id="1-defaultServiceManager"><a href="#1-defaultServiceManager" class="headerlink" title="1. defaultServiceManager()"></a>1. defaultServiceManager()</h2><pre><code>sp&lt;IServiceManager&gt; defaultServiceManager()
{
    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;

    {
        AutoMutex _l(gDefaultServiceManagerLock);
        while (gDefaultServiceManager == NULL) {
            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(
                ProcessState::self()-&gt;getContextObject(NULL));
            if (gDefaultServiceManager == NULL)
                sleep(1);
        }
    }

    return gDefaultServiceManager;
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/IServiceManager.cpp中。它是获取IServiceManager对象，该函数的声明在frameworks/native/include/binder/IServiceManager.h中。虽然defaultServiceManager()在IServiceManager.cpp文件中实现，但是它并不是IServiceManager的一个成员方法，而是一个全局方法。<br>(01) gDefaultServiceManagerLock是全局互斥锁，gDefaultServiceManager是全局的IServiceManager对象。它们都定义在frameworks/native/libs/binder/Static.cpp中。<br>(02) gDefaultServiceManager是采用单例模式实现的，第一次调用该函数时，会创建gDefaultServiceManager对象。gDefaultServiceManager的实现可以简化为以下语句：</p>
<pre><code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL));</code></pre><p>下面逐个对该语句中的代码进行解析。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-ProcessState-self"><a href="#2-ProcessState-self" class="headerlink" title="2. ProcessState::self()"></a>2. ProcessState::self()</h2><pre><code>sp&lt;ProcessState&gt; ProcessState::self()
{
    Mutex::Autolock _l(gProcessMutex);
    if (gProcess != NULL) {
        return gProcess;
    }
    gProcess = new ProcessState;
    return gProcess;
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/ProcessState.cpp中，它的作用是返回gProcess对象。gProcess也是单例模式对象，它也定义在frameworks/native/libs/binder/Static.cpp中。第一次执行self()时，会新建ProcessState对象。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="3-ProcessState-ProcessState"><a href="#3-ProcessState-ProcessState" class="headerlink" title="3. ProcessState::ProcessState()"></a>3. ProcessState::ProcessState()</h2><pre><code>ProcessState::ProcessState()
    : mDriverFD(open_driver())
    , mVMStart(MAP_FAILED)
    , mManagesContexts(false)
    , mBinderContextCheckFunc(NULL)
    , mBinderContextUserData(NULL)
    , mThreadPoolStarted(false)
    , mThreadPoolSeq(1)
{
    if (mDriverFD &gt;= 0) {
        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
        if (mVMStart == MAP_FAILED) {
            // *sigh*
            ALOGE(&quot;Using /dev/binder failed: unable to mmap transaction memory.\n&quot;);
            close(mDriverFD);
            mDriverFD = -1;
        }
    }
    ...
}</code></pre><p>说明：在ProcessState的构造函数中，它会进行一系列的初始化。比较重要的有如下两步。<br>(01) 通过open_driver()打开”/open/binder”，并将文件句柄赋值给mDriverFD。<br>(02) 通过调用mmap()映射内存。<br>下面，看看这两步的代码。</p>
<p><a name="anchor2_4"></a></p>
<h2 id="4-ProcessState-open-driver"><a href="#4-ProcessState-open-driver" class="headerlink" title="4. ProcessState::open_driver()"></a>4. ProcessState::open_driver()</h2><pre><code>static int open_driver()
{
    // 打开文件/dev/binder
    int fd = open(&quot;/dev/binder&quot;, O_RDWR);
    if (fd &gt;= 0) {
        fcntl(fd, F_SETFD, FD_CLOEXEC);
        int vers;
        // 检查/dev/binder的版本
        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);
        if (result == -1) {
            close(fd);
            ...
        }
        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {
            close(fd);
            ...
        }

        // 设置该进程最大线程数
        size_t maxThreads = 15;
        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);
        if (result == -1) {
            ...
        }
    } else {
        ...
    }
    return fd;
}</code></pre><p>说明：<br>(01) open_driver()首先打开”/dev/binder”文件。它会对应执行Binder驱动的binder_open()函数，该函数在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中已经详细介绍过了。<br>(02) 在成功打开文件之后，就会调用ioctl检查Binder版本，检查版本的部分非常简单(就是读取出版本号，判断读取的版本号与已有的版本号是否一样!)，这里就不再对Binder驱动的BINDER_VERSION进行展开了。<br>(03) 在检查版本通过之后，在调用ioctl(,BINDER_SET_MAX_THREADS,)设置该进程的最大线程数。它会对应调用Binder驱动的binder_ioctl()函数。    </p>
<p><strong>注意</strong>：要区分”此处的open(“/dev/binder”,…)” 和 “ServiceManager守护进程中的open(“/dev/binder”,…)”。它们分别是属于不同的进程，本文的open(“/dev/binder”,…)是属于调用defaultServiceManager()的进程；而在ServiceManager中的open(“/dev/binder”,…)是属于ServiceManager进程的。</p>
<h3 id="4-1-Binder驱动中binder-ioctl-的BINDER-SET-MAX-THREADS相关部分的源码"><a href="#4-1-Binder驱动中binder-ioctl-的BINDER-SET-MAX-THREADS相关部分的源码" class="headerlink" title="4.1 Binder驱动中binder_ioctl()的BINDER_SET_MAX_THREADS相关部分的源码"></a>4.1 Binder驱动中binder_ioctl()的BINDER_SET_MAX_THREADS相关部分的源码</h3><pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);

  // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。
  thread = binder_get_thread(proc);
  ...

  switch (cmd) {
    case BINDER_SET_MAX_THREADS:
        if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) {
            ret = -EINVAL;
            goto err;
        }
        break;

  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：BINDER_SET_MAX_THREADS的代码很简单，就是将最大线程数目从用户空间拷贝到内核空间，进而赋值给binder_proc-&gt;max_threads。</p>
<p><a name="anchor2_5"></a></p>
<h2 id="5-mmap"><a href="#5-mmap" class="headerlink" title="5. mmap()"></a>5. mmap()</h2><p>在执行完open_driver()之后，将调用mmap()映射内存到当前进程的虚拟地址空间。mmap()详细代码在<a href="/2014/09/03/Binder-ServiceManager-Daemon/">Android Binder机制(三) ServiceManager守护进程</a>中已经详细分析过，这里就不再重复说明了。</p>
<p><br> 到目前为止，ProcessState::self()就分析完毕。gDefaultServiceManager的赋值语句可以进一步的简化：</p>
<pre><code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::getContextObject(NULL));</code></pre><p><a name="anchor2_6"></a></p>
<h2 id="6-ProcessState-getContextObject"><a href="#6-ProcessState-getContextObject" class="headerlink" title="6. ProcessState::getContextObject()"></a>6. ProcessState::getContextObject()</h2><pre><code>sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; caller)
{
    return getStrongProxyForHandle(0);
}</code></pre><p>说明：getContextObject()调用了getStrongProxyForHandle(0)。这里的0是代表Service Manager的句柄。</p>
<p><a name="anchor2_7"></a></p>
<h2 id="7-ProcessState-getStrongProxyForHandle"><a href="#7-ProcessState-getStrongProxyForHandle" class="headerlink" title="7. ProcessState::getStrongProxyForHandle()"></a>7. ProcessState::getStrongProxyForHandle()</h2><pre><code>sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp&lt;IBinder&gt; result;

    AutoMutex _l(mLock);

    // 在矢量数组mHandleToObject中查找&quot;句柄值为handle的handle_entry对象&quot;；
    // 找到的话，则直接返回；找不到的话，则新建handle对应的handle_entry，并将其添加到mHandleToObject中。
    handle_entry* e = lookupHandleLocked(handle);

    if (e != NULL) {
        IBinder* b = e-&gt;binder;
        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
            // 当handle==0(即是Service Manager的句柄)时，尝试去ping Binder驱动。
            if (handle == 0) {
                Parcel data;
                status_t status = IPCThreadState::self()-&gt;transact(
                        0, IBinder::PING_TRANSACTION, data, NULL, 0);
                if (status == DEAD_OBJECT)
                   return NULL;
            }

            // 新建BpBinder代理
            b = new BpBinder(handle);
            e-&gt;binder = b;
            if (b) e-&gt;refs = b-&gt;getWeakRefs();
            result = b;
        } else {
            ...
        }
    }

    return result;
}</code></pre><p>说明：getStrongProxyForHandle()的目的是返回句柄为handle的IBinder代理，这里是返回Service Manager的IBinder代理。<br>(01) lookupHandleLocked()，是在矢量数组mHandleToObject中查找是否有句柄为handle的handle_entry对象。有的话，则返回该handle_entry对象；没有的话，则新建handle对应的handle_entry，并将其添加到矢量数组mHandleToObject中，然后再返回。mHandleToObject是用于保存各个IBinder代理对象的矢量数组，它相当于一个缓冲。<br>(02) 很显然，此时e!=NULL为true，进入if(e!=NULL)中。而此时e-&gt;binder=NULL，并且handle=0；则调用IPCThreadState::self()-&gt;transact()尝试去和Binder驱动通信(尝试去ping内核中Binder驱动)。由于Binder驱动已启动，ping通信是能够成功的。ping通信涉及到”Binder机制中Server和Client的通信”，后面再专门对Server和Client的交互进行介绍；这里只要了解ping通信能够成功即可。<br>(03) 接着，新建BpBinder对象，并赋值给e-&gt;binder。然后，将该BpBinder对象返回。</p>
<p>上面对流程进行了整体介绍，下面逐个进行分析！</p>
<p><a name="anchor2_8"></a></p>
<h2 id="8-ProcessState-lookupHandleLocked"><a href="#8-ProcessState-lookupHandleLocked" class="headerlink" title="8. ProcessState::lookupHandleLocked()"></a>8. ProcessState::lookupHandleLocked()</h2><pre><code>ProcessState::handle_entry* ProcessState::lookupHandleLocked(int32_t handle)
{               
    const size_t N=mHandleToObject.size();
    if (N &lt;= (size_t)handle) {
        handle_entry e;
        e.binder = NULL;
        e.refs = NULL;
        status_t err = mHandleToObject.insertAt(e, N, handle+1-N);
        if (err &lt; NO_ERROR) return NULL;
    }   
    return &amp;mHandleToObject.editItemAt(handle);
}           </code></pre><p>说明：mHandleToObject是Vector矢量数组。mHandleToObject的初始大小为0，因此if (N &lt;= handle)为true。接下来，就新建handle_entry，并将其添加到mHandleToObject中，然后返回该handle_entry。mHandleToObject和handle_entry的定义如下：</p>
<pre><code>class ProcessState : public virtual RefBase
{
    ...
private:
    ...
    struct handle_entry {
        IBinder* binder;
        RefBase::weakref_type* refs;
    };

    ...

    Vector&lt;handle_entry&gt;mHandleToObject;
    ...
}</code></pre><p>说明：该代码定义在frameworks/native/include/binder/ProcessState.h中。前面说过，mHandleToObject是个缓冲矢量数组。它的成员binder是保存的Server的BpBinder对象，而refs是保存的Server在Binder驱动中的Binder引用的描述。</p>
<p><a name="anchor2_9"></a></p>
<h2 id="9-BpBinder-BpBinder"><a href="#9-BpBinder-BpBinder" class="headerlink" title="9. BpBinder::BpBinder"></a>9. BpBinder::BpBinder</h2><p>new BpBinder(0)会新建BpBinder对象，下面看看BpBinder的构造函数。</p>
<pre><code>BpBinder::BpBinder(int32_t handle)
    : mHandle(handle)
    , mAlive(1)
    , mObitsSent(0)
    , mObituaries(NULL)
{
    ALOGV(&quot;Creating BpBinder %p handle %d\n&quot;, this, mHandle);

    extendObjectLifetime(OBJECT_LIFETIME_WEAK);
    IPCThreadState::self()-&gt;incWeakHandle(handle);
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/BpBinder.cpp中。主要工作是初始化。<br>(01) 将句柄handle保存到私有成员mHandle中。这里是将ServiceManager的句柄保存到mHandle中。<br>(02) 增加IPCThreadState的引用计数。IPCThreadState::self()是获取IPCThreadState对象，实际上，在前面介绍的ProcessState::getStrongProxyForHandle()中已经调用过该函数。下面看看它的代码。</p>
<p><a name="anchor2_10"></a></p>
<h2 id="10-IPCThreadState-self"><a href="#10-IPCThreadState-self" class="headerlink" title="10. IPCThreadState::self()"></a>10. IPCThreadState::self()</h2><pre><code>static pthread_mutex_t gTLSMutex = PTHREAD_MUTEX_INITIALIZER;
static bool gHaveTLS = false;
static pthread_key_t gTLS = 0;
static bool gShutdown = false;
static bool gDisableBackgroundScheduling = false;

IPCThreadState* IPCThreadState::self()
{
    if (gHaveTLS) {
restart:
        const pthread_key_t k = gTLS;
        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);
        if (st) return st;
        return new IPCThreadState;
    }

    if (gShutdown) return NULL;

    pthread_mutex_lock(&amp;gTLSMutex);
    if (!gHaveTLS) {
        if (pthread_key_create(&amp;gTLS, threadDestructor) != 0) {
            pthread_mutex_unlock(&amp;gTLSMutex);
            return NULL;
        }
        gHaveTLS = true;
    }
    pthread_mutex_unlock(&amp;gTLSMutex);
    goto restart;
}</code></pre><p>说明：该代码定义在frameworks/native/libs/binder/IPCThreadState.cpp中。self()的源码比较简单，它的作用是获取IPCThreadState对象。若该对象已经存在，则直接返回；否则，新建IPCThreadState对象。</p>
<p><a name="anchor2_11"></a></p>
<h2 id="11-IPCThreadState-IPCThreadState"><a href="#11-IPCThreadState-IPCThreadState" class="headerlink" title="11. IPCThreadState::IPCThreadState()"></a>11. IPCThreadState::IPCThreadState()</h2><pre><code>IPCThreadState::IPCThreadState()
    : mProcess(ProcessState::self()),
      mMyThreadId(androidGetTid()),
      mStrictModePolicy(0),
      mLastTransactionBinderFlags(0)
{
    pthread_setspecific(gTLS, this);
    clearCaller();
    mIn.setDataCapacity(256);
    mOut.setDataCapacity(256);
}</code></pre><p>说明：<br>(01) 获取ProcessState对象，并将其赋值给成员mProcess。ProcessState::self()在前面已经介绍国，它是获取全局的ProcessState对象。<br>(02) 设置mIn和mOut的容量为256字节。IPCThreadState是和Binder驱动交互的类，mOut是用来保存”IPCThreadState需要发送给Binder驱动的内容的”，而mIn则是用来保存”Binder驱动反馈给IPCThreadState的内容的”。后面在介绍”Server和Client”通信中用到它们时，再进一步说明。</p>
<br>
到目前为止，ProcessState::getContextObject()就分析完了。gDefaultServiceManager的赋值语句可以进一步的简化：

<pre><code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(new BpBinder(0));</code></pre><p>接下来，看看interface_cast<iservicemanager>。</iservicemanager></p>
<p><a name="anchor2_12"></a></p>
<h2 id="12-interface-cast"><a href="#12-interface-cast" class="headerlink" title="12. interface_cast()"></a>12. interface_cast()</h2><pre><code>template&lt;typename INTERFACE&gt;
inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)
{
    return INTERFACE::asInterface(obj);
}   </code></pre><p>说明：该代码在frameworks/native/include/binder/IInterface.h中。它是一个模板函数，对于interface_cast<iservicemanager>而言，返回的结果是IServiceManager::asInterface()。</iservicemanager></p>
<p><a name="anchor2_13"></a></p>
<h2 id="13-IServiceManager-asInterface"><a href="#13-IServiceManager-asInterface" class="headerlink" title="13. IServiceManager::asInterface()"></a>13. IServiceManager::asInterface()</h2><p>接下来，就是查找IServiceManager::asInterface()的实现了。在IServiceManager.cpp中不存在，追踪代码，发现asInterface()是通过DECLARE_META_INTERFACE()来声明，并通过IMPLEMENT_META_INTERFACE()来实现的。</p>
<p>(01) IServiceManager中的DECLARE_META_INTERFACE()声明和IMPLEMENT_META_INTERFACE()实现，分别在头文件frameworks/native/include/binder/IServiceManager.h 以及 frameworks/native/libs/binder/IServiceManager.cpp中。</p>
<pre><code>// IServiceManager.h中的声明
class IServiceManager : public IInterface
{
public:
    DECLARE_META_INTERFACE(ServiceManager);
    ...
}

// IServiceManager.pp中的实现
IMPLEMENT_META_INTERFACE(ServiceManager, &quot;android.os.IServiceManager&quot;);</code></pre><p>(02) DECLARE_META_INTERFACE()和IMPLEMENT_META_INTERFACE()的定义在frameworks/native/include/binder/IInterface.h中。 </p>
<pre><code>#define DECLARE_META_INTERFACE(INTERFACE)                               \
    static const android::String16 descriptor;                          \
    static android::sp&lt;I##INTERFACE&gt; asInterface(                       \
            const android::sp&lt;android::IBinder&gt;&amp; obj);                  \
    virtual const android::String16&amp; getInterfaceDescriptor() const;    \
    I##INTERFACE();                                                     \
    virtual ~I##INTERFACE();                                            \

#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \
    const android::String16 I##INTERFACE::descriptor(NAME);             \
    const android::String16&amp;                                            \
            I##INTERFACE::getInterfaceDescriptor() const {              \
        return I##INTERFACE::descriptor;                                \
    }                                                                   \
    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                \
            const android::sp&lt;android::IBinder&gt;&amp; obj)                   \
    {                                                                   \
        android::sp&lt;I##INTERFACE&gt; intr;                                 \
        if (obj != NULL) {                                              \
            intr = static_cast&lt;I##INTERFACE*&gt;(                          \
                obj-&gt;queryLocalInterface(                               \
                        I##INTERFACE::descriptor).get());               \
            if (intr == NULL) {                                         \
                intr = new Bp##INTERFACE(obj);                          \
            }                                                           \
        }                                                               \
        return intr;                                                    \
    }                                                                   \
    I##INTERFACE::I##INTERFACE() { }                                    \
    I##INTERFACE::~I##INTERFACE() { }                                   \


#define CHECK_INTERFACE(interface, data, reply)                         \
    if (!data.checkInterface(this)) { return PERMISSION_DENIED; }       \</code></pre><p>用ServiceManager替换INTERFACE之后，得到结果如下：<br>IMPLEMENT_META_INTERFACE(ServiceManager, “android.os.IServiceManager”);</p>
<pre><code>#define DECLARE_META_INTERFACE(IServiceManager)                         \
    static const android::String16 descriptor;                          \
    static android::sp&lt;IServiceManager&gt; asInterface(                    \
            const android::sp&lt;android::IBinder&gt;&amp; obj);                  \
    virtual const android::String16&amp; getInterfaceDescriptor() const;    \
    IServiceManager();                                                  \
    virtual ~IServiceManager();                                         \


#define IMPLEMENT_META_INTERFACE(IServiceManager, &quot;android.os.IServiceManager&quot;)        \
    const android::String16 IServiceManager::descriptor(&quot;android.os.IServiceManager&quot;); \
    const android::String16&amp;                                                           \
            IServiceManager::getInterfaceDescriptor() const {                          \
        return IServiceManager::descriptor;                                            \
    }                                                                                  \
    android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(                         \
            const android::sp&lt;android::IBinder&gt;&amp; obj)                                  \
    {                                                                                  \
        android::sp&lt;IServiceManager&gt; intr;                                             \
        if (obj != NULL) {                                                             \
            intr = static_cast&lt;IServiceManager*&gt;(                                      \
                obj-&gt;queryLocalInterface(                                              \
                        IServiceManager::descriptor).get());                           \
            if (intr == NULL) {                                                        \
                intr = new BpServiceManager(obj);                                      \
            }                                                                          \
        }                                                                              \
        return intr;                                                                   \
    }                                                                                  \
    IServiceManager::IServiceManager() { }                                             \
    IServiceManager::~IServiceManager() { }</code></pre><p>因此，得到IServiceManager::asInterface()的源码如下：</p>
<pre><code>android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(const android::sp&lt;android::IBinder&gt;&amp; obj)
{
    android::sp&lt;IServiceManager&gt; intr;
    if (obj != NULL) {
        intr = static_cast&lt;IServiceManager*&gt;(
            obj-&gt;queryLocalInterface(
                    IServiceManager::descriptor).get());
        if (intr == NULL) {
            intr = new BpServiceManager(obj);
        }
    }
    return intr;
}</code></pre><p>说明：asInterface()的作用是获取IServiceManager接口。<br>(01) obj是传入的BpBinder对象，不为NULL。因此，执行obj-&gt;queryLocalInterface(“android.os.IServiceManager”)来查找名称为”android.os.IServiceManager”的本地接口，queryLocalInterface()的实现在BpBinder的父类IBinder中，具体在文件frameworks/native/libs/binder/Binder.cpp中。很显然，IServiceManager接口还没创建，因此intr=NULL。<br>(02) 新建BpServiceManager(obj)对象，并返回。BpServiceManager的实现在frameworks/native/libs/binder/IServiceManager.cpp中。  </p>
<pre><code>sp&lt;IInterface&gt;  IBinder::queryLocalInterface(const String16&amp; descriptor)
{   
    return NULL;
}   </code></pre><br>
到目前为止，gDefaultServiceManager的创建流程就分析完了，它实际返回的是一个BpServiceManager对象，该对象包含IBinder的代理BpBinder。以下是转换后的获取gDefaultServiceManager的语句。

<pre><code>gDefaultServiceManager = new BpServiceManager(new BpBinder(0));</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/03/android/os/binder/2014-09-03-Binder-ServiceManager-Daemon/" itemprop="url">Android Binder机制(三) ServiceManager守护进程</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-03T01:01:00.000Z" itemprop="datePublished">9月 3 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 小时 read (About 8281 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>ServiceManager是用户空间的一个守护进程，它一直运行在后台。它的职责是管理Binder机制中的各个Server。当Server启动时，Server会将”Server对象的名字”连同”Server对象的信息”一起注册到ServiceManager中；而当Client需要获取Server接入点时，则通过”Server的名字”来从ServiceManager中找到对应的Server。<br>本文的主要内容就是对ServiceManager进行介绍，通过它的启动流程来分析它是如何成为Server管理者的。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor_1st">ServiceManager流程图</a><br><strong>2</strong>. <a href="#anchor_2nd">ServiceManager流程详解</a><br><strong>2.1</strong>. <a href="#anchor1">main()</a><br><strong>2.2</strong>. <a href="#anchor2">binder_open()</a><br><strong>2.3</strong>. <a href="#anchor3">open(“/dev/binder”)</a><br><strong>2.4</strong>. <a href="#anchor4">mmap()</a><br><strong>2.5</strong>. <a href="#anchor5">binder_become_context_manager()</a><br><strong>2.6</strong>. <a href="#anchor6">ioctl(, BINDER_SET_CONTEXT_MGR,)</a><br><strong>2.7</strong>. <a href="#anchor7">binder_loop()</a><br><strong>2.8</strong>. <a href="#anchor8">for(;;)</a><br><strong>3</strong>. <a href="#anchor_3rd">ServiceManager流程总结</a>  </p>
</blockquote>
<p><a name="anchor_1st"></a></p>
<h1 id="ServiceManager流程图"><a href="#ServiceManager流程图" class="headerlink" title="ServiceManager流程图"></a>ServiceManager流程图</h1><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/ServiceManager.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/ServiceManager.jpg" alt></a></p>
<p>上面是ServiceManager的时序图。它启动之后，会先打开”/dev/binder”文件(“/dev/binder”是Binder驱动注册的设备节点)。打开文件之后，再告诉Binder驱动，它是Binder的上下文管理者。之后，就进入到了消息循环中。进入消息循环之后，会不断的从Binder的待处理事务队列中读取事务(Binder请求或反馈)，读出事务之后就进行解析，然后交给相应的进程进行处理。若没有事务，则进入等待状态，等待被唤醒。</p>
<p><a name="anchor_2nd"></a></p>
<h1 id="ServiceManager流程详解"><a href="#ServiceManager流程详解" class="headerlink" title="ServiceManager流程详解"></a>ServiceManager流程详解</h1><p><a name="anchor1"></a></p>
<h2 id="1-main"><a href="#1-main" class="headerlink" title="1. main()"></a>1. main()</h2><p>ServiceManager是一个守护进程。它的main()函数源码如下：</p>
<pre><code>int main(int argc, char **argv)
{
    struct binder_state *bs;
    void *svcmgr = BINDER_SERVICE_MANAGER;

    bs = binder_open(128*1024);

    if (binder_become_context_manager(bs)) {
        ALOGE(&quot;cannot become context manager (%s)\n&quot;, strerror(errno));
        return -1; 
    }   

    svcmgr_handle = svcmgr;
    binder_loop(bs, svcmgr_handler);
    return 0;
}</code></pre><p>说明：该代码在frameworks/native/cmds/servicemanager/service_manager.c中。main()主要进行了三项工作：<br>(01) 通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。<br>(02) 调用binder_become_context_manager()，通过ioctl()告诉Binder驱动程序自己是Binder上下文管理者。<br>(03) 调用binder_loop()进入消息循环，等待Client的请求。如果没有Client请求，则进入中断等待状态；当有Client请求时，就被唤醒，然后读取并处理Client请求。  </p>
<blockquote>
<p>ServiceManager是如何启动的？<br>这里简要介绍一下ServiceManager的启动方式。当Kernel启动加载完驱动之后，会启动Android的init程序，init程序会解析init.rc，进而启动init.rc中定义的守护进程。而ServiceManager则正是通过注册在init.rc中，而被启动的。 </p>
</blockquote>
<p><a name="anchor2"></a></p>
<h2 id="2-binder-open"><a href="#2-binder-open" class="headerlink" title="2. binder_open()"></a>2. binder_open()</h2><p>下面，对main()的逐个步骤进行详细分析。先看看binder_open()，代码如下：</p>
<pre><code>struct binder_state *binder_open(unsigned mapsize)
{
    struct binder_state *bs;

    bs = malloc(sizeof(*bs));
    ...

    bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR);
    ...

    bs-&gt;mapsize = mapsize;
    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0); 
    ...

    return bs;
}</code></pre><p>说明： 该代码定义在frameworks/native/cmds/servicemanager/binder.c中。binder_open的作用是打开”/dev/binder”设备文件，然后调用mmap()将设备文件”/dev/binder”映射到进程空间的起始地址。<br>(01) open(“/dev/binder”, O_RDWR)对应会调用驱动的open函数。<br>(02) mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0)对应会调用驱动的mmap函数。第一个参数是映射内存的起始地址，NULL代表让系统自动选定地址；mapsize大小是128*1024B，即128K；PROT_READ表示映射区域是可读的；MAP_PRIVATE表示建立一个写入时拷贝的私有映射，即，当进程中对该内存区域进行写入时，是写入到映射的拷贝中；bs-&gt;fd是”/dev/binder”句柄；而0表示偏移。<br>(03) binder_state结构体是来保存/dev/binder设备信息的。其中，fd是用来保存文件句柄，mmaped是映射内存的起始地址，mapsize映射内存大小。</p>
<p><a name="anchor3"></a></p>
<h2 id="3-open-“-dev-binder”"><a href="#3-open-“-dev-binder”" class="headerlink" title="3. open(“/dev/binder”)"></a>3. open(“/dev/binder”)</h2><h3 id="3-1-Binder驱动注册信息"><a href="#3-1-Binder驱动注册信息" class="headerlink" title="3.1 Binder驱动注册信息"></a>3.1 Binder驱动注册信息</h3><p>下面看看open(“/dev/binder”, O_RDWR)到底做了些什么。先看看下面的代码：</p>
<pre><code>static const struct file_operations binder_fops = {
  .owner = THIS_MODULE,
  .poll = binder_poll,
  .unlocked_ioctl = binder_ioctl,
  .mmap = binder_mmap,
  .open = binder_open,
  .flush = binder_flush,
  .release = binder_release,
};

static struct miscdevice binder_miscdev = {
  .minor = MISC_DYNAMIC_MINOR,
  .name = &quot;binder&quot;,
  .fops = &amp;binder_fops
};

static int __init binder_init(void)
{
    ...
    ret = misc_register(&amp;binder_miscdev);
    ...
}

device_initcall(binder_init);</code></pre><p>说明：上面是Kernel中Binder驱动代码，定义在drivers/staging/android/binder.c中。<br>(01) device_initcall(binder_init)的作用是将binder_init()函数注册到Kernel的初始化函数列表中。当Kernel启动后，会按照一定的次序调用初始化函数列表，也就会执行binder_init()函数；执行binder_init()时便会加载Binder驱动。<br>(02) binder_init()函数中会通过misc_register(&amp;binder_miscdev)将Binder驱动注册到文件节点”/dev/binder”上。在Linux中，一切都是文件！将Binder驱动注册到文件节点上之后，就可以通过操作文件节点进而对Binder驱动进行操作。而该文件节点”/dev/binder”的设备信息是binder_miscdev这个结构体对象。<br>(03) binder_miscdev变量是struct miscdevice类型。minor是次设备号，这个我们不需要关心；name是Binder驱动对应在/dev虚拟文件系统下的设备节点名称，也就是/dev/binder中的”binder”；fops是该设备节点的文件操作对象，它是我们需要重点关注的！fops指向binder_fops变量。<br>(04) binder_fops变量是struct file_operations类型。owner是标明了该文件操作变量的拥有者，就是该驱动；poll则指定了poll函数指针，当我们对/dev/binder文件节点执行poll()操作时，实际上就是调用的binder_poll()函数；同理，mmap()对应binder_mmap()，open()对应binder_open()，ioctl()对应binder_ioctl()…</p>
<h3 id="3-2-Binder驱动中的binder-open-函数源码"><a href="#3-2-Binder驱动中的binder-open-函数源码" class="headerlink" title="3.2 Binder驱动中的binder_open()函数源码"></a>3.2 Binder驱动中的binder_open()函数源码</h3><p>经过上面的介绍，我们可以知道open(“/dev/binder”, O_RDWR)实际上是调用Binder驱动中的binder_open()函数。  </p>
<pre><code>static HLIST_HEAD(binder_procs);
...

static int binder_open(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc;

    binder_debug(BINDER_DEBUG_OPEN_CLOSE, &quot;binder_open: %d:%d\n&quot;,
           current-&gt;group_leader-&gt;pid, current-&gt;pid);

    // 为proc分配内存
    proc = kzalloc(sizeof(*proc), GFP_KERNEL);
    if (proc == NULL)
      return -ENOMEM;
    get_task_struct(current);
    // 将proc-&gt;tsk指向当前线程
    proc-&gt;tsk = current;
    // 初始化proc的待处理事务列表
    INIT_LIST_HEAD(&amp;proc-&gt;todo);
    // 初始化proc的等待队列
    init_waitqueue_head(&amp;proc-&gt;wait);
    // 设置proc的进程优先级为当前线程的优先级
    proc-&gt;default_priority = task_nice(current);

    binder_lock(__func__);

    binder_stats_created(BINDER_STAT_PROC);
    // 将该进程上下文信息proc保存到&quot;全局哈希表binder_procs&quot;中
    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);
    // 设置进程id
    proc-&gt;pid = current-&gt;group_leader-&gt;pid;
    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);
    // 将proc添加到私有数据中。
    // 这样，mmap(),ioctl()等函数都可以通过私有数据获取到proc，即该进程的上下文信息
    filp-&gt;private_data = proc;

    binder_unlock(__func__);

    if (binder_debugfs_dir_entry_proc) {
      char strbuf[11];
      snprintf(strbuf, sizeof(strbuf), &quot;%u&quot;, proc-&gt;pid);
      proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,
          binder_debugfs_dir_entry_proc, proc, &amp;binder_proc_fops);
    }

    return 0;
}</code></pre><p>说明：binder_proc是记录进程上下文信息的结构体，它的详细介绍请参考<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。该函数的作用如下。<br>(01) 创建并初始化binder_proc结构体变量proc。binder_proc是描述Binder进程的上下文信息结构体。这里，就是将ServiceManager这个进程的信息都存储到proc中。<br>(02) 将proc添加到全局哈希表binder_procs中。binder_procs不是我们关注的重点，也就不多说了。<br>(03) 将proc设为filp的私有成员。这样，在mmap()，ioctl()等函数中，我们都可以根据filp的私有成员来获取proc信息。  </p>
<p><a name="anchor4"></a></p>
<h2 id="4-mmap"><a href="#4-mmap" class="headerlink" title="4. mmap()"></a>4. mmap()</h2><p>分析完了open()，接下来看看mmap()。mmap()对应会调用Binder驱动的binder_mmap()函数。</p>
<h3 id="4-1-Binder驱动中的binder-mmap-源码"><a href="#4-1-Binder驱动中的binder-mmap-源码" class="headerlink" title="4.1 Binder驱动中的binder_mmap()源码"></a>4.1 Binder驱动中的binder_mmap()源码</h3><pre><code>static int binder_mmap(struct file *filp, struct vm_area_struct *vma)
{
  int ret;
  struct vm_struct *area;
  struct binder_proc *proc = filp-&gt;private_data;
  const char *failure_string;
  struct binder_buffer *buffer;

  // 有效性检查：映射的内存不能大于4M
  if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)
      vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;

  ...

  vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;

  mutex_lock(&amp;binder_mmap_lock);

  // 获取空闲的内核空间地址
  area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);
  ...

  // 将内核空间地址赋值给proc-&gt;buffer，即保存到进程上下文中
  proc-&gt;buffer = area-&gt;addr;
  // 计算 &quot;内核空间地址&quot; 和 &quot;进程虚拟地址&quot; 的偏移
  proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;
  mutex_unlock(&amp;binder_mmap_lock);

  // 为proc-&gt;pages分配内存
  proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);
  ...

  // 内核空间的内存大小 = 进程虚拟地址区域(用户空间)的内存大小
  proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;

  vma-&gt;vm_ops = &amp;binder_vm_ops;
  // 将 proc(进程上下文信息) 赋值给vma私有数据
  vma-&gt;vm_private_data = proc;

  // 通过调用binder_update_page_range()来分配物理页面。
  // 即，将物理内存映射到内核空间 以及 用户空间
  if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) {
      goto err_alloc_small_buf_failed;
  }
  buffer = proc-&gt;buffer;
  INIT_LIST_HEAD(&amp;proc-&gt;buffers);
  // 将物理内存添加到proc-&gt;buffers链表中进行管理。
  list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);
  buffer-&gt;free = 1;
  binder_insert_free_buffer(proc, buffer);
  proc-&gt;free_async_space = proc-&gt;buffer_size / 2;
  barrier();
  proc-&gt;files = get_files_struct(proc-&gt;tsk);
  // 将用户空间地址信息保存到proc中
  proc-&gt;vma = vma;
  proc-&gt;vma_vm_mm = vma-&gt;vm_mm;

  return 0;
  ...
}</code></pre><p>说明：mmap的作用是进行内存映射。当应用调用mmap()映射内存到进程虚拟地址时，该函数会进行两个操作：第一，将指定大小的”物理内存” 映射到 “用户空间”(即，进程的虚拟地址中)。 第二，将该”物理内存” 也映射到 “内核空间(即，内核的虚拟地址中)”。<br>  简单来说，就是”将进程虚拟地址空间和内核虚拟地址空间映射同一个物理页面”。为什么要这么做呢？这就是Binder进程间通信机制的精髓所在了！在讲解之前，先回顾一下进程间通信的基础知识。</p>
<blockquote>
<p>在32位Linux系统的内存地址划分中，0<del>3G为用户空间，3</del>4G为内核空间。应用程序都运行在用户空间，而kernel和驱动都运行在内核空间。应用程序之间若涉及到数据交换(例如，Client进程向Server进程发送请求)，即进程间通信，需要使用管道/消息队列/Socket/共享内存等IPC机制。共享内存控制比较复杂，而Socket常用于网络通信，这里将它们排除；剩下的就是管道/消息队列。下面对管道/消息队列的IPC等通信方式进行介绍。假如现在采用管道/消息队列从Client向Server发送请求，需要先将Client进程的数据拷贝到内核空间，然后再从内核空间拷贝到Server进程中。这其中，总共涉及到了2次内存拷贝！<br>而Binder机制则只需要进行1次内存拷贝即可！</p>
</blockquote>
<p>在Binder通信机制中，mmap()会将Server进程的虚拟地址和内核虚拟地址映射到同一个物理页面。那么当Client进程向Server进程发送请求时，只需要将Client的数据拷贝到内核空间即可！由于Server进程的地址和内核空间映射到同一个物理页面，因此，Client中的数据拷贝到内核空间时，也就相当于拷贝到了Server进程中。因此，Binder通信机制中，数据传输时，只需要1次内存拷贝！</p>
<br>
有了上面的理论基础，再来看mmap()是如何实现的。  
(01) proc = flip->private_data。该flip的私有数据是在binder_open()中设置的，这里通过该私有数据就获取binder_proc变量proc。  
(02) area = get_vm_area(vma->vm_end - vma->vm_start, VM_IOREMAP)。 它的作用是从内核虚拟地址中，获取指定大小的空闲地址，将空闲地址的起始地址赋值给area。 area是vm_struct类型，vm_struct是描述内核虚拟地址信息的结构体。此外，vm_area_struct则是描述进程虚拟地址信息的结构体。  
(03) 接着，给proc->buffer(内核空间地址)，proc->user_buffer_offset(内核空间地址和进程虚拟地址的偏移值)，proc->pages(内核空间所占物理页面的数目)，proc->buffer_size(内核地址空间的大小)赋值。  
(04) 然后，调用binder_update_page_range(proc, 1, proc->buffer, proc->buffer + PAGE_SIZE, vma)。它作用是分配物理内存，下面看看它的实现。  


<h3 id="4-2-Binder驱动中的binder-update-page-range-源码"><a href="#4-2-Binder驱动中的binder-update-page-range-源码" class="headerlink" title="4.2 Binder驱动中的binder_update_page_range()源码"></a>4.2 Binder驱动中的binder_update_page_range()源码</h3><pre><code>static int binder_update_page_range(struct binder_proc *proc, int allocate,
                  void *start, void *end,
                  struct vm_area_struct *vma)
{
  void *page_addr;
  unsigned long user_page_addr;
  struct vm_struct tmp_area;
  struct page **page;

  ...

  // 分配物理页面，
  // 并将&quot;内核空间&quot;和&quot;用户空间(进程的内存区域)&quot;指向同一块物理内存。
  for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) {
      int ret;
      struct page **page_array_ptr;
      page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];

      // 分配物理页面
      *page = alloc_page(GFP_KERNEL | __GFP_ZERO);
      ...

      tmp_area.addr = page_addr;
      tmp_area.size = PAGE_SIZE + PAGE_SIZE /* guard page? */;
      page_array_ptr = page;
      // 将物理页面映射到内核空间中
      ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr);
      ...

      user_page_addr =
          (uintptr_t)page_addr + proc-&gt;user_buffer_offset;
      // 将物理页面映射插入到进程的虚拟内存中
      ret = vm_insert_page(vma, user_page_addr, page[0]);
      ...
  }

  return 0;

  ...
}</code></pre><p>说明： binder_update_page_range()既可分配物理页面，也可以释放物理页面。当参数allocate=1时，会执行分配物理页面的操作；否则，会执行释放物理页面的操作。这里，allocate=1；因此，我们只关心分配物理页面的部分。<br>在for循环中，每分配一个物理页面都会先通过map_vm_area()将该物理内存映射到内核虚拟地址中；然后再将该物理页面插入到进程的虚拟地址空间。</p>
<p><br>至此，binder_open(128<em>1024)算是介绍完了。从”用户空间的ServiceManager进程” 和 “Binder驱动”这两个方面分析它的作用。<br>(01) *</em>ServiceManager进程<strong>：就是打开/dev/binder，同时映射物理内存到进程空间。<br>(02) **Binder驱动</strong>：新建并初始化该进程对应的binder_proc结构体，同时将内核虚拟地址和该进程的虚拟地址映射到同一物理内存中。</p>
<p><a name="anchor5"></a></p>
<h2 id="5-binder-become-context-manager"><a href="#5-binder-become-context-manager" class="headerlink" title="5. binder_become_context_manager()"></a>5. binder_become_context_manager()</h2><p>下面接着分析binder_become_context_manager(bs)。</p>
<pre><code>int binder_become_context_manager(struct binder_state *bs)
{
    return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);
}</code></pre><p>说明：根据前面介绍的Binder驱动初始化信息可知，ioctl()就是调用Binder驱动中的binder_ioctl()函数。 </p>
<p><a name="anchor6"></a></p>
<h2 id="6-ioctl-BINDER-SET-CONTEXT-MGR"><a href="#6-ioctl-BINDER-SET-CONTEXT-MGR" class="headerlink" title="6. ioctl(, BINDER_SET_CONTEXT_MGR,)"></a>6. ioctl(, BINDER_SET_CONTEXT_MGR,)</h2><h3 id="6-1-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#6-1-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="6.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>6.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h3><pre><code>// 全局binder实体，准确点说是ServiceManager的binder实体
static struct binder_node *binder_context_mgr_node;
// ServiceManager守护进程的uid
static uid_t binder_context_mgr_uid = -1;
static int binder_stop_on_user_error;
...

static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  // 中断等待函数。
  // 1. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。
  // 2. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。
  //    当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时；
  //    则继续执行；否则，再进入等待状态。
  ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
  ...

  binder_lock(__func__);
  // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。
  thread = binder_get_thread(proc);
  ...

  switch (cmd) {
  ...

  case BINDER_SET_CONTEXT_MGR:
      if (binder_context_mgr_node != NULL) {
          ...
      }
      if (binder_context_mgr_uid != -1) {
          ...
      } else
          // 设置ServiceManager对应的uid
          binder_context_mgr_uid = current-&gt;cred-&gt;euid;

      // 新建binder实体，并将proc进程上下文信息保存到binder实体中；
      // 然后，将该binder实体赋值给全局变量binder_context_mgr_node。
      // 这个全局的binder实体，是ServiceManager对应的binder实体。
      binder_context_mgr_node = binder_new_node(proc, NULL, NULL);
      ...

      // 设置binder实体的引用计数等参数
      binder_context_mgr_node-&gt;local_weak_refs++;
      binder_context_mgr_node-&gt;local_strong_refs++;
      binder_context_mgr_node-&gt;has_strong_ref = 1;
      binder_context_mgr_node-&gt;has_weak_ref = 1;
      break;
  ...

  }
  ret = 0;

err:
  // 去掉thread的BINDER_LOOPER_STATE_NEED_RETURN标记
  if (thread)
      thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;
  binder_unlock(__func__);
  wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
  ...

  return ret;
}</code></pre><p>说明：binder_ioctl()的内容很多，上面仅仅列出与BINDER_SET_CONTEXT_MGR相关的代码。<br>(01) proc = flip-&gt;private_data。该flip的私有数据是在binder_open()中设置的，这里通过该私有数据就获取binder_proc变量proc。<br>(02) 接着调用wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2)。由于binder_stop_on_user_error是全局变量，它的初始值是0，因此binder_stop_on_user_error &lt; 2为true，不进入中断等待，而是直接跳过该函数继续运行。<br>(03) binder_get_thread()会在proc中查找当前线程对应的binder_thread结构体；由于之前还未创建该线程的binder_thread结构体，因此查找失败。进而创建一个binder_thread结构体变量，并将其添加到proc-&gt;threads红黑树中，然后返回该变量。<br>(04) cmd的值是我们调用ioctl()传入的参数BINDER_SET_CONTEXT_MGR。在BINDER_SET_CONTEXT_MGR分支中，会设置binder_context_mgr_uid，binder_context_mgr_uid是一个全局变量，它代表ServiceManager对应的uid；接着，通过binder_new_node()新建一个Binder实体(即binder_node结构体对象)，并将该Binder实体赋值给全局变量binder_context_mgr_node，binder_context_mgr_node就是Serveice Manager对应的Binder实体；最后，设置binder实体的引用计数等参数。<br>(05) 清除thread-&gt;looper的BINDER_LOOPER_STATE_NEED_RETURN标记。这个BINDER_LOOPER_STATE_NEED_RETURN标记，是在调用binder_get_thread()中创建binder_thread对象时添加的。  </p>
<p>关于binder_node结构体，在<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>中有消息的介绍。特别需要了解的是，对于每一个Server，Binder驱动都会为其分配一个binder_node对象。对于ServiceManager这个Binder上下文管理者而言，Binder驱动更是会将它的Binder实体保存到全局变量中。</p>
<h3 id="6-2-Binder驱动中的binder-get-thread-源码"><a href="#6-2-Binder驱动中的binder-get-thread-源码" class="headerlink" title="6.2 Binder驱动中的binder_get_thread()源码"></a>6.2 Binder驱动中的binder_get_thread()源码</h3><p>下面看看binder_get_thread()中做了什么。</p>
<pre><code>static struct binder_thread *binder_get_thread(struct binder_proc *proc)
{
  struct binder_thread *thread = NULL;
  struct rb_node *parent = NULL;
  struct rb_node **p = &amp;proc-&gt;threads.rb_node;

  // 在proc-&gt;threads这棵红黑树中，查找是否有线程的pid和current-&gt;pid相同。
  // 即，查找当前线程中是否创建过binder_thread信息
  while (*p) {
      parent = *p;
      thread = rb_entry(parent, struct binder_thread, rb_node);

      if (current-&gt;pid &lt; thread-&gt;pid)
          p = &amp;(*p)-&gt;rb_left;
      else if (current-&gt;pid &gt; thread-&gt;pid)
          p = &amp;(*p)-&gt;rb_right;
      else
          break;
  }
  // 若当前线程中没有创建过binder_thread信息；
  // 则创建binder_thread，并初始化；然后将其添加到binder_proc进程的proc-&gt;threads中
  if (*p == NULL) {
      thread = kzalloc(sizeof(*thread), GFP_KERNEL);
      if (thread == NULL)
          return NULL;
      binder_stats_created(BINDER_STAT_THREAD);
      // 将进程的上下文信息保存到thread中
      thread-&gt;proc = proc;
      thread-&gt;pid = current-&gt;pid;
      // 初始化thread的等待队列
      init_waitqueue_head(&amp;thread-&gt;wait);
      // 初始化thread的待处理事件列表
      INIT_LIST_HEAD(&amp;thread-&gt;todo);
      // 将该thread链接到proc-&gt;threads这棵红黑树中
      rb_link_node(&amp;thread-&gt;rb_node, parent, p);
      rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);
      thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;
      thread-&gt;return_error = BR_OK;
      thread-&gt;return_error2 = BR_OK;
  }
  return thread;
}</code></pre><p>说明：<br>(01) 理解”红黑树”和”rb_entry”是理解while循环的前提。这里简单介绍下，proc-&gt;threads这棵红黑树是根据proc-&gt;thread-&gt;pid来排序的；而rb_entry(parent, struct binder_thread, rb_node)的作用根据binder_thread结构体对象中的已知成员的地址(binder_thread-&gt;rb_node的地址，也就是parent的值)来获取binder_thread结构体对象的地址。<br>(02) 很显然，由于之前没有创建过当前线程对应的binder_thread对象，所以*p==null为true。那么，接下来就新建binder_thread对象，并对其进行初始化，然后再添加到红黑树proc-&gt;threads中。</p>
<h3 id="6-3-Binder驱动中的binder-new-node-源码"><a href="#6-3-Binder驱动中的binder-new-node-源码" class="headerlink" title="6.3 Binder驱动中的binder_new_node()源码"></a>6.3 Binder驱动中的binder_new_node()源码</h3><p>下面看看binder_ioctl()中调用的binder_new_node()的代码。</p>
<pre><code>static struct binder_node *binder_new_node(struct binder_proc *proc,
                     void __user *ptr,
                     void __user *cookie)
{
  struct rb_node **p = &amp;proc-&gt;nodes.rb_node;
  struct rb_node *parent = NULL;
  struct binder_node *node;

  // 在proc-&gt;nodes这棵红黑树中，查找有要查找的binder实体(通过ptr成员来判断)
  while (*p) {
      parent = *p;
      node = rb_entry(parent, struct binder_node, rb_node);

      if (ptr &lt; node-&gt;ptr)
          p = &amp;(*p)-&gt;rb_left;
      else if (ptr &gt; node-&gt;ptr)
          p = &amp;(*p)-&gt;rb_right;
      else
          return NULL;
  }

  // 如果没有要找的binder实体，则新建该binder实体
  node = kzalloc(sizeof(*node), GFP_KERNEL);
  if (node == NULL)
      return NULL;
  binder_stats_created(BINDER_STAT_NODE);
  // 将node链接到红黑树proc-&gt;nodes中
  rb_link_node(&amp;node-&gt;rb_node, parent, p);
  rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);
  node-&gt;debug_id = ++binder_last_id;
  // 将进程上下文信息保存到node-&gt;proc中
  node-&gt;proc = proc;
  node-&gt;ptr = ptr;
  node-&gt;cookie = cookie;
  node-&gt;work.type = BINDER_WORK_NODE;
  INIT_LIST_HEAD(&amp;node-&gt;work.entry);
  INIT_LIST_HEAD(&amp;node-&gt;async_todo);
  return node;
}</code></pre><p>说明：跟binder_get_thread()类似，这里是先在proc-&gt;nodes这棵红黑树中查找是否有binder实体(即binder_node对象)存在。有的话，返回NULL，即不需要新建binder实体；没有的话，则新建并初始化binder_node对象，然后将其添加到proc-&gt;nodes红黑树中。</p>
<p><br>至此，binder_become_context_manager()就介绍完了。它的作用：<br>(01) <strong>ServiceManager进程</strong>：告诉Kernel驱动，当前进程(即ServiceManager进程)是Binder上下文管理者。<br>(02) <strong>Binder驱动</strong>：新建当前线程对应的binder_thread对象，并将其添加到进程上下文信息binder_proc的threads红黑树中；新建ServiceManager对应的binder实体，并将该binder实体保存到全局变量binder_context_mgr_node中。</p>
<p><a name="anchor7"></a></p>
<h2 id="7-binder-loop"><a href="#7-binder-loop" class="headerlink" title="7. binder_loop()"></a>7. binder_loop()</h2><p>我们继续回到main()函数，分析一下binder_loop(bs, svcmgr_handler)。</p>
<h3 id="7-1-binder-loop-的源码"><a href="#7-1-binder-loop-的源码" class="headerlink" title="7.1 binder_loop()的源码"></a>7.1 binder_loop()的源码</h3><pre><code>void binder_loop(struct binder_state *bs, binder_handler func)
{
    int res; 
    struct binder_write_read bwr;
    unsigned readbuf[32];

    bwr.write_size = 0;
    bwr.write_consumed = 0;
    bwr.write_buffer = 0;

    // 告诉Kernel，ServiceManager进程进入了消息循环状态。
    readbuf[0] = BC_ENTER_LOOPER;
    binder_write(bs, readbuf, sizeof(unsigned));

    for (;;) {
        bwr.read_size = sizeof(readbuf);
        bwr.read_consumed = 0;
        bwr.read_buffer = (unsigned) readbuf;

        // 向Kernel中发送消息(先写后读)。
        // 先将消息传递给Kernel，然后再从Kernel读取消息反馈
        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);

        ...

        // 解析读取的消息反馈
        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);
        ...
    }
}</code></pre><p>说明： 该代码定义在frameworks/native/cmds/servicemanager/binder.c中。<br>  binder_loop()首先调用binder_write(,BC_ENTER_LOOPER,)告诉Kernel，ServiceManager进入了消息循环状态。紧接着，就通过ioctl(,BINDER_WRITE_READ,)进入消息循环，等待Client发送请求(例如，MediaPlayer进程调用addService将MediaPlayer注册到ServiceManager中进行管理)。如果没有消息，则进入中断等待状态；如果有消息，则进行消息处理！ </p>
<h3 id="7-2-binder-write-的源码"><a href="#7-2-binder-write-的源码" class="headerlink" title="7.2 binder_write()的源码"></a>7.2 binder_write()的源码</h3><p>下面看看binder_loop()中的binder_write(,BC_ENTER_LOOPER,)。</p>
<pre><code>int binder_write(struct binder_state *bs, void *data, unsigned len)
{
    struct binder_write_read bwr;
    int res;
    bwr.write_size = len;                // 数据长度
    bwr.write_consumed = 0;             
    bwr.write_buffer = (unsigned) data;  // 数据是BINDER_WRITE_READ
    bwr.read_size = 0;
    bwr.read_consumed = 0;
    bwr.read_buffer = 0;
    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
    if (res &lt; 0) {
        fprintf(stderr,&quot;binder_write: ioctl failed (%s)\n&quot;,
                strerror(errno));
    }
    return res;
}</code></pre><p>说明：binder_write()单单只是向Kernel发送一个消息，而不会去读取消息反馈。这里的ioctl()又会调用到binder_ioctl()。<br>这里涉及到了Binder通信中常用的数据结构体binder_write_read。bwr.write_size&gt;0，表示通过ServiceManager有数据(即BC_ENTER_LOOPER指令)发送给Binder驱动，而发送的数据就保存在bwr.write_buffer中，bwr.write_consumed则表示已经被读取并处理的数据的大小。bwr.read_XXX则是用来保存Binder驱动即将反馈给ServiceManager的信息的。<br>更多关于binder_write_read的介绍，请参考<a href="/2014/09/02/Binder-Datastruct/">Android Binder机制(二) Binder中的数据结构</a>。</p>
<h3 id="7-3-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#7-3-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="7.3 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>7.3 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h3><p>下面我们看看Binder驱动部分的对应代码。</p>
<pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  int ret;
  struct binder_proc *proc = filp-&gt;private_data;
  struct binder_thread *thread;
  unsigned int size = _IOC_SIZE(cmd);
  void __user *ubuf = (void __user *)arg;

  // 中断等待函数。
  // 1. 当binder_stop_on_user_error &lt; 2为true时；不会进入等待状态；直接跳过。
  // 2. 当binder_stop_on_user_error &lt; 2为false时，进入等待状态。
  //    当有其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且binder_stop_on_user_error &lt; 2为true时；
  //    则继续执行；否则，再进入等待状态。
  ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);

  binder_lock(__func__);
  // 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。
  thread = binder_get_thread(proc);
  ...

  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：<br>(01) wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2)中binder_stop_on_user_error &lt; 2为true。因此，不进入中断等待状态而是直接跳过该函数。<br>(02) thread = binder_get_thread(proc)。由于在上一次调用ioctl时，已经创建了该线程对应的binder_thread对象。因此，这次能在proc-&gt;threads红黑树中找到对应的binder_thread对象，然后，返回给thread。<br>(03) copy_from_user()的作用是将用户空间的数据拷贝到内核空间。即，将ServiceManager中调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)时的bwr对象拷贝到Binder驱动中。<br>(04) 在binder_write()中，设置的bwr.write_size&gt;0；所以，调用binder_thread_write()进行写操作。<br>(05) 在binder_write()中，设置的bwr.read_size为0；所以，不调用binder_thread_read()进行读操作。<br>(06) 读写操作完毕之后，将bwr从内核空间再拷贝到用户空间。  </p>
<h3 id="7-4-Binder驱动中binder-thread-write-的源码"><a href="#7-4-Binder驱动中binder-thread-write-的源码" class="headerlink" title="7.4 Binder驱动中binder_thread_write()的源码"></a>7.4 Binder驱动中binder_thread_write()的源码</h3><pre><code>int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
          void __user *buffer, int size, signed long *consumed)
{
  uint32_t cmd;
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  // 读取binder_write_read.write_buffer中的内容。
  // 每次读取32bit(即4个字节)
  while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
      // 从用户空间读取32bit到内核中，并赋值给cmd。
      if (get_user(cmd, (uint32_t __user *)ptr))
          return -EFAULT;

      ptr += sizeof(uint32_t);
      ...
      switch (cmd) {
      ...
      case BC_ENTER_LOOPER:
          ...
          // 设置线程的状态为BINDER_LOOPER_STATE_ENTERED；
          // 即，进入了循环状态
          thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;
          break;
      ...
      }
      // 更新bwr.write_consumed的值
      *consumed = ptr - buffer;
  }
  return 0;
}</code></pre><p>说明：binder_thread_write()从brw.write_buffer中读取4个字节作为cmd。这4个字节就是ServiceManager传递的指令BC_ENTER_LOOPER。<br>在BC_ENTER_LOOPER对应的switch分支中，就是将BINDER_LOOPER_STATE_ENTERED加入到thread-&gt;looper中。即，告诉Binder驱动，ServiceManager进程进入了消息循环状态。</p>
<p><a name="anchor8"></a></p>
<h2 id="8-for"><a href="#8-for" class="headerlink" title="8. for(;;)"></a>8. for(;;)</h2><p>继续往下走。回到binder_loop()中后，便进入了for(;;)消息循环中。进入循环后，首先调用ioctl(,BINDER_WRITE_READ,)；此时，对应的bwr内容如下：</p>
<pre><code>bwr.write_size = 0;
bwr.write_consumed = 0;
bwr.write_buffer = 0;
bwr.read_size = sizeof(readbuf);
bwr.read_consumed = 0;
bwr.read_buffer = (unsigned) readbuf;</code></pre><p>bwr.write_size=0，而bwr.read_size&gt;0；表示只会从Binder驱动读取数据，而并不会向Binder驱动中写入数据。接着，调用ioctl()便再次进入到Binder驱动binder_ioctl()中。</p>
<h3 id="8-1-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码"><a href="#8-1-Binder驱动中binder-ioctl-的BINDER-WRITE-READ相关部分的源码" class="headerlink" title="8.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码"></a>8.1 Binder驱动中binder_ioctl()的BINDER_WRITE_READ相关部分的源码</h3><pre><code>static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
  ...
  switch (cmd) {
  case BINDER_WRITE_READ: {
      struct binder_write_read bwr;
      ...

      // 将binder_write_read从&quot;用户空间&quot; 拷贝到 &quot;内核空间&quot;
      if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
          ...
      }

      // 如果write_size&gt;0，则进行写操作
      if (bwr.write_size &gt; 0) {
          ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
          ...
      }

      // 如果read_size&gt;0，则进行读操作
      if (bwr.read_size &gt; 0) {
          ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);
          ...
      }
      ...

      if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
          ret = -EFAULT;
          goto err;
      }
      break;
  }
  ...
  }
  ret = 0;

  ...
  return ret;
}</code></pre><p>说明：由于此次bwr.write_size=0，而bwr.read_size不为0。因此，在通过copy_from_user()将数据从用户空间拷贝到内核空间之后，不进行写操作，而只进行读操作，即只执行binder_thread_read()。 在读操作执行完毕之后，再通过copy_to_user()，将数据返回给用户空间。  </p>
<h3 id="8-2-Binder驱动中binder-thread-read-的源码"><a href="#8-2-Binder驱动中binder-thread-read-的源码" class="headerlink" title="8.2 Binder驱动中binder_thread_read()的源码"></a>8.2 Binder驱动中binder_thread_read()的源码</h3><pre><code>static int binder_thread_read(struct binder_proc *proc,
                struct binder_thread *thread,
                void  __user *buffer, int size,
                signed long *consumed, int non_block)
{
  void __user *ptr = buffer + *consumed;
  void __user *end = buffer + size;

  int ret = 0;
  int wait_for_proc_work;

  // 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区
  if (*consumed == 0) {
      if (put_user(BR_NOOP, (uint32_t __user *)ptr))
          return -EFAULT;
      // 修改指针位置
      ptr += sizeof(uint32_t);
  }

retry:
  // 等待proc进程的事务标记。
  // 当线程的事务栈为空 并且 待处理事务列表为空时，该标记位true。
  wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;
              list_empty(&amp;thread-&gt;todo);

  ...

  // 设置线程为&quot;等待状态&quot;
  thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;
  if (wait_for_proc_work)
      proc-&gt;ready_threads++;

  ...
  if (wait_for_proc_work) {
      ...
      // 设置当前线程的优先级=proc-&gt;default_priority。
      // 即，当前线程要处理proc的事务，所以设置优先级和proc一样。
      binder_set_nice(proc-&gt;default_priority);
      if (non_block) {
          // 非阻塞式的读取，则通过binder_has_proc_work()读取proc的事务；
          // 若没有，则直接返回
          if (!binder_has_proc_work(proc, thread))
              ret = -EAGAIN;
      } else
          // 阻塞式的读取，则阻塞等待事务的发生。
          ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
  } else {
      ...
  }
  ...
}</code></pre><p>说明：<br>(01) 很显然，bwr.read_consumed=0。因此，*consumed=0，那么就将BR_NOOP拷贝到用户空间的bwr.read_buffer缓存区中。<br>(02) 目前为止，并没有进程将事务添加到当前线程中；因此，线程的事务栈和待处理事务队列都是为空。于是得到wait_for_proc_work的值是true。<br>(03) binder_set_nice()的作用是设置当前线程的优先级=proc-&gt;default_priority。<br>(04) 根据上下文，可知non_block为false。因此调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))。 而目前ServiceManager进程中没有待处理事务，因此binder_has_proc_work(proc, thread)为false。从而当前线程进入中断等待状态，等待其它进程将ServiceManager唤醒。 </p>
<p><br>至此，ServiceManager进入了等待状态，binder_loop()就分析就暂告一段落。<br>(01) <strong>ServiceManager进程</strong>：binder_loop()通过BC_ENTER_LOOPER告诉Kernel，ServiceManager进入了消息循环状态。接着，ServiceManager就进入等待状态，等待Client请求。<br>(02) <strong>Binder驱动</strong>：已知ServiceManager进入了消息循环状态；在收到ServiceManager的BINDER_WRITE_READ消息之后，就去ServiceManager的从进程上下文binder_proc对象中读取是否有待处理事务，由于没有事务处理，则将ServiceManager线程设为中断等待状态。  </p>
<p><a name="anchor_3rd"></a></p>
<h1 id="ServiceManager流程总结"><a href="#ServiceManager流程总结" class="headerlink" title="ServiceManager流程总结"></a>ServiceManager流程总结</h1><p>总结上面的分析，ServiceManager的main()进程完成了以下工作。 </p>
<ol>
<li><p>对于<strong>ServiceManager进程</strong>而言<br>它打开了Binder设备文件，并且将内存映射到ServiceManager的进程空间。然后，它告诉Binder驱动自己是Binder上下文的管理者。最后，进入消息循环，等待Client请求。</p>
</li>
<li><p>对于<strong>Binder驱动</strong>而言<br>初始化了ServiceManager对应的进程上下文环境(即binder_proc变量)，并将内核虚拟地址和进程虚拟地址映射到同一物理内存中。然后，新建当前线程对应的binder_thread对象，并将其添加到进程上下文信息binder_proc-&gt;threads红黑树中。在得知ServiceManager是Binder上下文管理者后，建立ServiceManager对应的Binder实体，并将该Binder实体保存到全局变量中。最后，得知ServiceManager进入消息循环后，由于当前线程中没有事务可处理，则进入中断等待状态，等待其他进程将其唤醒。</p>
</li>
</ol>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/02/android/os/binder/2014-09-02-Binder-Datastruct/" itemprop="url">Android Binder机制(二) Binder中的数据结构</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-02T01:01:00.000Z" itemprop="datePublished">9月 2 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            32 分钟 read (About 4753 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>在对Binder代码展开详细介绍之前，先列举出Binder机制中涉及到的数据结构。本文是一篇参考文章，读者在阅读代码的过程中遇到相关的数据结构，就可以查阅此文中的内容。本文列举的数据结构，涵盖了内核空间和用户空间两个部分。内核空间部分就是Binder驱动中涉及到的数据结构；而用户空间的部分，包括ServiceManager守护进程，以及Android的C++层和Framework层的相关数据结构。</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">内核空间的Binder数据结构</a><br><strong>1.1</strong>. <a href="#anchor1_1">binder_proc</a><br><strong>1.2</strong>. <a href="#anchor1_2">binder_buffer</a><br><strong>1.3</strong>. <a href="#anchor1_3">binder_thread</a><br><strong>1.4</strong>. <a href="#anchor1_4">binder_node</a><br><strong>1.5</strong>. <a href="#anchor1_5">binder_ref</a><br><strong>1.6</strong>. <a href="#anchor1_6">binder_write_read</a><br><strong>1.7</strong>. <a href="#anchor1_7">flat_binder_object</a><br><strong>1.8</strong>. <a href="#anchor1_8">binder_transaction_data</a><br><strong>2</strong>. <a href="#anchor2">用户空间的</a><br><strong>2.1</strong>. <a href="#anchor2_1">ServiceManager守护进程中的数据结构</a><br><strong>2.2</strong>. <a href="#anchor2_2">C++层的数据结构</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-内核空间的Binder数据结构"><a href="#1-内核空间的Binder数据结构" class="headerlink" title="1. 内核空间的Binder数据结构"></a>1. 内核空间的Binder数据结构</h1><p>在介绍Binder驱动中的数据结构时，先回顾一下上一篇提到的”内核中的Binder设计图”，有一个整体印象。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds01.jpg" alt></a></p>
<p>前面说过，binder_proc是描述进程上下文信息的，每一个用户空间的进程都对应一个binder_proc结构体。binder_node是Binder实体对应的结构体，它是Server在Binder驱动中的体现。binder_ref是Binder引用对应的结构体，它是Client在Binder驱动中的体现。</p>
<p><a name="anchor1_1"></a></p>
<h2 id="1-1-binder-proc"><a href="#1-1-binder-proc" class="headerlink" title="1.1 binder_proc"></a>1.1 binder_proc</h2><p>binder_proc是描述Binder进程上下文信息的结构体。Binder驱动的文件节点是”/dev/binder”，每当一个程序打开该文件节点时；Binder驱动中都会新建一个binder_proc对象来保存该进程的上下文信息。</p>
<pre><code>struct binder_proc {
  struct hlist_node proc_node;    // 根据proc_node，可以获取该进程在&quot;全局哈希表binder_procs(统计了所有的binder proc进程)&quot;中的位置
  struct rb_root threads;         // binder_proc进程内用于处理用户请求的线程组成的红黑树(关联binder_thread-&gt;rb_node)
  struct rb_root nodes;           // binder_proc进程内的binder实体组成的红黑树(关联binder_node-&gt;rb_node)
  struct rb_root refs_by_desc;    // binder_proc进程内的binder引用组成的红黑树，该引用以句柄来排序(关联binder_ref-&gt;rb_node_desc)
  struct rb_root refs_by_node;    // binder_proc进程内的binder引用组成的红黑树，该引用以它对应的binder实体的地址来排序(关联binder_ref-&gt;rb_node)
  int pid;                        // 进程id
  struct vm_area_struct *vma;     // 进程的内核虚拟内存
  struct mm_struct *vma_vm_mm;
  struct task_struct *tsk;        // 进程控制结构体(每一个进程都由task_struct 数据结构来定义)。
  struct files_struct *files;     // 保存了进程打开的所有文件表数据
  struct hlist_node deferred_work_node;
  int deferred_work;
  void *buffer;                   // 该进程映射的物理内存在内核空间中的起始位置
  ptrdiff_t user_buffer_offset;   // 内核虚拟地址与进程虚拟地址之间的差值

  // 内存管理的相关变量
  struct list_head buffers;         // 和binder_buffer-&gt;entry关联到同一链表，从而对Binder内存进行管理
  struct rb_root free_buffers;      // 空闲内存，和binder_buffer-&gt;rb_node关联。
  struct rb_root allocated_buffers; // 已分配内存，和binder_buffer-&gt;rb_node关联。
  size_t free_async_space;

  struct page **pages;            // 映射内存的page页数组，page是描述物理内存的结构体
  size_t buffer_size;             // 映射内存的大小
  uint32_t buffer_free;
  struct list_head todo;          // 该进程的待处理事件队列。
  wait_queue_head_t wait;         // 等待队列。
  struct binder_stats stats;
  struct list_head delivered_death;
  int max_threads;                // 最大线程数。定义threads中可包含的最大进程数。
  int requested_threads;
  int requested_threads_started;
  int ready_threads;
  long default_priority;          // 默认优先级。
  struct dentry *debugfs_entry;
};</code></pre><p>说明：binder_proc定义在drivers/staging/android/binder.c中。由于定义在.c文件中，可见binder_proc是Binder驱动的私有结构体。上面已经给出了相关成员的注释，这里只对部分比较重要的成员进行说明。<br>(01) proc_node, 它的作用是通过proc_node，将该binder_proc添加到”全局哈希表binder_procs(它记录了所有的binder_proc)”。不过binder_procs在Kernel驱动中暂时没有太大用处，所以不用太过关注该成员。<br>(02) threads，它是包含该进程内用于处理用户请求的所有线程的红黑树。threads成员和binder_thread-&gt;rb_node关联到一棵红黑树，从而将binder_proc和binder_thread关联起来。<br>(03) nodes，它是包行该进程内的所有Binder实体所组成的红黑树。nodes成员和binder_node-&gt;rb_node关联到一棵红黑树，从而将binder_proc和binder_node关联起来。<br>(04) refs_by_desc，它是包行该进程内的所有Binder引用所组成的红黑树。refs_by_desc成员和binder_ref-&gt;rb_node_desc关联到一棵红黑树，从而将binder_proc和binder_ref关联起来。<br>(05) refs_by_node，它是包行该进程内的所有Binder引用所组成的红黑树。refs_by_node成员和binder_ref-&gt;rb_node_node关联到一棵红黑树，从而将binder_proc和binder_ref关联起来。<br>(06) buffer，它是该进程内核虚拟内存的起始地址。而user_buffer_offset，则是该内核虚拟地址和进程虚拟地址之间的差值。在Binder驱动中，将进程的内核虚拟地址和进程虚拟地址映射到同一物理页面，该user_buffer_offset则是它们之间的差值；这样，已知其中一个，就可以根据差值算出另外一个。<br>(07) todo是该进程的待处理事务队列，而wait则是等待队列。它们的作用是实现进程的等待/唤醒。例如，当Server进程的wait等待队列为空时，Server就进入中断等待状态；当某Client向Server发送请求时，就将该请求添加到Server的todo待处理事务队列中，并尝试唤醒Server等待队列上的线程。如果，此时Server的待处理事务队列不为空，则Server被唤醒后；唤醒后，则取出待处理事务进行处理，处理完毕，则将结果返回给Client。  </p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-binder-buffer"><a href="#1-2-binder-buffer" class="headerlink" title="1.2 binder_buffer"></a>1.2 binder_buffer</h2><p>binder_buffer是描述Binder进程所管理的每段内存的结构体。</p>
<pre><code>struct binder_buffer {
    struct list_head entry;    // 和binder_proc-&gt;buffers关联到同一链表，从而使Binder进程对内存进行管理。
    struct rb_node rb_node;    // 和binder_proc-&gt;free_buffers或binder_proc-&gt;allocated_buffers关联到同一红黑树，从而对已有内存和空闲内存进行管理。

    unsigned free:1;                // 空闲与否的标记
    unsigned allow_user_free:1;
    unsigned async_transaction:1;
    unsigned debug_id:29;

    struct binder_transaction *transaction;

    struct binder_node *target_node;
    size_t data_size;
    size_t offsets_size;
    uint8_t data[0];
};</code></pre><p>说明：binder_buffer是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。Binder驱动将Binder进程的内存分成一段一段进行管理，而这每一段则是使用binder_buffer来描述的。</p>
<p><a name="anchor1_3"></a></p>
<h2 id="1-3-binder-thread"><a href="#1-3-binder-thread" class="headerlink" title="1.3 binder_thread"></a>1.3 binder_thread</h2><p>binder_thread是描述Binder线程的结构体。binder_proc是描述进程的，而binder_thread是描述进程中的线程。</p>
<pre><code>struct binder_thread {
    struct binder_proc *proc;   // 线程所属的Binder进程
    struct rb_node rb_node;     // 红黑树节点，关联到红黑树binder_proc-&gt;threads中。
    int pid;                    // 进程id
    int looper;                 // 线程状态。可以取BINDER_LOOPER_STATE_REGISTERED等值
    struct binder_transaction *transaction_stack;   // 正在处理的事务栈
    struct list_head todo;                          // 待处理的事务链表
    uint32_t return_error; /* Write failed, return error code in read buf */
    uint32_t return_error2; /* Write failed, return error code in read */

    wait_queue_head_t wait;                         // 等待队列
    struct binder_stats stats;                      // 保存一些统计信息
};</code></pre><p>说明：binder_thread是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。binder_thread是描述Binder线程相关信息的结构体。<br>(01) proc，它是binder_proc(进程上下文信息)结构体对象。目的是保存该线程所属的Binder进程。<br>(02) rb_node，它是红黑树节点。通过将rb_node binder关联到红黑树proc-&gt;threads中，从而将该线程添加到进程的threads红黑树中进行管理。</p>
<p><a name="anchor1_4"></a></p>
<h2 id="1-4-binder-node"><a href="#1-4-binder-node" class="headerlink" title="1.4 binder_node"></a>1.4 binder_node</h2><p>binder_node是描述Binder实体的结构体。</p>
<pre><code>struct binder_node {
    int debug_id;
    struct binder_work work;
    union {
        struct rb_node rb_node;         // 如果这个Binder实体还在使用，则将该节点链接到proc-&gt;nodes中。
        struct hlist_node dead_node;    // 如果这个Binder实体所属的进程已经销毁，而这个Binder实体又被其它进程所引用，则这个Binder实体通过dead_node进入到一个哈希表中去存放
    };
    struct binder_proc *proc;           // 该binder实体所属的Binder进程
    struct hlist_head refs;             // 该Binder实体的所有Binder引用所组成的链表
    int internal_strong_refs;
    int local_weak_refs;
    int local_strong_refs;
    void __user *ptr;                   // Binder实体在用户空间的地址(为Binder实体对应的Server在用户空间的本地Binder的引用)
    void __user *cookie;                // Binder实体在用户空间的其他数据(为Binder实体对应的Server在用户空间的本地Binder自身)
    unsigned has_strong_ref:1;
    unsigned pending_strong_ref:1;
    unsigned has_weak_ref:1;
    unsigned pending_weak_ref:1;
    unsigned has_async_transaction:1;
    unsigned accept_fds:1;
    unsigned min_priority:8;
    struct list_head async_todo;
};</code></pre><p>说明：binder_node是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。binder_node是描述Binder实体相关信息的结构体。<br>(01) rb_node和dead_node属于一个union。如果该Binder实体还在使用，则通过rb_node将该节点链接到proc-&gt;nodes红黑树中；否则，则将该Binder实体通过dead_node链接到全局哈希表binder_dead_nodes中。<br>(02) proc，它是binder_proc(进程上下文信息)结构体对象。目的是保存该Binder实体的进程。<br>(03) refs，它是该Binder实体的所有引用所组成的链表。</p>
<p>在Binder驱动中，会为每一个Server都创建一个Binder实体，即会为每个Server都创建一个binder_node对象。</p>
<p><a name="anchor1_5"></a></p>
<h2 id="1-5-binder-ref"><a href="#1-5-binder-ref" class="headerlink" title="1.5 binder_ref"></a>1.5 binder_ref</h2><p>binder_ref是描述Binder引用的结构体。</p>
<pre><code>struct binder_ref {
    int debug_id;
    struct rb_node rb_node_desc;    // 关联到binder_proc-&gt;refs_by_desc红黑树中
    struct rb_node rb_node_node;    // 关联到binder_proc-&gt;refs_by_node红黑树中
    struct hlist_node node_entry;   // 关联到binder_node-&gt;refs哈希表中
    struct binder_proc *proc;       // 该Binder引用所属的Binder进程
    struct binder_node *node;       // 该Binder引用对应的Binder实体
    uint32_t desc;                  // 描述
    int strong;                     
    int weak;
    struct binder_ref_death *death;
};</code></pre><p>说明：binder_ref是Binder驱动的私有结构体，它定义在drivers/staging/android/binder.c中。它是用来描述Binder引用的相关信息的。<br>(01) rb_node_desc和rb_node_node都是红黑树节点。通过rb_node_desc，Binder引用和binder_proc-&gt;refs_by_desc红黑树相关联；通过rb_node_node，Binder引用和binder_proc-&gt;refs_by_node红黑树相关联。<br>(02) node是该Binder引用所引用的Binder实体。而node_entry在是关联到该Binder实体的binder_node-&gt;refs哈希表中。<br>(03) proc，它是binder_proc(进程上下文信息)结构体对象。目的是保存该Binder引用所属的进程。<br>(04) desc是Binder引用的描述，实际上它就是Binder驱动为该Binder分配的一个唯一的int型整数。通过该desc，可以在binder_proc-&gt;refs_by_desc中找到该Binder引用，进而可以找到该Binder引用所引用的Binder实体等信息。  </p>
<p>在Binder驱动中，会为每个Client创建对应的Binder引用，即会为每个Client创建binder_ref对象。</p>
<p><strong>“Binder实体”和”Binder引用”可以很好的将Server和Client关联起来：因为Binder实体和Binder引用分别是Server和Client在Binder驱动中的体现。 Client获取到Server对象后，”Binder引用所引用的Biner实体(即binder_ref.node)” 会指向 “Server对应的Biner实体”；同样的，Server被某个Client引用之后，”Server对应的Binder实体的引用列表(即，binder_node.refs)” 会包含 “Client对应的Binder引用”。</strong></p>
<p><a name="anchor1_6"></a></p>
<h2 id="1-6-binder-write-read"><a href="#1-6-binder-write-read" class="headerlink" title="1.6 binder_write_read"></a>1.6 binder_write_read</h2><p>binder_write_read是描述Binder读写信息的结构体。</p>
<pre><code>struct binder_write_read {
    signed long write_size;
    signed long write_consumed;
    unsigned long   write_buffer;
    signed long read_size;
    signed long read_consumed;
    unsigned long   read_buffer;
};</code></pre><p>说明：binder_write_read是内核空间和用户空间的通信结构体，它记录了Binder读写内容的相关信息。在内核中，它定义在drivers/staging/android/binder.h中；在Android中，它对应的引用在external/kernel-headers/original/linux/binder.h中。<br>当用户空间的应用程序和Binder驱动通信时，它会将数据打包到binder_write_read中。write_开头的是记录应用程序要发送给Binder驱动的内容，而read_开头的是记录Binder驱动要反馈给应用程序的内容。<br>(01) write_size，是写内容的总大小；write_consumed，是已写内容的大小；write_buffer，是写的内容的虚拟地址。<br>(02) read_size，是读内容的总大小；read_consumed，是已读内容的大小；read_buffer，是读的内容的虚拟地址。</p>
<p><a name="anchor1_7"></a></p>
<h2 id="1-7-flat-binder-object"><a href="#1-7-flat-binder-object" class="headerlink" title="1.7 flat_binder_object"></a>1.7 flat_binder_object</h2><p>flat_binder_object是描述Binder对象信息的结构体。</p>
<pre><code>struct flat_binder_object {
    unsigned long       type;   // binder类型：可以为BINDER_TYPE_BINDER或BINDER_TYPE_HANDLE等类型
    unsigned long       flags;  // 标记

    union {
        void        *binder;    // 当type=BINDER_TYPE_BINDER时，它指向Binder对象位于C++层的本地Binder对象(即BBinder对象)的弱引用。 
        signed long handle;     // 当type=BINDER_TYPE_HANDLE时，它等于Binder对象在Binder驱动中对应的Binder实体的Binder引用的描述。
    };

    void            *cookie;    // 当type=BINDER_TYPE_BINDER时才有效，它指向Binder对象位于C++层的本地Binder对象(即BBinder对象)。 
};</code></pre><p>说明： flat_binder_object是用来描述Binder信息的结构体。它也属于内核空间和用户空间的通信结构体。当它在用户空间被使用时(例如，Server发送添加服务请求给ServiceManager)，flat_binder_object就是记录的Server位于用户空间的Binder对象的信息的结构体；此时的type的值一般都是BINDER_TYPE_BINDER类型，对应的union中的binder的值是该Binder对象在用户空间的本地Binder(即BBinder对象)的引用；同时，cookie则是本地Binder自身。  而当flat_binder_object在Binder驱动中被使用(例如，当Binder驱动收到发送服务请求时)，它会将type修改为BINDER_TYPE_HANDLE，然后将联合体中的handle修改为”该Server对应的Binder实体的Binder引用”的描述；根据Binder引用的描述就能找到该Server。总体来说，在用户空间，flat_binder_object是描述该Binder实体在用户空间的存在形式；而在内核空间中，flat_binder_object则描述该Binder实体在内核中的存在形式。</p>
<p><a name="anchor1_8"></a></p>
<h2 id="1-8-binder-transaction-data"><a href="#1-8-binder-transaction-data" class="headerlink" title="1.8 binder_transaction_data"></a>1.8 binder_transaction_data</h2><p>binder_transaction_data是描述Binder事务交互的数据格式的结构体。</p>
<pre><code>struct binder_transaction_data {
    union {
        size_t  handle; // 当binder_transaction_data是由用户空间的进程发送给Binder驱动时，
                        // handle是该事务的发送目标在Binder驱动中的信息，即该事务会交给handle来处理；
                        // handle的值是目标在Binder驱动中的Binder引用。
        void    *ptr;   // 当binder_transaction_data是有Binder驱动反馈给用户空间进程时，
                        // ptr是该事务的发送目标在用户空间中的信息，即该事务会交给ptr对应的服务来处理；
                        // ptr是处理该事务的服务的服务在用户空间的本地Binder对象。
    } target;           // 该事务的目标对象(即，该事务数据包是给该target来处理的)
    void        *cookie;    // 只有当事务是由Binder驱动传递给用户空间时，cookie才有意思，它的值是处理该事务的Server位于C++层的本地Binder对象
    unsigned int    code;   // 事务编码。如果是请求，则以BC_开头；如果是回复，则以BR_开头。

    unsigned int    flags;
    pid_t       sender_pid;
    uid_t       sender_euid;
    size_t      data_size;    // 数据大小
    size_t      offsets_size; // 数据中包含的对象的个数

    union {
        struct {
            const void  *buffer;
            const void  *offsets;
        } ptr;
        uint8_t buf[8];
    } data;                   // 数据
};</code></pre><p>说明： binder_transaction_data是用来描述Binder事务交互的数据结构体。它也属于内核空间和用户空间的通信结构体。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-用户空间的Binder数据结构"><a href="#2-用户空间的Binder数据结构" class="headerlink" title="2. 用户空间的Binder数据结构"></a>2. 用户空间的Binder数据结构</h1><p><a name="anchor2_1"></a></p>
<h2 id="2-1-ServiceManager守护进程中的数据结构"><a href="#2-1-ServiceManager守护进程中的数据结构" class="headerlink" title="2.1 ServiceManager守护进程中的数据结构"></a>2.1 ServiceManager守护进程中的数据结构</h2><p><a name="anchor2_1_1"></a></p>
<h3 id="2-1-1-binder-state"><a href="#2-1-1-binder-state" class="headerlink" title="2.1.1 binder_state"></a>2.1.1 binder_state</h3><pre><code>struct binder_state
{
    int fd;           // 文件节点&quot;/dev/binder&quot;的句柄
    void *mapped;     // 映射内存的起始地址
    unsigned mapsize; // 映射内存的大小
};  </code></pre><p>说明：binder_state定义在frameworks/native/cmds/servicemanager/binder.c中，它是ServiceManager用来描述打开的”/dev/binder”的信息结构体。</p>
<p><a name="anchor2_1_2"></a></p>
<h3 id="2-1-2-binder-object"><a href="#2-1-2-binder-object" class="headerlink" title="2.1.2 binder_object"></a>2.1.2 binder_object</h3><p>binder_object是与flat_binder_object对应的结构体。</p>
<pre><code>struct binder_object
{
    uint32_t type;  // 类型
    uint32_t flags;
    void *pointer;
    void *cookie;
};</code></pre><p>说明：binder_object定义在frameworks/native/cmds/servicemanager/binder.h中，它是ServiceManager中与flat_binder_object对应的结构体。</p>
<p><a name="anchor2_1_3"></a></p>
<h3 id="2-1-3-binder-txn"><a href="#2-1-3-binder-txn" class="headerlink" title="2.1.3 binder_txn"></a>2.1.3 binder_txn</h3><p>binder_txn与binder_transaction_data对应的结构体。</p>
<pre><code>struct binder_txn
{
    void *target;
    void *cookie;
    uint32_t code;
    uint32_t flags;

    uint32_t sender_pid;
    uint32_t sender_euid;

    uint32_t data_size;
    uint32_t offs_size;
    void *data;
    void *offs;
};</code></pre><p>说明：binder_txn定义在frameworks/native/cmds/servicemanager/binder.h中，它是ServiceManager中与binder_transaction_data对应的结构体。</p>
<p><a name="anchor2_1_4"></a></p>
<h3 id="2-1-4-svcinfo"><a href="#2-1-4-svcinfo" class="headerlink" title="2.1.4 svcinfo"></a>2.1.4 svcinfo</h3><pre><code>struct svcinfo
{
    struct svcinfo *next;         // 下一个&quot;服务的信息&quot;
    void *ptr;                    // 服务在Binder驱动中的Binder引用的描述
    struct binder_death death;
    int allow_isolated;
    unsigned len;                 // 服务的名称长度
    uint16_t name[0];             // 服务的名称
};      </code></pre><p>说明：svcinfo定义在frameworks/native/cmds/servicemanager/service_manager.c中。它是ServiceManager守护进程的私有结构体。<br>  svcinfo是保存”注册到ServiceManager中的服务”的相关信息的结构体。它是一个单链表，在ServiceManager守护进程中的svclist是保存注册到ServiceManager中的服务的链表，它就是struct info类型。svcinfo中的next是指向下一个服务的节点，而ptr是该服务在Binder驱动中Binder引用的描述。name则是服务的名称。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-C-层的数据结构"><a href="#2-2-C-层的数据结构" class="headerlink" title="2.2 C++层的数据结构"></a>2.2 C++层的数据结构</h2><p><a name="anchor2_2_1"></a></p>
<h3 id="2-2-1-Parcel"><a href="#2-2-1-Parcel" class="headerlink" title="2.2.1 Parcel"></a>2.2.1 Parcel</h3><p>Parcel是描述Binder通信信息的结构体。</p>
<pre><code>class Parcel {
public:
    ...

    // 获取数据(返回mData)
    const uint8_t*      data() const;
    // 获取数据大小(返回mDataSize)
    size_t              dataSize() const;
    // 获取数据指针的当前位置(返回mDataPos)
    size_t              dataPosition() const;

private:
    ...

    status_t            mError;                                   
    uint8_t*            mData;            // 数据
    size_t              mDataSize;        // 数据大小
    size_t              mDataCapacity;    // 数据容量
    mutable size_t      mDataPos;         // 数据指针的当前位置
    size_t*             mObjects;         // 对象在mData中的偏移地址
    size_t              mObjectsSize;     // 对象个数
    size_t              mObjectsCapacity; // 对象的容量

    ...
}</code></pre><p>说明：Parcel定义在frameworks/native/include/binder/Parcel.h中。</p>

    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous is-invisible is-hidden-mobile">
        <a href="/tags/android/page/0/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/tags/android/page/2/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link is-current" href="/tags/android/">1</a></li>
        
        <li><a class="pagination-link" href="/tags/android/page/2/">2</a></li>
        
        <li><a class="pagination-link" href="/tags/android/page/3/">3</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 炸鸡叔&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>