<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Tag: android - PillBlog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta property="og:type" content="website">
<meta property="og:title" content="PillBlog">
<meta property="og:url" content="https://apppills.com/tags/android/page/2/index.html">
<meta property="og:site_name" content="PillBlog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PillBlog">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">归档</a>
            
            <a class="navbar-item " href="/about">关于</a>
            
            <a class="navbar-item " href="https://everything.apppills.com">Everything</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#android</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/09/01/android/os/binder/2014-09-01-Binder-Introduce/" itemprop="url">Android Binder机制(一) Binder的设计和框架</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-09-01T01:01:00.000Z" itemprop="datePublished">9月 1 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            44 分钟 read (About 6605 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>这是关于Android中Binder机制的一系列纯技术贴。花了一个多礼拜的时间，才终于将其整理完毕。行文于此，以做记录；也是将自己所得与大家分享。<br>和以往一样，介绍Binder时，先讲解框架，然后再从设计和细节等方面一一展开。若文章若错误或纰漏，请不吝指出。谢谢！</p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Binder架构解析</a><br><strong>1.1</strong>. <a href="#anchor1_1">Binder模型</a><br><strong>1.2</strong>. <a href="#anchor1_2">Binder驱动存在的原因和意义</a><br><strong>1.3</strong>. <a href="#anchor1_3">ServiceManager存在的原因和意义</a><br><strong>1.4</strong>. <a href="#anchor1_4">为什么采用Binder机制，而不是其他的IPC通信方式</a><br><strong>1.5</strong>. <a href="#anchor1_5">Binder中各角色之间关系</a><br><strong>2</strong>. <a href="#anchor2">Binder设计解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">Binder设计</a><br><strong>2.1.1</strong>. <a href="#anchor2_1_1">内核空间的Binder设计</a><br><strong>2.1.2</strong>. <a href="#anchor2_1_2">用户空间的Binder设计</a><br><strong>2.2</strong>. <a href="#anchor2_2">Binder通信</a><br><strong>2.2.1</strong>. <a href="#anchor2_2_1">Binder通信模型</a><br><strong>2.2.2</strong>. <a href="#anchor2_2_2">Binder通信数据</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Binder架构解析"><a href="#1-Binder架构解析" class="headerlink" title="1. Binder架构解析"></a>1. Binder架构解析</h1><p><a name="anchor1_1"></a></p>
<h2 id="1-1-Binder模型"><a href="#1-1-Binder模型" class="headerlink" title="1.1 Binder模型"></a>1.1 Binder模型</h2><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_frame.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_frame.jpg" alt></a></p>
<p>上图中涉及到Binder模型的4类角色：<strong>Binder驱动</strong>，<strong>ServiceManager</strong>，<strong>Server</strong>和<strong>Client</strong>。 因为后面章节讲解Binder时，都是以MediaPlayerService和MediaPlayer为代表进行讲解的；这里就使用MediaPlayerService代表了Server，而MediaPlayer则代表了Client。</p>
<p>Binder机制的目的<strong>是实现IPC(Inter-Process Communication)，即实现进程间通信</strong>。在上图中，由于MediaPlayerService是Server的代表，而MediaPlayer是Client的代表；因此，对于上图而言，Binder机制则表现为”实现MediaPlayerService和MediaPlayer之间的通信”。</p>
<p><a name="anchor1_2"></a></p>
<h2 id="1-2-Binder驱动存在的原因和意义"><a href="#1-2-Binder驱动存在的原因和意义" class="headerlink" title="1.2 Binder驱动存在的原因和意义"></a>1.2 Binder驱动存在的原因和意义</h2><p>在回答”Binder机制中Binder驱动存在的原因和意义”之前，先介绍几个基本的概念。</p>
<h3 id="1-Linux系统中的内存划分"><a href="#1-Linux系统中的内存划分" class="headerlink" title="1. Linux系统中的内存划分"></a>1. Linux系统中的内存划分</h3><p>Android是基于Linux内核而打造的操作系统。<br>以32位Linux系统而言，它的内存最大是4G。在这4G内存中，0<del>3G为用户空间，3</del>4G为内核空间。应用程序都运行在用户空间，而Kernel和驱动都运行在内核空间。用户空间和内核空间若涉及到通信(即，数据交互)，两者不能简单地使用指针传递数据，而必须在”内核”中通过copy_from_user(),copy_to_user(),get_user()或put_user()等函数传递数据。copy_from_user()和get_user()是将内核空间的数据拷贝到用户空间，而copy_to_user()和put_user()则是将用户空间的数据拷贝到内核空间。</p>
<h3 id="2-进程的基本概念"><a href="#2-进程的基本概念" class="headerlink" title="2. 进程的基本概念"></a>2. 进程的基本概念</h3><p>进程拥有独立的内存单元，它是系统进行资源分配和调度的基本单位。对于Linux系统而言，每一个运行在用户空间的应用程序都可以看作一个进程。<br>不同的进程在不同的内存中，因此当一个程序崩溃之后，不会对其它的程序造成影响。</p>
<br>
通过上面的"Linux的内存划分"和"进程"，我们可以了解到：**应用程序都运行在用户空间，每个应用程序都有它自己独立的内存空间；若不同的应用程序之间涉及到通信，需要通过内核进行中转，因为需要用到内核的copy_from_user()和copy_to_user()等函数。**   
现在，再回到上面的框架图中。图中的ServiceManager, MediaPlayerService和MediaPlayer都位于用户空间，它们是不同的进程。前面说过，Binder机制的最终目的是实现"MediaPlayerService和MediaPlayer这两个不同进程之间的通信"。而这两个不同进程的通信必须要内核进行中转，对于Android而言，在内核中起中转作用便是Binder驱动。那么Binder驱动是如何进行数据中转的呢？这里概括的介绍一下，后面再详细说明。   
Android的通信是基于Client-Server架构的，进程间的通信无非就是Client向Server发起请求，Server响应Client的请求。这里以发起请求为例：当Client向Server发起请求(例如，MediaPlayer向MediaPlayerService发起请求)，Client会先将请求数据从用户空间拷贝到内核空间(将数据从MediaPlayer发给Binder驱动)；数据被拷贝到内核空间之后，再通过驱动程序，将内核空间中的数据拷贝到Server位于用户空间的缓存中(Binder驱动将数据发给MediaPlayerService)。这样，就成功的将Client进程中的请求数据传递到了Server进程中。

<p>实际上，Binder驱动是整个Binder机制的核心。除了实现上面所说的数据传输之外，Binder驱动还是实现线程控制(通过中断等待队列实现线程的等待/唤醒)，以及UID/PID等安全机制的保证。</p>
<p><a name="anchor1_3"></a></p>
<h2 id="1-3-ServiceManager存在的原因和意义"><a href="#1-3-ServiceManager存在的原因和意义" class="headerlink" title="1.3 ServiceManager存在的原因和意义"></a>1.3 ServiceManager存在的原因和意义</h2><p>Binder是要实现Android的C-S架构的，即Client-Server架构。而ServiceManager，是以服务管理者的身份存在的。</p>
<p>ServiceManager也是运行在用户空间的一个独立进程。<br>(01) 对于Binder驱动而言，<strong>ServiceManager是一个守护进程，更是Android系统各个服务的管理者</strong>。Android系统中的各个服务，都是添加到ServiceManager中进行管理的，而且每个服务都对应一个服务名。当Client获取某个服务时，则通过服务名来从ServiceManager中获取相应的服务。<br>(02) 对于MediaPlayerService和MediaPlayer而言，<strong>ServiceManager是一个Server服务端，是一个服务器</strong>。当要将MediaPlayerService等服务添加到ServiceManager中进行管理时，ServiceManager是服务器，它会收到MediaPlayerService进程的添加服务请求。当MediaPlayer等客户端要获取MediaPlayerService等服务时，它会向ServiceManager发起获取服务请求。</p>
<p>当MediaPlayer和MediaPlayerService通信时，MediaPlayerService是服务端；而当MediaPlayerService则ServiceManager通信时，ServiceManager则是服务端。这样，就造就了ServiceManager的特殊性。于是，在Binder驱动中，将句柄0指定为ServiceManager对应的句柄，通过这个特殊的句柄就能获取ServiceManager对象。这部分的知识后面会详细介绍。</p>
<p><a name="anchor1_4"></a></p>
<h2 id="1-4-为什么采用Binder机制，而不是其他的IPC通信方式"><a href="#1-4-为什么采用Binder机制，而不是其他的IPC通信方式" class="headerlink" title="1.4 为什么采用Binder机制，而不是其他的IPC通信方式"></a>1.4 为什么采用Binder机制，而不是其他的IPC通信方式</h2><p>前面说过，Android是在Linux内核的基础上设计的。而在Linux中，已经拥有”管道/消息队列/共享内存/信号量/Socket等等”众多的IPC通信手段；但是，Google为什么单单选择了Binder，而不是其它的IPC机制呢？</p>
<p>这肯定是因为Binder具有无可比拟的优势。下面就从 “实用性(Client-Server架构)/传输效率/操作复杂度/安全性” 等几方面进行分析。</p>
<h3 id="第一-Binder能够很好的实现Client-Server架构"><a href="#第一-Binder能够很好的实现Client-Server架构" class="headerlink" title="第一. Binder能够很好的实现Client-Server架构"></a>第一. Binder能够很好的实现Client-Server架构</h3><p>对于Android系统，Google想提供一套基于Client-Server的通信方式。<br>例如，将”电池信息/马达控制/wifi信息/多媒体服务”等等不同的服务都由不同的Server提供，当Client需要获取某Server的服务时，只需要Client向Server发送相应的请求，Server收到请求之后进行处理，处理完毕再将反馈内容发送给Client。</p>
<p>但是，目前Linux支持的”传统的管道/消息队列/共享内存/信号量/Socket等”IPC通信手段中，只有Socket是Client-Server的通信方式。但是，Socket主要用于网络间通信以及本机中进程间的低速通信，它的传输效率太低。</p>
<h3 id="第二-Binder的传输效率和可操作性很好"><a href="#第二-Binder的传输效率和可操作性很好" class="headerlink" title="第二. Binder的传输效率和可操作性很好"></a>第二. Binder的传输效率和可操作性很好</h3><p>前面已经说了，Socket传输效率很低，已经被排除。而消息队列和管道又采用存储-转发方式，使用它们进行IPC通信时，需要经过2次内存拷贝！效率太低！</p>
<p>为什么消息队列和管道的数据传输需要经过2次内存拷贝呢？ 首先，数据先从发送方的缓存区(即，Linux中的用户存储空间)拷贝到内核开辟的缓存区(即，Linux中的内核存储空间)中，是第1次拷贝。接着，再从内核缓存区拷贝到接收方的缓存区(也是Linux中的用户存储空间)，这是第2次拷贝。<br>而采用Binder机制的话，则只需要经过1次内存拷贝即可！ 即，从发送方的缓存区拷贝到内核的缓存区，而接收方的缓存区与内核的缓存区是映射到同一块物理地址的，因此只需要1次拷贝即可。</p>
<p>至于共享内存呢，虽然使用它进行IPC通信时进行的内存拷贝次数是0。但是，共享内存操作复杂，也将它排除。</p>
<h3 id="第三-Binder机制的安全性很高"><a href="#第三-Binder机制的安全性很高" class="headerlink" title="第三. Binder机制的安全性很高"></a>第三. Binder机制的安全性很高</h3><p>传统IPC没有任何安全措施，完全依赖上层协议来确保。传统IPC的接收方无法获得对方进程可靠的UID/PID(用户ID/进程ID)，从而无法鉴别对方身份。而Binder机制则为每个进程分配了UID/PID来作为鉴别身份的标示，并且在Binder通信时会根据UID/PID进行有效性检测。</p>
<p><a name="anchor1_5"></a></p>
<h2 id="1-5-Binder中各角色之间关系"><a href="#1-5-Binder中各角色之间关系" class="headerlink" title="1.5 Binder中各角色之间关系"></a>1.5 Binder中各角色之间关系</h2><p>先看看下面的关系图</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_4relationship.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_4relationship.jpg" alt></a></p>
<p>在解释上面的图之前，先解释图中涉及到的几个非常重要的概念。</p>
<p><strong>1. Binder实体</strong></p>
<p>  Binder实体，是各个Server以及ServiceManager在内核中的存在形式。<br>  Binder实体实际上是内核中binder_node结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。<br>  在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。</p>
<p><strong>2. Binder引用</strong></p>
<p>   说到Binder实体，就不得不说”Binder引用”。所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。<br>   如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。</p>
<p>   Binder实体和Binder引用都是内核(即，Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。</p>
<p><strong>3. 远程服务</strong></p>
<p>   Server都是以服务的形式注册到ServiceManager中进行管理的。如果将Server本身看作是”本地服务”的话，那么Client中的”远程服务”就是本地服务的代理。如果你对代理模式比较熟悉的话，就很容易理解了，远程服务就是本地服务的一个代理，通过该远程服务Client就能和Server进行通信。</p>
<br>
理解上面3个概念之后，下面再通过几个典型的通信示例来解析该关系图。

<p><strong>ServiceManager守护进程</strong><br>  ServiceManager是用户空间的一个守护进程。当该应用程序启动时，它会和Binder驱动进行通信，告诉Binder驱动它是服务管理者；对Binder驱动而言，它则会新建ServiceManager对应的Binder实体，并将该Binder实体设为全局变量。为什么要将它设为全局变量呢？这点应该很容易理解–因为Client和Server都需要和ServiceManager进行通信，不将它设为全局变量的话，怎么找到ServiceManager呢！</p>
<p><strong>Server注册到ServiceManager中</strong><br>  Server首先会向Binder驱动发起注册请求，而Binder驱动在收到该请求之后就将该请求转发给ServiceManager进程。但是Binder驱动怎么才能知道该请求是要转发给ServiceManager的呢？这是因为Server在发送请求的时候，会告诉Binder驱动这个请求是交给0号Binder引用对应的进程来进行处理的。而Binder驱动中指定了0号引用是与ServiceManager对应的。<br>  在Binder驱动转发该请求之前，它其实还做了两件很重要的事：(01) 当它知道该请求是由一个Server发送的时候，它会新建该Server对应的Binder实体。 (02) 它在ServiceManager的”保存Binder引用的红黑树”中查找是否存在该Server的Binder引用；找不到的话，就新建该Server对应的Binder引用，并将其添加到”ServiceManager的保存Binder引用的红黑树”中。简言之，Binder驱动会创建Server对应的Binder实体，并在ServiceManager的红黑树中添加该Binder实体的Binder引用。<br>  当ServiceManager收到Binder驱动转发的注册请求之后，它就将该Server的相关信息注册到”Binder引用组成的单链表”中。这里所说的Server相关信息主要包括两部分：Server对应的服务名 + Server对应的Binder实体的一个Binder引用。</p>
<p><strong>Client获取远程服务</strong><br>  Client要和某个Server通信，需要先获取到该Server的远程服务。那么Client是如何获取到Server的远程服务的呢？<br>  Client首先会向Binder驱动发起获取服务的请求。Binder驱动在收到该请求之后也是该请求转发给ServiceManager进程。ServiceManager在收到Binder驱动转发的请求之后，会从”Binder引用组成的单链表”中找到要获取的Server的相关信息。至于ServiceManager是如何从单链表中找到需要的Server的呢？答案是Client发送的请求数据中，会包括它要获取的Server的服务名；而ServiceManager正是根据这个服务名来找到Server的。<br>  接下来，ServiceManager通过Binder驱动将Server信息反馈给Client的。它反馈的信息是Server对应的Binder实体的Binder引用信息。而Client在收到该Server的Binder引用信息之后，就根据该Binder引用信息创建一个Server对应的远程服务。这个远程服务就是Server的代理，Client通过调用该远程服务的接口，就相当于在调用Server的服务接口一样；因为Client调用该Server的远程服务接口时，该远程服务会对应的通过Binder驱动和真正的Server进行交互，从而执行相应的动作。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-Binder设计解析"><a href="#2-Binder设计解析" class="headerlink" title="2. Binder设计解析"></a>2. Binder设计解析</h1><p>有了上面Binder模型的理论基础，接下来就可以逐步来讲解Binder的设计了。实际上，在设计C-S架构时，要考虑以下两个非常重要的因素。</p>
<p><strong>第一，Server要提供接入点</strong></p>
<p>  如果C-S架构中的Client和Server属于同一进程的话，那么Client和Server之间的通信将非常容易。只需要在Client端先获取相应的Server端对象；然后，再通过Server对象调用Server的相应接口即可。但是，Binder机制中涉及到的Client和Server是位于不同的进程中的，这也就意味着，不可能直接获取到Server对象。那么怎么办呢？ 那就需要Server提供一个接入点给Client。<br>  这个接入点就是<strong>“Server的远程服务代理”</strong>！<br>  Client能够获取到Server的远程服务，它就相当于Server的代理。Client要和Server通信时，它只需要调用该远程服务的相应接口即可，其他的工作都交给远程服务来处理。远程服务收到Client请求之后，会和Binder驱动通信；因为远程服务中有Server在Binder驱动中的Binder引用信息，因此远程服务就能轻易的找到对应的Server，进而将Client的请求内容发送Server。</p>
<p><strong>第二，通信协议</strong></p>
<p>  Binder机制中，涉及到大量的”内核的Binder驱动 和 用户空间的引用程序”之间的通信。需要指定对应的通信协议，确保通信的安全和正常。关于这部分，稍候再详细展开。</p>
<p>有了上面的两个中心思想之后，再来对Binder驱动的设计和协议进行逐步展开。</p>
<p><a name="anchor2_1"></a></p>
<h2 id="2-1-Binder设计"><a href="#2-1-Binder设计" class="headerlink" title="2.1 Binder设计"></a>2.1 Binder设计</h2><p>讲解Binder设计时，分为”内核空间”和”用户空间”这两部分进程讲解。内核空间就是Binder驱动中的Binder设计，而用户空间则是Android的C++层中的Binder设计。</p>
<p><a name="anchor2_1_1"></a></p>
<h3 id="2-1-1-内核空间的Binder设计"><a href="#2-1-1-内核空间的Binder设计" class="headerlink" title="2.1.1 内核空间的Binder设计"></a>2.1.1 内核空间的Binder设计</h3><p>内核空间的Binder设计涉及到3个非常重要的结构体：binder_proc，binder_node和binder_ref。由于本文的重点是介绍Binder机制的理论知识，因此，在这里我并不打算展开这3个结构体对它们进行详细介绍。当然，后面会再撰文对这些类进行详细说明。这里只需要了解个大概即可。</p>
<p>binder_proc是描述进程上下文信息的，每一个用户空间的进程都对应一个binder_proc结构体。<br>binder_node是Binder实体对应的结构体，它是Server在Binder驱动中的体现。<br>binder_ref是Binder引用对应的结构体，它是Client在Binder驱动中的体现。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds01.jpg" alt></a></p>
<p>如上图所示，binder_proc中包含了3棵红黑树。<br>(01) Binder实体红黑树是保存”binder_proc对应的进程”所包含的Binder实体的，而Binder实体是与Server的服务对应的。可以将Binder实体红黑树理解为Server进程中包行的Server服务的红黑树。<br>(02) 图中有两棵Binder引用红黑树，这两棵树所包含的Binder引用都是一样的。不同的是，红黑树的排序基准不同，一个是以Binder实体来排序，而另一个则是以Binder引用描述(Binder引用描述实际上就是一个32位的整型数)来排序。以Binder引用描述的红黑树是为了方便进行快速查找。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_kernel_ds02.jpg" alt></a></p>
<p>上图是描述Binder驱动中Binder实体结构体的。如图所示，Binder实体中有一个Binder引用的哈希表，专门来存放该Binder实体的Binder引用。这也如我们之前所说，每个Binder实体则可以多个Binder引用，而每个Binder引用则都只对应一个Binder实体。</p>
<p><a name="anchor2_1_2"></a></p>
<h3 id="2-1-2-用户空间的Binder设计"><a href="#2-1-2-用户空间的Binder设计" class="headerlink" title="2.1.2 用户空间的Binder设计"></a>2.1.2 用户空间的Binder设计</h3><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_user_ds01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_user_ds01.jpg" alt></a></p>
<p>上面是用户空间中Binder模型图，该图仅仅只描述出Server的相关类图，并没有Client部分。不过不要紧，通过这个Server的模型图，就能理清用户空间的Binder框架。</p>
<p>  前面说过，Server是以服务的形式注册到ServiceManager中，而Server在Client中则是以远程服务的形式存在的。因此，这个图的主干就是理清楚本地服务和远程服务这两者之间的关系。<br>  “本地服务”就是Server提供的服务本身，而”远程服务”就是服务的代理；”服务接口”则是抽象出了它们的通用接口。这3个角色都是通用的，对于不同的服务而言，它们的名称都不相同。例如，对于MediaPlayerService服务而言，本地服务就是MediaPlayerService自身，远程服务是BpMediaPlayerService，而服务接口是IMediaPlayerService。当Client需要向MediaPlayerService发送请求时，它需要先获取到服务的代理(即，远程服务对象)，也就是BpMediaPlayerService实例，然后通过该实例和MediaPlayerService进行通信。</p>
<p>  图中的ProcessState和IPCThreadState都是采用单例模式实现的，它们的实例都是全局的，而且只有唯一一个。</p>
<p>(01) 当Server启动之后，它会先将自己注册到ServiceManager中。注册时，Binder驱动会创建Server对应的Binder实体，并将”Server对应的本地服务对象的地址”保存到Binder实体中。注册成功之后，Server就进入消息循环，等待Client的请求。<br>(02) 当Client需要和Server通信时，会先获取到Server接入点，即获取到远程服务对象；而且Client要获取的远程服务对象是”服务接口”类型的。Client向ServiceManager发送获取服务的请求时，会通过IPCThreadState和Binder驱动进行通信；当ServiceManager反馈之后，IPCThreadState会将ServiceManager反馈的”Server的Binder引用信息”保存BpBinder中(具体来说，BpBinder的mHandle成员保存的就是Server的Binder引用信息)。然后，会根据该BpBinder对象创建对应的远程服务。这样，Client就获取到了远程服务对象，而且远程服务对象的成员中保存了Server的Binder引用信息。<br>(03) 当Client获取到远程服务对象之后，它就可以轻松的和Server进行通信了。当它需要向Server发送请求时，它会调用远程服务接口；远程服务能够获取到BpBinder对象，而BpBinder则通过IPCThreadState和Binder驱动进行通信。由于BpBinder中保存了Server在Binder驱动中的Binder引用；因此，IPCThreadState和Binder驱动通信时，是知道该请求是需要传给哪个Server的。Binder驱动通过Binder引用找到对应的Binder实体，然后将Binder实体中保存的”Server对应的本地服务对象的地址”返回给用户空间。当IPC收到Binder驱动反馈的内容之后，它从内容中找到”Server对应的本地服务对象”，然后调用该对象的onTransact()。不同的本地服务都可以实现自己的onTransact()；这样，不同的服务就可以按照自己的需求来处理请求。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-Binder通信"><a href="#2-2-Binder通信" class="headerlink" title="2.2 Binder通信"></a>2.2 Binder通信</h2><p>Binder通信协议是基于Command-Reply的方式的。</p>
<p><a name="anchor2_2_1"></a></p>
<h3 id="2-2-1-Binder通信模型"><a href="#2-2-1-Binder通信模型" class="headerlink" title="2.2.1 Binder通信模型"></a>2.2.1 Binder通信模型</h3><p>下面是Client和Server的交互模型图。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_communication.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_communication.jpg" alt></a></p>
<p>图中的原理很简单。<br>(01) Server进程启动之后，会进入中断等待状态，等待Client的请求。<br>(02) 当Client需要和Server通信时，会将请求发送给Binder驱动。<br>(03) Binder驱动收到请求之后，会唤醒Server进程。<br>(04) 接着，Binder驱动还会反馈信息给Client，告诉Client：它发送给Binder驱动的请求，Binder驱动已经收到。<br>(05) Client将请求发送成功之后，就进入等待状态。等待Server的回复。<br>(06) Binder驱动唤醒Server之后，就将请求转发给Server进程。<br>(07) Server进程解析出请求内容，并将回复内容发送给Binder驱动。<br>(08) Binder驱动收到回复之后，唤醒Client进程。<br>(09) 接着，Binder驱动还会反馈信息给Server，告诉Server：它发送给Binder驱动的回复，Binder驱动已经收到。<br>(10) Server将回复发送成功之后，再次进入等待状态，等待Client的请求。<br>(11) 最后，Binder驱动将回复转发给Client。</p>
<p><a name="anchor2_2_2"></a></p>
<h3 id="2-2-2-Binder通信数据"><a href="#2-2-2-Binder通信数据" class="headerlink" title="2.2.2 Binder通信数据"></a>2.2.2 Binder通信数据</h3><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_data.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/binder/binder_data.jpg" alt></a></p>
<p>上面是用户空间和内核空间进行交互时，数据的打包方式。例如，当Client向Server发送请求时，Client会将数据打包成上诉格式，然后通过ioctl()发送给Binder驱动。根据数据的层次，从外到里分为3层进行说明。</p>
<p><strong>第一层</strong>：这是用户空间的进程调用ioctl(fd,BINDER_WRITE_READ,&amp;bwr)时传递给Binder驱动的信息。fd是Binder驱动的文件句柄，BINDER_WRITE_READ是ioctl()的一个标识，而bwr是传递的数据，它对应是途中的binder_write_read结构体的指针。binder_write_read中以write_开头的是保存请求数据的，而read_开头的是保存反馈数据的。其中，write_size是请求数据的大小，write_buffer是请求数据的内容，而write_consumed是用来记录请求数据中已经被Binder驱动处理过的数据的大小。</p>
<p><strong>第二层</strong>：这层的数据是”事务指令”+”binder_transaction_data结构体”组成的。图中给出的事务指令是BC_TRANSACTION，表示该事务是请求；如果是回复，则是BR_开头的，例如BR_TRANSACTION。binder_transaction_data是描述事务交互数据的结构体；例如，target是指定事务目标，用来表示这个事务是交给谁进行处理的；code是事务编码，用来表示这是一个什么样的事务(例如，注册服务事务/获取服务事务等待)；data是保存事务中具体数据的内存地址。</p>
<p><strong>第三层</strong>：这层是有效数据。如果该请求是传递给ServiceManager进行处理的，则有效数据是：消息头+”Server的相关信息”。消息头是用来进行有效性检查的，而”Server的相关信息”则是请求要处理的信息。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/08/26/android/os/message/2014-08-26-MessageQueue/" itemprop="url">Android消息机制架构和源码解析</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-08-26T01:01:00.000Z" itemprop="datePublished">8月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            36 分钟 read (About 5349 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文会介绍Android的消息处理机制。  </p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Android消息机制的架构</a><br><strong>2</strong>. <a href="#anchor2">Android消息机制的源码解析</a><br><strong>2.1</strong>. <a href="#anchor2_1">消息循环</a><br><strong>2.2</strong>. <a href="#anchor2_2">消息的发送</a><br><strong>2.3</strong>. <a href="#anchor2_3">消息的处理</a>  </p>
</blockquote>
<blockquote>
<p>注意：本文是基于Android 4.4.2版本进行介绍的！</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Android消息机制的架构"><a href="#Android消息机制的架构" class="headerlink" title="Android消息机制的架构"></a>Android消息机制的架构</h1><p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/messagequeue/message_queue01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/messagequeue/message_queue01.jpg" alt></a></p>
<p>上面是消息机制的框架图。<br>(01) Looper是消息循环类，它包括了mQueue成员变量；mQueue是消息队列MessageQueue的实例。Looper还包含了loop()方法，通过调用loop()就能进入到消息循环中。<br>(02) MessageQueue是消息队列类，它包含了mMessages成员；mMessages是消息Message的实例。MessageQueue提供了next()方法来获取消息队列的下一则消息。<br>(03) Message是消息类。Message包含了next，next是Message的实例；由此可见，Message是一个单链表。Message还包括了target成员，target是Handler实例。此外，它还包括了arg1,arg2,what,obj等参数，它们都是用于记录消息的相关内容。<br>(04) Handler是消息句柄类。Handler提供了sendMessage()来向消息队列发送消息；发送消息的API有很多，它们的原理都是一样的，这里仅仅只列举了sendMessage()一个。  此外，Handler还提供了handleMessage()来处理消息队列的消息；这样，用户通过覆盖handleMessage()就能处理相应的消息。<br>消息机制位于Java层的框架主要就有上面4个类所组成。在C++层，比较重要的是NativeMessageQueue和Loop这两个类。<br>当我们启动一个APK时，ActivityManagerService会为我们的Activity创建并启动一个主线程(ActivityThread对象)；在启动主线程时，就会创建主线程对应的消息循环，并通过调用loop()进入到消息循环中。当我们需要往消息队列发送消息时，可以继承Handler类，然后创建Handler类的实例；接着，通过该实例的sendMessage()方法就可以向消息队列发送消息。  也就是说，主线程的消息队列也一直存在的。当消息队列中没有消息时，消息队列会进入空闲等待状态；当有消息时，则消息队列会进入运行状态，进而将相应的消息发送给handleMessage()进行处理。</p>
<br>
下面是消息机制的流程图：消息队列没有消息时进入空闲等待，有消息时才获取并发送消息。这种机制是通过pipe(管道)机制实现的，关于pipe机制的相关内容，后面再详细说明。

<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/messagequeue/message_queue02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/os/pic/messagequeue/message_queue02.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="Android消息机制的源码解析"><a href="#Android消息机制的源码解析" class="headerlink" title="Android消息机制的源码解析"></a>Android消息机制的源码解析</h1><p>下面从”消息循环、消息发送和消息处理”这3个方面对消息机制进行介绍。</p>
<p><a name="anchor2_1"></a></p>
<h2 id="1-消息循环"><a href="#1-消息循环" class="headerlink" title="1. 消息循环"></a>1. 消息循环</h2><p>Looper是消息循环类。下面先看看ActivityThread中是如何使用Looper的。</p>
<pre><code>public final class ActivityThread {

    ...

    public static void main(String[] args) {

        ...

        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        ...

        Looper.loop();

        ...
    }
}</code></pre><p>说明：上面是frameworks/base/core/java/android/app/ActivityThread.java中的main()函数代码。<br>通常在新打开一个APK界面时，系统会为APK启动创建一个ActivityThread对象，并调用它的main()方法。该main函数主要做了两件事：(01),新建ActivityThread对象。  (02),使用主线程进入消息循环。</p>
<pre><code>public final class Looper {
    private static final String TAG = &quot;Looper&quot;;

    static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
    private static Looper sMainLooper;  // guarded by Looper.class

    final MessageQueue mQueue;
    final Thread mThread;

    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
            }
            sMainLooper = myLooper();
        }
    }

    public static Looper getMainLooper() {
        synchronized (Looper.class) {
            return sMainLooper;
        }
    }

    public static Looper myLooper() {
        return sThreadLocal.get();
    }

    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }

    ...
}</code></pre><p>说明：上面是frameworks/base/core/java/android/os/Looper.java中创建消息循环的相关代码。<br>(01), prepareMainLooper()是新调用prepare()创建一个Looper对象，并且该Looper对象对应的消息队列是不能退出(quit)的。<br>(02), 新建的Looper对象是存放在sThreadLocal成员变量里面的，而sThreadLocal的类型为ThreadLocal。这意味着，它是一个线程局部变量，即保证每一个调用了prepareMainLooper函数的线程里面都有一个独立的Looper对象。<br>(03)，Looper()的构造函数中会新建消息队列MessageQueue对象，并且将当前的主线程保存到mThread中。实际上，Looper中的消息都是通过存放到MessageQueue消息队列中再进行处理的。</p>
<pre><code>public final class MessageQueue {

    // True if the message queue can be quit.
    private final boolean mQuitAllowed;

    @SuppressWarnings(&quot;unused&quot;)
    private int mPtr; // used by native code

    private native static int nativeInit();

    ...

    MessageQueue(boolean quitAllowed) {
        mQuitAllowed = quitAllowed;
        mPtr = nativeInit();
    }

    ...
}</code></pre><p>说明：该代码在frameworks/base/core/java/android/os/MessageQueue.java中。MessageQueue的构造函数会执行nativeInit()，nativeInit()是一个JNI函数，它的实现在frameworks/base/core/jni/android_os_MessageQueue.cpp中。</p>
<pre><code>static jint android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {
    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();
    if (!nativeMessageQueue) {
        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);
        return 0;
    }   

    nativeMessageQueue-&gt;incStrong(env);
    return reinterpret_cast&lt;jint&gt;(nativeMessageQueue);
}</code></pre><p>说明：该代码在frameworks/base/core/jni/android_os_MessageQueue.cpp中。android_os_MessageQueue_nativeInit()是与nativeInit()对应的JNI函数。<br>(01) 在该函数中，会新建NativeMessageQueue对象。这是我们分析的重点。<br>(02) nativeMessageQueue-&gt;incStrong(env); 它的作用是增加引用计数。  </p>
<pre><code>NativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) {
    mLooper = Looper::getForThread();
    if (mLooper == NULL) {
        mLooper = new Looper(false);
        Looper::setForThread(mLooper);
    }
}</code></pre><p>说明：该代码在frameworks/base/core/jni/android_os_MessageQueue.cpp中。NativeMessageQueue继承于MessageQueue，而MessageQueue包含mLooper成员，mLooper是一个Looper对象。 该函数中，会新建Looper对象，并调用setForThread()。</p>
<pre><code>Looper::Looper(bool allowNonCallbacks) :
        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),
        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {
    int wakeFds[2];
    int result = pipe(wakeFds);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not create wake pipe.  errno=%d&quot;, errno);

    mWakeReadPipeFd = wakeFds[0];
    mWakeWritePipeFd = wakeFds[1];

    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake read pipe non-blocking.  errno=%d&quot;,
            errno);

    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake write pipe non-blocking.  errno=%d&quot;,
            errno);

    mIdling = false;

    // Allocate the epoll instance and register the wake pipe.
    mEpollFd = epoll_create(EPOLL_SIZE_HINT);
    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);

    struct epoll_event eventItem;
    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
    eventItem.events = EPOLLIN;
    eventItem.data.fd = mWakeReadPipeFd;
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake read pipe to epoll instance.  errno=%d&quot;,
            errno);
}</code></pre><p>说明：该代码在system/core/libutils/Looper.cpp中。Looper构造函数所在做的事情非常重要，它跟消息机制的原理息息相关：Looper是通过管道(pipe)实现的。</p>
<blockquote>
<p>关于管道，简单来说，管道就是一个文件。<br>在管道的两端，分别是两个打开文件文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的。<br>一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。这个等待和唤醒的操作是如何进行的呢，这就要借助Linux系统中的epoll机制了。 Linux系统中的epoll机制为处理大批量句柄而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
</blockquote>
<p>(01) pipe(wakeFds)，该函数创建了两个管道句柄。<br>(02) mWakeReadPipeFd=wakeFds[0]，是读管道的句柄。<br>(03) mWakeWritePipeFd=wakeFds[1]，是写管道的句柄。<br>(04) epoll_create(EPOLL_SIZE_HINT)是创建epoll句柄。<br>(05) epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem)，它的作用是告诉mEpollFd，它要监控mWakeReadPipeFd文件描述符的EPOLLIN事件，即当管道中有内容可读时，就唤醒当前正在等待管道中的内容的线程。</p>
<br>
至此，就介绍完消息循环的创建/准备阶段。该节点的主要工作可以概括为2部分内容：  
(01) Java层，创建Looper对象，Looper的构造函数中会创建消息队列MessageQueue的对象。MessageQueue的作用存储消息队列，用来管理消息的。  
(02) C++层，消息队列创建时，会调用JNI函数，初始化NativeMessageQueue对象。NativeMessageQueue则会初始化Looper对象。Looper的作用就是，当Java层的消息队列中没有消息时，就使Android应用程序主线程进入等待状态，而当Java层的消息队列中来了新的消息后，就唤醒Android应用程序的主线程来处理这个消息。



<br>
下面分析Looper.loop()函数。

<pre><code>public final class Looper {

    ...

    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
        }
        final MessageQueue queue = me.mQueue;

        ...

        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                return;
            }

            ...

            msg.target.dispatchMessage(msg);

            ...

            msg.recycle();
        }
    }  

    ...
}</code></pre><p>说明：loop()的作用就是不断的从消息队列中获取消息，然后分发处理。<br>(01) myLooper()，是获取当前的Looper对象；而mQueue则是Looper对应的消息队列对象。<br>(02) queue.next()是消息队列的下一个要处理消息。如果消息为空，则退出loop循环；否则，调用dispatchMessage()分发消息。  </p>
<pre><code>Message next() {
    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        // 调用JNI函数Poll消息。nextPollTimeoutMillis是消息队列中没消息时的等待时间。
        // (01) nextPollTimeoutMillis = 0，不等待。
        // (02) nextPollTimeoutMillis = -1，无限等待。
        nativePollOnce(mPtr, nextPollTimeoutMillis);

        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            // 如果当前消息非空，但是当前消息的目标是空；则获取下一则消息。
            if (msg != null &amp;&amp; msg.target == null) {
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    // 如果消息队列中有消息，并且当前时间小于于消息中的执行时间，
                    // 则设置消息的等待时间
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // 如果消息队列中有消息，并且当前时间大于/等于消息中的执行时间，
                    // 则将该消息返回给Looper。
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false) Log.v(&quot;MessageQueue&quot;, &quot;Returning message: &quot; + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // 如果消息队列中无消息，则设置nextPollTimeoutMillis=-1；
                // 下次调用nativePollOnce()时，则会进入无穷等待状态。
                nextPollTimeoutMillis = -1;
            }

            // 如主线程调用的quit()函数，则退出消息循环。
            if (mQuitting) {
                dispose();
                return null;
            }

            // 查看空闲等待(不是忙等待)对应的pendingIdleHandlerCount数量。
            // 如果pendingIdleHandlerCount=0，则继续下一次循环。
            if (pendingIdleHandlerCount &lt; 0
                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            // 将mIdleHandlers转换位数组
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // 执行mPendingIdleHandlers中每一个IdleHandler的queueIdle()，
        // 即，进行空闲等待。
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(&quot;MessageQueue&quot;, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}</code></pre><p>说明：next()的作用是获取消息队列的下一条待处理消息。该函数可能导致主线程进入等待状态。源码中已经消息标明了注释，这里就不再重复说明了。 下面分析next()中的nativePollOnce()，它对应的实现函数是android_os_MessageQueue_nativePollOnce()。 </p>
<pre><code>static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jclass clazz,
        jint ptr, jint timeoutMillis) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;pollOnce(env, timeoutMillis);
}</code></pre><p>说明：该函数调用了pollOnce()。</p>
<pre><code>void NativeMessageQueue::pollOnce(JNIEnv* env, int timeoutMillis) {
    ...
    mLooper-&gt;pollOnce(timeoutMillis);
    ...
}</code></pre><p>说明：NativeMessageQueue的pollOnce()，调用了Looper.java中(即mLooper)的pollOnce()。</p>
<pre><code>int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    ...
    int result = 0;
    for (;;) {
        ...   

        if (result != 0) {
            ...
            return result;
        }   

        result = pollInner(timeoutMillis);
    }   
}</code></pre><p>说明：pollOnce()调用了pollInner()。 </p>
<pre><code>int Looper::pollInner(int timeoutMillis) {

    ...

    // 通过epoll_wait()等待mEpollFd上IO事件的发生
    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    ...

    // 如果epoll_wait()时出错，则直接跳到Done处。
    if (eventCount &lt; 0) {
        ...
        goto Done;
    }

    // 如果没有IO事件发生，则直接跳到Done处。
    if (eventCount == 0) {
        ...
        goto Done;
    }

    // 如果有IO事件发生，则逐个取出IO事件，如果是写事件(EPOLLIN)，则调用awoken()
    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeReadPipeFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            } else {
                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;, epollEvents);
            }
        } else {
            ...
        }
    }

Done: ;

    ...

    return result;
}</code></pre><p>说明：pollInner()就是先通过epoll_wait()进入空闲等待状态，等待消息队列的管道上的消息(IO事件)。如果有消息待处理(即管道上有IO写事件发生，写事件是EPOLLIN类型)，则调用awoken()将消息读取出来。</p>
<pre><code>void Looper::awoken() {
    ...

    char buffer[16];
    ssize_t nRead;
    do {
        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));
    } while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer));
}</code></pre><p>说明：awoken()的作用只是把管道中的内容都读取出来。在了解了后面将介绍的”发送消息”之后，会了解到，这里读取的数据内容是无所谓的(实际上读取到的数据就是一个”w”)。重要的是，通过往管道中读/写数据来使处于等待状态的主线程继续运行。</p>
<br>
至此，"消息循环"部分就介绍完毕了！  
回到Looper.loop()中，next()获取到了消息队列的下一则待处理的消息之后；接着，会调用dispatchMessage()来分发处理消息了。dispatchMessage()的内容，我们放到后面的"消息的处理"部分再来介绍。





<p><a name="anchor2_2"></a></p>
<h2 id="2-消息的发送"><a href="#2-消息的发送" class="headerlink" title="2. 消息的发送"></a>2. 消息的发送</h2><p>还是以ActivityThread为例，看看如何发送消息。在启动Activity时，会调用scheduleLaunchActivity()，下面看看scheduleLaunchActivity()是如何发送消息的。</p>
<pre><code>public final class ActivityThread {
    ...

    private class ApplicationThread extends ApplicationThreadNative {
        ...

        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo,
                int procState, Bundle state, List&lt;ResultInfo&gt; pendingResults,
                List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward,
                String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) {

            ...

            sendMessage(H.LAUNCH_ACTIVITY, r);
        }

        ...
    }

    ...

    private void sendMessage(int what, Object obj) {
        sendMessage(what, obj, 0, 0, false);
    }

    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {

        Message msg = Message.obtain();
        msg.what = what;
        msg.obj = obj;
        msg.arg1 = arg1;
        msg.arg2 = arg2;
        if (async) {
            msg.setAsynchronous(true);
        }
        mH.sendMessage(msg);
    }

    ...
}</code></pre><p>说明：scheduleLaunchActivity()定义在类ApplicationThread中，而ApplicationThread是ActivityThread的内部类。<br>(01) scheduleLaunchActivity()调用sendMessage()发送消息，实际上是调用的ActivityThread类中的sendMessage。<br>(02) 在sendMessage()中，会新建一个Message；然后调用mH.sendMessage(msg)来发送消息。  </p>
<pre><code>public final class ActivityThread {

    ...

    final H mH = new H();

    ...

    private class H extends Handler {
        ... 

        public void handleMessage(Message msg) {
            ...

            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;

                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ...
            }
        }
    }
}</code></pre><p>说明：mH是H实例，H继承于Handler。sendMessage()的实现在Handler中，下面看看它的实现代码。</p>
<pre><code>public class Handler {

    ...

    public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }

    public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis &lt; 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }

    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }

    ...
}</code></pre><p>说明：该代码在frameworks/base/core/java/android/os/Handler.java中。<br>(01) sendMessage()调用sendMessageDelayed(msg, delayMillis)。sendMessageDelayed(msg, delayMillis)是延时发送消息函数，sendMessage()传入的delayMillis=0，表示延时是0。<br>(02) sendMessageDelayed()调用sendMessageAtTime()。sendMessageAtTime()是指定消息的执行时间的函数。<br>(03) sendMessageAtTime()调用enqueueMessage()。<br>(04) enqueueMessage()queue.enqueueMessage()将消息添加到消息队列中。  </p>
<pre><code>public final class MessageQueue {

    ...

    boolean enqueueMessage(Message msg, long when) {

        ...

        synchronized (this) {
            if (mQuitting) {
                return false;
            }

            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                // 消息队列无消息
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // 消息队列有消息。将当前消息插入到适当的位置
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // 唤醒主线程
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }

    ...

}</code></pre><p>说明：enqueueMessage()会将消息加入到消息队列中。把消息加入到消息队列时，分2种情况：<br>(01)，消息队列为空。  这时候应用程序的主线程一般就是处于空闲等待状态了，这时候就要唤醒它。<br>(02)，消息队列不为空。  这时候就不需要唤醒应用程序的主线程了，因为这时候它一定是在忙着处于消息队列中的消息，因此不会处于空闲等待的状态。<br>在添加完消息之后，如果主线程需要唤醒，则调用nativeWake()。nativeWake()是个JNI函数，它对应的实现是frameworks/base/core/jni/android_os_MessageQueue.cpp中的android_os_MessageQueue_nativeWake()。</p>
<pre><code>static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jint ptr) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    return nativeMessageQueue-&gt;wake();
}</code></pre><p>说明：该函数会调用NativeMessageQueue类中的wake()。</p>
<pre><code>void NativeMessageQueue::wake() {
    mLooper-&gt;wake();
}</code></pre><p>说明：该函数会调用system/core/libutils/Looper.cpp中的wake()。mLooper是创建NativeMessageQueue时创建的Looper对象，这在前面已经介绍过了。</p>
<pre><code>void Looper::wake() {

    ...       

    ssize_t nWrite;
    do {
        nWrite = write(mWakeWritePipeFd, &quot;W&quot;, 1);
    } while (nWrite == -1 &amp;&amp; errno == EINTR);

    ...       
}           </code></pre><p>说明：wake()的作用很简单，就是通过打开文件描述符mWakeWritePipeFd往管道的写入一个”W”字符串。<br>其实，往管道写入什么内容并不重要，往管道写入内容的目的是为了唤醒应用程序的主线程。<strong>前面我们在分析应用程序的消息循环时说到，当应用程序的消息队列中没有消息处理时，应用程序的主线程就会进入空闲等待状态，而这个空闲等待状态就是通过调用这个Looper类的pollInner()函数来进入的，具体就是在pollInner()函数中调用epoll_wait()函数来等待管道中有内容可读的</strong>。这样，就将发送消息和接收消息联系起来了。</p>
<p><a name="anchor2_3"></a></p>
<h2 id="3-消息的处理"><a href="#3-消息的处理" class="headerlink" title="3. 消息的处理"></a>3. 消息的处理</h2><p>前面介绍了”消息的发送过程”；而且我们又知道，在”消息循环”中，会不断读取消息，然后调用dispatchMessage()来分发处理。</p>
<pre><code>public final class Looper {

    ...

    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
        }
        final MessageQueue queue = me.mQueue;

        ...

        for (;;) {
            // 取出消息
            Message msg = queue.next(); // might block
            if (msg == null) {
                return;
            }

            ...

            // 分发处理
            msg.target.dispatchMessage(msg);

            ...

            msg.recycle();
        }
    }  

    ...
}</code></pre><p>说明：上面就是loop()消息循环的代码，这在前面已经介绍过了。首先，从消息队列中通过next()取出消息；然后通过dispatchMessage()分发消息。<br>下面，现看看msg.target是什么对象。 </p>
<pre><code>public class Handler {

    ...

    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }

    ...
}</code></pre><p>说明：实际上，msg.target是在”发送消息时”调用的enqueueMessage()中赋值的。this就是Handler对象，而在”消息的发送”中，真正发送消息的是Handler的子类H。也就是说，this是类H的实例。  </p>
<pre><code>public final class ActivityThread {

    ...

    private class H extends Handler {
        ... 
    }

    ...

}</code></pre><p>说明：上面就是ActivityThread中H的定义。<br>现在，我们已经澄清了msg.target是H类的实例。那么，再次回到 msg.target.dispatchMessage(msg)中，它实际上是调用的Handler类(H类的父类)的dispatchMessage()函数。</p>
<pre><code>public class Handler {

    ...

    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }

    ...

}</code></pre><p>说明：在本文的示例ActivityThread中，msg.callback为空。dispatchMessage()最终会调用handleMessage()处理消息。下面看看H中handleMessage()的代码。</p>
<pre><code>public final class ActivityThread {

    ...

    final H mH = new H();

    ...

    private class H extends Handler {
        ... 

        public void handleMessage(Message msg) {
            ...

            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;

                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ...
            }
        }
    }
}</code></pre><p>说明：handleMessage()的内容不是重点，需要关注的是：消息队列的消息最终是通过handleMessage()来处理的！</p>
<br>
至此，消息机制的发送/接受/处理消息部分都介绍完毕了！总的来说：  
(01)，应用程序先通过Looper.prepareMainLooper()来创建消息队列。在创建消息队列的过程中，会创建Looper对象，MessageQueue对象，并调用JNI函数；最终，通过管道来进入空闲等待状态。  
(02)，当应用程序调用sendMessage()或其他类似接口发送消息时，消息会被添加到消息队列；并最终会先管道中写入内容，从而唤醒管道上处于空闲等待状态的主线程。  
(03)，管道上的空闲状态的主线程被唤醒之后，就会读出消息队列的消息，然后通过dispatchMessage()来分发处理。最终，消息会通过handleMessage()来进行处理。



    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/26/android/api_guide/animation/drawable_animation/2014-07-24-DrawableAnimation-BasicUsage/" itemprop="url">Android 之Animation动画(七)之 Drawable Animation</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-26T01:00:00.000Z" itemprop="datePublished">7月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 read (About 265 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Android中的Drawable Animation。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Drawable Animation的简介和语法</a><br><strong>2</strong>. <a href="#anchor2">Drawable Animation的示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Drawable-Animation的简介和语法"><a href="#Drawable-Animation的简介和语法" class="headerlink" title="Drawable Animation的简介和语法"></a>Drawable Animation的简介和语法</h1><p>Drawable Animation(Frame Animation)：帧动画，就像GIF图片，通过一系列Drawable依次显示来模拟动画的效果。</p>
<p>Drawable Animation的定义是通过在<strong>res/anim</strong>目录下新建一个xml文件来定义。xml文件的格式如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:oneshot=&quot;false&quot;&gt;
    &lt;item android:drawable=&quot;@drawable/rocket_thrust1&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/rocket_thrust2&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/rocket_thrust3&quot; android:duration=&quot;200&quot; /&gt;
&lt;/animation-list&gt;</code></pre><p>说明：<br>(01) oneshot表示是否循环播放。true表示不循环播放，否则就循环播放。<br>(02) duration表示每帧的播放时间。  </p>
<p><a name="anchor2"></a></p>
<h1 id="Drawable-Animation的示例"><a href="#Drawable-Animation的示例" class="headerlink" title="Drawable Animation的示例"></a>Drawable Animation的示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/drawable_animation/01_basic/AnimationTest" target="_blank" rel="noopener">Drawable Animation示例的完整源码</a></p>
<p>示例中是通过ImageView来使用Drawable Animation的。 下面是获取ImageView的AnimationDrawable对象的方法：</p>
<pre><code>mImage = (ImageView)findViewById(R.id.animation);
mImage.setBackgroundResource(R.anim.anim_kof);
mAnimation = (AnimationDrawable) mImage.getBackground();</code></pre><p>说明：res/anim/anim_kof.xml就是动画的定义。</p>
<p>得到AnimationDrawable对象之后，就可以通过mAnimation.start()直接启动动画了。 </p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/25/android/api_guide/animation/view_animation/2014-07-24-ViewAnimation-BasicUsage/" itemprop="url">Android 之Animation动画(六)之 View Animation</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-25T01:00:00.000Z" itemprop="datePublished">7月 25 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            6 分钟 read (About 930 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Android中的View Animation。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">View Animation简介</a><br><strong>2</strong>. <a href="#anchor2">View Animation的语法规则</a><br><strong>3</strong>. <a href="#anchor3">View Animation的示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="View-Animation简介"><a href="#View-Animation简介" class="headerlink" title="View Animation简介"></a>View Animation简介</h1><p>View Animation(Tween Animation): 补间动画，给出两个关键帧，通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。</p>
<p>View Animation只能用来实现四种基本动作：透明/伸缩/移动/旋转。它与”Property Animation适用于任意Object类型不同”，View Animation只适用于View。但是View Animation相比于Property Animation的使用更加简单。</p>
<p><a name="anchor2"></a></p>
<h1 id="View-Animation的语法规则"><a href="#View-Animation的语法规则" class="headerlink" title="View Animation的语法规则"></a>View Animation的语法规则</h1><h2 id="1-View-Animation的样式"><a href="#1-View-Animation的样式" class="headerlink" title="1. View Animation的样式"></a>1. View Animation的样式</h2><p>View Animation通常在<strong>res/anim</strong>目录下新建一个xml文件来定义。xml文件的格式如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;
    android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt;
    &lt;alpha
        android:fromAlpha=&quot;float&quot;
        android:toAlpha=&quot;float&quot; /&gt;
    &lt;scale
        android:fromXScale=&quot;float&quot;
        android:toXScale=&quot;float&quot;
        android:fromYScale=&quot;float&quot;
        android:toYScale=&quot;float&quot;
        android:pivotX=&quot;float&quot;
        android:pivotY=&quot;float&quot; /&gt;
    &lt;translate
        android:fromXDelta=&quot;float&quot;
        android:toXDelta=&quot;float&quot;
        android:fromYDelta=&quot;float&quot;
        android:toYDelta=&quot;float&quot; /&gt;
    &lt;rotate
        android:fromDegrees=&quot;float&quot;
        android:toDegrees=&quot;float&quot;
        android:pivotX=&quot;float&quot;
        android:pivotY=&quot;float&quot; /&gt;
    &lt;set&gt;
        ...
    &lt;/set&gt;
&lt;/set&gt;</code></pre><p>说明：<br>(01) <strong>set</strong>: 是动画的集合，相当于一个容器。<br>(02) <strong>interpolator</strong>: 动画的动作类型，比如accelerate_interpolator类型的动画是加速的，它会越来越快。<br>(03) <strong>shareInterpolator</strong>: 将set的interpolator应用到set所包行的动画中。<br>(04) <strong>alpha</strong>: 透明度。<br>&nbsp;&nbsp; a) <strong>fromAlpha</strong>: 起始动画的透明度。它的值是0<del>1.0之间；0表示完全透明，1.0表示完全不透明。<br>&nbsp;&nbsp; b) <strong>toAlpha</strong>: 结束动画的透明度。它的值是0</del>1.0之间；0表示完全透明，1.0表示完全不透明。<br>(05) <strong>scale</strong>: 缩放。<br>&nbsp;&nbsp; a) <strong>fromXScale</strong>: 起始动画在X轴上的缩放倍数。0表示没有，2表示2倍。<br>&nbsp;&nbsp; b) <strong>toXScale</strong>: 结束动画在X轴上的缩放倍数。0表示没有，2表示2倍。<br>&nbsp;&nbsp; c) <strong>fromYScale</strong>: 起始动画在Y轴上的缩放倍数。0表示没有，2表示2倍。<br>&nbsp;&nbsp; d) <strong>toYScale</strong>: 结束动画在Y轴上的缩放倍数。0表示没有，2表示2倍。<br>&nbsp;&nbsp; e) <strong>pivotX</strong>: 动画缩放时，中心点在X轴上的位置(相对于原始的视图)。50%表示在视图的X轴中间。<br>&nbsp;&nbsp; f) <strong>pivotY</strong>: 动画缩放时，中心点在Y轴上的位置(相对于原始的视图)。50%表示在视图的Y轴中间。<br>(06) <strong>training</strong>: 移动。<br>&nbsp;&nbsp; a) <strong>fromXDelta</strong>: 起始动画在X轴上的偏移像素(相对于视图左上角)。<br>&nbsp;&nbsp; b) <strong>toXDelta</strong>: 结束动画在X轴上的偏移像素(相对于视图左上角)。<br>&nbsp;&nbsp; c) <strong>fromYDelta</strong>: 起始动画在Y轴上的偏移像素(相对于视图左上角)。<br>&nbsp;&nbsp; d) <strong>toYDelta</strong>: 结束动画在Y轴上的偏移像素(相对于视图左上角)。<br>(07) <strong>rotate</strong>: 旋转。<br>&nbsp;&nbsp; a) <strong>fromDegrees</strong>: 起始动画在的角度。可以是负数，也可以大于360。<br>&nbsp;&nbsp; b) <strong>toDegrees</strong>: 起始动画在的角度。可以是负数，也可以大于360。<br>&nbsp;&nbsp; c) <strong>pivotX</strong>: 动画旋转时，中心点在X轴上的位置(相对于原始的视图)。50%表示在视图的X轴中间。<br>&nbsp;&nbsp; d) <strong>pivotY</strong>: 动画旋转时，中心点在Y轴上的位置(相对于原始的视图)。50%表示在视图的Y轴中间。<br>rotate既可以顺时针旋转，也可以逆时针旋转。 </p>
<h2 id="2-interpolator的样式"><a href="#2-interpolator的样式" class="headerlink" title="2. interpolator的样式"></a>2. interpolator的样式</h2><p>系统自带的interpolator样式如下：</p>
<p>@android:anim/accelerate_decelerate_interpolator<br>@android:anim/accelerate_interpolator<br>@android:anim/anticipate_interpolator<br>@android:anim/anticipate_overshoot_interpolator<br>@android:anim/bounce_interpolator<br>@android:anim/cycle_interpolator<br>@android:anim/decelerate_interpolator<br>@android:anim/linear_interpolator<br>@android:anim/overshoot_interpolator</p>
<p><a name="anchor3"></a></p>
<h1 id="View-Animation的示例"><a href="#View-Animation的示例" class="headerlink" title="View Animation的示例"></a>View Animation的示例</h1><p>点击查看: <a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/view_animation/01_basic/AnimationTest" target="_blank" rel="noopener">View Animation的示例源码</a></p>
<p>该示例包括View Animation的”透明/伸缩/移动/旋转”，也包括”它们的组合”。</p>
<p>View Animation的具体播放代码如下：</p>
<pre><code>Animation anim = AnimationUtils.loadAnimation(this, R.anim.anim_alpha);
view.startAnimation(anim);</code></pre><p>说明：view是一个View对象。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-Layout/" itemprop="url">Android 之Animation动画(五)之 Property Animation的布局动画</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T04:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 分钟 read (About 385 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章如何通过Property Animation设置Android的布局动画。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Property Animation布局动画简介</a><br><strong>2</strong>. <a href="#anchor2">Property Animation布局动画示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Property-Animation布局动画简介"><a href="#Property-Animation布局动画简介" class="headerlink" title="Property Animation布局动画简介"></a>Property Animation布局动画简介</h1><p>Property Animation支持对ViewGroup中的View设置动画。</p>
<p>例如，当你添加或者移除ViewGroup中的View时，或者你调用View的setVisibility()方法来控制其显示或消失时；就可以设置相应的Property Animation动画。</p>
<p>Android的View视图支持动画的主要有四种行为：<br><strong>APPEARING</strong>：某个View被添加到ViewGroup中时，该View的动画。<br><strong>DISAPPEARING</strong>：某个View从ViewGroup中删除时，该View的动画。<br><strong>CHANGE_APPEARING</strong>：某个View被添加到ViewGroup中，并引起该ViewGroup中其他View的变化位置时，其他View的动画。<br><strong>CHANGE_DISAPPEARING</strong>：某个View从ViewGroup中删除，，并引起该ViewGroup中其他View的变化位置时，其他View的动画。</p>
<p><a name="anchor2"></a></p>
<h1 id="Property-Animation布局动画示例"><a href="#Property-Animation布局动画示例" class="headerlink" title="Property Animation布局动画示例"></a>Property Animation布局动画示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/property_animation/04_layout_animation/AnimationTest" target="_blank" rel="noopener">Property Animation布局动画示例</a></p>
<p>该示例中，包括：Android默认的动画，以及前面介绍的View的四种类型的动画的演示。以APPEARING来简单说明下布局动画的使用。</p>
<pre><code>// 设置ViewGroup(mSelfLayout)对应的LayoutTransition。
LayoutTransition transition = new LayoutTransition();
mSelfLayout.setLayoutTransition(transition);

// (添加)动画：APPEARING
ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 90f, 0f);
animIn.setDuration(transition.getDuration(LayoutTransition.APPEARING));
transition.setAnimator(LayoutTransition.APPEARING, animIn);
animIn.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator anim) {
        View view = (View) ((ObjectAnimator) anim).getTarget();
        view.setRotationY(0f);
    }   
}); </code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-MultiPropChange/" itemprop="url">Android 之Animation动画(四)之 Property Animation的多属性变化</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T03:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 read (About 354 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Property Animation中多属性变化的情况。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Property Animation的多属性变化的种类</a><br><strong>2</strong>. <a href="#anchor2">Property Animation的关键帧</a><br><strong>3</strong>. <a href="#anchor3">Property Animation的完整示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Property-Animation的多属性变化的种类"><a href="#Property-Animation的多属性变化的种类" class="headerlink" title="Property Animation的多属性变化的种类"></a>Property Animation的多属性变化的种类</h1><p>给同一个View实现同一个动画效果(同时变化x和y)，有下面三种方法。</p>
<p><strong>方法一：用多个ObjectAnimator对象</strong> </p>
<pre><code>ObjectAnimator animX = ObjectAnimator.ofFloat(myView, &quot;x&quot;, 50f);
ObjectAnimator animY = ObjectAnimator.ofFloat(myView, &quot;y&quot;, 100f);
AnimatorSet animSetXY = new AnimatorSet();
animSetXY.playTogether(animX, animY);
animSetXY.start();</code></pre><p><strong>方法二：用一个ObjectAnimator对象加多个PropertyValuesHolder</strong></p>
<pre><code>PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(&quot;x&quot;, 50f);
PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(&quot;y&quot;, 100f);
ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();</code></pre><p><strong>方法三：用ViewPropertyAnimator</strong></p>
<pre><code>myView.animate().x(50f).y(100f);</code></pre><p><a name="anchor2"></a></p>
<h1 id="Property-Animation的关键帧"><a href="#Property-Animation的关键帧" class="headerlink" title="Property Animation的关键帧"></a>Property Animation的关键帧</h1><p>通过关键帧，我们能实现较为复杂的动画；例如，实现曲线运动。下面给出关键帧的使用示例：</p>
<pre><code>// ==== view4的动画 ==== (利用&quot;关键帧&quot;实现曲线运动)
PropertyValuesHolder anim4Y = PropertyValuesHolder.ofFloat(
        &quot;y&quot;, 0f, (float)(view2.getHeight() - view2.getWidth()));
float x = view2.getX();
// 三个关键帧
Keyframe kf0 = Keyframe.ofFloat(0f, x); 
Keyframe kf1 = Keyframe.ofFloat(.5f, x + 20f);
Keyframe kf2 = Keyframe.ofFloat(1f, x); 
PropertyValuesHolder anim4X = PropertyValuesHolder.ofKeyframe(
        &quot;x&quot;, kf0, kf1, kf2);
ObjectAnimator anim4 = ObjectAnimator.ofPropertyValuesHolder(view4, anim4Y, anim4X);
anim4.setDuration(1000);
anim4.setInterpolator(new AccelerateInterpolator());
anim4.setRepeatCount(1);
anim4.setRepeatMode(ValueAnimator.REVERSE);
anim4.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        //view4.invalidate();
        mContainer.invalidate();
    }   
}); </code></pre><p><a name="anchor3"></a></p>
<h1 id="Property-Animation的完整示例"><a href="#Property-Animation的完整示例" class="headerlink" title="Property Animation的完整示例"></a>Property Animation的完整示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/property_animation/03_multi_action/AnimationTest" target="_blank" rel="noopener">多属性变化和关键帧的完整源码</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-XmlUsage/" itemprop="url">Android 之Animation动画(三)之 Property Animation的XML属性和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T02:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 read (About 545 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面介绍了Property Animation的相关类和类的基本使用方法，本章将介绍Property Animation的属性以及如何通过属性来使用Property Animation。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Property Animation属性介绍</a><br><strong>2</strong>. <a href="#anchor2">Property Animation属性使用示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Property-Animation属性介绍"><a href="#Property-Animation属性介绍" class="headerlink" title="Property Animation属性介绍"></a>Property Animation属性介绍</h1><p>我们可以用XML文件来定义Property Animation。XML的基本语法如下：</p>
<pre><code>&lt;set
  android:ordering=[&quot;together&quot; | &quot;sequentially&quot;]&gt;

    &lt;objectAnimator
        android:propertyName=&quot;string&quot;
        android:duration=&quot;int&quot;
        android:valueFrom=&quot;float | int | color&quot;
        android:valueTo=&quot;float | int | color&quot;
        android:startOffset=&quot;int&quot;
        android:repeatCount=&quot;int&quot;
        android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]
        android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt;

    &lt;animator
        android:duration=&quot;int&quot;
        android:valueFrom=&quot;float | int | color&quot;
        android:valueTo=&quot;float | int | color&quot;
        android:startOffset=&quot;int&quot;
        android:repeatCount=&quot;int&quot;
        android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]
        android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt;

    &lt;set&gt;
        ...
    &lt;/set&gt;
&lt;/set&gt;</code></pre><p>说明：<br>(01) <strong><set></set></strong>: 是objectAnimator和animator的集合。<set>标签是可以嵌套的。<br>(02) <strong><objectanimator></objectanimator></strong>: 对应是ObjectAnimator动画。<br>(03) <strong><animator></animator></strong>: 对应是ValueAnimator动画。<br>(04) <strong>android:propertyName</strong>: 属性名。仅ObjectAnimator才有该属性。<br>(05) <strong>android:duration</strong>: 动画的总时间，以ms为单位，默认是300ms。<br>(06) <strong>android:valueFrom</strong>: 动画的起始值。<br>(07) <strong>android:valueTo</strong>: 动画的结束值。<br>(08) <strong>android:startOffset</strong>: 动画的起始偏移时间，以ms为单位。<br>(09) <strong>android:repeatCount</strong>: 动画重复播放重复次数。-1表示无穷次，默认是0。<br>(10) <strong>android:repeatMode</strong>: 动画重复播放时的模式。repeat表示和原来一样从头开始播放，reverse表示反向播放；默认是repeat。<br>(11) <strong>android:valueType</strong>: 属性的值的类型。可以位intType或floatType。  </set></p>
<p>假设存在res/anim/property_animator.xml文件，该文件中定义了Property Animation动画。则动画的使用方法如下：</p>
<pre><code>AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,
    R.anim.property_animator);
set.setTarget(myObject);
set.start();</code></pre><p>此外，补充说明两点：<br>(01) View Animation的部分属性在Property Animation中也是可以使用的。例如，android:interpolator。<br>(02) 为了区分Property Animation和View Animation的资源文件，从Android 3.1开始，Property Animation的xml文件存在res/animator/目录下（View Animation存在res/anim/目录下）， animator这个名是可选的。</p>
<p><a name="anchor2"></a></p>
<h1 id="Property-Animation属性使用示例"><a href="#Property-Animation属性使用示例" class="headerlink" title="Property Animation属性使用示例"></a>Property Animation属性使用示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/property_animation/02_xml_basic/AnimationTest" target="_blank" rel="noopener">Property Animation属性使用示例的源码</a></p>
<p>在该示例中存在多种动画。下面列举一种：球加速下落，并具有弹跳效果。</p>
<p>动画的配置文件res/anim/view01.xml的内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1200&quot;
    android:propertyName=&quot;y&quot;
    android:valueFrom=&quot;0&quot;
    android:valueTo=&quot;249&quot;
    android:valueType=&quot;floatType&quot;
    android:interpolator=&quot;@android:anim/bounce_interpolator&quot;
    android:repeatCount=&quot;0&quot; /&gt;</code></pre><p>动画的使用代码如下：</p>
<pre><code>ObjectAnimator anim1 = (ObjectAnimator) AnimatorInflater.loadAnimator(context, R.anim.view01);
anim1.setTarget(view1);
anim1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        view1.invalidate();
    }
});</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/property_animation/2014-07-24-PropertyAnimation-BasicUsage/" itemprop="url">Android 之Animation动画(二)之 Property Animation的基本介绍和使用示例</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T01:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            11 分钟 read (About 1598 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Android的Property Animation。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Property Animation简介</a><br><strong>2</strong>. <a href="#anchor2">Property Animation的基本用法和示例源码</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Property-Animation简介"><a href="#Property-Animation简介" class="headerlink" title="Property Animation简介"></a>Property Animation简介</h1><p>Property Animation是属性动画。它是在Android 3.0中才引进的，它比View Animation和Drawable Animation功能更加强大。</p>
<h2 id="1-Property-Animation支持的属性"><a href="#1-Property-Animation支持的属性" class="headerlink" title="1. Property Animation支持的属性"></a>1. Property Animation支持的属性</h2><p>在Property Animation中，可以对动画应用以下属性：<br><strong>Duration</strong>：动画的持续时间。<br><strong>TimeInterpolation</strong>：属性值的计算方式，如先快后慢。<br><strong>TypeEvaluator</strong>：根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值。<br><strong>Repeat Count and behavoir</strong>：重复次数与方式，如播放3次、5次、无限循环，可以此动画一直重复，或播放完时再反向播放。<br><strong>Animation sets</strong>：动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同开始偏移。<br><strong>Frame refreash delay</strong>：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为10ms，最终刷新时间还受系统进程调度与硬件的影响。  </p>
<h2 id="2-Property-Animation的工作原理"><a href="#2-Property-Animation的工作原理" class="headerlink" title="2. Property Animation的工作原理"></a>2. Property Animation的工作原理</h2><p>对于下图的动画，这个对象的X坐标在40ms内从0移动到40 pixel。默认的10ms刷新一次，这个对象会移动4次，每次移动40/4=10pixel。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/animation/property_animation/pic/01.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/animation/property_animation/pic/01.png" alt></a></p>
<p>也可以改变属性值的改变方法，即设置不同的interpolation，在下图中运动速度先快后慢。</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/animation/property_animation/pic/02.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/animation/property_animation/pic/02.png" alt></a></p>
<h2 id="3-Property-Animation的框架"><a href="#3-Property-Animation的框架" class="headerlink" title="3. Property Animation的框架"></a>3. Property Animation的框架</h2><p>Animator<br>&nbsp;&nbsp; – &nbsp;&nbsp; ValueAnimator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; – &nbsp;&nbsp; ObjectAnimator<br>&nbsp;&nbsp;  –  AnimatorSet<br>AnimatorInflater<br>Keyframe<br>KeyframeSet<br>PropertyValuesHolder<br>AnimatorListenerAdapter.java<br>TypeEvaluator<br>&nbsp;&nbsp; –  IntEvaluator<br>&nbsp;&nbsp; –  FloatEvaluator<br>&nbsp;&nbsp; –  ArgbEvaluator  </p>
<p>说明：<br>(01) Animator, ValueAnimator, ObjectAnimator是描述动画的核心类。其中，Animator是父类，它定义了动画开始/结束/暂停/恢复/重复等接口，并实现了公共函数。ValueAnimator和ObjectAnimator是描述动画的具体类。<br>(02) AnimatorSet是动画集合。<br>(03) AnimatorInflater是解析xml定义的动画的核心类。<br>(04) Keyframe是关键帧，通过关键帧可以实现较复杂的动画(例如，曲线运动等)。KeyframeSet是关键帧的辅助类。<br>(05) PropertyValuesHolder通常用于动画中有多个属性需要同时变化的情况。<br>(06) AnimatorUpdateListener中实现了全部的动画监听接口。但是，监听函数体都没有执行任何动作。在我们需要监听动画相应动作时，可以实现Animator提供的接口，也可以继承于AnimatorUpdateListener。<br>(07) TypeEvaluator则是动画中需要变化的属性值的计算类。Android提供了三种：用于计算int类型属性的IntEvaluator，用于计算float类型属性的FloatEvaluator，和用于计算rgb颜色类属性的ArgbEvaluator。若上面的三种均无法满足你的需求，则你可以自定义属性计算类。  </p>
<h2 id="4-Property-Animation和View-Animation的区别"><a href="#4-Property-Animation和View-Animation的区别" class="headerlink" title="4. Property Animation和View Animation的区别"></a>4. Property Animation和View Animation的区别</h2><ol>
<li><p>Property Animation的动画对象是Object类型，而View Animation仅仅适用于View对象。</p>
</li>
<li><p>View Animation动画的功能有限：它可以进行缩放和旋转，但是却无法改变背景色。</p>
</li>
<li><p>View Animation动画在变化时，仅仅改变了View的绘制位置，并没有改变View本身的实际位置。<br>比如，如果当通过View Animation让一个按钮移动到屏幕上的另一个位置时；虽然它绘制在目标位置，但是它的点击区域并没改变，还是和变化之前的点击区域一样。</p>
</li>
</ol>
<p>Property Animation就不存在上面的问题，它是确实地改变了View对象的属性。虽然，View Animation存在上述缺点；但它一个明显的有点就是使用方法更简单。在View Animation能满足你的需求时，就不需要使用Property Animation。</p>
<p><a name="anchor2"></a></p>
<h1 id="Property-Animation的基本用法和示例源码"><a href="#Property-Animation的基本用法和示例源码" class="headerlink" title="Property Animation的基本用法和示例源码"></a>Property Animation的基本用法和示例源码</h1><p>Android提供的Property Animation动画类主要有两个：ValueAnimator和ObjectAnimator。</p>
<p>点击查看: <a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/animation/property_animation/01_basic/AnimationTest" target="_blank" rel="noopener">PropertyAnimation基本用法的完整源码</a></p>
<h2 id="1-ValueAnimator的基本用法"><a href="#1-ValueAnimator的基本用法" class="headerlink" title="1. ValueAnimator的基本用法"></a>1. ValueAnimator的基本用法</h2><p>在显示动画的具体图像之前，需要执行两步操作：<br>(01) 计算属性值。<br>(02) 根据此时的属性值执行相应的动作，如改变对象的某一属性。  </p>
<p>ValueAnimator只完成了第一步。当我们使用ValueAnimator时，需要自己完成第二步。如下示例：</p>
<pre><code>// 创建ValueAnimator动画。ofFloat()的参数是从&quot;动画开始&quot; 到 &quot;动画结束&quot;对应的值。
ValueAnimator anim2 = ValueAnimator.ofFloat(0f, (float)(view2.getHeight() - view2.getWidth()));
// 总的显示时间
anim2.setDuration(500);
// 变化模式(加速)
anim2.setInterpolator(new AccelerateInterpolator());
// 监听：每次变化时的回调函数
anim2.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        // 设置view2的纵坐标y
        view2.setY((Float) animation.getAnimatedValue());
        // 更新view2
        view2.invalidate();
    }
});</code></pre><p>说明：<br>(01) view2是自定义的View试图，它是一个圆。<br>(02) 对于ValueAnimator而言，需要我们实现AnimatorUpdateListener()接口，并在接口中处理试图的位置变化。例如，view2.setY()就是用于设置view2的位置。这就是上面所说的第二步。<br>(03) onAnimationUpdate()是动画变化的回调函数。当动画发生变化时，回执行该函数。  </p>
<h2 id="2-ObjectAnimator的基本用法"><a href="#2-ObjectAnimator的基本用法" class="headerlink" title="2. ObjectAnimator的基本用法"></a>2. ObjectAnimator的基本用法</h2><p>ObjectAnimator继承于ValueAnimator。它相比于ValueAnimator，完成了第二部。下面看看ObjectAnimator的使用方法。  </p>
<pre><code>// 创建ObjectAnimator动画。view1中必须有setY方法
ObjectAnimator anim1 = ObjectAnimator.ofFloat(view1, &quot;y&quot;, 0f, (float)(view1.getHeight() - view1.getWidth()));
// 总的显示时间
anim1.setDuration(1200);
// 变化模式(弹跳)
anim1.setInterpolator(new BounceInterpolator());
// 监听：每次变化时的回调函数
anim1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        // 更新view1
        view1.invalidate();
    }
});</code></pre><p>说明<br>(01) 虽然ObjectAnimator完成了第二步。ObjectAnimator的操作对象必须有对应的set<propertyname>方法。例如，上面的示例中操作的属性是”y”，因此view1类中必须要有setY(float)函数。<br>(02) 虽然Object完成了位置的计算和设置。但是，我们还必须在onAnimationUpdate()中更新要显示的视图。  </propertyname></p>
<h2 id="3-AnimatorSet的基本用法"><a href="#3-AnimatorSet的基本用法" class="headerlink" title="3. AnimatorSet的基本用法"></a>3. AnimatorSet的基本用法</h2><p>AnimatorSet是动画集合。用于来管理多个动画的播放次序。 如下示例：</p>
<pre><code>AnimatorSet animSet = new AnimatorSet();
animSet.playTogether(anim1, anim2, anim3);// 并行
animSet.playSequentially(anim3, anim4, anim5);// 串行
animSet.start();</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/24/android/api_guide/animation/2014-07-24-Animation/" itemprop="url">Android 之Animation动画(一)之 Animation介绍</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-24T00:00:00.000Z" itemprop="datePublished">7月 24 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            几秒 read (About 74 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>Android动画都支持通过”代码”和”属性”两种方式进行控制。Google官网文档建议，通过”属性”的方式来控制动画。</p>
<p>Android动画包括三种：View Animation，Drawable Animation和Property Animation。</p>
<p>下面分别对这3种动画进行介绍。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/06/android/api_guide/app_component/content_provider/2014-07-06-ContentProvider-Permission/" itemprop="url">Android 之ContentProvider(三)之 Permission权限设置</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-06T04:11:00.000Z" itemprop="datePublished">7月 6 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 分钟 read (About 451 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面自定义Permission权限。自定义权限除了用在ContentProvider中之外，也可以用在Activity与Service中。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Permission介绍</a><br><strong>2</strong>. <a href="#anchor2">自定义Permission示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Permission介绍"><a href="#Permission介绍" class="headerlink" title="Permission介绍"></a>Permission介绍</h1><pre><code>&lt;permission
    android:name=&quot;com.skw.permission.myprovider&quot;
    android:protectionLevel=&quot;normal&quot;
    android:label=&quot;@string/permission_label&quot;
    android:description=&quot;@string/permission_description&quot;
    /&gt;</code></pre><p>说明：permission常用的几个属性如下：<br>(01) <strong>android:name</strong>: 必需的。权限的名称，通常应遵循android 命名方案(<em>.permission.</em>)。<br>(02) <strong>android:protectionLevel</strong>: 必需的。权限的安全级别，共包括”normal, dangerous, signature, signatureOrSystem”四种。  </p>
<blockquote>
<p>normal 表示权限是低风险的，不会对系统、用户或其他应用程序造成危害；<br>dangerous 表示权限是高风险的，系统将可能要求用户输入相关信息，才会授予此权限；<br>signature 表示只有当应用程序所用数字签名与声明引权限的应用程序所用数字签名相同时，才能将权限授给它；<br>signatureOrSystem 表示将权限授给具有相同数字签名的应用程序或android 包类。</p>
</blockquote>
<p>(03) <strong>android:permissionGroup</strong>: 非必需的。可以将权限放在一个组中，但对于自定义权限，应该避免设置此属性。<br>(04) <strong>android:label</strong>: 非必需的。标签。<br>(05) <strong>android:description</strong>: 非必需的。描述。<br>(06) <strong>android:icon</strong>非必需的。图标。  </p>
<p><a name="anchor2"></a></p>
<h1 id="自定义Permission示例"><a href="#自定义Permission示例" class="headerlink" title="自定义Permission示例"></a>自定义Permission示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/contentprovider/02_permission/MyProvider" target="_blank" rel="noopener">自定义Permission完整源码</a></p>
<h2 id="1-设置权限"><a href="#1-设置权限" class="headerlink" title="1. 设置权限"></a>1. 设置权限</h2><pre><code>&lt;application 
    android:exported=&quot;true&quot;
    android:label=&quot;@string/app_name&quot; 
    android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;provider 
        android:name=&quot;MyProvider&quot;
        android:authorities=&quot;com.skw.myprovider&quot;
        android:permission=&quot;com.skw.permission.myprovider&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/provider&gt;
&lt;/application&gt;

&lt;permission
    android:name=&quot;com.skw.permission.myprovider&quot;
    android:protectionLevel=&quot;normal&quot;
    android:label=&quot;@string/permission_label&quot;
    android:description=&quot;@string/permission_description&quot;
    /&gt;</code></pre><p>说明：上面是自定义权限的manifest文件内容。<br>(01) 首先，在需要定义权限的ContentProvider中声明权限android:permission=”com.skw.permission.myprovider”。<br>(02) 接着，再定义permission。permission对应的name与声明的权限对应。 </p>
<h2 id="2-获取权限"><a href="#2-获取权限" class="headerlink" title="2. 获取权限"></a>2. 获取权限</h2><p>在需要使用ContentProvider的APK的manifest中需要声明使用该权限。声明方法如下：</p>
<pre><code>&lt;uses-permission android:name=&quot;com.skw.permission.myprovider&quot; /&gt;</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/06/android/api_guide/app_component/content_provider/2014-07-06-ContentProvider-Usage/" itemprop="url">Android 之ContentProvider(二)之 ContentProvider基本用法</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-06T02:11:00.000Z" itemprop="datePublished">7月 6 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            12 分钟 read (About 1796 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章给出ContentProvider的完整示例，并对之进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">ContentProvider简介</a><br><strong>2</strong>. <a href="#anchor2">ContentProvider示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="ContentProvider简介"><a href="#ContentProvider简介" class="headerlink" title="ContentProvider简介"></a>ContentProvider简介</h1><p>ContentProvider通常用于共享数据。</p>
<p>当其他程序需要访问本程序的数据，并且数据的结构比较复杂时，就可以使用ContentProvider来共享数据。如果数据不需要跨程序访问，使用数据库即可；如果数据结构比较简单，可以考虑前面提到的通过Intent共享文本等简单数据，或者通过FileProvider共享文件。</p>
<p><a name="anchor2"></a></p>
<h1 id="ContentProvider示例"><a href="#ContentProvider示例" class="headerlink" title="ContentProvider示例"></a>ContentProvider示例</h1><p>接下来，实现一个ContentProvider。该ContentProvider包括两部分：ContentProvider提供者APK 和 ContentProvider测试APK。<br>(01) ContentProvider提供者：自定义一个ContentProvider，并监听相应的URI。客户可以通过URI插入/删除/更新/查询数据。ContentProvider中的数据记录的是人的信息，包括”姓名，出生年月，email，性别”等信息。<br>(02) ContentProvider测试APK：通过URI向ContentProvider发起插入/删除/更新/查询等操作。  </p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/contentprovider/01_basic/MyProvider" target="_blank" rel="noopener">ContentProvider示例的完整源码</a></p>
<p>下面介绍ContentProvider的实现步骤。</p>
<h2 id="1-ContentProvider提供者APK"><a href="#1-ContentProvider提供者APK" class="headerlink" title="1. ContentProvider提供者APK"></a>1. ContentProvider提供者APK</h2><h3 id="1-1-ContentProvider的存储表格"><a href="#1-1-ContentProvider的存储表格" class="headerlink" title="1.1 ContentProvider的存储表格"></a>1.1 ContentProvider的存储表格</h3><p>根据ContentProvider的数据特性，我们建立一张表，表格包括”id/姓名/出生年月/email/性别”这些信息。表对应的类如下：</p>
<pre><code>public final class MyContract {
    public MyContract() {}

    /** 
     * BaseColumns类中有两个属性：_ID 和 _COUNT
     */
    public static abstract class Entry implements BaseColumns {
        public static final String TABLE_NAME = &quot;mytable01&quot;;
        public static final String NAME       = &quot;name&quot;;
        public static final String BIRTH_DAY  = &quot;birthday&quot;;
        public static final String EMAIL      = &quot;email&quot;;
        public static final String GENDER     = &quot;gender&quot;;
    }   
}</code></pre><p>说明：BaseColumns是Android自带的类，它集成了”_ID”和”_COUNT”两个属性。 </p>
<h3 id="1-2-ContentProvider对应的manifest"><a href="#1-2-ContentProvider对应的manifest" class="headerlink" title="1.2 ContentProvider对应的manifest"></a>1.2 ContentProvider对应的manifest</h3><p>在manifest中声明我们自定义的ContentProvider。</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;provider android:name=&quot;MyProvider&quot; android:authorities=&quot;com.skw.myprovider&quot; /&gt;
&lt;/application&gt;</code></pre><h3 id="1-3-自定义的ContentProvider类"><a href="#1-3-自定义的ContentProvider类" class="headerlink" title="1.3 自定义的ContentProvider类"></a>1.3 自定义的ContentProvider类</h3><p>完成ContentProvider类，主要需要注意以下几点：<br>(01) ContentProvider的数据一般是以”数据库”或”网络数据”的方式存储的。如果是数据库，则需要实现SQLiteOpenHelper类。通过SQLiteOpenHelper类新建/管理数据库。<br>(02) ContentProvider主要是以Uri的形式方式访问的(也可以通过Intent)。要通过UriMatcher注册ContentProvider监听的Uri。<br>(03) ContentProvider是一个抽象类。当我们需要以继承ContentProvider的方式自定义ContentProvider时，需要实现query(), insert(), update(), delete(), getType(), onCreate()这六个函数。  </p>
<h3 id="1-3-1-数据库"><a href="#1-3-1-数据库" class="headerlink" title="1.3.1 数据库"></a>1.3.1 数据库</h3><p>下面，先介绍ContentProvider的数据库的实现。</p>
<pre><code>// 创建表格的SQL语句
private static final String SQL_CREATE_ENTRIES =
    &quot;CREATE TABLE &quot; + Entry.TABLE_NAME + &quot; (&quot; +
    Entry._ID + &quot; INTEGER PRIMARY KEY,&quot; +
    Entry.NAME + &quot; TEXT NOT NULL, &quot; +
    Entry.BIRTH_DAY + &quot; TEXT, &quot; +
    Entry.EMAIL + &quot; TEXT, &quot; +
    Entry.GENDER + &quot; INTEGER &quot; +
    &quot; )&quot;;

...

private class DBLiteHelper extends SQLiteOpenHelper {
    public static final int DATABASE_VERSION = 1;
    public static final String DATABASE_NAME = &quot;MyProvider.db&quot;;

    public DBLiteHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(SQL_CREATE_ENTRIES);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    }
}</code></pre><p>说明：关于SQLiteOpenHelper的内容在”<a href="/2014/05/30/SavingData/">数据存储章节</a>“中已经详细介绍过了。</p>
<h3 id="1-3-2-注册Uri"><a href="#1-3-2-注册Uri" class="headerlink" title="1.3.2 注册Uri"></a>1.3.2 注册Uri</h3><pre><code>// Uri的authority
public static final String AUTHORITY = &quot;com.skw.myprovider&quot;;
// Uri的path
public static final String PATH = &quot;table01&quot;;
// UriMatcher中URI对应的序号
public static final int ITEM_ALL = 1;
public static final int ITEM_ID  = 2;

private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
static {
    URI_MATCHER.addURI(AUTHORITY, PATH, ITEM_ALL);
    URI_MATCHER.addURI(AUTHORITY, PATH+&quot;/#&quot;, ITEM_ID);
}</code></pre><p>说明：通过addURI()就可以将URI注册到UriMatcher中，从而实现ContentProvider对URI的监听。这里的AUTHORITY与manifest中的android:authorities一致！<br>例如， URI_MATCHER.addURI(AUTHORITY, PATH, ITEM_ALL); 意味着ContentProvider对”content://con.skw.myprovider/table01”进行监听。<br>例如， URI_MATCHER.addURI(AUTHORITY, PATH+”/#”, ITEM_ALL); 意味着ContentProvider对”content://con.skw.myprovider/table01/5”进行监听。   </p>
<h3 id="1-3-2-实现ContentProvider的抽象函数"><a href="#1-3-2-实现ContentProvider的抽象函数" class="headerlink" title="1.3.2 实现ContentProvider的抽象函数"></a>1.3.2 实现ContentProvider的抽象函数</h3><h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h4><pre><code>@Override
public boolean onCreate() {
    mDbHelper = new DBLiteHelper(this.getContext());
    Log.d(TAG, &quot;open/create table&quot;);
    return true;
}</code></pre><p>说明：onCreate()中新建SQLiteOpenHelper对象。</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h4><pre><code>@Override
public int delete(Uri uri, String selection, String[] selectionArgs) {
    SQLiteDatabase db = mDbHelper.getWritableDatabase();

    int count = 0;
    switch (URI_MATCHER.match(uri)) {
    case ITEM_ALL:
        count = db.delete(Entry.TABLE_NAME, selection, selectionArgs);
        Log.d(TAG, &quot;delete ITEM uri=&quot;+uri+&quot;, count=&quot;+count);
        break;
    case ITEM_ID:
        // 获取id列的值
        String id = uri.getPathSegments().get(1);
        count = db.delete(Entry.TABLE_NAME, Entry._ID+&quot;=?&quot;, new String[]{id});
        Log.d(TAG, &quot;delete ITEM_ID id=&quot;+id+&quot;, uri=&quot;+uri+&quot;, count=&quot;+count);
        break;
    default:
        throw new IllegalArgumentException(&quot;Unknown URI&quot;+uri);
    }
    getContext().getContentResolver().notifyChange(uri, null);
    return count;
}</code></pre><p>说明：delete()中会通过match()获取uri对应的编码。这里的编码就是和addURI()注册uri的编码是相对应的。此外，notifyChange()的作用是通常数据库变化，若有ContentObserver监听该Uri，则notifyChange()最终会将消息传递给监听者。</p>
<p>insert(), update(), query()的实现与delete()类似，就不再说明。</p>
<h4 id="getType"><a href="#getType" class="headerlink" title="getType()"></a>getType()</h4><pre><code>@Override
public String getType(Uri uri) {
    switch (URI_MATCHER.match(uri)) {
    case ITEM_ALL:
        return &quot;skw.myprovider.dir/table01&quot;;
    case ITEM_ID:
        return &quot;skw.myprovider.item/table01&quot;;
    default:
        throw new IllegalArgumentException(&quot;Unknown URI&quot;+uri);
    }
}</code></pre><p>说明：getType()是返回Uri对应的数据类型。</p>
<h2 id="2-ContentProvider测试APK"><a href="#2-ContentProvider测试APK" class="headerlink" title="2. ContentProvider测试APK"></a>2. ContentProvider测试APK</h2><pre><code>public class ProviderTest extends Activity 
    implements View.OnClickListener {

    private static final String TAG = &quot;##ProviderTest##&quot;;

    // 数据库的属性，与MyProvider的表格属性一致
    public static final String NAME      = &quot;name&quot;;
    public static final String BIRTH_DAY = &quot;birthday&quot;;
    public static final String EMAIL     = &quot;email&quot;;
    public static final String GENDER    = &quot;gender&quot;;
    // 数据库的URI
    public static final Uri CONTENT_URI = Uri.parse(&quot;content://com.skw.myprovider/table01&quot;);

    private ContentResolver mContentResolver = null;
    /** Called when the activity is first created. */

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        ((Button)findViewById(R.id.insert)).setOnClickListener(this);
        ((Button)findViewById(R.id.deleteFirst)).setOnClickListener(this);
        ((Button)findViewById(R.id.deleteKate)).setOnClickListener(this);
        ((Button)findViewById(R.id.deleteAll)).setOnClickListener(this);
        ((Button)findViewById(R.id.update)).setOnClickListener(this);
        ((Button)findViewById(R.id.show)).setOnClickListener(this);

        // 删除第一行，然后全部打印出来
        mContentResolver = getContentResolver();

    }


    @Override
    public void onClick(View view) {
        switch(view.getId()) {
            case R.id.insert:
                // 添加
                insert(&quot;Jimmy&quot;, &quot;20020201&quot;, &quot;Jimmy20020201@126.com&quot;, 1);
                insert(&quot;Kate&quot;,  &quot;20030104&quot;, &quot;kate20030104@126.com&quot;, 0);
                insert(&quot;Li Lei&quot;, &quot;20021124&quot;, &quot;lilei20101124@126.com&quot;, 1);
                insert(&quot;Lucy&quot;, &quot;20010624&quot;, &quot;lucy20101124@126.com&quot;, 0);
                break;
            case R.id.deleteFirst:
                ContentUris cus = new ContentUris();
                Uri uri = cus.withAppendedId(CONTENT_URI, 1);
                Log.d(TAG, &quot;delete uri=&quot;+uri);
                mContentResolver.delete(uri, null, null);
                break;
            case R.id.deleteKate:
                // 删除“username=Kate”的行，然后全部打印出来
                mContentResolver.delete(CONTENT_URI, NAME+&quot;=?&quot;, new String[]{&quot;Kate&quot;});
                break;
            case R.id.deleteAll:
                // 删除全部的行，然后全部打印出来
                deleteAll() ;
                break;
            case R.id.update:
                // 更新第1个值，然后全部打印出来
                updateItem() ;
                break;
            case R.id.show:
                // 打印全部的值
                printAll() ;
                break;
            default:
                // 查找第2个值
                //querySecondItem() ;
                break;
        }
    }

    /*
     * 通过ContentResolver,将值插入到MyProvider中
     */
    private void insert(String name, String date, String email, int gender) {

        ContentResolver cr = getContentResolver();

        ContentValues cv = new ContentValues();
        cv.put(NAME, name);
        cv.put(BIRTH_DAY, date);
        cv.put(EMAIL, email);
        cv.put(GENDER, gender);
        Uri uri = cr.insert(CONTENT_URI, cv);
        Log.d(TAG, &quot;insert uri=&quot;+uri);
    }

    private void updateItem() {
        ContentResolver cr = getContentResolver();

        ContentUris cus = new ContentUris();
        Uri uri = cus.withAppendedId(CONTENT_URI, 1);

        ContentValues cv = new ContentValues();
        cv.put(NAME, &quot;update_name&quot;);
        cv.put(BIRTH_DAY, &quot;update_date&quot;);
        cv.put(EMAIL, &quot;update_email&quot;);
        cv.put(GENDER, 1);
        cr.update(uri, cv, null, null);
    }

    /*
     * 通过ContentResolver,将MyProvider中的值全部删除
     */
    private void deleteAll() {

        Log.d(TAG, &quot;delete all value!&quot;);
        ContentResolver cr = getContentResolver();
        cr.delete(CONTENT_URI, null, null);
    }

    private void querySecondItem() {
        ContentResolver cr = getContentResolver();
        ContentUris cus = new ContentUris();
        Uri uri = cus.withAppendedId(CONTENT_URI, 2);
        String[] proj = new String[] { NAME, BIRTH_DAY, EMAIL, GENDER};
        Cursor cursor = cr.query(uri, proj, null, null, null);
        int index = 0;
        while (cursor.moveToNext()) {
            Log.d(TAG, &quot;querySecondItem--&quot;+index+&quot;--&quot;
                    +&quot;, email=&quot; + cursor.getString(cursor.getColumnIndex(EMAIL))
                    +&quot;, username=&quot; + cursor.getString(cursor.getColumnIndex(NAME))
                    +&quot;, date=&quot; + cursor.getString(cursor.getColumnIndex(BIRTH_DAY))
                    +&quot;, gender=&quot; + cursor.getInt(cursor.getColumnIndex(GENDER)));
            index++;
        }
    }

    private void printAll() {
        //通过contentResolver进行查找
        ContentResolver cr = getContentResolver();

        Log.d(TAG, &quot;print all value!&quot;);
        // query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
        // 返回的列
        String[] proj = new String[] { NAME, BIRTH_DAY, EMAIL, GENDER};
        Cursor cursor = cr.query(
            CONTENT_URI, proj, null, null, null);
        int index = 0;
        while (cursor.moveToNext()) {
            Log.d(TAG, &quot;printAll--&quot;+index+&quot;--&quot;
                    +&quot;, email=&quot; + cursor.getString(cursor.getColumnIndex(EMAIL))
                    +&quot;, username=&quot; + cursor.getString(cursor.getColumnIndex(NAME))
                    +&quot;, date=&quot; + cursor.getString(cursor.getColumnIndex(BIRTH_DAY))
                    +&quot;, gender=&quot; + cursor.getString(cursor.getColumnIndex(GENDER)));
            index++;
        }
        startManagingCursor(cursor);  //查找后关闭游标
    }
}</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/07/06/android/api_guide/app_component/content_provider/2014-07-06-ContentProvider-Uri/" itemprop="url">Android 之ContentProvider(一)之 Uri介绍</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-07-06T01:11:00.000Z" itemprop="datePublished">7月 6 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 read (About 592 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Uri及其相关内容。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">URI简介</a><br><strong>2</strong>. <a href="#anchor2">Content URIs介绍</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="URI简介"><a href="#URI简介" class="headerlink" title="URI简介"></a>URI简介</h1><p>URI(Universal Resource Identifier)，又被称为”通用资源标志符”。</p>
<p>URI由许多部分所组成，示例及解说如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/app_components/contentprovider/pic/uri01.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/app_components/contentprovider/pic/uri01.jpg" alt></a></p>
<p><a name="anchor2"></a></p>
<h1 id="Content-URIs介绍"><a href="#Content-URIs介绍" class="headerlink" title="Content URIs介绍"></a>Content URIs介绍</h1><p>Android遵循URI的标准，定义了一套专用的Uri(即，Content URIs)。并且，Android提供了ContentUris、UriMatcher等类用于操作Content URIs。</p>
<h2 id="1-Content-URIs语法"><a href="#1-Content-URIs语法" class="headerlink" title="1. Content URIs语法"></a>1. Content URIs语法</h2><p>Content URIs的语法如下：</p>
<p><strong>content://authority/path/id</strong></p>
<p>Content URIs的示例及说明如下：</p>
<p><a href="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/app_components/contentprovider/pic/uri02.jpg" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/wangkuiwu/android_applets/master/api_guide/app_components/contentprovider/pic/uri02.jpg" alt></a></p>
<p>说明：<br><strong>content</strong>: Content URIs前缀，它对应与标准URI的scheme。它的值为ContentResolver.SCHEME_CONTENT(即，content://)。<br><strong>authority</strong>: 一个唯一的标识符，Google建议使用类的全名来作为authority。外部调用者可以根据这个标识来找到它。<br><strong>path</strong>: 它可以用来表示我们要操作的数据，外部调用者根据这个路径信息来判断要返回什么类型的数据。这个后缀路径可以自由定义。<br><strong>id</strong>: 唯一的数字标识符。它表示要具体操作的数据类型中的具体某一项。</p>
<h2 id="2-Content-URIs相关类介绍"><a href="#2-Content-URIs相关类介绍" class="headerlink" title="2. Content URIs相关类介绍"></a>2. Content URIs相关类介绍</h2><h3 id="2-1-ContentUris"><a href="#2-1-ContentUris" class="headerlink" title="2.1 ContentUris"></a>2.1 ContentUris</h3><p>ContentUris中包含了三个静态函数:  </p>
<blockquote>
<p> long parseId(Uri uri): 解析Uri中的末尾id。成功返回id，失败则返回-1。<br> Uri withAppendedId(Uri uri, long id): 将id追加到uri中，并返回追加id后的uri。<br> Uri.Builder appendId(Uri.Builder builder, long id): 将id追加到builder中，并返回追加id后的builder。  </p>
</blockquote>
<h3 id="2-2-UriMatcher"><a href="#2-2-UriMatcher" class="headerlink" title="2.2 UriMatcher"></a>2.2 UriMatcher</h3><p>UriMatcher用于匹配Uri。它的用法如下：<br>(01) 创建UriMatcher对象。<br>(02) 把你需要匹配Uri路径通过addURI()注册到UriMatcher对象上。<br>(03) 注册成功后，ContentProvider就可以通过UriMatcher监听你注册的Uri。当有匹配的Uri动作(如插入)时，再就可以通过UriMatcher的match()函数来获取Uri的一个标识，该标识是在addURI()时传入的。这个标识的作用是方便在switch语句中对不同的Uri进行处理。  </p>
<p>UriMatcher的主要API说明：  </p>
<blockquote>
<p>void addURI(String authority, String path, int code): 将”authority”+”path”注册的Uri注册到UriMatcher中，code是该Uri对应的标识。<br>int match(Uri uri): 匹配Uri，并返回Uri对应的标识。这里返回的标识与addURI中的标识对应。</p>
</blockquote>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/26/android/api_guide/app_component/activity/2014-06-26-OtherModeAttrs/" itemprop="url">Android 之Activity启动模式(三)之 启动模式的其它属性</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-26T04:10:00.000Z" itemprop="datePublished">6月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 read (About 525 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面两章分别介绍了”四种launchMode”以及”Intent中与启动模式相关的Flag标签”，本章补充介绍一下manifest中其他与启动模式相关的属性。除非是有特殊需求，否则本章涉及到的知识很少会被用到。</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h1><pre><code>android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;]
android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;]
android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;]
android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;]
android:noHistory=[&quot;true&quot; | &quot;false&quot;]
android:taskAffinity=&quot;string&quot;</code></pre><ol>
<li><p><strong>android:taskAffinity</strong></p>
<p>它在前面两章都已经涉及到了。它的作用是描述了不同Activity之间的亲密关系。拥有相同的taskAffinity的Activity是亲密的，它们之间在相互跳转时，会位于同一个task中，而不会新建一个task！<br>如果在manifest中没有对Activity的android:taskAffinity进行配置，则每个Activity都采用和Application相同的taskAffinity；这也就意味着，同一个Application中的所有Activity的taskAffinity在默认情况下是相同的！</p>
</li>
</ol>
<ol start="2">
<li><p><strong>allowTaskReparenting</strong></p>
<p>与字面理解相同，本属性允许activity重新指定Task。默认值是false。<br>假设存在A并且它allowTaskReparenting为true。当系统中存在一个A的实例，并且A位于task1中时；此时，task2中的某一个Activity要跳转到A中，则此时会将A从task1转移到task2中。</p>
</li>
</ol>
<ol start="3">
<li><p><strong>alwaysRetainTaskState</strong></p>
<p>总是保留task的状态。默认值是false。<br>如果某个Activity的allowTaskReparenting设置为true；那么当该Activity位于某个task的栈底时，不管出现任何情况, 系统都会一直会保留task栈中Activity的状态。</p>
</li>
</ol>
<ol start="4">
<li><p><strong>clearTaskOnLaunch</strong></p>
<p>默认值是false。<br>如果某个Activity的clearTaskOnLaunch设置为true。当该Activity位于某个task的栈底时，如果你离开当前的task而转到别的task；那么，该task中除了该Activity之外的其它Activity都会被删除！</p>
</li>
</ol>
<ol start="5">
<li><p><strong>finishOnTaskLaunch</strong></p>
<p>默认值是false。<br>如果某个Activity的finishOnTaskLaunch设置位true。只要你一离开这个task栈, 则系统会马上清除这个Activity, 不管这个Activity在堆栈的任何位置。</p>
</li>
</ol>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/26/android/api_guide/app_component/activity/2014-06-26-IntentFlag/" itemprop="url">Android 之Activity启动模式(二)之 Intent的Flag属性</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-26T02:12:00.000Z" itemprop="datePublished">6月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            18 分钟 read (About 2728 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>前面介绍了通过launchMode设置Activity的启动模式。本章接着介绍Activity的启动模式相关内容，讲解的内容是Intent与启动模式相关的Flag，以及android:taskAffinity的属性。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Intent与启动模式相关的Flag简介</a><br><strong>2</strong>. <a href="#anchor2">1. FLAG_ACTIVITY_NEW_TASK标签测试</a><br><strong>3</strong>. <a href="#anchor3">2. FLAG_ACTIVITY_CLEAR_TOP标签测试</a><br><strong>4</strong>. <a href="#anchor4">3. FLAG_ACTIVITY_CLEAR_TASK标签测试</a><br><strong>5</strong>. <a href="#anchor5">4. FLAG_ACTIVITY_SINGLE_TOP标签测试</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Intent与启动模式相关的Flag简介"><a href="#Intent与启动模式相关的Flag简介" class="headerlink" title="Intent与启动模式相关的Flag简介"></a>Intent与启动模式相关的Flag简介</h1><p>这里仅仅对几个常用的与启动模式相关的Flag进行介绍。</p>
<ol>
<li><strong>FLAG_ACTIVITY_NEW_TASK</strong><br>在google的官方文档中介绍，它与launchMode=”singleTask”具有相同的行为。实际上，并不是完全相同！<br>很少单独使用FLAG_ACTIVITY_NEW_TASK，通常与FLAG_ACTIVITY_CLEAR_TASK或FLAG_ACTIVITY_CLEAR_TOP联合使用。因为单独使用该属性会导致奇怪的现象，通常达不到我们想要的效果！尽管如何，后面还是会通过”FLAG_ACTIVITY_NEW_TASK示例一”和”FLAG_ACTIVITY_NEW_TASK示例二”会向你展示单独使用它的效果。</li>
</ol>
<ol start="2">
<li><p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong><br>在google的官方文档中介绍，它与launchMode=”singleTop”具有相同的行为。实际上，的确如此！单独的使用FLAG_ACTIVITY_SINGLE_TOP，就能达到和launchMode=”singleTop”一样的效果。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong><br>顾名思义，FLAG_ACTIVITY_CLEAR_TOP的作用清除”包含Activity的task”中位于该Activity实例之上的其他Activity实例。FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_NEW_TASK两者同时使用，就能达到和launchMode=”singleTask”一样的效果！</p>
</li>
<li><p><strong>FLAG_ACTIVITY_CLEAR_TASK</strong><br>FLAG_ACTIVITY_CLEAR_TASK的作用包含Activity的task。使用FLAG_ACTIVITY_CLEAR_TASK时，通常会包含FLAG_ACTIVITY_NEW_TASK。这样做的目的是启动Activity时，清除之前已经存在的Activity实例所在的task；这自然也就清除了之前存在的Activity实例！</p>
</li>
</ol>
<p>注意：<strong>当同时使用launchMode和上面的FLAG_ACTIVITY_NEW_TASK等标签时，以FLAG_ACTIVITY_NEW_TASK为标准。也就是说，代码的优先级比manifest中配置文件的优先级更高</strong>！ </p>
<p>下面，通过几个实例加深对这几个标记的理解。</p>
<p><a name="anchor2"></a></p>
<h1 id="1-FLAG-ACTIVITY-NEW-TASK标签测试"><a href="#1-FLAG-ACTIVITY-NEW-TASK标签测试" class="headerlink" title="1. FLAG_ACTIVITY_NEW_TASK标签测试"></a>1. FLAG_ACTIVITY_NEW_TASK标签测试</h1><h2 id="1-1-FLAG-ACTIVITY-NEW-TASK示例一"><a href="#1-1-FLAG-ACTIVITY-NEW-TASK示例一" class="headerlink" title="1.1 FLAG_ACTIVITY_NEW_TASK示例一"></a>1.1 FLAG_ACTIVITY_NEW_TASK示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/02_new_task/01_same_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_NEW_TASK示例一的源码</a></p>
<p>在该实例中，有两个Activity：ActivityTest和SecondActivity。manifest定义如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot; /&gt;
&lt;/application&gt;</code></pre><p>说明：通过manifest可以看出，ActivityTest和SecondActivity在同一个APK中。这也就意味着它们的android:taskAffinity是一样的！</p>
<p><strong>ActivityTest的源码</strong></p>
<pre><code>public class ActivityTest extends Activity {
    private static final String TAG=&quot;##ActivityTest##&quot;;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        Log.d(TAG, &quot;onCreate: &quot;+this.toString()+&quot;, taskId=&quot;+this.getTaskId());
        TextView tv = (TextView) findViewById(R.id.tv);
        tv.setText(this.toString()+&quot;, taskId=&quot;+this.getTaskId());
    }   

    public void onJump(View view) {
        Intent intent = new Intent(this, SecondActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this+&quot;, taskId=&quot;+this.getTaskId());
    }   
}</code></pre><p>说明：onJump()是ActivityTest中一个按钮的回调函数，点击该按钮会跳转到SecondActivity。<strong>注意，跳转的Intent添加了FLAG_ACTIVITY_NEW_TASK标志</strong>。</p>
<p><strong>SecondActivity的源码</strong></p>
<pre><code>public class SecondActivity extends Activity {

    private static final String TAG=&quot;##SecondActivity##&quot;;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.second);

        Log.d(TAG, &quot;onCreate: &quot;+this.toString()+&quot;, taskId=&quot;+this.getTaskId());
        TextView tv = (TextView) findViewById(R.id.tv2);
        tv.setText(this.toString()+&quot;, taskId=&quot;+this.getTaskId());
    }   

    public void onBack(View view) {
        Intent intent = new Intent(this, ActivityTest.class);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this+&quot;, taskId=&quot;+this.getTaskId());
    }   
}</code></pre><p>说明：onBack()是SecondActivity中一个按钮的回调函数，点击该按钮会跳转回ActivityTest。</p>
<p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在同一个task中。 (02) 两个SecondActivity不同的实例！<br><strong>结果分析</strong>：如果说FLAG_ACTIVITY_NEW_TASK的作用和singleTask具有相同的效果。那么这个示例很明显的否则了这个结论！事实上，在相互跳转的两个Activity的android:taskAffinity相同的情况下，单独使用FLAG_ACTIVITY_NEW_TASK不会产生任何效果！</p>
<p>那如果两个Activity的android:taskAffinity不相同呢？此时会导致什么效果呢？下面，我们通过示例来看看效果。</p>
<h2 id="1-2-FLAG-ACTIVITY-NEW-TASK示例二"><a href="#1-2-FLAG-ACTIVITY-NEW-TASK示例二" class="headerlink" title="1.2 FLAG_ACTIVITY_NEW_TASK示例二"></a>1.2 FLAG_ACTIVITY_NEW_TASK示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/02_new_task/02_diff_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_NEW_TASK示例二的源码</a></p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中manifest，将ActivityTest和SecondActivity的android:taskAffinity改为不同；其余的保持不变！修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:taskAffinity=&quot;com.skw.activitytest01&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:taskAffinity=&quot;com.skw.activitytest02&quot;
        /&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在不同task中！ (02) 当第二次进入到ActivityTest中，再企图从ActivityTest中进入到SecondActivity时，没有产生任何效果，仍然停留在ActivityTest中！即第二次ActivityTest –&gt; SecondActivity压根就没发生！<br><strong>结果分析</strong>：当相互跳转的两个Activity的android:taskAffinity不同时，添加FLAG_ACTIVITY_NEW_TASK确实产生了一些效果：第一次启动Activity时，会新建一个task，并将Activity添加到该task中。这与singleTask产生的效果是一样的！但是，当企图再次从ActivityTest进入到SecondActivity时，却什么也没有发生！<br>为什么呢？是因为此时SecondActivity实例已经存在，但是它所在的task的栈顶是ActivityTest；而单独的添加FLAG_ACTIVITY_NEW_TASK又不会”删除task中位于SecondActivity之上的Activity实例”，所以就没有发生跳转！  </p>
<p>好的，那下面，我们添加FLAG_ACTIVITY_CLEAR_TOP之后，再来看看效果。</p>
<p><a name="anchor3"></a></p>
<h1 id="2-FLAG-ACTIVITY-CLEAR-TOP标签测试"><a href="#2-FLAG-ACTIVITY-CLEAR-TOP标签测试" class="headerlink" title="2. FLAG_ACTIVITY_CLEAR_TOP标签测试"></a>2. FLAG_ACTIVITY_CLEAR_TOP标签测试</h1><h2 id="2-1-FLAG-ACTIVITY-CLEAR-TOP示例一"><a href="#2-1-FLAG-ACTIVITY-CLEAR-TOP示例一" class="headerlink" title="2.1 FLAG_ACTIVITY_CLEAR_TOP示例一"></a>2.1 FLAG_ACTIVITY_CLEAR_TOP示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/03_clear_top/01_same_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_CLEAR_TOP示例一的源码</a>。</p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下：</p>
<pre><code>public void onJump(View view) {
    Intent intent = new Intent(this, SecondActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
            | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    startActivity(intent);
}   </code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在同一个task中！ (02) 两个SecondActivity是不同的实例。<br><strong>结果分析</strong>：这与没有添加FLAG_ACTIVITY_CLEAR_TOP时效果一样！这说明，当相互跳转的两个Activity的android:taskAffinity一样时，不会产生任何效果！  </p>
<p>接下来，看看不同android:taskAffinity的情况。</p>
<h2 id="2-2-FLAG-ACTIVITY-CLEAR-TOP示例二"><a href="#2-2-FLAG-ACTIVITY-CLEAR-TOP示例二" class="headerlink" title="2.2 FLAG_ACTIVITY_CLEAR_TOP示例二"></a>2.2 FLAG_ACTIVITY_CLEAR_TOP示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/03_clear_top/02_diff_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_CLEAR_TOP示例二的源码</a>。</p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下：</p>
<pre><code>public void onJump(View view) {
    Intent intent = new Intent(this, SecondActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
            | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    startActivity(intent);
}   </code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在不同task中！ (02) 两个SecondActivity是同一个实例。<br><strong>结果分析</strong>：此时的表现和SecondActivity是singleTask一样！ 这说明，在相互跳转的Activity的android:taskAffinity不同时，同时使用FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP，才具有和singleTask一样的效果！</p>
<p>总的来说：FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TOP的使用和android:taskAffinity相关。在同时使用FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP的情况下，以A启动B来说<br>(01) 当A和B的taskAffinity相同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP没有任何作用。和没有添加时的效果一样！<br>(02) 当A和B的taskAffinity不同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TOP后，表现的和B是singleTask一样！</p>
<p><a name="anchor4"></a></p>
<h1 id="3-FLAG-ACTIVITY-CLEAR-TASK标签测试"><a href="#3-FLAG-ACTIVITY-CLEAR-TASK标签测试" class="headerlink" title="3. FLAG_ACTIVITY_CLEAR_TASK标签测试"></a>3. FLAG_ACTIVITY_CLEAR_TASK标签测试</h1><h2 id="3-1-FLAG-ACTIVITY-CLEAR-TASK示例一"><a href="#3-1-FLAG-ACTIVITY-CLEAR-TASK示例一" class="headerlink" title="3.1 FLAG_ACTIVITY_CLEAR_TASK示例一"></a>3.1 FLAG_ACTIVITY_CLEAR_TASK示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/04_clear_task/01_same_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_CLEAR_TASK示例一的源码</a></p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下：</p>
<pre><code>public void onJump(View view) {
    Intent intent = new Intent(this, SecondActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
            | Intent.FLAG_ACTIVITY_CLEAR_TASK);
    startActivity(intent);
}   </code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在同一个task中！ (02) 两个SecondActivity是不同的实例。<br><strong>结果分析</strong>：这与没有添加FLAG_ACTIVITY_CLEAR_TASK时效果一样！这说明，当相互跳转的两个Activity的android:taskAffinity一样时，不会产生任何效果！  </p>
<p>接下来，看看不同android:taskAffinity的情况。</p>
<h2 id="3-2-FLAG-ACTIVITY-CLEAR-TASK示例二"><a href="#3-2-FLAG-ACTIVITY-CLEAR-TASK示例二" class="headerlink" title="3.2 FLAG_ACTIVITY_CLEAR_TASK示例二"></a>3.2 FLAG_ACTIVITY_CLEAR_TASK示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/04_clear_task/02_diff_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_CLEAR_TASK示例二的源码</a></p>
<p>我们修改”FLAG_ACTIVITY_NEW_TASK示例一”中onJump()函数，修改后的代码如下：</p>
<pre><code>public void onJump(View view) {
    Intent intent = new Intent(this, SecondActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
            | Intent.FLAG_ACTIVITY_CLEAR_TASK);
    startActivity(intent);
}   </code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity –&gt; 返回键 –&gt; 返回键<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在不同的task中！ (02) 两个SecondActivity是不同的实例。 (03) 第一次返回键，返回到第一个ActivityTest中。 (04) 第二次返回键，返回到进入第一个ActivityTest之前的画面。<br><strong>结果分析</strong>：当同时使用FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK时，每次启动Activity时，若该Activity的实例已经存在于某个task中，则清除该task中的全部内容；然后重新创建task并将Activity添加到新建的task中；否则，直接启动新的task并将该Activity添加到新建的task中。</p>
<p>总的来说：FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TASK的使用和android:taskAffinity相关。在同时使用FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK的情况下，以A启动B来说<br>(01) 当A和B的taskAffinity相同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK没有任何作用。和没有添加时的效果一样！<br>(02) 当A和B的taskAffinity不同时：添加FLAG_ACTIVITY_NEW_TASK|FLAG_ACTIVITY_CLEAR_TASK后，启动B时，若该B已经存在于某个task中，则清除该task中的全部内容；然后重新创建task并将B添加到新建的task中；否则，直接启动新的task并将B添加到新建的task中。</p>
<p><a name="anchor5"></a></p>
<h1 id="4-FLAG-ACTIVITY-SINGLE-TOP标签测试"><a href="#4-FLAG-ACTIVITY-SINGLE-TOP标签测试" class="headerlink" title="4. FLAG_ACTIVITY_SINGLE_TOP标签测试"></a>4. FLAG_ACTIVITY_SINGLE_TOP标签测试</h1><p>FLAG_ACTIVITY_SINGLE_TOP的特性和launchMode=”singleTop”一样！这里就不做过多的说明了。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/01_single_top/01_single" target="_blank" rel="noopener">FLAG_ACTIVITY_SINGLE_TOP示例一的源码</a>。该示例中，只有一个Activity示例，点击该Activity会跳转到它自身。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/intent_lauchmode/01_single_top/02_same_taskAffinity" target="_blank" rel="noopener">FLAG_ACTIVITY_SINGLE_TOP示例二的源码</a>。该示例中，有两个Activity示例，两个Activity之间可以相互跳转。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/26/android/api_guide/app_component/activity/2014-06-26-LaunchMode/" itemprop="url">Android 之Activity启动模式(一)之 lauchMode</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-26T01:10:00.000Z" itemprop="datePublished">6月 26 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            23 分钟 read (About 3457 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍Activity的四种launchMode。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">launchMode简介</a><br><strong>2</strong>. <a href="#anchor2">1. standard模式</a><br><strong>3</strong>. <a href="#anchor3">2. singleTop模式</a><br><strong>4</strong>. <a href="#anchor4">3. singleTask模式</a><br><strong>5</strong>. <a href="#anchor5">4. singleInstance模式</a><br><strong>6</strong>. <a href="#anchor6">模式总结</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="launchMode简介"><a href="#launchMode简介" class="headerlink" title="launchMode简介"></a>launchMode简介</h1><p>在讲解launchMode之前，需要先了解两个概念：task和taskAffinity。</p>
<p>task是一个”First In Last Out”的栈，task可以有一个或多个Activity。我们可以将task看作是管理Activity的单元。某一时刻，系统可以有多个task；每个task可以有一个或多个Activity。同一个Activity可能只允许存在一个实例，也可能可以有多个实例，而且这些实例既可以位于同一个task，也可以位于不同的task。Activity究竟是怎么处理它的实例，以及它在task中的分布情况；这些都可以通过launchMode进行设置。</p>
<p>android:taskAffinity是Activity的一个属性。例如,android:taskAffinity=”string”。它的作用是描述了不同Activity之间的亲密关系。拥有相同的taskAffinity的Activity是亲密的，它们之间在相互跳转时，会位于同一个task中，而不会新建一个task！<br>如果在manifest中没有对Activity的android:taskAffinity进行配置，则每个Activity都采用和Application相同的taskAffinity；这也就意味着，同一个Application中的所有Activity的taskAffinity在默认情况下是相同的！</p>
<p>下面开始介绍四种launchMode模式，在通过示例介绍之后，再来对这四种launchMode进行总结。</p>
<p><a name="anchor2"></a></p>
<h1 id="1-standard模式"><a href="#1-standard模式" class="headerlink" title="1. standard模式"></a>1. standard模式</h1><p>standard模式是默认模式。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个task，也可以位于不同的task。</p>
<p>下面通过示例来对standard进行验证。在该示例中，ActivityTest是standard模式的，而且点击ActivityTest中的按钮能跳转到它自身。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/01_standard" target="_blank" rel="noopener">standard模式的测试源码</a></p>
<p>manifest源码</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
&lt;/application&gt;</code></pre><p>ActivityTest的代码</p>
<pre><code>public class ActivityTest extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        TextView tv = (TextView) findViewById(R.id.tv);
        tv.setText(this.toString()+&quot;, taskId=&quot;+this.getTaskId());
    }   

    public void onJump(View view) {
        Intent intent = new Intent(this, ActivityTest.class);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent);
    }   
}</code></pre><p>说明：上面的ActivityTest就是android:launchMode=”standard”模式的。onJump()是按钮的回调函数，点击该按钮，会重新创建一个ActivityTest实例。</p>
<p><strong>测试内容</strong>：ActivityTest –&gt; ActivityTest –&gt; ActivityTest。 (注：ActivityTest –&gt; ActivityTest表示从ActivityTest跳转到ActivityTest)<br><strong>测试结果</strong>：每一个ActivityTest实例都是不同的，而且这三个ActivityTest实例都位于同一个task中。<br><strong>结果分析</strong>：这与我们前面介绍的standard模式的特性是相符的。</p>
<p><a name="anchor3"></a></p>
<h1 id="2-singleTop模式"><a href="#2-singleTop模式" class="headerlink" title="2. singleTop模式"></a>2. singleTop模式</h1><p>singleTop模式下，在同一个task中，如果存在该Activity的实例，并且该Activity实例位于栈顶(即，该Activity位于前端)，则调用startActivity()时，不再创建该Activity的示例；而仅仅只是调用Activity的onNewIntent()。否则的话，则新建该Activity的实例，并将其置于栈顶。</p>
<h2 id="2-1-singleTop示例一"><a href="#2-1-singleTop示例一" class="headerlink" title="2.1 singleTop示例一"></a>2.1 singleTop示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/02_single_top/SingleActvity" target="_blank" rel="noopener">singleTop示例二的源码</a></p>
<p>我们将”standard示例”中ActivityTest的launchMode修改为singleTop，其他的保持不变。修改后的manifest如下：</p>
<pre><code>&lt;activity android:name=&quot;ActivityTest&quot;
          android:launchMode=&quot;singleTop&quot;
          android:label=&quot;@string/app_name&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;</code></pre><p>说明：上面的ActivityTest就是android:launchMode=”singleTop”模式的。并不会创建新的ActivityTest实例；但是会调用onNewIntent()。<br>        </p>
<p><strong>测试内容</strong>：ActivityTest –&gt; ActivityTest –&gt; ActivityTest<br><strong>测试结果</strong>：每一个ActivityTest实例都是相同的！当从一个ActivityTest跳转到它自身时，没有创建新的ActivityTest实例，但是会调用onNewIntent()。<br><strong>结果分析</strong>：这与我们前面介绍的singleTop模式的特性是相符的。</p>
<p>如果是singleTop模式的Activity不在栈顶，那会如何呢？我们通过下面的示例来进行分析。</p>
<h2 id="2-2-singleTop示例二"><a href="#2-2-singleTop示例二" class="headerlink" title="2.2 singleTop示例二"></a>2.2 singleTop示例二</h2><p>在该示例中，有两个Activity：ActivityTest和SecondActivity。其中ActivityTest是singleTop类型的，而SecondActivity则是standard类型的。这两个Activity之间能相互跳转。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/02_single_top/TwoActivity" target="_blank" rel="noopener">singleTop示例二的源码</a></p>
<p>manifest的源码</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;singleTop&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:launchMode=&quot;standard&quot;/&gt;
&lt;/application&gt;</code></pre><p>ActivityTest的代码</p>
<pre><code>public class ActivityTest extends Activity {
    private static final String TAG=&quot;##ActivityTest##&quot;;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        Log.d(TAG, &quot;onCreate: &quot;+this.toString());
        TextView tv = (TextView) findViewById(R.id.tv);
        tv.setText(this.toString());
    }   

    public void onJump(View view) {
        Log.d(TAG, &quot;onJump: &quot;+this.toString());
        Intent intent = new Intent(this, SecondActivity.class);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this);
    }   

}</code></pre><p>说明：上面的ActivityTest就是android:launchMode=”singleTop”模式的。onJump()是按钮的回调函数，点击该按钮，会跳转到SecondActivity中。</p>
<pre><code>public class SecondActivity extends Activity {

    private static final String TAG=&quot;##SecondActivity##&quot;;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.second);

        Log.d(TAG, &quot;onCreate: &quot;+this.toString());
        TextView tv = (TextView) findViewById(R.id.tv2);
        tv.setText(this.toString());
    }   

    public void onBack(View view) {
        Log.d(TAG, &quot;onBack: &quot;+this.toString());
        Intent intent = new Intent(this, ActivityTest.class);
        startActivity(intent);
    }   

    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, &quot;onNewIntent: intent=&quot;+intent+&quot;, activity=&quot;+this);
    }   
}</code></pre><p>说明：上面的SecondActivity是standard模式的。onBack是按钮的回调函数，点击该按钮，会跳转回ActivityTest。</p>
<p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest<br><strong>测试结果</strong>：两个ActivityTest是不同的实例！<br><strong>结果分析</strong>：这与我们之前的描述是相符的，当singleTop类型的Activity不在栈顶时，会新建Activity实例。</p>
<p><a name="anchor4"></a></p>
<h1 id="4-singleTask模式"><a href="#4-singleTask模式" class="headerlink" title="4. singleTask模式"></a>4. singleTask模式</h1><p>Google官网对singleTask的描述如下：</p>
<blockquote>
<p>The system creates a new task and instantiates the activity at the root of the new task. However, if an instance of the activity already exists in a separate task, the system routes the intent to the existing instance through a call to its onNewIntent() method, rather than creating a new instance. Only one instance of the activity can exist at a time. </p>
</blockquote>
<p>大致意思是：</p>
<blockquote>
<p>在singleTask模式下，如果是第一次创建该Activity实例时，则会新建task并将该Activity添加到该task中。否则(该Activity的实例已存在)，则会打开已有的Activity实例，并调用Activity的onNewIntent()方法，而不会新建Activity实例。在任意时刻，最多只会有该一个Activity实例存在。</p>
</blockquote>
<p>上面的描述…其实特别抽象。我们通过实例来对singleTask进行了解，最后再对singleTask进行总结。需要建立的一个概念是：singleTask，顾名思义，只容许有一个包含该Activity实例的task存在！</p>
<h2 id="4-1-singleTask示例一"><a href="#4-1-singleTask示例一" class="headerlink" title="4.1 singleTask示例一"></a>4.1 singleTask示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/03_single_task/01_same_taskAffinity" target="_blank" rel="noopener">singleTask示例一的测试源码</a></p>
<p>该示例是来验证：(01) 第一次创建singleTask类型的Activity时，会创建新的task！(02) 该Activity实例已经存在时，不会创建新的Activity实例，才是跳转到已有的Activity实例中。</p>
<p>将前面的”singleTop示例二”中的ActivityTest的模式改为”standard”，将SecondActivity的模式改为”singleTask”。修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;standard&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
        android:launchMode=&quot;singleTask&quot; /&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) ActivityTest和SecondActivity在同一个task中。 (02) 两个SecondActivity是相同的实例！<br><strong>结果分析</strong>：结论(01)验证失败，结论(02)验证成功!</p>
<p>为什么会出现结论(01)验证失败呢？根据Google官网的描述，分明会启动一个新的task才对啊？为什么呢？<br>会不会是由于ActivityTest和SecondActivity位于同一个APK中，由于它们的android:taskAffinity相同导致的！嗯…到底是不是呢？下面就通过示例来进一步验证！</p>
<h2 id="4-2-singleTask示例二"><a href="#4-2-singleTask示例二" class="headerlink" title="4.2 singleTask示例二"></a>4.2 singleTask示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/03_single_task/02_diff_taskAffinity" target="_blank" rel="noopener">singleTask示例二的测试源码</a></p>
<p>将”singleTask示例一”中的两个Activity的taskAffinity改为不同，其他保持不变。修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;standard&quot;
              android:taskAffinity=&quot;com.skw.activitytest.task01&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:taskAffinity=&quot;com.skw.activitytest.task02&quot;
              android:launchMode=&quot;singleTask&quot; /&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) 第一个ActivityTest和第一个SecondActivity在不同task中。 (02) 两个SecondActivity是相同的实例！<br><strong>结果分析</strong>：结论(01)验证成功，结论(02)验证成功!</p>
<p>进一步进行测试：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity  –&gt; 返回键 –&gt; 返回键<br><strong>测试结果</strong>：在前面测试的基础上，按两次返回键。结果：第一次按返回键的时候，回到第一次创建的ActivityTest实例；再按一次返回键的话，则返回到原始画面(第一次进入ActivityTest之前的画面)！<br><strong>结果分析</strong>：这个结果表明，再次进入SecondActivity时，会将SecondActivity所在task中位于SecondActivity之上的全部Activity都删除！  </p>
<p>总结来说：singleTask的结论与android:taskAffinity相关。以A启动B来说<br>(01) 当A和B的taskAffinity相同时：第一次创建B的实例时，并不会启动新的task，而是直接将B添加到A所在的task；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。<br>(02) 当A和B的taskAffinity不同时：第一次创建B的实例时，会启动新的task，然后将B添加到新建的task中；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。  </p>
<p><a name="anchor5"></a></p>
<h1 id="5-singleInstance模式"><a href="#5-singleInstance模式" class="headerlink" title="5. singleInstance模式"></a>5. singleInstance模式</h1><p>singleInstance，顾名思义，是单一实例的意思，即任意时刻只允许存在唯一的Activity实例！<br>根据Google官网的描述，在模式下，只允许有一个Activity实例。当第一次创建该Activity实例时，会新建一个task，并将该Activity添加到该task中。<strong>注意：该task只能容纳该Activity实例，不会再添加其他的Activity实例！</strong>如果该Activity实例已经存在于某个task，则直接跳转到该task。</p>
<h2 id="5-1-singleInstance示例一"><a href="#5-1-singleInstance示例一" class="headerlink" title="5.1 singleInstance示例一"></a>5.1 singleInstance示例一</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/04_single_instance/singleTop_singleInstance" target="_blank" rel="noopener">singleInstance示例一的测试源码</a></p>
<p>将前面的”singleTop示例二”中的ActivityTest的模式改为”standard”，将SecondActivity的模式改为”singleInstance”。修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;standard&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) 两个SecondActivity是同一个实例。 (02) 第一次进入的ActivityTest和第一次进入的SecondActivity位于不同的task中。 (03) 两个ActivityTest是位于同一个task中的不同实例。<br> <strong>结果分析</strong>：这个结论与预期是相同的，即，singleInstance类型的Activity的实例只能有一个，而且它只允许存在于单独的一个task中。singleInstance与相互跳转的两个Activity的taskAffinity无关系！</p>
<p>至于为什么两个ActivityTest是位于同一个task中的不同实例，那是因为它是standard类型的。我们可以将ActivityTest修改为singleTop等其他类型进行测试。</p>
<h2 id="5-2-singleInstance示例二"><a href="#5-2-singleInstance示例二" class="headerlink" title="5.2 singleInstance示例二"></a>5.2 singleInstance示例二</h2><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/activity/launch_mode/04_single_instance/standard_singleInstance" target="_blank" rel="noopener">singleInstance示例二的测试源码</a></p>
<p>将前面的”singleInstance示例一”中的ActivityTest的模式改为”singleTop”。修改后的manifest如下：</p>
<pre><code>&lt;application android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot;&gt;
    &lt;activity android:name=&quot;ActivityTest&quot;
              android:launchMode=&quot;singleTop&quot;
              android:label=&quot;@string/app_name&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=&quot;SecondActivity&quot;
              android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;/application&gt;</code></pre><p><strong>测试内容</strong>：ActivityTest –&gt; SecondActivity –&gt; ActivityTest –&gt; SecondActivity<br><strong>测试结果</strong>：(01) 两个SecondActivity是同一个实例。 (02) 第一次进入的ActivityTest和第一次进入的SecondActivity位于不同的task中。 (03) 两个ActivityTest是同一个实例。<br> <strong>结果分析</strong>：这个结论与预期是相同的。</p>
<p><a name="anchor6"></a></p>
<h1 id="launchMode模式总结"><a href="#launchMode模式总结" class="headerlink" title="launchMode模式总结"></a>launchMode模式总结</h1><p>现在，总结一下launchMode的四种模式：</p>
<h2 id="1-standard"><a href="#1-standard" class="headerlink" title="1. standard"></a>1. standard</h2><p>它是默认模式。在该模式下，Activity可以拥有多个实例，并且这些实例既可以位于同一个task，也可以位于不同的task。  </p>
<h2 id="2-singleTop"><a href="#2-singleTop" class="headerlink" title="2.singleTop"></a>2.singleTop</h2><p>该模式下，在同一个task中，如果存在该Activity的实例，并且该Activity实例位于栈顶(即，该Activity位于前端)，则调用startActivity()时，不再创建该Activity的示例；而仅仅只是调用Activity的onNewIntent()。否则的话，则新建该Activity的实例，并将其置于栈顶。</p>
<h2 id="3-singleTask"><a href="#3-singleTask" class="headerlink" title="3. singleTask"></a>3. singleTask</h2><p>顾名思义，只容许有一个包含该Activity实例的task存在！</p>
<p>总的来说：singleTask的结论与android:taskAffinity相关。以A启动B来说<br>(01) 当A和B的taskAffinity相同时：第一次创建B的实例时，并不会启动新的task，而是直接将B添加到A所在的task；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。<br>(02) 当A和B的taskAffinity不同时：第一次创建B的实例时，会启动新的task，然后将B添加到新建的task中；否则，将B所在task中位于B之上的全部Activity都删除，然后跳转到B中。  </p>
<h2 id="4-singleInstance"><a href="#4-singleInstance" class="headerlink" title="4. singleInstance"></a>4. singleInstance</h2><p>顾名思义，是单一实例的意思，即任意时刻只允许存在唯一的Activity实例，而且该Activity所在的task不能容纳除该Activity之外的其他Activity实例！  </p>
<p>它与singleTask有相同之处，也有不同之处。<br><strong>相同之处</strong>：任意时刻，最多只允许存在一个实例。<br><strong>不同之处</strong>：(01) singleTask受android:taskAffinity属性的影响，而singleInstance不受android:taskAffinity的影响。 (02) singleTask所在的task中能有其它的Activity，而singleInstance的task中不能有其他Activity。 (03) 当跳转到singleTask类型的Activity，并且该Activity实例已经存在时，会删除该Activity所在task中位于该Activity之上的全部Activity实例；而跳转到singleInstance类型的Activity，并且该Activity已经存在时，不需要删除其他Activity，因为它所在的task只有该Activity唯一一个Activity实例。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/25/android/api_guide/tasks/2014-06-25-Loader/" itemprop="url">Android之Loader介绍</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-25T01:11:00.000Z" itemprop="datePublished">6月 25 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            25 分钟 read (About 3681 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文介绍Loader, CursorLoader, AsyncTaskLoader 和 LoaderManager。先给出它们的使用示例，然后再对它们的架构和原理进行分析。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">Loader简介</a><br><strong>2</strong>. <a href="#anchor2">Loader使用示例</a><br><strong>3</strong>. <a href="#anchor3">Loader架构和原理</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="Loader简介"><a href="#Loader简介" class="headerlink" title="Loader简介"></a>Loader简介</h1><p><strong>Loader</strong>：是一个执行异步数据加载的抽象类。它是AsyncTaskLoader的父类，CursorLoader的祖父类。</p>
<p><strong>AsyncTaskLoader</strong>：它是继承于Loader的抽象类。在AsyncTaskLoader中有AsyncTask用来执行异步工作。</p>
<p><strong>CursorLoader</strong>：它是AsyncTaskLoader的子类。它可以查询ContentResolver然后返回一个Cursor，同时CursorLoader内包含ContentObserver对象来监听Cursor数据的变化。</p>
<p><strong>LoaderManager</strong>：它是一个抽像类，作用是用来管理Loader。LoaderManager关联到一个Activity或Fragment；例如，在Activity中通过getLoaderManager()可以获取到一个LoaderManager对象。</p>
<p><strong>LoaderManager.LoaderCallbacks</strong>：它提供了与”Activity或Fragment”交互的接口。LoaderCallbacks中共包行三个接口：</p>
<blockquote>
<ol>
<li>onCreateLoader()：根据所给出的ID，初始化并返回一个新的加载器。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>onLoadFinished()：当一个先前被创建的加载器完成了它的加载过程时被调用。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>onLoaderReset()：当一个先前被创建的加载器被重置时被调用，然后使加载器的数据无效。</li>
</ol>
</blockquote>
<p>总结：Loader, AsyncTaskLoader和CursorLoader都是用来提供异步加载的类；而LoaderManager则提供了管理这些异步加载类的接口。此外，Activity或Fragment保护了获取LoaderManager的接口，通过这样的接口，就可以在Activity或Fragment中实现异步加载任务！</p>
<p><a name="anchor2"></a></p>
<h1 id="Loader使用示例"><a href="#Loader使用示例" class="headerlink" title="Loader使用示例"></a>Loader使用示例</h1><p>下面通过一则示例演示Fragment中执行异步加载的完整流程！该示例中，会在FragmentActivity中采用异步加载的方式查找并显示数据库中所有的图片的相关信息。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/loader/loader_picture/LoaderTest" target="_blank" rel="noopener">Loader示例的完整源码</a></p>
<h2 id="1-获取LoaderManager，并执行initLoader"><a href="#1-获取LoaderManager，并执行initLoader" class="headerlink" title="1. 获取LoaderManager，并执行initLoader()"></a>1. 获取LoaderManager，并执行initLoader()</h2><pre><code>public class LoaderTest extends FragmentActivity
    implements LoaderCallbacks&lt;Cursor&gt;, OnItemClickListener {

    ...

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        listView = (ListView)findViewById(android.R.id.list);
        simpleCursorAdapter = new SimpleCursorAdapter(
                this, 
                R.layout.list_item, 
                null, 
                STORE_IMAGES, 
                new int[] { R.id.item_title, R.id.item_value}
                );  

        simpleCursorAdapter.setViewBinder(new ImageLocationBinder());
        listView.setAdapter(simpleCursorAdapter);
        // 注意此处是getSupportLoaderManager()，而不是getLoaderManager()方法。
        getSupportLoaderManager().initLoader(0, null, this);

        listView.setOnItemClickListener(this);
    }   
}</code></pre><p>说明：需要重点关注的是getSupportLoaderManager()，它的作用是获取LoaderManager。然后，通过initLoader()初始化Loader。</p>
<p>initLoader()的完整声明如下：</p>
<pre><code>public &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback);</code></pre><p>说明：<br>(01) id是Loader的唯一标识。<br>(02) args是Bundle，这里赋值位null。<br>(03) callback是回调函数。后面会给出回调的实现。  </p>
<h2 id="2-实现LoaderManager-LoaderCallbacks接口"><a href="#2-实现LoaderManager-LoaderCallbacks接口" class="headerlink" title="2. 实现LoaderManager.LoaderCallbacks接口"></a>2. 实现LoaderManager.LoaderCallbacks接口</h2><p>LoaderCallbacks中包行onCreateLoader(), onLoaderReset(), onLoadFinished()三个接口。下面是它们的实现：</p>
<pre><code>@Override
public Loader&lt;Cursor&gt; onCreateLoader(int arg0, Bundle arg1) {
    CursorLoader cursorLoader = new CursorLoader(
            this, 
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI, 
            STORE_IMAGES, 
            null, 
            null, 
            null);
    return cursorLoader;
}

@Override
public void onLoaderReset(Loader&lt;Cursor&gt; arg0) {
    simpleCursorAdapter.swapCursor(null);
}

@Override
public void onLoadFinished(Loader&lt;Cursor&gt; arg0, Cursor cursor) {
    simpleCursorAdapter.swapCursor(cursor);
}</code></pre><p>说明：<br>(01) onCreateLoader()会在初始化Loader之后执行，它的作用是返回一个Loader对象。<br>(02) 而onLoadFinished()是当异步加载完成之后会被执行，当Loader加载完数据时，我们会通过 simpleCursorAdapter.swapCursor(cursor)将simpleCursorAdapter切换到新的Cursor对象(即，加载完后保存数据的对象)。不同于changeCursor()，changeCursor()在切换到新的Cursor之后，会将旧的Cursor关闭掉；而swapCursor()切换到新的Cursor之后，不会关闭旧的Cursor，如果旧的Cursor存在的话，它会返回旧的Cursor。<br>(03) onLoaderReset()则是当异步加载起被重置时会被调用。当Loader被重置会，我们通过simpleCursorAdapter.swapCursor(null)将Cursor设为null。</p>
<h2 id="3-其他操作"><a href="#3-其他操作" class="headerlink" title="3. 其他操作"></a>3. 其他操作</h2><p>经过上面两步之后，已经能成功的使用异步加载数据了。得到的数据保存在SimpleCursorAdapter对象中，接下来需要做的就是在SimpleCursorAdapter中显示数据。</p>
<p>在onCreate()中，我们通过simpleCursorAdapter.setViewBinder(new ImageLocationBinder())设置了SimpleCursorAdapter的ViewBinder对象。下面看看ViewBinder中是如何显示的：</p>
<pre><code>// 将图片的位置绑定到视图
private class ImageLocationBinder implements ViewBinder {
    @Override
    public boolean setViewValue(View view, Cursor cursor, int columnIndex) {
        if (columnIndex == 1) {
            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
            String path = cursor.getString(column_index);
            ((TextView)view).setText(&quot;Location: &quot;+path);
            return true;
        }

        return false;
    }
}</code></pre><p>至此，数据的异步加载示例差不多介绍完了。总的来说很简单，先获取LoaderManager对象，然后通过initLoader()初始化Loader。接着，需要作的是实现LoaderCallbacks接口！LoaderCallbacks接口中，需要重点关注的是onCreateLoader()和onLoadFinished()接口！</p>
<p><a name="anchor3"></a></p>
<h1 id="Loader架构和原理"><a href="#Loader架构和原理" class="headerlink" title="Loader架构和原理"></a>Loader架构和原理</h1><p>在Loader简介中，我们大致介绍了Loader, LoaderManager各个类的作用。这里，我们分析一下它们的源码来查看它们是如何工作的。主要解决的有以下几个问题：<br>(01) <strong>Loader的异步加载原理。也就是说Loader异步是通过什么实现的？是一个Thread，还是AsyncTask，还是其他的什么方式</strong>？<br>(02) <strong>onCreateLoader()和onLoadFinished()是如何回调的。尤其是onLoadFinished()，当数据加载完时，是如何回调的</strong>？<br>(03) <strong>当发生Activity或Fragment被重新加载(例如，发生旋屏动作)时，Loader不会重新加载，它里面的数据仍然存在。这是如何做到的</strong>？<br>(04) <strong>Loader异步加载器，能够自动更新数据。它又是如何做到的</strong>？  </p>
<h2 id="1-异步加载原理"><a href="#1-异步加载原理" class="headerlink" title="1. 异步加载原理"></a>1. 异步加载原理</h2><p>涉及到的文件：<br>frameworks/base/core/java/android/app/LoaderManager.java<br>frameworks/base/core/java/android/content/Loader.java<br>frameworks/base/core/java/android/content/AsyncTaskLoader.java<br>frameworks/base/core/java/android/content/CursorLoader.java</p>
<h3 id="1-1-initLoader"><a href="#1-1-initLoader" class="headerlink" title="1.1 initLoader()"></a>1.1 initLoader()</h3><p>LoaderManager.java中initLoader()源码如下：</p>
<pre><code>public &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback) {
    if (mCreatingLoader) {
        throw new IllegalStateException(&quot;Called while creating a loader&quot;);
    }   

    LoaderInfo info = mLoaders.get(id);

    if (DEBUG) Log.v(TAG, &quot;initLoader in &quot; + this + &quot;: args=&quot; + args);

    if (info == null) {
        // Loader doesn&apos;t already exist; create.
        info = createAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);
        if (DEBUG) Log.v(TAG, &quot;  Created new loader &quot; + info);
    } else {
        if (DEBUG) Log.v(TAG, &quot;  Re-using existing loader &quot; + info);
        info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback;
    }   

    if (info.mHaveData &amp;&amp; mStarted) {
        // If the loader has already generated its data, report it now.
        info.callOnLoadFinished(info.mLoader, info.mData);
    }   

    return (Loader&lt;D&gt;)info.mLoader;
}   </code></pre><p>说明：<br>(01) initLoader()会现通过mLoaders.get(id)来根据id获取LoaderInfo对象。如果Activity或Fragment第一次调用initLoader()，则获取到的LoaderInfo对象为null。<br>(02) 如果info为null，则执行createAndInstallLoader()来创建LoaderInfo对象。  </p>
<h3 id="1-2-createAndInstallLoader"><a href="#1-2-createAndInstallLoader" class="headerlink" title="1.2 createAndInstallLoader()"></a>1.2 createAndInstallLoader()</h3><p>LoaderManager.java中createAndInstallLoader()源码如下：</p>
<pre><code>private LoaderInfo createLoader(int id, Bundle args,
        LoaderManager.LoaderCallbacks&lt;Object&gt; callback) {
    LoaderInfo info = new LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);
    Loader&lt;Object&gt; loader = callback.onCreateLoader(id, args);
    info.mLoader = (Loader&lt;Object&gt;)loader;
    return info;
}

private LoaderInfo createAndInstallLoader(int id, Bundle args,
        LoaderManager.LoaderCallbacks&lt;Object&gt; callback) {
    try {
        mCreatingLoader = true;
        LoaderInfo info = createLoader(id, args, callback);
        installLoader(info);
        return info;
    } finally {
        mCreatingLoader = false;
    }
}

void installLoader(LoaderInfo info) {
    mLoaders.put(info.mId, info);
    if (mStarted) {
        // The activity will start all existing loaders in it&apos;s onStart(),
        // so only start them here if we&apos;re past that point of the activitiy&apos;s
        // life cycle
        info.start();
    }
}</code></pre><p>说明：<br>(01) createAndInstallLoader()会分别调用createLoader()和installLoader()接口。<br>(02) createLoader()会新建LoaderInfo对象，然后调用callback.onCreateLoader()接口。<strong>这里的onCreateLoader()就是我们实现的LoaderCallbacks接口中的onCreateLoader()接口</strong>。<br>(03) initLoader()中会调用info.start()接口。  </p>
<h3 id="1-3-LoaderInfo中的start"><a href="#1-3-LoaderInfo中的start" class="headerlink" title="1.3 LoaderInfo中的start()"></a>1.3 LoaderInfo中的start()</h3><p>LoaderManager.java中的内部类LoaderInfo的源码如下：</p>
<pre><code>final class LoaderInfo implements Loader.OnLoadCompleteListener&lt;Object&gt;,
        Loader.OnLoadCanceledListener&lt;Object&gt; {

    final int mId;
    final Bundle mArgs;
    LoaderManager.LoaderCallbacks&lt;Object&gt; mCallbacks;
    Loader&lt;Object&gt; mLoader;

    ...

    public LoaderInfo(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;Object&gt; callbacks) {
        mId = id;
        mArgs = args;
        mCallbacks = callbacks;
    }

    void start() {
        if (mRetaining &amp;&amp; mRetainingStarted) {
            mStarted = true;
            return;
        }

        if (mStarted) {
            return;
        }

        mStarted = true;

        if (DEBUG) Log.v(TAG, &quot;  Starting: &quot; + this);
        if (mLoader == null &amp;&amp; mCallbacks != null) {
           mLoader = mCallbacks.onCreateLoader(mId, mArgs);
        }
        if (mLoader != null) {
            if (mLoader.getClass().isMemberClass()
                    &amp;&amp; !Modifier.isStatic(mLoader.getClass().getModifiers())) {
                throw new IllegalArgumentException(
                        &quot;Object returned from onCreateLoader must not be a non-static inner member class: &quot;
                        + mLoader);
            }
            if (!mListenerRegistered) {
                mLoader.registerListener(mId, this);
                mLoader.registerOnLoadCanceledListener(this);
                mListenerRegistered = true;
            }
            mLoader.startLoading();
        }
    }

    ...
}</code></pre><p>说明：start()中一个非常重要的成员是mLoader。<strong>它就是onCreateLoader()返回的Loader对象</strong>。start()会调用mLoaders.startLoading()。</p>
<h3 id="1-4-startLoading"><a href="#1-4-startLoading" class="headerlink" title="1.4 startLoading()"></a>1.4 startLoading()</h3><p>下面查看startLoading的相关代码。查看代码时，请记得：Loader.java, AsyncTaskLoader和CursorLoader这三者之间存在继承关系！</p>
<pre><code>// 在Loader.java中
public final void startLoading() {
    mStarted = true;
    mReset = false;
    mAbandoned = false;
    onStartLoading();
}

// 在CursorLoader.java中
@Override
protected void onStartLoading() {
    if (mCursor != null) {
        deliverResult(mCursor);
    }   
    if (takeContentChanged() || mCursor == null) {
        forceLoad();
    }   
}   </code></pre><p>说明：startLoading()是在Loader.java中定义的，它调用了onStartLoading()。而CursorLoader.java覆盖了onStartLoading()函数。在onStartLoading()中，此时的mCursor是为null；所以，它会执行forceLoad()。</p>
<h3 id="1-5-forceLoad"><a href="#1-5-forceLoad" class="headerlink" title="1.5 forceLoad()"></a>1.5 forceLoad()</h3><p>下面查看forceLoad的相关代码。</p>
<pre><code>// 在Loader.java中
public void forceLoad() {
    onForceLoad();
}

// 在AsyncTaskLoader.java中
@Override
protected void onForceLoad() {
    super.onForceLoad();
    cancelLoad();
    mTask = new LoadTask();
    if (DEBUG) Slog.v(TAG, &quot;Preparing load: mTask=&quot; + mTask);
    executePendingTask();
}  

// 在AsyncTaskLoader.java中
void executePendingTask() {
    if (mCancellingTask == null &amp;&amp; mTask != null) {
        if (mTask.waiting) {
            mTask.waiting = false;
            mHandler.removeCallbacks(mTask);
        }
        if (mUpdateThrottle &gt; 0) {
            long now = SystemClock.uptimeMillis();
            if (now &lt; (mLastLoadCompleteTime+mUpdateThrottle)) {
                // Not yet time to do another load.
                if (DEBUG) Slog.v(TAG, &quot;Waiting until &quot;
                        + (mLastLoadCompleteTime+mUpdateThrottle)
                        + &quot; to execute: &quot; + mTask);
                mTask.waiting = true;
                mHandler.postAtTime(mTask, mLastLoadCompleteTime+mUpdateThrottle);
                return;
            }
        }
        if (DEBUG) Slog.v(TAG, &quot;Executing: &quot; + mTask);
        mTask.executeOnExecutor(mExecutor, (Void[]) null);
    }
}</code></pre><p>说明：forceLoad()会调用onForceLoad()。而onForceLoad()中会新建LoadTask对象，然后执行executePendingTask()。在executePendingTask()中会调用LoadTask对象的executeOnExecutor()。</p>
<h3 id="1-6-LoadTask"><a href="#1-6-LoadTask" class="headerlink" title="1.6 LoadTask"></a>1.6 LoadTask</h3><p>LoadTask是AsyncTaskLoader的内部类。实际上，它是AsyncTask的子类。在<a href="/2014/06/25/AsyncTask">介绍AsyncTask的文章中</a>，我们知道executeOnExecutor()会将任务提交到线程池中去执行，而这个被提交到线程池的任务会执行AsyncTask的doInBackground()。</p>
<pre><code>// AsyncTaskLoader.java中
final class LoadTask extends AsyncTask&lt;Void, Void, D&gt; implements Runnable {
    private final CountDownLatch mDone = new CountDownLatch(1);

    boolean waiting;

    @Override
    protected D doInBackground(Void... params) {
        if (DEBUG) Slog.v(TAG, this + &quot; &gt;&gt;&gt; doInBackground&quot;);
        try {
            D data = AsyncTaskLoader.this.onLoadInBackground();
            if (DEBUG) Slog.v(TAG, this + &quot;  &lt;&lt;&lt; doInBackground&quot;);
            return data;
        } catch (OperationCanceledException ex) {
            if (!isCancelled()) {
                throw ex;
            }
            if (DEBUG) Slog.v(TAG, this + &quot;  &lt;&lt;&lt; doInBackground (was canceled)&quot;, ex);
            return null;
        }
    }

    /* Runs on the UI thread */
    @Override
    protected void onPostExecute(D data) {
        if (DEBUG) Slog.v(TAG, this + &quot; onPostExecute&quot;);
        try {
            AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
        } finally {
            mDone.countDown();
        }
    }

    ...
}</code></pre><p>说明：LoadTask的doInBackground()会调用onLoadInBackground()。</p>
<h3 id="1-7-onLoadInBackground"><a href="#1-7-onLoadInBackground" class="headerlink" title="1.7 onLoadInBackground()"></a>1.7 onLoadInBackground()</h3><p>下面查看onLoadInBackground()的相关代码。</p>
<pre><code>// AsyncTaskLoader.java中
protected D onLoadInBackground() {
    return loadInBackground();
}

// CursorLoader.java中
@Override
public Cursor loadInBackground() {
    synchronized (this) {
        if (isLoadInBackgroundCanceled()) {
            throw new OperationCanceledException();
        }
        mCancellationSignal = new CancellationSignal();
    }           
    try {
        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,
                mSelectionArgs, mSortOrder, mCancellationSignal);
        if (cursor != null) {
            try {
                // Ensure the cursor window is filled.
                cursor.getCount();
                cursor.registerContentObserver(mObserver);
            } catch (RuntimeException ex) {
                cursor.close();
                throw ex;
            } 
        }
        return cursor;
    } finally {
        synchronized (this) {
            mCancellationSignal = null;
        }
    }
}   </code></pre><p>说明：loadInBackground()会执行查询。<strong>这就是后台任务真正执行的动作所在！</strong></p>
<p>至此，我们已经回答了第一个问题：Loader的异步加载原理。实际上，Loader的异步加载是通过AsyncTask启动一个后台任务，在后台任务中再执行query()查询操作！</p>
<h2 id="2-onLoadFinished是如何被回调的"><a href="#2-onLoadFinished是如何被回调的" class="headerlink" title="2. onLoadFinished是如何被回调的"></a>2. onLoadFinished是如何被回调的</h2><p>我们知道，当AsyncTask中的任务执行完时，会通过onPostExecute()反馈执行结果。下面，我们看看AsyncTask反馈的结果中是如何调用onLoadFinished()的。</p>
<h3 id="2-1-onPostExecute"><a href="#2-1-onPostExecute" class="headerlink" title="2.1 onPostExecute"></a>2.1 onPostExecute</h3><p>下面看看onPostExecute()的相关代码。</p>
<pre><code>// AsyncTaskLoader.java中
@Override
protected void onPostExecute(D data) {
    if (DEBUG) Slog.v(TAG, this + &quot; onPostExecute&quot;);
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        mDone.countDown();
    }
}

// AsyncTaskLoader.java中
void dispatchOnLoadComplete(LoadTask task, D data) {
    if (mTask != task) {
        if (DEBUG) Slog.v(TAG, &quot;Load complete of old task, trying to cancel&quot;);
        dispatchOnCancelled(task, data);
    } else {
        if (isAbandoned()) {
            // This cursor has been abandoned; just cancel the new data.
            onCanceled(data);
        } else {
            commitContentChanged();
            mLastLoadCompleteTime = SystemClock.uptimeMillis();
            mTask = null;
            if (DEBUG) Slog.v(TAG, &quot;Delivering result&quot;);
            deliverResult(data);
        }
    }
}</code></pre><p>说明：onPostExecute()会执行dispatchOnLoadComplete()，而后者会调用deliverResult()来分发消息。</p>
<h3 id="2-2-deliverResult"><a href="#2-2-deliverResult" class="headerlink" title="2.2 deliverResult()"></a>2.2 deliverResult()</h3><pre><code>// CursorLoader.java中
@Override
public void deliverResult(Cursor cursor) {
    if (isReset()) {
        // An async query came in while the loader is stopped
        if (cursor != null) {
            cursor.close();
        }   
        return;
    }   
    Cursor oldCursor = mCursor;
    mCursor = cursor;

    if (isStarted()) {
        super.deliverResult(cursor);
    }   

    if (oldCursor != null &amp;&amp; oldCursor != cursor &amp;&amp; !oldCursor.isClosed()) {
        oldCursor.close();
    }   
}   

// Loader.java中
public void deliverResult(D data) {
    if (mListener != null) {
        mListener.onLoadComplete(this, data);
    }
}</code></pre><p>说明：CursorLoader.java中的deliverResult()会通过super.deliverResult()调用父类的deliverResult()，也就是会执行Loader.java中的deliverResult()。最终会执行mListener.onLoadComplete()。mListener是什么呢？它是我们在执行LoaderManager.java的start()函数时，通过mLoader.registerListener(mId, this)注册到Loader上的。也就是说，mListener是LoaderManager中的LoaderInfo对象。</p>
<h3 id="2-3-LoaderInfo中的onLoadComplete"><a href="#2-3-LoaderInfo中的onLoadComplete" class="headerlink" title="2.3 LoaderInfo中的onLoadComplete()"></a>2.3 LoaderInfo中的onLoadComplete()</h3><pre><code>@Override
public void onLoadComplete(Loader&lt;Object&gt; loader, Object data) {
    if (DEBUG) Log.v(TAG, &quot;onLoadComplete: &quot; + this);

    if (mDestroyed) {
        if (DEBUG) Log.v(TAG, &quot;  Ignoring load complete -- destroyed&quot;);
        return;
    }

    if (mLoaders.get(mId) != this) {
        if (DEBUG) Log.v(TAG, &quot;  Ignoring load complete -- not active&quot;);
        return;
    }

    LoaderInfo pending = mPendingLoader;
    if (pending != null) {
        mPendingLoader = null;
        mLoaders.put(mId, null);
        destroy();
        installLoader(pending);
        return;
    }

    if (mData != data || !mHaveData) {
        mData = data;
        mHaveData = true;
        if (mStarted) {
            callOnLoadFinished(loader, data);
        }
    }

    LoaderInfo info = mInactiveLoaders.get(mId);
    if (info != null &amp;&amp; info != this) {
        info.mDeliveredData = false;
        info.destroy();
        mInactiveLoaders.remove(mId);
    }

    if (mActivity != null &amp;&amp; !hasRunningLoaders()) {
        mActivity.mFragments.startPendingDeferredFragments();
    }
}

void callOnLoadFinished(Loader&lt;Object&gt; loader, Object data) {
    if (mCallbacks != null) {
        String lastBecause = null;
        if (mActivity != null) {
            lastBecause = mActivity.mFragments.mNoTransactionsBecause;
            mActivity.mFragments.mNoTransactionsBecause = &quot;onLoadFinished&quot;;
        }
        try {
            if (DEBUG) Log.v(TAG, &quot;  onLoadFinished in &quot; + loader + &quot;: &quot;
                    + loader.dataToString(data));
            mCallbacks.onLoadFinished(loader, data);
        } finally {
            if (mActivity != null) {
                mActivity.mFragments.mNoTransactionsBecause = lastBecause;
            }
        }
        mDeliveredData = true;
    }
}</code></pre><p>说明：onLoadComplete()会调用callOnLoadFinished()，而callOnLoadFinished()最终会调用onLoadFinished()。<strong>这就是我们实现的LoaderCallbacks接口中的onLoadFinished()</strong>。</p>
<p>至此，我们也搞明白了第二个问题onLoadFinished()是如何被回调的。当AsyncTask任务执行完时，会调用onPostExecute()；而onPostExecute()会通过LoaderManager，LoaderManager最终会调用onLoadFinished()。</p>
<h2 id="3-当Activity或Fragment被重新加载时，Loader不会被重新加载。"><a href="#3-当Activity或Fragment被重新加载时，Loader不会被重新加载。" class="headerlink" title="3. 当Activity或Fragment被重新加载时，Loader不会被重新加载。"></a>3. 当Activity或Fragment被重新加载时，Loader不会被重新加载。</h2><p>这个原理其实非常简单，关键就是initLoader()的实现方式。</p>
<pre><code>public &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback) {
    if (mCreatingLoader) {
        throw new IllegalStateException(&quot;Called while creating a loader&quot;);
    }   

    LoaderInfo info = mLoaders.get(id);

    if (DEBUG) Log.v(TAG, &quot;initLoader in &quot; + this + &quot;: args=&quot; + args);

    if (info == null) {
        // Loader doesn&apos;t already exist; create.
        info = createAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);
        if (DEBUG) Log.v(TAG, &quot;  Created new loader &quot; + info);
    } else {
        if (DEBUG) Log.v(TAG, &quot;  Re-using existing loader &quot; + info);
        info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback;
    }   

    if (info.mHaveData &amp;&amp; mStarted) {
        // If the loader has already generated its data, report it now.
        info.callOnLoadFinished(info.mLoader, info.mData);
    }   

    return (Loader&lt;D&gt;)info.mLoader;
}   </code></pre><p>说明：initLoader()会首先调用mLoaders.get(id)来获取id对应的LoaderInfo对象。如果Activity或Fragment是由于旋屏而发生重载，那么通过id获取到的LoaderInfo就不是null。那么initLoader()就会调用info.callOnLoadFinished()。</p>
<h2 id="4-Loader异步加载器自动更新数据"><a href="#4-Loader异步加载器自动更新数据" class="headerlink" title="4. Loader异步加载器自动更新数据"></a>4. Loader异步加载器自动更新数据</h2><p>Loader自动更新数据是通过ContentObserver来实现的。</p>
<h3 id="4-1-注册ContentResolver"><a href="#4-1-注册ContentResolver" class="headerlink" title="4.1 注册ContentResolver"></a>4.1 注册ContentResolver</h3><pre><code>// CursorLoader.java中
@Override
public Cursor loadInBackground() {
    synchronized (this) {
        if (isLoadInBackgroundCanceled()) {
            throw new OperationCanceledException();
        }
        mCancellationSignal = new CancellationSignal();
    }           
    try {
        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,
                mSelectionArgs, mSortOrder, mCancellationSignal);
        if (cursor != null) {
            try {
                // Ensure the cursor window is filled.
                cursor.getCount();
                cursor.registerContentObserver(mObserver);
            } catch (RuntimeException ex) {
                cursor.close();
                throw ex;
            } 
        }
        return cursor;
    } finally {
        synchronized (this) {
            mCancellationSignal = null;
        }
    }
}   </code></pre><p>说明：在执行query()查询之后，如果得到的Cursor对象不是null。则通过cursor.registerContentObserver(mObserver)来监听该cursor的内容。</p>
<h3 id="4-2-注册mObserver"><a href="#4-2-注册mObserver" class="headerlink" title="4.2 注册mObserver"></a>4.2 注册mObserver</h3><pre><code>// CursorLoader.java中
public CursorLoader(Context context) {
    super(context);
    mObserver = new ForceLoadContentObserver();
}

// CursorLoader.java中
public CursorLoader(Context context, Uri uri, String[] projection, String selection,
        String[] selectionArgs, String sortOrder) {
    super(context);
    mObserver = new ForceLoadContentObserver();
    mUri = uri;
    mProjection = projection;
    mSelection = selection;
    mSelectionArgs = selectionArgs;
    mSortOrder = sortOrder;
}</code></pre><p>说明：在创建CursorLoader对象时，就创建了mObserver，它是ForceLoadContentObserver对象。</p>
<h3 id="4-3-ForceLoadContentObserver"><a href="#4-3-ForceLoadContentObserver" class="headerlink" title="4.3 ForceLoadContentObserver"></a>4.3 ForceLoadContentObserver</h3><pre><code>// Loader.java
public final class ForceLoadContentObserver extends ContentObserver {
    public ForceLoadContentObserver() {
        super(new Handler());
    }

    @Override
    public boolean deliverSelfNotifications() {
        return true;
    }

    @Override
    public void onChange(boolean selfChange) {
        onContentChanged();
    }
}

// Loader.java中
public void onContentChanged() {
    if (mStarted) {
        forceLoad();
    } else {
        // This loader has been stopped, so we don&apos;t want to load
        // new data right now...  but keep track of it changing to
        // refresh later if we start again.
        mContentChanged = true;
    }
}</code></pre><p>说明：ForceLoadContentObserver是Loader.java的内部类，它继承于ContentObserver。当数据发生变化时，它会回调onChange()，进而调用onContentChanged()。而onContentChanged()则会执行forceLoad()。forceLoad()在前面已经介绍过了，它会启动AsyncTask被执行query查询操作！</p>
<p>至此，几个问题都回答完了。Loader, AsyncTaskLoader, CursorLoader和LoaderManager的相互关系也整理完了！谢谢观赏！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/25/android/api_guide/tasks/2014-06-25-AsyncTask/" itemprop="url">Android之AsyncTask介绍</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-25T01:11:00.000Z" itemprop="datePublished">6月 25 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            12 分钟 read (About 1840 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文介绍AsyncTask，它通常用于执行异步任务。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><strong>1</strong>. <a href="#anchor1">AsyncTask介绍</a><br><strong>2</strong>. <a href="#anchor2">AsyncTask使用和示例</a><br><strong>3</strong>. <a href="#anchor3">AsyncTask原理</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="AsyncTask介绍"><a href="#AsyncTask介绍" class="headerlink" title="AsyncTask介绍"></a>AsyncTask介绍</h1><p>AsyncTask比Handler更轻量级一些，适用于简单的异步处理。</p>
<p>使用AsyncTask时，注意重写以下几个方法：</p>
<h2 id="1-doInBackground"><a href="#1-doInBackground" class="headerlink" title="1. doInBackground()"></a>1. doInBackground()</h2><p><strong>作用</strong>：执行后台任务。<br><strong>要求</strong>：必须重写！<br><strong>注意</strong>：在doInBackground()中不能进行UI操作！  </p>
<h2 id="2-onPreExecute"><a href="#2-onPreExecute" class="headerlink" title="2. onPreExecute()"></a>2. onPreExecute()</h2><p><strong>作用</strong>：通常用于执行后台任务开始前的准备动作。在用户调用execute()后，并且在AsyncTask主动执行doInBackground()之前被调用。<br><strong>要求</strong>：选择性重写。如果不重写该函数，默认不执行任何动作  </p>
<h2 id="3-onPostExecute"><a href="#3-onPostExecute" class="headerlink" title="3. onPostExecute()"></a>3. onPostExecute()</h2><p><strong>作用</strong>：通常用于处理后台动作的返回结果。在AsyncTask主动执行doInBackground()之前被调用。<br><strong>要求</strong>：选择性重写。如果不重写该函数，默认不执行任何动作  </p>
<h2 id="4-onProgressUpdate"><a href="#4-onProgressUpdate" class="headerlink" title="4. onProgressUpdate()"></a>4. onProgressUpdate()</h2><p><strong>作用</strong>：通常用于执行后台任务执行期间的进度更新。因为doInBackground()中不能操作UI，假如我们想在后台任务处理时显示进度，可以在doInBackground()中调用publishProgress()，而publicProgress()会调用onProgressUpdate()；在onProgressUpdate()中进行UI操作即可。<br><strong>要求</strong>：选择性重写。如果不重写该函数，默认不执行任何动作  </p>
<h2 id="5-onCancelled"><a href="#5-onCancelled" class="headerlink" title="5. onCancelled()"></a>5. onCancelled()</h2><p><strong>作用</strong>：通常用于执行取消AsyncTask任务时的相关动作。如果客户主动调用cancel()，则会执行onCancelled()；否则(AsyncTask执行完之后正常停止)，则不会调用onCancelled()。<br><strong>要求</strong>：选择性重写。如果不重写该函数，默认不执行任何动作  </p>
<p><a name="anchor2"></a></p>
<h1 id="AsyncTask使用和示例"><a href="#AsyncTask使用和示例" class="headerlink" title="AsyncTask使用和示例"></a>AsyncTask使用和示例</h1><p>下面是一个自定义的AsyncTask。</p>
<pre><code>private class MyTask extends AsyncTask&lt;String, Integer, String&gt; {
    //onPreExecute方法用于在执行后台任务前做一些UI操作
    @Override
    protected void onPreExecute() {
        Log.i(TAG, &quot;onPreExecute&quot;);
        textView.setText(&quot;loading...&quot;);
    }

    //doInBackground方法内部执行后台任务,不可在此方法内修改UI
    @Override
    protected String doInBackground(String... params) {
        Log.i(TAG, &quot;doInBackground&quot;);
        try {
            for (int i=0; i&lt;6; i++) {
                Log.d(TAG, &quot;doInBackground: publishProgress=&quot;+i);
                publishProgress(20*i);
                Thread.sleep(500);
            }

            Log.d(TAG, &quot;doInBackground: return OK!&quot;);
            return &quot;OK&quot;;
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        Log.d(TAG, &quot;doInBackground: return FAIL!&quot;);
        return &quot;FAIL&quot;;
    }

    //onProgressUpdate方法用于更新进度信息
    @Override
    protected void onProgressUpdate(Integer... progresses) {
        Log.i(TAG, &quot;onProgressUpdate&quot;);
        progressBar.setProgress(progresses[0]);
        textView.setText(&quot;loading...&quot; + progresses[0] + &quot;%&quot;);
    }

    //onPostExecute方法用于在执行完后台任务后更新UI,显示结果
    @Override
    protected void onPostExecute(String result) {
        Log.i(TAG, &quot;onPostExecute&quot;);
        textView.setText(result);

        execute.setEnabled(true);
        cancel.setEnabled(false);
    }

    //onCancelled方法用于在取消执行中的任务时更改UI
    @Override
    protected void onCancelled() {
        Log.i(TAG, &quot;onCancelled&quot;);
        textView.setText(&quot;cancelled&quot;);
        progressBar.setProgress(0);

        execute.setEnabled(true);
        cancel.setEnabled(false);
    }
}</code></pre><p>说明：<br>(01) textView是一个TextView对象，cancel和execute分别是两个Button按钮，而progressBar则是进度条。<br>(02) 在任务开始时会通过onPreExecute()更新TextView的显示内容。<br>(03) 在任务结束时通过onPreExecute()更新TextView的显示内容。<br>(04) 任务执行过程中会通过publishProgress()更新进度条。<br>(05) 如果任务被强制取消的话，会将进度条重置为0。 </p>
<p>创建并执行AsyncTask的接口如下：</p>
<pre><code>mTask = new MyTask();
mTask.execute(&quot;http://www.baidu.com&quot;);</code></pre><p>取消AsyncTask的接口如下：</p>
<pre><code>mTask.cancel();</code></pre><p>点击查看：<a href="TODO">AsyncTask示例完整原理</a></p>
<p><a name="anchor3"></a></p>
<h1 id="AsyncTask原理"><a href="#AsyncTask原理" class="headerlink" title="AsyncTask原理"></a>AsyncTask原理</h1><p>下面通过Android4.4.2的AsyncTask源码来对AsyncTask原理进行介绍。</p>
<h2 id="1-AsyncTask构造函数"><a href="#1-AsyncTask构造函数" class="headerlink" title="1. AsyncTask构造函数"></a>1. AsyncTask构造函数</h2><pre><code>public AsyncTask() {
    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
        public Result call() throws Exception {
            mTaskInvoked.set(true);

            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            //noinspection unchecked
            return postResult(doInBackground(mParams));
        }
    };

    mFuture = new FutureTask&lt;Result&gt;(mWorker) {
        @Override
        protected void done() {
            try {
                postResultIfNotInvoked(get());
            } catch (InterruptedException e) {
                android.util.Log.w(LOG_TAG, e);
            } catch (ExecutionException e) {
                throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;,
                        e.getCause());
            } catch (CancellationException e) {
                postResultIfNotInvoked(null);
            }
        }
    };
}</code></pre><p>说明：</p>
<p>(01) mWorker是个WorkerRunnable对象，而WorkerRunnable是Callable的实现类。而在”<a href="http://www.cnblogs.com/skywang12345/p/3544116.html" target="_blank" rel="noopener">线程池中关于Callable的介绍</a>“时，我们说过，Callable类似于Runnable接口，不同之处主要在于Callable能和Future配合使用获取任务的结果，而Runnable不能获取结果！<br>(02) mFuture是FutureTask对象，而FutureTask洽洽是Future的实现类。 mWorker和mFuture配合使用，能获取后台任务的结果！  </p>
<h2 id="2-execute"><a href="#2-execute" class="headerlink" title="2. execute"></a>2. execute</h2><p>execute()的源码如下：</p>
<pre><code>public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}</code></pre><p>说明：sDefaultExecutor是线程池对象，而executeOnExecutor()是真正执行后台动作的地方。</p>
<p>下面是线程池相关的代码：</p>
<pre><code>private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE = 1;

public static final Executor THREAD_POOL_EXECUTOR
        = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);

...

public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;

private static class SerialExecutor implements Executor {
    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        if (mActive == null) {
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}</code></pre><p>说明：该线程池是”通过双向队列实现的串行线程池”。scheduleNext()每次只会执行一个任务。</p>
<p>下面看看executeOnExecutor()的代码：</p>
<pre><code>public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
        Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }

    mStatus = Status.RUNNING;

    onPreExecute();

    mWorker.mParams = params;
    exec.execute(mFuture);

    return this;
}</code></pre><p>说明：<br>(01) executeOnExecutor()首先会对任务的状态进行处理。任务共三种姿态：  </p>
<blockquote>
<p>PENDING: 挂起状态。当AsyncTask被创建时，就进入了PENDING状态。<br>RUNNING: 运行状态。当AsyncTask被执行时，就进入了RUNNING状态。<br>FINISHED: 完成状态。当AsyncTask完成(被客户cancel()或正常运行完毕)时，就进入了FINISHED状态。  </p>
</blockquote>
<p>当任务是RUNNING或PENDING状态时，会抛出异常。这就决定了，一个AsyncTask只能被执行一次，即只能对一个AsyncTask调用一次execute()；如果要重新执行任务，则需要新建AsyncTask后再调用execute()。<br>(02) 接着，调用onPreExecute()。这也就是任务执行前的准备动作！<br>(03) 然后，调用exec.execute(mFuture)。作用是将任务提交到线程池中进行执行。线程池的代码前面已经给出，SerialExecutor中的execute()会执行r.run()任务。r.run()实际上是调用FutureTask中run()方法，而FutureTask的run()方法，则会执行Callable的call()函数，即会执行到mWorker的call()方法。而观察前面mWorker的run()方法，我们会发现它会调用doInBackground()接口，并通过postResult()返回任务执行结果。而postResult()的内容如下：   </p>
<pre><code>private static final InternalHandler sHandler = new InternalHandler();

private Result postResult(Result result) {
    @SuppressWarnings(&quot;unchecked&quot;)
    Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,
            new AsyncTaskResult&lt;Result&gt;(this, result));
    message.sendToTarget();
    return result;
}

private static class InternalHandler extends Handler {
    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})
    @Override
    public void handleMessage(Message msg) {
        AsyncTaskResult result = (AsyncTaskResult) msg.obj;
        switch (msg.what) {
            case MESSAGE_POST_RESULT:
                // There is only one result
                result.mTask.finish(result.mData[0]);
                break;
            case MESSAGE_POST_PROGRESS:
                result.mTask.onProgressUpdate(result.mData);
                break;
        }
    }
}</code></pre><p>说明：postResult()会发送MESSAGE_POST_RESULT给sHandler，而sHandler中会将任务执行结果传递给finish()。以下是finish()的代码：</p>
<pre><code>private void finish(Result result) {
    if (isCancelled()) {
        onCancelled(result);
    } else {
        onPostExecute(result);
    }
    mStatus = Status.FINISHED;
}</code></pre><p>说明：如果是正常执行结束，则调用onPostExecute()方法；否则(异常结束)，则调用onCancelled()方法。</p>
<p>至此，AsyncTask的原理结果完毕！总的来说，就是通过线程池来实现的，AsyncTask的任务会提交到线程池中，执行完后，线程池再返回结果。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/23/android/api_guide/app_component/fragment/2014-06-23-DialogFragment/" itemprop="url">Android组件--Fragment(五)之 DialogFragment</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-23T02:25:00.000Z" itemprop="datePublished">6月 23 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            几秒 read (About 22 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>关于DialogFragment的相关内容。请参考：<a href="/2014/06/15/Dialog">android对话框</a></p>
</blockquote>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/23/android/api_guide/app_component/fragment/2014-06-23-SelfDefine-ListPreference/" itemprop="url">Android组件--Fragment(三)之 自定义ListPreference</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-23T01:55:00.000Z" itemprop="datePublished">6月 23 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            10 分钟 read (About 1466 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文介绍自定义ListPreference的相关内容。</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="ListPreference自定义属性"><a href="#ListPreference自定义属性" class="headerlink" title="ListPreference自定义属性"></a>ListPreference自定义属性</h1><p>系统自带的ListPreference的列表中只能显示文本。如果想显示图片或其他内容，只有通过自定义ListPreference的方式。</p>
<p>接下来，将通过示例来演示如何在ListPreference中显示图片。</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/fragment/preference_fragment/02_selfdeine_ListPreference_with_attr" target="_blank" rel="noopener">ListPreference示例的完整代码</a></p>
<h2 id="1-自定义属性"><a href="#1-自定义属性" class="headerlink" title="1. 自定义属性"></a>1. 自定义属性</h2><p>添加文件res/values/attrs.xml，内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;IconListPreference&quot;&gt;
        &lt;attr name=&quot;entryIcons&quot; format=&quot;reference&quot; /&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;</code></pre><p>说明：<br>(01) name=”IconListPreference”，与自定义的ListPreference类的名称相对应。后面会实现一个继承于ListPreference的IconListPreference.java。<br>(02) name=”entryIcons”，这是属性的名称。<br>(03) format=”reference”，这描述属性的值是引用类型。因为，后面会根据资源id设置该属性，所以将属性格式设为reference。如果是颜色，设为format=”color”；如果是布尔类型，format=”boolean”；如果是字符串，设为format=”string”。  </p>
<h2 id="2-自定义ListPreference"><a href="#2-自定义ListPreference" class="headerlink" title="2. 自定义ListPreference"></a>2. 自定义ListPreference</h2><h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><pre><code>public IconListPreference(Context context, AttributeSet attrs) {
    super(context, attrs);
    mContext = context;

    // 获取自定义的属性(attrs.xml中)对应行的TypedArray
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.IconListPreference);
    // 获取entryIcons属性对应的值
    int iconResId = a.getResourceId(R.styleable.IconListPreference_entryIcons, -1);
    if (iconResId != -1) {
        setEntryIcons(iconResId);
    }   

    // 获取Preferece对应的key
    mKey = getKey();
    // 获取SharedPreferences
    mPref = PreferenceManager.getDefaultSharedPreferences(context);
    // 获取SharedPreferences.Editor
    mEditor = mPref.edit();
    // 获取Entry
    // 注意：如果配置文件中没有android:entries属性，则getEntries()为空；
    mEntries = getEntries();
    // 获取Entry对应的值
    // 注意：如果配置文件中没有android:entryValues属性，则getEntries()为空
    mEntryValues = getEntryValues();

    // 获取该ListPreference保存的值
    String value = mPref.getString(mKey, &quot;&quot;);
    mPosition = findIndexOfValue(value);
    // 设置Summary
    if (mPosition!=-1) {
        setSummary(mEntries[mPosition]);
        setIcon(mEntryIcons[mPosition]);
    }   

    a.recycle();</code></pre><p>   }   </p>
<p>说明：<br>(01) 首先，根据obtainStyledAttributes()能获取自定义属性对应的TypedArray对象。<br>(02) 在自定义属性中，entryIcons对应的类名是IconListPreference。因为需要通过”类名”_”属性名”，即IconListPreference_entryIcons的方式来获取资源信息。<br>(03) getKey()是获取Preferece对应的Key。该Key是Preference对象的唯一标识。<br>(04) getEntries()是获取Preferece的Entry数组。<br>(05) getEntryValues()是获取Preferece的Entry对应的值的数组。<br>(06) setSummary()是设置Preferece的summary标题内容。<br>(07) setIcon()是设置Preferece的图标。  </p>
<h3 id="2-2-自定义ListPreference中图片相关代码"><a href="#2-2-自定义ListPreference中图片相关代码" class="headerlink" title="2.2 自定义ListPreference中图片相关代码"></a>2.2 自定义ListPreference中图片相关代码</h3><pre><code>/**
 * 设置图标：icons数组
 */
private void setEntryIcons(int[] entryIcons) {
    mEntryIcons = entryIcons;
}

/**
 * 设置图标：根据icon的id数组
 */
public void setEntryIcons(int entryIconsResId) {
    TypedArray icons = getContext().getResources().obtainTypedArray(entryIconsResId);
    int[] ids = new int[icons.length()];
    for (int i = 0; i &lt; icons.length(); i++)
        ids[i] = icons.getResourceId(i, -1);
    setEntryIcons(ids);
    icons.recycle();
}</code></pre><p>说明：这两个函数是读取图片信息的。</p>
<h3 id="2-3-自定义ListPreference弹出的列表选项"><a href="#2-3-自定义ListPreference弹出的列表选项" class="headerlink" title="2.3 自定义ListPreference弹出的列表选项"></a>2.3 自定义ListPreference弹出的列表选项</h3><pre><code>@Override
protected void onPrepareDialogBuilder(Builder builder) {
    super.onPrepareDialogBuilder(builder);

    IconAdapter adapter = new IconAdapter(mContext);
    builder.setAdapter(adapter, null);
}</code></pre><p>说明：点击ListPreference，会弹出一个列表对话框。通过重写onPrepareDialogBuilder()，我们可以自定义弹出的列表对话框。这里是通过IconAdapter来显示的。</p>
<pre><code>public class IconAdapter extends BaseAdapter{

    private LayoutInflater mInflater;


    public IconAdapter(Context context){
        this.mInflater = LayoutInflater.from(context);
    }
    @Override
    public int getCount() {
        return mEntryIcons.length;
    }

    @Override
    public Object getItem(int arg0) {
        return null;
    }

    @Override
    public long getItemId(int arg0) {
        return 0;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {

        ViewHolder holder = null;
        if (convertView == null) {

            holder = new ViewHolder();

            convertView = mInflater.inflate(R.layout.icon_adapter, parent, false);
            holder.layout = (LinearLayout)convertView.findViewById(R.id.icon_layout);
            holder.img = (ImageView)convertView.findViewById(R.id.icon_img);
            holder.info = (TextView)convertView.findViewById(R.id.icon_info);
            holder.check = (RadioButton)convertView.findViewById(R.id.icon_check);
            convertView.setTag(holder);

        }else {
            holder = (ViewHolder)convertView.getTag();
        }

        holder.img.setBackgroundResource(mEntryIcons[position]);
        holder.info.setText(mEntries[position]);
        holder.check.setChecked(mPosition == position);

        final ViewHolder fholder = holder;
        final int fpos = position;
        convertView.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                v.requestFocus();
                // 选中效果
                fholder.layout.setBackgroundColor(Color.CYAN);

                // 更新mPosition
                mPosition = fpos;
                // 更新Summary
                IconListPreference.this.setSummary(mEntries[fpos]);
                IconListPreference.this.setIcon(mEntryIcons[fpos]);
                // 更新该ListPreference保存的值
                mEditor.putString(mKey, mEntryValues[fpos].toString());
                mEditor.commit();

                // 取消ListPreference设置对话框
                getDialog().dismiss();
            }
        });

        return convertView;
    }

    // ListPreference每一项对应的Layout文件的结构体
    private final class ViewHolder {
        ImageView img;
        TextView info;
        RadioButton check;
        LinearLayout layout;
    }
}</code></pre><p>说明：弹出的列表对话框中的每一项的内容是通过布局icon_adapter.xml来显示的。下面看看icon_adapter.xml的源码。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/icon_layout&quot; 
    android:orientation=&quot;horizontal&quot;
    android:paddingLeft=&quot;6dp&quot;  
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;fill_parent&quot;&gt;


    &lt;ImageView
        android:id=&quot;@+id/icon_img&quot; 
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; 
        android:gravity=&quot;center_vertical&quot;
        android:layout_margin=&quot;4dp&quot;/&gt;

    &lt;TextView
        android:id=&quot;@+id/icon_info&quot; 
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;wrap_content&quot; 
        android:layout_weight=&quot;1&quot;
        android:paddingLeft=&quot;6dp&quot;
        android:layout_gravity=&quot;left|center_vertical&quot;
        android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot; /&gt;

    &lt;RadioButton
        android:id=&quot;@+id/icon_check&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:checked=&quot;false&quot;
        android:layout_gravity=&quot;right|center_vertical&quot;
        android:layout_marginRight=&quot;6dp&quot;/&gt;

&lt;/LinearLayout&gt;</code></pre><p>至此，自定义的ListPreference就算完成了。下面就是如何使用它了。</p>
<h2 id="3-使用该自定义ListPreference"><a href="#3-使用该自定义ListPreference" class="headerlink" title="3. 使用该自定义ListPreference"></a>3. 使用该自定义ListPreference</h2><p>我们是通过PreferenceFragment使用该自定义的ListPreference。</p>
<h3 id="3-1-PreferenceFragment的配置文件"><a href="#3-1-PreferenceFragment的配置文件" class="headerlink" title="3.1 PreferenceFragment的配置文件"></a>3.1 PreferenceFragment的配置文件</h3><p>res/xml/preferences.xml的内容如下：</p>
<pre><code>&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:iconlistpreference=&quot;http://schemas.android.com/apk/res/com.skw.fragmenttest&quot;&gt;

    &lt;!-- 系统默认的ListPreference --&gt;
    &lt;PreferenceCategory
        android:title=&quot;PreferenceCategory A&quot;&gt;

        &lt;!-- 
          (01) android:key是Preferece的id
          (02) android:title是Preferece的大标题
          (03) android:summary是Preferece的小标题
          (04) android:dialogTitle是对话框的标题
          (05) android:defaultValue是默认值
          (06) android:entries是列表中各项的说明
          (07) android:entryValues是列表中各项的值
          --&gt;
        &lt;ListPreference  
            android:key=&quot;list_preference&quot;  
            android:dialogTitle=&quot;Choose font&quot;  
            android:entries=&quot;@array/pref_font_types&quot;  
            android:entryValues=&quot;@array/pref_font_types_values&quot;  
            android:summary=&quot;sans&quot;  
            android:title=&quot;Font&quot; 
            android:defaultValue=&quot;sans&quot;/&gt; 
    &lt;/PreferenceCategory&gt;

    &lt;!-- 自定义的ListPreference --&gt;

    &lt;PreferenceCategory
        android:title=&quot;PreferenceCategory B&quot;&gt;

        &lt;!-- 
          iconlistpreference:entryIcons是自定义的属性
          --&gt;
        &lt;com.skw.fragmenttest.IconListPreference
            android:key=&quot;icon_list_preference&quot;  
            android:dialogTitle=&quot;ChooseIcon&quot;  
            android:entries=&quot;@array/android_versions&quot;
            android:entryValues=&quot;@array/android_version_values&quot;  
            iconlistpreference:entryIcons=&quot;@array/android_version_icons&quot;
            android:icon=&quot;@drawable/cupcake&quot;
            android:summary=&quot;summary_icon_list_preference&quot;
            android:title=&quot;title_icon_list_preference&quot; /&gt; 

    &lt;/PreferenceCategory&gt;

&lt;/PreferenceScreen&gt;</code></pre><p>说明：该配置文件中使用了”系统默认的ListPreference”和”自定义的ListPreference(即IconListPreference)”。<br>注意，<strong>IconListPreference中的”iconlistpreference:entryIcons”属性。前面的”iconlistpreference”与该文件的命名空间表示”xmlns:iconlistpreference=”<a href="http://schemas.android.com/apk/res/com.skw.fragmenttest&quot;中的iconlistpreference一样" target="_blank" rel="noopener">http://schemas.android.com/apk/res/com.skw.fragmenttest&quot;中的iconlistpreference一样</a>! 而entryIcons则是我们自定义的属性名称</strong>。 </p>
<h3 id="3-2-自定义PreferenceFragment的代码"><a href="#3-2-自定义PreferenceFragment的代码" class="headerlink" title="3.2 自定义PreferenceFragment的代码"></a>3.2 自定义PreferenceFragment的代码</h3><pre><code>public class PrefsFragment extends PreferenceFragment {

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        addPreferencesFromResource(R.xml.preferences);
    }

    ...
}</code></pre><h2 id="4-使用PrefsFragment"><a href="#4-使用PrefsFragment" class="headerlink" title="4. 使用PrefsFragment"></a>4. 使用PrefsFragment</h2><p>下面，就可以在Activity中使用该PrefsFragment了。</p>
<h2 id="4-1-使用PrefsFragment的Activity的代码"><a href="#4-1-使用PrefsFragment的Activity的代码" class="headerlink" title="4.1 使用PrefsFragment的Activity的代码"></a>4.1 使用PrefsFragment的Activity的代码</h2><pre><code>public class FragmentTest extends Activity {

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        // 获取FragmentManager
        FragmentManager fragmentManager = getFragmentManager();
        // 获取FragmentTransaction        
        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

        PrefsFragment fragment = new PrefsFragment();
        // 将fragment添加到容器frag_example中
        fragmentTransaction.add(R.id.prefs, fragment);
        fragmentTransaction.commit();
    }   
}</code></pre><h2 id="4-2-使用PrefsFragment的Activity的配置文件"><a href="#4-2-使用PrefsFragment的Activity的配置文件" class="headerlink" title="4.2 使用PrefsFragment的Activity的配置文件"></a>4.2 使用PrefsFragment的Activity的配置文件</h2><p>res/layout/main.xml的内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;fill_parent&quot;
    &gt;

    &lt;FrameLayout
        android:id=&quot;@+id/prefs&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;/&gt;

&lt;/LinearLayout&gt;</code></pre><p><a name="anchor1"></a></p>
<h1 id="ListPreference自定义说明"><a href="#ListPreference自定义说明" class="headerlink" title="ListPreference自定义说明"></a>ListPreference自定义说明</h1><p>如果你想通过提供API的方式，而不是配置属性的方式完成上面的工作。那么，也是可以办到的！</p>
<p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/fragment/preference_fragment/03_selfdeine_ListPreference_plus_api" target="_blank" rel="noopener">修改后的自定义ListPreference源码</a></p>
<p><strong>不过，还是建议采用配置属性的方式！</strong></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2014/06/23/android/api_guide/app_component/fragment/2014-06-23-ListFragment/" itemprop="url">Android组件--Fragment(四)之 ListFragment</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2014-06-23T01:45:00.000Z" itemprop="datePublished">6月 23 2014</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/android/">android</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            5 分钟 read (About 706 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本文介绍ListFragment。</p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="ListFragment简介"><a href="#ListFragment简介" class="headerlink" title="ListFragment简介"></a>ListFragment简介</h1><p>ListFragment继承于Fragment。因此它具有Fragment的特性，能够作为activity中的一部分，目的也是为了使页面设计更加灵活。</p>
<p>相比Fragment，ListFragment的内容是以列表(list)的形式显示的。ListFragment的布局默认包含一个ListView。因此，在ListFragment对应的布局文件中，必须指定一个 android:id 为 “@android:id/list” 的ListView控件! </p>
<h1 id="ListFragment使用示例"><a href="#ListFragment使用示例" class="headerlink" title="ListFragment使用示例"></a>ListFragment使用示例</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/fragment/list_fragment/01_simple" target="_blank" rel="noopener">ListFragment的完整代码</a></p>
<p>下面介绍在Activity中显示ListFragment的步骤。</p>
<h2 id="1-Activity对应的代码"><a href="#1-Activity对应的代码" class="headerlink" title="1. Activity对应的代码"></a>1. Activity对应的代码</h2><pre><code>public class FragmentTest extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }   
}</code></pre><h2 id="2-Activity对应的布局"><a href="#2-Activity对应的布局" class="headerlink" title="2. Activity对应的布局"></a>2. Activity对应的布局</h2><pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;horizontal&quot; &gt;

    &lt;fragment 
        android:name=&quot;com.skw.fragmenttest.MyListFragment&quot;
        android:id=&quot;@+id/myfragment&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;

&lt;/LinearLayout&gt;</code></pre><p>说明：该Activity的布局中只包行了一个Fragment。下面看看MyListFragment的内容。</p>
<h2 id="3-MyListFragment的内容"><a href="#3-MyListFragment的内容" class="headerlink" title="3. MyListFragment的内容"></a>3. MyListFragment的内容</h2><pre><code>public class MyListFragment extends ListFragment {
    private static final String TAG = &quot;##MyListFragment##&quot;;

    private ListView selfList;

    String[] cities = {
         &quot;Shenzhen&quot;,
         &quot;Beijing&quot;,
         &quot;Shanghai&quot;,
         &quot;Guangzhou&quot;,
         &quot;Wuhan&quot;,
         &quot;Tianjing&quot;,
         &quot;Changsha&quot;,
         &quot;Xi&apos;an&quot;,
         &quot;Chongqing&quot;,
         &quot;Guilin&quot;,
    };

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, 
            Bundle savedInstanceState) {
        Log.d(TAG, &quot;onCreateView&quot;);
        return inflater.inflate(R.layout.list_fragment, container, false);
    }


    @Override
    public void onCreate(Bundle savedInstanceState) {
        Log.d(TAG, &quot;onCreate&quot;);
        super.onCreate(savedInstanceState);
        // 设置ListFragment默认的ListView，即@id/android:list
        this.setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), 
                android.R.layout.simple_list_item_1, cities));

    }

    public void onListItemClick(ListView parent, View v, 
            int position, long id) {
        Log.d(TAG, &quot;onListItemClick&quot;);
        Toast.makeText(getActivity(), &quot;You have selected &quot; + cities[position],
                Toast.LENGTH_SHORT).show();
    }    
}</code></pre><p>说明：MyListFragment是自定义的ListFragment。它使用了list_fragment.xml作为布局，并通过android.R.layout.simple_list_item_1显示ListView中的每一项。</p>
<h2 id="4-list-fragment-xml的内容"><a href="#4-list-fragment-xml的内容" class="headerlink" title="4. list_fragment.xml的内容"></a>4. list_fragment.xml的内容</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;!-- ListFragment对应的android:id值固定为&quot;@id/android:list&quot; --&gt;
    &lt;ListView
        android:id=&quot;@id/android:list&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; 
        android:drawSelectorOnTop=&quot;false&quot;
        /&gt;

&lt;/LinearLayout&gt;</code></pre><h1 id="自定义ListFragment"><a href="#自定义ListFragment" class="headerlink" title="自定义ListFragment"></a>自定义ListFragment</h1><p>点击查看：<a href="https://github.com/wangkuiwu/android_applets/tree/master/api_guide/app_components/fragment/list_fragment/02_self_layout" target="_blank" rel="noopener">自定义ListFragment的完整代码</a></p>
<p>“Activity的布局以及代码”和前面一样，这里就不再重复说明。</p>
<h2 id="3-MyListFragment的内容-1"><a href="#3-MyListFragment的内容-1" class="headerlink" title="3. MyListFragment的内容"></a>3. MyListFragment的内容</h2><pre><code>public class MyListFragment extends ListFragment {
    private static final String TAG = &quot;##MyListFragment##&quot;;

    private ListView selfList;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, 
            Bundle savedInstanceState) {
        Log.d(TAG, &quot;onCreateView&quot;);
        return inflater.inflate(R.layout.list_fragment, container, false);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        final String[] from = new String[] {&quot;title&quot;, &quot;info&quot;};
        final int[] to = new int[] {R.id.text1, R.id.text2};

        Log.d(TAG, &quot;onCreate&quot;);
        super.onCreate(savedInstanceState);
        // 建立SimpleAdapter，将from和to对应起来
        SimpleAdapter adapter = new SimpleAdapter(
                this.getActivity(), getSimpleData(), 
                R.layout.item, from, to);
        this.setListAdapter(adapter);
    }

    public void onListItemClick(ListView parent, View v, 
            int position, long id) {
        Log.d(TAG, &quot;onListItemClick&quot;);
        Toast.makeText(getActivity(), 
                &quot;You have selected &quot; + position,
                Toast.LENGTH_SHORT).show();
    }

    private List&lt;Map&lt;String, Object&gt;&gt; getSimpleData() {
        List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();

        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;Ferris wheel&quot;);
        map.put(&quot;info&quot;, &quot;Suzhou Ferris wheel&quot;);
        list.add(map);

        map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;Flower&quot;);
        map.put(&quot;info&quot;, &quot;Roser&quot;);
        list.add(map);

        map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;title&quot;, &quot;Disk&quot;);
        map.put(&quot;info&quot;, &quot;Song Disk&quot;);
        list.add(map);

        return list;
    }
}</code></pre><p>说明：MyListFragment使用了R.layout.list_fragment作为布局，并且对于ListView中的每一项都使用了R.layout.item作为布局。</p>
<h2 id="4-list-fragment-xml的内容-1"><a href="#4-list-fragment-xml的内容-1" class="headerlink" title="4. list_fragment.xml的内容"></a>4. list_fragment.xml的内容</h2><pre><code>&lt;!-- ListFragment对应的android:id值固定为&quot;@id/android:list&quot; --&gt;
&lt;ListView
    android:id=&quot;@id/android:list&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; 
    android:drawSelectorOnTop=&quot;false&quot;
    /&gt;</code></pre><h2 id="5-item-xml的内容"><a href="#5-item-xml的内容" class="headerlink" title="5. item.xml的内容"></a>5. item.xml的内容</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;TextView android:id=&quot;@+id/text1&quot;
        android:textSize=&quot;12sp&quot;
        android:textStyle=&quot;bold&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;/&gt;

    &lt;TextView android:id=&quot;@+id/text2&quot;
        android:textSize=&quot;24sp&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;/&gt;

&lt;/LinearLayout&gt;</code></pre>
    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/tags/android/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/tags/android/page/3/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/tags/android/">1</a></li>
        
        <li><a class="pagination-link is-current" href="/tags/android/page/2/">2</a></li>
        
        <li><a class="pagination-link" href="/tags/android/page/3/">3</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 炸鸡叔&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>