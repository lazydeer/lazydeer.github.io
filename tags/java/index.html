<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Tag: java - PillBlog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta property="og:type" content="website">
<meta property="og:title" content="PillBlog">
<meta property="og:url" content="https://apppills.com/tags/java/index.html">
<meta property="og:site_name" content="PillBlog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PillBlog">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">归档</a>
            
            <a class="navbar-item " href="/about">关于</a>
            
            <a class="navbar-item " href="https://everything.apppills.com">Everything</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#java</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/11/java/threads/2012-08-11-threads-basic/" itemprop="url">Java多线程系列--“基础篇”11之 生产消费者问题</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-11T01:01:00.000Z" itemprop="datePublished">8月 11 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 read (About 672 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章，会对“生产/消费者问题”进行讨论。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. 生产/消费者模型</a><br><a href="#anchor2">2. 生产/消费者实现</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-生产-消费者模型"><a href="#1-生产-消费者模型" class="headerlink" title="1. 生产/消费者模型"></a>1. 生产/消费者模型</h1><p>生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括“生产者”、“消费者”、“仓库”和“产品”。他们之间的关系如下：<br>(01) 生产者仅仅在仓储未满时候生产，仓满则停止生产。<br>(02) 消费者仅仅在仓储有产品时候才能消费，仓空则等待。<br>(03) 当消费者发现仓储没产品可消费时候会通知生产者生产。<br>(04) 生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-生产-消费者实现"><a href="#2-生产-消费者实现" class="headerlink" title="2. 生产/消费者实现"></a>2. 生产/消费者实现</h1><p>下面通过wait()/notify()方式实现该模型(后面在学习了线程池相关内容之后，再通过其它方式实现生产/消费者模型)。源码如下：</p>
<pre><code>// Demo1.java
// 仓库
class Depot {
    private int capacity;    // 仓库的容量
    private int size;        // 仓库的实际数量

    public Depot(int capacity) {
        this.capacity = capacity;
        this.size = 0;
    }

    public synchronized void produce(int val) {
        try {
             // left 表示“想要生产的数量”(有可能生产量太多，需多此生产)
            int left = val;
            while (left &gt; 0) {
                // 库存已满时，等待“消费者”消费产品。
                while (size &gt;= capacity)
                    wait();
                // 获取“实际生产的数量”(即库存中新增的数量)
                // 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库)
                // 否则“实际增量”=“想要生产的数量”
                int inc = (size+left)&gt;capacity ? (capacity-size) : left;
                size += inc;
                left -= inc;
                System.out.printf(&quot;%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\n&quot;, 
                        Thread.currentThread().getName(), val, left, inc, size);
                // 通知“消费者”可以消费了。
                notifyAll();
            }
        } catch (InterruptedException e) {
        }
    } 

    public synchronized void consume(int val) {
        try {
            // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费)
            int left = val;
            while (left &gt; 0) {
                // 库存为0时，等待“生产者”生产产品。
                while (size &lt;= 0)
                    wait();
                // 获取“实际消费的数量”(即库存中实际减少的数量)
                // 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”；
                // 否则，“实际消费量”=“客户要消费的数量”。
                int dec = (size&lt;left) ? size : left;
                size -= dec;
                left -= dec;
                System.out.printf(&quot;%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\n&quot;, 
                        Thread.currentThread().getName(), val, left, dec, size);
                notifyAll();
            }
        } catch (InterruptedException e) {
        }
    }

    public String toString() {
        return &quot;capacity:&quot;+capacity+&quot;, actual size:&quot;+size;
    }
} 

// 生产者
class Producer {
    private Depot depot;

    public Producer(Depot depot) {
        this.depot = depot;
    }

    // 消费产品：新建一个线程向仓库中生产产品。
    public void produce(final int val) {
        new Thread() {
            public void run() {
                depot.produce(val);
            }
        }.start();
    }
}

// 消费者
class Customer {
    private Depot depot;

    public Customer(Depot depot) {
        this.depot = depot;
    }

    // 消费产品：新建一个线程从仓库中消费产品。
    public void consume(final int val) {
        new Thread() {
            public void run() {
                depot.consume(val);
            }
        }.start();
    }
}

public class Demo1 {  
    public static void main(String[] args) {  
        Depot mDepot = new Depot(100);
        Producer mPro = new Producer(mDepot);
        Customer mCus = new Customer(mDepot);

        mPro.produce(60);
        mPro.produce(120);
        mCus.consume(90);
        mCus.consume(150);
        mPro.produce(110);
    }
}</code></pre><p>说明：<br>(01) Producer是“生产者”类，它与“仓库(depot)”关联。当调用“生产者”的produce()方法时，它会新建一个线程并向“仓库”中生产产品。<br>(02) Customer是“消费者”类，它与“仓库(depot)”关联。当调用“消费者”的consume()方法时，它会新建一个线程并消费“仓库”中的产品。<br>(03) Depot是“仓库”类，仓库中记录“仓库的容量(capacity)”以及“仓库中当前产品数目(size)”。<br>&nbsp;&nbsp;&nbsp;&nbsp; “仓库”类的生产方法produce()和消费方法consume()方法都是synchronized方法，进入synchronized方法体，意味着这个线程获取到了该“仓库”对象的同步锁。这也就是说，同一时间，生产者和消费者线程只能有一个能运行。通过同步锁，实现了对“残酷”的互斥访问。<br>&nbsp;&nbsp;&nbsp;&nbsp; 对于生产方法produce()而言：当仓库满时，生产者线程等待，需要等待消费者消费产品之后，生产线程才能生产；生产者线程生产完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“消费者线程”，即我们所说的“通知消费者进行消费”。<br>&nbsp;&nbsp;&nbsp;&nbsp; 对于消费方法consume()而言：当仓库为空时，消费者线程等待，需要等待生产者生产产品之后，消费者线程才能消费；消费者线程消费完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“生产者线程”，即我们所说的“通知生产者进行生产”。</p>
<p>(某一次)运行结果：</p>
<pre><code>Thread-0 produce( 60) --&gt; left=  0, inc= 60, size= 60
Thread-4 produce(110) --&gt; left= 70, inc= 40, size=100
Thread-2 consume( 90) &lt;-- left=  0, dec= 90, size= 10
Thread-3 consume(150) &lt;-- left=140, dec= 10, size=  0
Thread-1 produce(120) --&gt; left= 20, inc=100, size=100
Thread-3 consume(150) &lt;-- left= 40, dec=100, size=  0
Thread-4 produce(110) --&gt; left=  0, inc= 70, size= 70
Thread-3 consume(150) &lt;-- left=  0, dec= 40, size= 30
Thread-1 produce(120) --&gt; left=  0, inc= 20, size= 50</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/10/java/threads/2012-08-10-threads-basic/" itemprop="url">Java多线程系列--“基础篇”10之 线程优先级和守护线程</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-10T01:01:00.000Z" itemprop="datePublished">8月 10 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 read (About 1247 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章，会对守护线程和线程优先级进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. 线程优先级的介绍</a><br><a href="#anchor2">2. 线程优先级的示例</a><br><a href="#anchor3">3. 守护线程的示例</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-线程优先级的介绍"><a href="#1-线程优先级的介绍" class="headerlink" title="1. 线程优先级的介绍"></a>1. 线程优先级的介绍</h1><p>java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。</p>
<p>java 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。<br>用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。</p>
<p>JDK 中关于线程优先级和守护线程的介绍如下：</p>
<blockquote>
<p>Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.<br>When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:<br>The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.<br>All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method.<br>Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.</p>
</blockquote>
<p>大致意思是：</p>
<p>每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。</p>
<p>当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：<br>(01) 调用了exit()方法，并且exit()有权限被正常执行。<br>(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。  </p>
<p>每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-线程优先级的示例"><a href="#2-线程优先级的示例" class="headerlink" title="2. 线程优先级的示例"></a>2. 线程优先级的示例</h1><p>我们先看看优先级的示例 </p>
<pre><code>class MyThread extends Thread{
    public MyThread(String name) {
        super(name);
    }

    public void run(){
        for (int i=0; i&lt;5; i++) {
            System.out.println(Thread.currentThread().getName()
                    +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;
                    +&quot;, loop &quot;+i);
        }
    } 
}; 

public class Demo {  
    public static void main(String[] args) {  

        System.out.println(Thread.currentThread().getName()
                +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;);

        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1
        Thread t2=new MyThread(&quot;t2&quot;);    // 新建t2
        t1.setPriority(1);                // 设置t1的优先级为1
        t2.setPriority(10);                // 设置t2的优先级为10
        t1.start();                        // 启动t1
        t2.start();                        // 启动t2
    }  
}</code></pre><p>运行结果：</p>
<pre><code>main(5)
t1(1), loop 0
t2(10), loop 0
t1(1), loop 1
t2(10), loop 1
t1(1), loop 2
t2(10), loop 2
t1(1), loop 3
t2(10), loop 3
t1(1), loop 4
t2(10), loop 4</code></pre><p>结果说明：<br>(01) 主线程main的优先级是5。<br>(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-守护线程的示例"><a href="#3-守护线程的示例" class="headerlink" title="3. 守护线程的示例"></a>3. 守护线程的示例</h1><p>下面是守护线程的示例。</p>
<pre><code>// Demo.java
class MyThread extends Thread{
    public MyThread(String name) {
        super(name);
    }

    public void run(){
        try {
            for (int i=0; i&lt;5; i++) {
                Thread.sleep(3);
                System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; +&quot;, loop &quot;+i);
            }
        } catch (InterruptedException e) {
        }
    } 
}; 

class MyDaemon extends Thread{  
    public MyDaemon(String name) {
        super(name);
    }

    public void run(){
        try {
            for (int i=0; i&lt;10000; i++) {
                Thread.sleep(1);
                System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; +&quot;, loop &quot;+i);
            }
        } catch (InterruptedException e) {
        }
    } 
}
public class Demo {  
    public static void main(String[] args) {  

        System.out.println(Thread.currentThread().getName()
                +&quot;(isDaemon=&quot;+Thread.currentThread().isDaemon()+ &quot;)&quot;);

        Thread t1=new MyThread(&quot;t1&quot;);    // 新建t1
        Thread t2=new MyDaemon(&quot;t2&quot;);    // 新建t2
        t2.setDaemon(true);                // 设置t2为守护线程
        t1.start();                        // 启动t1
        t2.start();                        // 启动t2
    }  
}</code></pre><p>运行结果：</p>
<pre><code>main(isDaemon=false)
t2(isDaemon=true), loop 0
t2(isDaemon=true), loop 1
t1(isDaemon=false), loop 0
t2(isDaemon=true), loop 2
t2(isDaemon=true), loop 3
t1(isDaemon=false), loop 1
t2(isDaemon=true), loop 4
t2(isDaemon=true), loop 5
t2(isDaemon=true), loop 6
t1(isDaemon=false), loop 2
t2(isDaemon=true), loop 7
t2(isDaemon=true), loop 8
t2(isDaemon=true), loop 9
t1(isDaemon=false), loop 3
t2(isDaemon=true), loop 10
t2(isDaemon=true), loop 11
t1(isDaemon=false), loop 4
t2(isDaemon=true), loop 12</code></pre><p>结果说明：<br>(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。<br>(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/09/java/threads/2012-08-09-threads-basic/" itemprop="url">Java多线程系列--“基础篇”09之 interrupt()和线程终止方式</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-09T01:01:00.000Z" itemprop="datePublished">8月 9 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 分钟 read (About 2800 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章，会对线程的interrupt()中断和终止方式进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. interrupt()说明</a><br><a href="#anchor2">2. 终止线程的方式</a><br>&nbsp;&nbsp;&nbsp;&nbsp; <a href="#anchor2_1">2.1 终止处于“阻塞状态”的线程</a><br>&nbsp;&nbsp;&nbsp;&nbsp; <a href="#anchor2_2">2.2 终止处于“运行状态”的线程</a><br><a href="#anchor3">3. 终止线程的示例</a><br><a href="#anchor4">4. interrupted() 和 isInterrupted()的区别</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-interrupt-说明"><a href="#1-interrupt-说明" class="headerlink" title="1. interrupt()说明"></a>1. interrupt()说明</h1><p>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。<br>关于interrupt()，java的djk文档描述如下：<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/</a></p>
<blockquote>
<p>Interrupts this thread.<br>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</p>
</blockquote>
<blockquote>
<p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p>
</blockquote>
<blockquote>
<p>If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException.</p>
</blockquote>
<blockquote>
<p>If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.</p>
</blockquote>
<blockquote>
<p>If none of the previous conditions hold then this thread’s interrupt status will be set.</p>
</blockquote>
<blockquote>
<p>Interrupting a thread that is not alive need not have any effect.</p>
</blockquote>
<p>大致意思是：</p>
<blockquote>
<p>interrupt()的作用是中断本线程。<br>本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。</p>
</blockquote>
<blockquote>
<p>如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。<br>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。<br>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。<br>中断一个“已终止的线程”不会产生任何操作。</p>
</blockquote>
<p><a name="anchor2"></a></p>
<h1 id="2-终止线程的方式"><a href="#2-终止线程的方式" class="headerlink" title="2. 终止线程的方式"></a>2. 终止线程的方式</h1><p>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！<br>下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。</p>
<p><a name="anchor2_1"></a></p>
<h2 id="2-1-终止处于“阻塞状态”的线程"><a href="#2-1-终止处于“阻塞状态”的线程" class="headerlink" title="2.1 终止处于“阻塞状态”的线程"></a>2.1 终止处于“阻塞状态”的线程</h2><p>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。<br>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下：</p>
<pre><code>@Override
public void run() {
    try {
        while (true) {
            // 执行任务...
        }
    } catch (InterruptedException ie) {  
        // 由于产生InterruptedException异常，退出while(true)循环，线程终止！
    }
}</code></pre><p>说明：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！<br>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：</p>
<pre><code>@Override
public void run() {
    while (true) {
        try {
            // 执行任务...
        } catch (InterruptedException ie) {  
            // InterruptedException在while(true)循环体内。
            // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出
            break;
        }
    }
}</code></pre><p>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。</p>
<p><a name="anchor2_2"></a></p>
<h2 id="2-2-终止处于“运行状态”的线程"><a href="#2-2-终止处于“运行状态”的线程" class="headerlink" title="2.2 终止处于“运行状态”的线程"></a>2.2 终止处于“运行状态”的线程</h2><p>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。</p>
<p><strong>(01) 通过“中断标记”终止线程。</strong><br>形式如下：</p>
<pre><code>@Override
public void run() {
    while (!isInterrupted()) {
        // 执行任务...
    }
}</code></pre><p>说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。<br>注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。</p>
<p><strong>(02) 通过“额外添加标记”。</strong><br>形式如下：</p>
<pre><code>private volatile boolean flag= true;
protected void stopTask() {
    flag = false;
}

@Override
public void run() {
    while (flag) {
        // 执行任务...
    }
}</code></pre><p>说明：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。<br>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</p>
<p>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：</p>
<pre><code>@Override
public void run() {
    try {
        // 1. isInterrupted()保证，只要中断标记为true就终止线程。
        while (!isInterrupted()) {
            // 执行任务...
        }
    } catch (InterruptedException ie) {  
        // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。
    }
}</code></pre><p><a name="anchor3"></a></p>
<h1 id="3-终止线程的示例"><a href="#3-终止线程的示例" class="headerlink" title="3. 终止线程的示例"></a>3. 终止线程的示例</h1><p>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：</p>
<pre><code>// Demo1.java的源码
class MyThread extends Thread {

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        try {  
            int i=0;
            while (!isInterrupted()) {
                Thread.sleep(100); // 休眠100ms
                i++;
                System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  
            }
        } catch (InterruptedException e) {  
            System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  
        }
    }
}

public class Demo1 {

    public static void main(String[] args) {  
        try {  
            Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  

            t1.start();                      // 启动“线程t1”
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  

            // 主线程休眠300ms，然后主线程给t1发“中断”指令。
            Thread.sleep(300);
            t1.interrupt();
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);

            // 主线程休眠300ms，然后查看t1的状态。
            Thread.sleep(300);
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);
        } catch (InterruptedException e) {  
            e.printStackTrace();
        }
    } 
}</code></pre><p>运行结果：</p>
<pre><code>t1 (NEW) is new.
t1 (RUNNABLE) is started.
t1 (RUNNABLE) loop 1
t1 (RUNNABLE) loop 2
t1 (TIMED_WAITING) is interrupted.
t1 (RUNNABLE) catch InterruptedException.
t1 (TERMINATED) is interrupted now.</code></pre><p>结果说明：<br>(01) 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。<br>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。<br>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。</p>
<p>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。</p>
<pre><code>// Demo2.java的源码
class MyThread extends Thread {

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        int i=0;
        while (!isInterrupted()) {
            try {
                Thread.sleep(100); // 休眠100ms
            } catch (InterruptedException ie) {  
                System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  
            }
            i++;
            System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  
        }
    }
}

public class Demo2 {

    public static void main(String[] args) {  
        try {  
            Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  

            t1.start();                      // 启动“线程t1”
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  

            // 主线程休眠300ms，然后主线程给t1发“中断”指令。
            Thread.sleep(300);
            t1.interrupt();
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);

            // 主线程休眠300ms，然后查看t1的状态。
            Thread.sleep(300);
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);
        } catch (InterruptedException e) {  
            e.printStackTrace();
        }
    } 
}</code></pre><p>运行结果：</p>
<pre><code>t1 (NEW) is new.
t1 (RUNNABLE) is started.
t1 (RUNNABLE) loop 1
t1 (RUNNABLE) loop 2
t1 (TIMED_WAITING) is interrupted.
t1 (RUNNABLE) catch InterruptedException.
t1 (RUNNABLE) loop 3
t1 (RUNNABLE) loop 4
t1 (RUNNABLE) loop 5
t1 (TIMED_WAITING) is interrupted now.
t1 (RUNNABLE) loop 6
t1 (RUNNABLE) loop 7
t1 (RUNNABLE) loop 8
t1 (RUNNABLE) loop 9
...</code></pre><p>结果说明：<br>程序进入了死循环！<br>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。<br>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。</p>
<p>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：</p>
<pre><code>// Demo3.java的源码
class MyThread extends Thread {

    private volatile boolean flag= true;
    public void stopTask() {
        flag = false;
    }

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        synchronized(this) {
            try {
                int i=0;
                while (flag) {
                    Thread.sleep(100); // 休眠100ms
                    i++;
                    System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i);  
                }
            } catch (InterruptedException ie) {  
                System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;);  
            }
        }  
    }
}

public class Demo3 {

    public static void main(String[] args) {  
        try {  
            MyThread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);  

            t1.start();                      // 启动“线程t1”
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);  

            // 主线程休眠300ms，然后主线程给t1发“中断”指令。
            Thread.sleep(300);
            t1.stopTask();
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);

            // 主线程休眠300ms，然后查看t1的状态。
            Thread.sleep(300);
            System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);
        } catch (InterruptedException e) {  
            e.printStackTrace();
        }
    } 
}</code></pre><p>运行结果：</p>
<pre><code>t1 (NEW) is new.
t1 (RUNNABLE) is started.
t1 (RUNNABLE) loop 1
t1 (RUNNABLE) loop 2
t1 (TIMED_WAITING) is interrupted.
t1 (RUNNABLE) loop 3
t1 (TERMINATED) is interrupted now.</code></pre><p><a name="anchor4"></a></p>
<h1 id="4-interrupted-和-isInterrupted-的区别"><a href="#4-interrupted-和-isInterrupted-的区别" class="headerlink" title="4. interrupted() 和 isInterrupted()的区别"></a>4. interrupted() 和 isInterrupted()的区别</h1><p>最后谈谈 interrupted() 和 isInterrupted()。<br>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。<br>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/08/java/threads/2012-08-08-threads-basic/" itemprop="url">Java多线程系列--“基础篇”08之 join()</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-08T01:01:00.000Z" itemprop="datePublished">8月 8 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 read (About 987 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章，会对Thread中join()方法进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. join()介绍</a><br><a href="#anchor2">2. join()源码分析(基于JDK1.7.0_40)</a><br><a href="#anchor3">3. join()示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-join-介绍"><a href="#1-join-介绍" class="headerlink" title="1. join()介绍"></a>1. join()介绍</h1><p>join() 定义在Thread.java中。</p>
<p>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：</p>
<pre><code>// 主线程
public class Father extends Thread {
    public void run() {
        Son s = new Son();
        s.start();
        s.join();
        ...
    }
}
// 子线程
public class Son extends Thread {
    public void run() {
        ...
    }
}</code></pre><p>说明：<br>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。<br>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！</p>
<p><a name="anchor2"></a></p>
<h1 id="2-join-源码分析-基于JDK1-7-0-40"><a href="#2-join-源码分析-基于JDK1-7-0-40" class="headerlink" title="2. join()源码分析(基于JDK1.7.0_40)"></a>2. join()源码分析(基于JDK1.7.0_40)</h1><pre><code>public final void join() throws InterruptedException {
    join(0);
}

public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay &lt;= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}</code></pre><p>说明：<br>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；即只要子线程是活的，主线程就不停的等待。<br>我们根据上面解释join()作用时的代码来理解join()的用法！</p>
<p><strong>问题</strong>：虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让”子线程等待才对(因为调用子线程对象s的wait方法嘛)”？</p>
<p><strong>答案</strong>：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！</p>
<p><a name="anchor3"></a></p>
<h1 id="3-join-示例"><a href="#3-join-示例" class="headerlink" title="3. join()示例"></a>3. join()示例</h1><p>在理解join()的作用之后，接下来通过示例查看join()的用法。</p>
<pre><code>// JoinTest.java的源码
public class JoinTest{

    public static void main(String[] args){ 
        try {
            ThreadA t1 = new ThreadA(&quot;t1&quot;); // 新建“线程t1”

            t1.start();                     // 启动“线程t1”
            t1.join();                        // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”
            System.out.printf(&quot;%s finish\n&quot;, Thread.currentThread().getName()); 
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    } 

    static class ThreadA extends Thread{

        public ThreadA(String name){ 
            super(name); 
        } 
        public void run(){ 
            System.out.printf(&quot;%s start\n&quot;, this.getName()); 

            // 延时操作
            for(int i=0; i &lt;1000000; i++)
               ;

            System.out.printf(&quot;%s finish\n&quot;, this.getName()); 
        } 
    } 
}</code></pre><p>运行结果：</p>
<pre><code>t1 start
t1 finish
main finish</code></pre><p>结果说明：<br>运行流程如图<br>(01) 在“主线程main”中通过 new ThreadA(“t1”) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。<br>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。  </p>
<p><img src="/media/pic/java/threads/basic08.png" alt="img"></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/07/java/threads/2012-08-07-threads-basic/" itemprop="url">Java多线程系列--“基础篇”07之 线程休眠</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-07T01:01:00.000Z" itemprop="datePublished">8月 7 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            5 分钟 read (About 787 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章，会对Thread中sleep()方法进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. sleep()介绍</a><br><a href="#anchor2">2. sleep()示例</a><br><a href="#anchor3">3. sleep() 与 wait()的比较</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-sleep-介绍"><a href="#1-sleep-介绍" class="headerlink" title="1. sleep()介绍"></a>1. sleep()介绍</h1><p>sleep() 定义在Thread.java中。</p>
<p>sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-sleep-示例"><a href="#2-sleep-示例" class="headerlink" title="2. sleep()示例"></a>2. sleep()示例</h1><p>下面通过一个简单示例演示sleep()的用法。</p>
<pre><code>// SleepTest.java的源码
class ThreadA extends Thread{
    public ThreadA(String name){ 
        super(name); 
    } 
    public synchronized void run() { 
        try {
            for(int i=0; i &lt;10; i++){ 
                System.out.printf(&quot;%s: %d\n&quot;, this.getName(), i); 
                // i能被4整除时，休眠100毫秒
                if (i%4 == 0)
                    Thread.sleep(100);
            } 
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    } 
} 

public class SleepTest{ 
    public static void main(String[] args){ 
        ThreadA t1 = new ThreadA(&quot;t1&quot;); 
        t1.start(); 
    } 
} </code></pre><p>运行结果：</p>
<pre><code>t1: 0
t1: 1
t1: 2
t1: 3
t1: 4
t1: 5
t1: 6
t1: 7
t1: 8
t1: 9</code></pre><p>结果说明：<br>程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-sleep-与-wait-的比较"><a href="#3-sleep-与-wait-的比较" class="headerlink" title="3. sleep() 与 wait()的比较"></a>3. sleep() 与 wait()的比较</h1><p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。<br>但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。</p>
<p>下面通过示例演示sleep()是不会释放锁的。</p>
<pre><code>// SleepLockTest.java的源码
public class SleepLockTest{ 

    private static Object obj = new Object();

    public static void main(String[] args){ 
        ThreadA t1 = new ThreadA(&quot;t1&quot;); 
        ThreadA t2 = new ThreadA(&quot;t2&quot;); 
        t1.start(); 
        t2.start();
    } 

    static class ThreadA extends Thread{
        public ThreadA(String name){ 
            super(name); 
        } 
        public void run(){ 
            // 获取obj对象的同步锁
            synchronized (obj) {
                try {
                    for(int i=0; i &lt;10; i++){ 
                        System.out.printf(&quot;%s: %d\n&quot;, this.getName(), i); 
                        // i能被4整除时，休眠100毫秒
                        if (i%4 == 0)
                            Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        } 
    } 
} </code></pre><p>运行结果：</p>
<pre><code>t1: 0
t1: 1
t1: 2
t1: 3
t1: 4
t1: 5
t1: 6
t1: 7
t1: 8
t1: 9
t2: 0
t2: 1
t2: 2
t2: 3
t2: 4
t2: 5
t2: 6
t2: 7
t2: 8
t2: 9</code></pre><p>结果说明：<br>主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！</p>
<p>注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。下面是注释调synchronized(obj) 之后的源码：</p>
<pre><code>// SleepLockTest.java的源码(注释掉synchronized(obj))
public class SleepLockTest{ 

    private static Object obj = new Object();

    public static void main(String[] args){ 
        ThreadA t1 = new ThreadA(&quot;t1&quot;); 
        ThreadA t2 = new ThreadA(&quot;t2&quot;); 
        t1.start(); 
        t2.start();
    } 

    static class ThreadA extends Thread{
        public ThreadA(String name){ 
            super(name); 
        } 
        public void run(){ 
            // 获取obj对象的同步锁
//            synchronized (obj) {
                try {
                    for(int i=0; i &lt;10; i++){ 
                        System.out.printf(&quot;%s: %d\n&quot;, this.getName(), i); 
                        // i能被4整除时，休眠100毫秒
                        if (i%4 == 0)
                            Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
//            }
        } 
    } 
} </code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/06/java/threads/2012-08-06-threads-basic/" itemprop="url">Java多线程系列--“基础篇”06之 线程让步</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-06T01:01:00.000Z" itemprop="datePublished">8月 6 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            5 分钟 read (About 786 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章，会对Thread中的线程让步方法yield()进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. yield()介绍</a><br><a href="#anchor2">2. yield()示例</a><br><a href="#anchor3">3. yield() 与 wait()的比较</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-yield-介绍"><a href="#1-yield-介绍" class="headerlink" title="1. yield()介绍"></a>1. yield()介绍</h1><p>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p>
<p><a name="anchor2"></a></p>
<h1 id="2-yield-示例"><a href="#2-yield-示例" class="headerlink" title="2. yield()示例"></a>2. yield()示例</h1><p>下面，通过示例查看它的用法。</p>
<pre><code>// YieldTest.java的源码
class ThreadA extends Thread{
    public ThreadA(String name){ 
        super(name); 
    } 
    public synchronized void run(){ 
        for(int i=0; i &lt;10; i++){ 
            System.out.printf(&quot;%s [%d]:%d\n&quot;, this.getName(), this.getPriority(), i); 
            // i整除4时，调用yield
            if (i%4 == 0)
                Thread.yield();
        } 
    } 
} 

public class YieldTest{ 
    public static void main(String[] args){ 
        ThreadA t1 = new ThreadA(&quot;t1&quot;); 
        ThreadA t2 = new ThreadA(&quot;t2&quot;); 
        t1.start(); 
        t2.start();
    } 
} </code></pre><p>(某一次的)运行结果:</p>
<pre><code>t1 [5]:0
t2 [5]:0
t1 [5]:1
t1 [5]:2
t1 [5]:3
t1 [5]:4
t1 [5]:5
t1 [5]:6
t1 [5]:7
t1 [5]:8
t1 [5]:9
t2 [5]:1
t2 [5]:2
t2 [5]:3
t2 [5]:4
t2 [5]:5
t2 [5]:6
t2 [5]:7
t2 [5]:8
t2 [5]:9</code></pre><p>结果说明：<br>“线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-yield-与-wait-的比较"><a href="#3-yield-与-wait-的比较" class="headerlink" title="3. yield() 与 wait()的比较"></a>3. yield() 与 wait()的比较</h1><p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：<br>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。<br>(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p>
<p>下面通过示例演示yield()是不会释放锁的。</p>
<pre><code>// YieldLockTest.java 的源码
public class YieldLockTest{ 

    private static Object obj = new Object();

    public static void main(String[] args){ 
        ThreadA t1 = new ThreadA(&quot;t1&quot;); 
        ThreadA t2 = new ThreadA(&quot;t2&quot;); 
        t1.start(); 
        t2.start();
    } 

    static class ThreadA extends Thread{
        public ThreadA(String name){ 
            super(name); 
        } 
        public void run(){ 
            // 获取obj对象的同步锁
            synchronized (obj) {
                for(int i=0; i &lt;10; i++){ 
                    System.out.printf(&quot;%s [%d]:%d\n&quot;, this.getName(), this.getPriority(), i); 
                    // i整除4时，调用yield
                    if (i%4 == 0)
                        Thread.yield();
                }
            }
        } 
    } 
} </code></pre><p>(某一次)运行结果：</p>
<pre><code>t1 [5]:0
t1 [5]:1
t1 [5]:2
t1 [5]:3
t1 [5]:4
t1 [5]:5
t1 [5]:6
t1 [5]:7
t1 [5]:8
t1 [5]:9
t2 [5]:0
t2 [5]:1
t2 [5]:2
t2 [5]:3
t2 [5]:4
t2 [5]:5
t2 [5]:6
t2 [5]:7
t2 [5]:8
t2 [5]:9</code></pre><p>结果说明：<br>主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/05/java/threads/2012-08-05-threads-basic/" itemprop="url">Java多线程系列--“基础篇”05之 线程等待与唤醒</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-05T01:01:00.000Z" itemprop="datePublished">8月 5 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 分钟 read (About 2813 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章，会对线程等待/唤醒方法进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. wait(), notify(), notifyAll()等方法介绍</a><br><a href="#anchor2">2. wait()和notify()示例</a><br><a href="#anchor3">3. wait(long timeout)和notify()</a><br><a href="#anchor4">4. wait() 和 notifyAll()</a><br><a href="#anchor5">5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-wait-notify-notifyAll-等方法介绍"><a href="#1-wait-notify-notifyAll-等方法介绍" class="headerlink" title="1. wait(), notify(), notifyAll()等方法介绍"></a>1. wait(), notify(), notifyAll()等方法介绍</h1><p>在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p>
<p>Object类中关于等待/唤醒的API详细信息如下：</p>
<table>
<thead>
<tr>
<th>API接口</th>
<th>API说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>notify()</strong></td>
<td>唤醒在此对象监视器上等待的单个线程。</td>
</tr>
<tr>
<td><strong>notifyAll()</strong></td>
<td>唤醒在此对象监视器上等待的所有线程。</td>
</tr>
<tr>
<td><strong>wait()</strong></td>
<td>让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。</td>
</tr>
<tr>
<td><strong>wait(long timeout)</strong></td>
<td>让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</td>
</tr>
<tr>
<td><strong>wait(long timeout, int nanos)</strong></td>
<td>让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</td>
</tr>
</tbody></table>
<p><a name="anchor2"></a></p>
<h1 id="2-wait-和notify-示例"><a href="#2-wait-和notify-示例" class="headerlink" title="2. wait()和notify()示例"></a>2. wait()和notify()示例</h1><p>下面通过示例演示”wait()和notify()配合使用的情形”。</p>
<pre><code>// WaitTest.java的源码
class ThreadA extends Thread{

    public ThreadA(String name) {
        super(name);
    }

    public void run() {
        synchronized (this) {
            System.out.println(Thread.currentThread().getName()+&quot; call notify()&quot;);
            // 唤醒当前的wait线程
            notify();
        }
    }
}

public class WaitTest {

    public static void main(String[] args) {

        ThreadA t1 = new ThreadA(&quot;t1&quot;);

        synchronized(t1) {
            try {
                // 启动“线程t1”
                System.out.println(Thread.currentThread().getName()+&quot; start t1&quot;);
                t1.start();

                // 主线程等待t1通过notify()唤醒。
                System.out.println(Thread.currentThread().getName()+&quot; wait()&quot;);
                t1.wait();

                System.out.println(Thread.currentThread().getName()+&quot; continue&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre><p>运行结果:</p>
<pre><code>main start t1
main wait()
t1 call notify()
main continue</code></pre><p>结果说明：<br>如下图，说明了“主线程”和“线程t1”的流程。<br>(01) 注意，图中”主线程” 代表“主线程main”。”线程t1” 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) “主线程”通过 new ThreadA(“t1”) 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。<br>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。<br>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。<br>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。</p>
<p><img src="/media/pic/java/threads/basic05-01.png" alt="img"></p>
<p>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？<br>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：</p>
<blockquote>
<p>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.<br>In other words, this method behaves exactly as if it simply performs the call wait(0).<br>The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.</p>
</blockquote>
<p>中文意思大概是：</p>
<p><em>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。</em><br><em>“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。</em></p>
<p>注意：<strong>jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！</strong><br>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！</p>
<p><a name="anchor3"></a></p>
<h1 id="3-wait-long-timeout-和notify"><a href="#3-wait-long-timeout-和notify" class="headerlink" title="3. wait(long timeout)和notify()"></a>3. wait(long timeout)和notify()</h1><p>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
<p>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。</p>
<pre><code>// WaitTimeoutTest.java的源码
class ThreadA extends Thread{

    public ThreadA(String name) {
        super(name);
    }

    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot; run &quot;);
        // 死循环，不断运行。
        while(true)
            ;
    }
}

public class WaitTimeoutTest {

    public static void main(String[] args) {

        ThreadA t1 = new ThreadA(&quot;t1&quot;);

        synchronized(t1) {
            try {
                // 启动“线程t1”
                System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;);
                t1.start();

                // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。
                System.out.println(Thread.currentThread().getName() + &quot; call wait &quot;);
                t1.wait(3000);

                System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>main start t1
main call wait 
t1 run                  // 大约3秒之后...输出“main continue”
main continue</code></pre><p>结果说明：<br>如下图，说明了“主线程”和“线程t1”的流程。<br>(01) 注意，图中”主线程” 代表WaitTimeoutTest主线程(即，线程main)。”线程t1” 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) 主线程main执行t1.start()启动“线程t1”。<br>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。<br>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。<br>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。</p>
<p><img src="/media/pic/java/threads/basic05-02.png" alt="img"></p>
<p><a name="anchor4"></a></p>
<h1 id="4-wait-和-notifyAll"><a href="#4-wait-和-notifyAll" class="headerlink" title="4. wait() 和 notifyAll()"></a>4. wait() 和 notifyAll()</h1><p>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。</p>
<p>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。</p>
<pre><code>public class NotifyAllTest {

    private static Object obj = new Object();
    public static void main(String[] args) {

        ThreadA t1 = new ThreadA(&quot;t1&quot;);
        ThreadA t2 = new ThreadA(&quot;t2&quot;);
        ThreadA t3 = new ThreadA(&quot;t3&quot;);
        t1.start();
        t2.start();
        t3.start();

        try {
            System.out.println(Thread.currentThread().getName()+&quot; sleep(3000)&quot;);
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        synchronized(obj) {
            // 主线程等待唤醒。
            System.out.println(Thread.currentThread().getName()+&quot; notifyAll()&quot;);
            obj.notifyAll();
        }
    }

    static class ThreadA extends Thread{

        public ThreadA(String name){
            super(name);
        }

        public void run() {
            synchronized (obj) {
                try {
                    // 打印输出结果
                    System.out.println(Thread.currentThread().getName() + &quot; wait&quot;);

                    // 唤醒当前的wait线程
                    obj.wait();

                    // 打印输出结果
                    System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>t1 wait
main sleep(3000)
t3 wait
t2 wait
main notifyAll()
t2 continue
t3 continue
t1 continue</code></pre><p>结果说明：<br>参考下面的流程图。<br>(01) 主线程中新建并且启动了3个线程”t1”, “t2”和”t3”。<br>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设”t1”, “t2”和”t3”这3个线程都运行了。以”t1”为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，”t2”和”t3”也会等待其它线程通过nofity()或nofityAll()来唤醒它们。<br>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒”t1”, “t2”和”t3”这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，”t1”, “t2”和”t3”就可以获取“obj锁”而继续运行了！</p>
<p><img src="/media/pic/java/threads/basic05-03.png" alt="img"></p>
<p><a name="anchor5"></a></p>
<h1 id="5-为什么notify-wait-等函数定义在Object中，而不是Thread中"><a href="#5-为什么notify-wait-等函数定义在Object中，而不是Thread中" class="headerlink" title="5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中"></a>5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中</h1><p>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。</p>
<p>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！<br>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。</p>
<p>负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>
<p>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/04/java/threads/2012-08-04-threads-basic/" itemprop="url">Java多线程系列--“基础篇”04之 synchronized关键字</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-04T01:01:00.000Z" itemprop="datePublished">8月 4 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            25 分钟 read (About 3702 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章，会对synchronized关键字进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. synchronized原理</a><br><a href="#anchor2">2. synchronized基本规则</a><br><a href="#anchor3">3. synchronized方法 和 synchronized代码块</a><br><a href="#anchor4">4. 实例锁 和 全局锁</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-synchronized原理"><a href="#1-synchronized原理" class="headerlink" title="1. synchronized原理"></a>1. synchronized原理</h1><p>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。</p>
<p>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。</p>
<p>不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-synchronized基本规则"><a href="#2-synchronized基本规则" class="headerlink" title="2. synchronized基本规则"></a>2. synchronized基本规则</h1><p>我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。</p>
<p><strong>第一条</strong>: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。<br><strong>第二条</strong>: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。<br><strong>第三条</strong>: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p>
<h2 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。<br>下面是“synchronized代码块”对应的演示程序。</p>
<pre><code>class MyRunable implements Runnable {

    @Override
    public void run() {
        synchronized(this) {
            try {  
                for (int i = 0; i &lt; 5; i++) {
                    Thread.sleep(100); // 休眠100ms
                    System.out.println(Thread.currentThread().getName() + &quot; loop &quot; + i);  
                }
            } catch (InterruptedException ie) {  
            }
        }  
    }
}

public class Demo1_1 {

    public static void main(String[] args) {  
        Runnable demo = new MyRunable();     // 新建“Runnable对象”

        Thread t1 = new Thread(demo, &quot;t1&quot;);  // 新建“线程t1”, t1是基于demo这个Runnable对象
        Thread t2 = new Thread(demo, &quot;t2&quot;);  // 新建“线程t2”, t2是基于demo这个Runnable对象
        t1.start();                          // 启动“线程t1”
        t2.start();                          // 启动“线程t2” 
    } 
}</code></pre><p>运行结果：</p>
<pre><code>t1 loop 0
t1 loop 1
t1 loop 2
t1 loop 3
t1 loop 4
t2 loop 0
t2 loop 1
t2 loop 2
t2 loop 3
t2 loop 4</code></pre><p>结果说明：run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于”demo这个Runnable对象”创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。</p>
<p>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：</p>
<pre><code>class MyThread extends Thread {

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        synchronized(this) {
            try {  
                for (int i = 0; i &lt; 5; i++) {
                    Thread.sleep(100); // 休眠100ms
                    System.out.println(Thread.currentThread().getName() + &quot; loop &quot; + i);  
                }
            } catch (InterruptedException ie) {  
            }
        }  
    }
}

public class Demo1_2 {

    public static void main(String[] args) {  
        Thread t1 = new MyThread(&quot;t1&quot;);  // 新建“线程t1”
        Thread t2 = new MyThread(&quot;t2&quot;);  // 新建“线程t2”
        t1.start();                          // 启动“线程t1”
        t2.start();                          // 启动“线程t2” 
    } 
}</code></pre><p>代码说明：比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。<br>幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！  </p>
<p>那么，Demo1_2的执行流程是不是和Demo1_1一样呢？运行结果：</p>
<pre><code>t1 loop 0
t2 loop 0
t1 loop 1
t2 loop 1
t1 loop 2
t2 loop 2
t1 loop 3
t2 loop 3
t1 loop 4
t2 loop 4</code></pre><p>结果说明：<br>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。<br>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。<br>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。</p>
<h2 id="第二条"><a href="#第二条" class="headerlink" title="第二条"></a>第二条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。<br>下面是“synchronized代码块”对应的演示程序。</p>
<pre><code>class Count {

    // 含有synchronized同步块的方法
    public void synMethod() {
        synchronized(this) {
            try {  
                for (int i = 0; i &lt; 5; i++) {
                    Thread.sleep(100); // 休眠100ms
                    System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  
                }
            } catch (InterruptedException ie) {  
            }
        }  
    }

    // 非同步的方法
    public void nonSynMethod() {
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100);
                System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  
            }
        } catch (InterruptedException ie) {  
        }
    }
}

public class Demo2 {

    public static void main(String[] args) {  
        final Count count = new Count();
        // 新建t1, t1会调用“count对象”的synMethod()方法
        Thread t1 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        count.synMethod();
                    }
                }, &quot;t1&quot;);

        // 新建t2, t2会调用“count对象”的nonSynMethod()方法
        Thread t2 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        count.nonSynMethod();
                    }
                }, &quot;t2&quot;);  


        t1.start();  // 启动t1
        t2.start();  // 启动t2
    } 
}</code></pre><p>运行结果：</p>
<pre><code>t1 synMethod loop 0
t2 nonSynMethod loop 0
t1 synMethod loop 1
t2 nonSynMethod loop 1
t1 synMethod loop 2
t2 nonSynMethod loop 2
t1 synMethod loop 3
t2 nonSynMethod loop 3
t1 synMethod loop 4
t2 nonSynMethod loop 4</code></pre><p>结果说明：<br>主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。</p>
<h2 id="第三条"><a href="#第三条" class="headerlink" title="第三条"></a>第三条</h2><p>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。<br>我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：</p>
<pre><code>class Count {

    // 含有synchronized同步块的方法
    public void synMethod() {
        synchronized(this) {
            try {  
                for (int i = 0; i &lt; 5; i++) {
                    Thread.sleep(100); // 休眠100ms
                    System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i);  
                }
            } catch (InterruptedException ie) {  
            }
        }  
    }

    // 也包含synchronized同步块的方法
    public void nonSynMethod() {
        synchronized(this) {
            try {  
                for (int i = 0; i &lt; 5; i++) {
                    Thread.sleep(100);
                    System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i);  
                }
            } catch (InterruptedException ie) {  
            }
        }
    }
}

public class Demo3 {

    public static void main(String[] args) {  
        final Count count = new Count();
        // 新建t1, t1会调用“count对象”的synMethod()方法
        Thread t1 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        count.synMethod();
                    }
                }, &quot;t1&quot;);

        // 新建t2, t2会调用“count对象”的nonSynMethod()方法
        Thread t2 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        count.nonSynMethod();
                    }
                }, &quot;t2&quot;);  


        t1.start();  // 启动t1
        t2.start();  // 启动t2
    } 
}</code></pre><p>运行结果：</p>
<pre><code>t1 synMethod loop 0
t1 synMethod loop 1
t1 synMethod loop 2
t1 synMethod loop 3
t1 synMethod loop 4
t2 nonSynMethod loop 0
t2 nonSynMethod loop 1
t2 nonSynMethod loop 2
t2 nonSynMethod loop 3
t2 nonSynMethod loop 4</code></pre><p>结果说明：<br>主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-synchronized方法-和-synchronized代码块"><a href="#3-synchronized方法-和-synchronized代码块" class="headerlink" title="3. synchronized方法 和 synchronized代码块"></a>3. synchronized方法 和 synchronized代码块</h1><p>“synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。</p>
<p><strong>synchronized方法示例</strong></p>
<pre><code>public synchronized void foo1() {
    System.out.println(&quot;synchronized methoed&quot;);
}</code></pre><p><strong>synchronized代码块</strong></p>
<pre><code>public void foo2() {
    synchronized (this) {
        System.out.println(&quot;synchronized methoed&quot;);
    }
}</code></pre><p>synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。</p>
<p>synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。下面通过一个示例来演示：</p>
<pre><code>// Demo4.java的源码
public class Demo4 {

    public synchronized void synMethod() {
        for(int i=0; i&lt;1000000; i++)
            ;
    }

    public void synBlock() {
        synchronized( this ) {
            for(int i=0; i&lt;1000000; i++)
                ;
        }
    }

    public static void main(String[] args) {
        Demo4 demo = new Demo4();

        long start, diff;
        start = System.currentTimeMillis();                // 获取当前时间(millis)
        demo.synMethod();                                // 调用“synchronized方法”
        diff = System.currentTimeMillis() - start;        // 获取“时间差值”
        System.out.println(&quot;synMethod() : &quot;+ diff);

        start = System.currentTimeMillis();                // 获取当前时间(millis)
        demo.synBlock();                                // 调用“synchronized方法块”
        diff = System.currentTimeMillis() - start;        // 获取“时间差值”
        System.out.println(&quot;synBlock()  : &quot;+ diff);
    }
}</code></pre><p>(某一次)执行结果：</p>
<pre><code>synMethod() : 11
synBlock() : 3</code></pre><p><a name="anchor4"></a></p>
<h1 id="4-实例锁-和-全局锁"><a href="#4-实例锁-和-全局锁" class="headerlink" title="4. 实例锁 和 全局锁"></a>4. 实例锁 和 全局锁</h1><p>实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。<br>  &nbsp;&nbsp;&nbsp;&nbsp; 实例锁对应的就是synchronized关键字。<br>全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。<br>  &nbsp;&nbsp;&nbsp;&nbsp; 全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。</p>
<p>关于“实例锁”和“全局锁”有一个很形象的例子：</p>
<pre><code>pulbic class Something {
    public synchronized void isSyncA(){}
    public synchronized void isSyncB(){}
    public static synchronized void cSyncA(){}
    public static synchronized void cSyncB(){}
}</code></pre><p>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。<br>(01) x.isSyncA()与x.isSyncB()<br>(02) x.isSyncA()与y.isSyncA()<br>(03) x.cSyncA()与y.cSyncB()<br>(04) x.isSyncA()与Something.cSyncA()  </p>
<p><strong>(01) 不能被同时访问。</strong><br>因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！</p>
<pre><code>// LockTest1.java的源码
class Something {
    public synchronized void isSyncA(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);
            }
        }catch (InterruptedException ie) {  
        }  
    }
    public synchronized void isSyncB(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);
            }
        }catch (InterruptedException ie) {  
        }  
    }
}

public class LockTest1 {

    Something x = new Something();
    Something y = new Something();

    // 比较(01) x.isSyncA()与x.isSyncB() 
    private void test1() {
        // 新建t11, t11会调用 x.isSyncA()
        Thread t11 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        x.isSyncA();
                    }
                }, &quot;t11&quot;);

        // 新建t12, t12会调用 x.isSyncB()
        Thread t12 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        x.isSyncB();
                    }
                }, &quot;t12&quot;);  


        t11.start();  // 启动t11
        t12.start();  // 启动t12
    }

    public static void main(String[] args) {
        LockTest1 demo = new LockTest1();
        demo.test1();
    }
}</code></pre><p>运行结果：</p>
<pre><code>t11 : isSyncA
t11 : isSyncA
t11 : isSyncA
t11 : isSyncA
t11 : isSyncA
t12 : isSyncB
t12 : isSyncB
t12 : isSyncB
t12 : isSyncB
t12 : isSyncB</code></pre><p><strong>(02) 可以同时被访问。</strong><br>因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。</p>
<pre><code>// LockTest2.java的源码
class Something {
    public synchronized void isSyncA(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);
            }
        }catch (InterruptedException ie) {  
        }  
    }
    public synchronized void isSyncB(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);
            }
        }catch (InterruptedException ie) {  
        }  
    }
    public static synchronized void cSyncA(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);
            } 
        }catch (InterruptedException ie) {  
        }  
    }
    public static synchronized void cSyncB(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);
            } 
        }catch (InterruptedException ie) {  
        }  
    }
}

public class LockTest2 {

    Something x = new Something();
    Something y = new Something();

    // 比较(02) x.isSyncA()与y.isSyncA()
    private void test2() {
        // 新建t21, t21会调用 x.isSyncA()
        Thread t21 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        x.isSyncA();
                    }
                }, &quot;t21&quot;);

        // 新建t22, t22会调用 x.isSyncB()
        Thread t22 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        y.isSyncA();
                    }
                }, &quot;t22&quot;);  


        t21.start();  // 启动t21
        t22.start();  // 启动t22
    }

    public static void main(String[] args) {
        LockTest2 demo = new LockTest2();

        demo.test2();
    }
}</code></pre><p>运行结果：</p>
<pre><code>t21 : isSyncA
t22 : isSyncA
t21 : isSyncA
t22 : isSyncA
t21 : isSyncA
t22 : isSyncA
t21 : isSyncA
t22 : isSyncA
t21 : isSyncA
t22 : isSyncA</code></pre><p><strong>(03) 不能被同时访问。</strong><br>因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。</p>
<pre><code>// LockTest3.java的源码
class Something {
    public synchronized void isSyncA(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);
            }
        }catch (InterruptedException ie) {  
        }  
    }
    public synchronized void isSyncB(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);
            }
        }catch (InterruptedException ie) {  
        }  
    }
    public static synchronized void cSyncA(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);
            } 
        }catch (InterruptedException ie) {  
        }  
    }
    public static synchronized void cSyncB(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);
            } 
        }catch (InterruptedException ie) {  
        }  
    }
}

public class LockTest3 {

    Something x = new Something();
    Something y = new Something();

    // 比较(03) x.cSyncA()与y.cSyncB()
    private void test3() {
        // 新建t31, t31会调用 x.isSyncA()
        Thread t31 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        x.cSyncA();
                    }
                }, &quot;t31&quot;);

        // 新建t32, t32会调用 x.isSyncB()
        Thread t32 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        y.cSyncB();
                    }
                }, &quot;t32&quot;);  


        t31.start();  // 启动t31
        t32.start();  // 启动t32
    }

    public static void main(String[] args) {
        LockTest3 demo = new LockTest3();

        demo.test3();
    }
}</code></pre><p>运行结果：</p>
<pre><code>t31 : cSyncA
t31 : cSyncA
t31 : cSyncA
t31 : cSyncA
t31 : cSyncA
t32 : cSyncB
t32 : cSyncB
t32 : cSyncB
t32 : cSyncB
t32 : cSyncB</code></pre><p><strong>(04) 可以被同时访问。</strong><br>因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。</p>
<pre><code>// LockTest4.java的源码
class Something {
    public synchronized void isSyncA(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;);
            }
        }catch (InterruptedException ie) {  
        }  
    }
    public synchronized void isSyncB(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;);
            }
        }catch (InterruptedException ie) {  
        }  
    }
    public static synchronized void cSyncA(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;);
            } 
        }catch (InterruptedException ie) {  
        }  
    }
    public static synchronized void cSyncB(){
        try {  
            for (int i = 0; i &lt; 5; i++) {
                Thread.sleep(100); // 休眠100ms
                System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;);
            } 
        }catch (InterruptedException ie) {  
        }  
    }
}

public class LockTest4 {

    Something x = new Something();
    Something y = new Something();

    // 比较(04) x.isSyncA()与Something.cSyncA()
    private void test4() {
        // 新建t41, t41会调用 x.isSyncA()
        Thread t41 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        x.isSyncA();
                    }
                }, &quot;t41&quot;);

        // 新建t42, t42会调用 x.isSyncB()
        Thread t42 = new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        Something.cSyncA();
                    }
                }, &quot;t42&quot;);  


        t41.start();  // 启动t41
        t42.start();  // 启动t42
    }

    public static void main(String[] args) {
        LockTest4 demo = new LockTest4();

        demo.test4();
    }
}</code></pre><p>运行结果：</p>
<pre><code>t41 : isSyncA
t42 : cSyncA
t41 : isSyncA
t42 : cSyncA
t41 : isSyncA
t42 : cSyncA
t41 : isSyncA
t42 : cSyncA
t41 : isSyncA
t42 : cSyncA</code></pre>
    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/03/java/threads/2012-08-03-threads-basic/" itemprop="url">Java多线程系列--“基础篇”03之  Thread中start()和run()的区别</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-03T01:01:00.000Z" itemprop="datePublished">8月 3 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 read (About 659 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>Thread类包含start()和run()方法，它们的区别是什么？本章将对此作出解答。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. start() 和 run()的区别说明</a><br><a href="#anchor2">2. start() 和 run()的区别示例</a><br><a href="#anchor3">3. start() 和 run()相关源码(基于JDK1.7.0_40)</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-start-和-run-的区别说明"><a href="#1-start-和-run-的区别说明" class="headerlink" title="1. start() 和 run()的区别说明"></a>1. start() 和 run()的区别说明</h1><p>start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。<br>run()   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</p>
<p>下面以代码来进行说明。</p>
<pre><code>class MyThread extends Thread{  
    public void run(){
        ...
    } 
};
MyThread mythread = new MyThread();</code></pre><p>mythread.start()会启动一个新线程，并在新线程中运行run()方法。<br>而mythread.run()则会直接在当前线程中运行run()方法，并不会启动一个新线程来运行run()。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-start-和-run-的区别示例"><a href="#2-start-和-run-的区别示例" class="headerlink" title="2. start() 和 run()的区别示例"></a>2. start() 和 run()的区别示例</h1><p>下面，通过一个简单示例演示它们之间的区别。源码如下：</p>
<pre><code>// Demo.java 的源码
class MyThread extends Thread{
    public MyThread(String name) {
        super(name);
    }

    public void run(){
        System.out.println(Thread.currentThread().getName()+&quot; is running&quot;);
    } 
}; 

public class Demo {  
    public static void main(String[] args) {  
        Thread mythread=new MyThread(&quot;mythread&quot;);

        System.out.println(Thread.currentThread().getName()+&quot; call mythread.run()&quot;);
        mythread.run();

        System.out.println(Thread.currentThread().getName()+&quot; call mythread.start()&quot;);
        mythread.start();
    }  
}</code></pre><p>运行结果：</p>
<pre><code>main call mythread.run()
main is running
main call mythread.start()
mythread is running</code></pre><p>结果说明：<br>(01) Thread.currentThread().getName()是用于获取“当前线程”的名字。当前线程是指正在cpu中调度执行的线程。<br>(02) mythread.run()是在“主线程main”中调用的，该run()方法直接运行在“主线程main”上。<br>(03) mythread.start()会启动“线程mythread”，“线程mythread”启动之后，会调用run()方法；此时的run()方法是运行在“线程mythread”上。</p>
<p><a name="anchor3"></a></p>
<h1 id="3-start-和-run-相关源码-基于JDK1-7-0-40"><a href="#3-start-和-run-相关源码-基于JDK1-7-0-40" class="headerlink" title="3. start() 和 run()相关源码(基于JDK1.7.0_40)"></a>3. start() 和 run()相关源码(基于JDK1.7.0_40)</h1><p>Thread.java中start()方法的源码如下：</p>
<pre><code>public synchronized void start() {
    // 如果线程不是&quot;就绪状态&quot;，则抛出异常！
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    // 将线程添加到ThreadGroup中
    group.add(this);

    boolean started = false;
    try {
        // 通过start0()启动线程
        start0();
        // 设置started标记
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        }
    }
}</code></pre><p>说明：start()实际上是通过本地方法start0()启动线程的。而start0()会新运行一个线程，新线程会调用run()方法。</p>
<pre><code>private native void start0();</code></pre><p>Thread.java中run()的代码如下：</p>
<pre><code>public void run() {
    if (target != null) {
        target.run();
    }
}</code></pre><p>说明：target是一个Runnable对象。run()就是直接调用Thread线程的Runnable成员的run()方法，并不会新建一个线程。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/02/java/threads/2012-08-02-threads-basic/" itemprop="url">Java多线程系列--“基础篇”02之 常用的实现多线程的两种方式</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-02T01:01:00.000Z" itemprop="datePublished">8月 2 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            7 分钟 read (About 1042 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章，我们学习“常用的实现多线程的2种方式”：Thread 和 Runnable。<br>之所以说是常用的，是因为通过还可以通过java.util.concurrent包中的线程池来实现多线程。关于线程池的内容，我们以后会详细介绍；现在，先对的Thread和Runnable进行了解。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. Thread和Runnable简介</a><br><a href="#anchor2">2. Thread和Runnable的异同点</a><br><a href="#anchor3">3. Thread和Runnable的多线程示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Thread和Runnable简介"><a href="#1-Thread和Runnable简介" class="headerlink" title="1. Thread和Runnable简介"></a>1. Thread和Runnable简介</h1><p>Runnable 是一个接口，该接口中只包含了一个run()方法。它的定义如下：</p>
<pre><code>public interface Runnable {
    public abstract void run();
}</code></pre><p>Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。</p>
<p>Thread 是一个类。Thread本身就实现了Runnable接口。它的声明如下：</p>
<pre><code>public class Thread implements Runnable {}</code></pre><p>Thread的作用，实现多线程。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-Thread和Runnable的异同点"><a href="#2-Thread和Runnable的异同点" class="headerlink" title="2. Thread和Runnable的异同点"></a>2. Thread和Runnable的异同点</h1><p>Thread 和 Runnable 的相同点：都是“多线程的实现方式”。</p>
<p>Thread 和 Runnable 的不同点：<br>Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。<br>此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。</p>
<p>通常，建议通过“Runnable”实现多线程！</p>
<p><a name="anchor3"></a></p>
<h1 id="3-Thread和Runnable的多线程示例"><a href="#3-Thread和Runnable的多线程示例" class="headerlink" title="3. Thread和Runnable的多线程示例"></a>3. Thread和Runnable的多线程示例</h1><h2 id="3-1-Thread的多线程示例"><a href="#3-1-Thread的多线程示例" class="headerlink" title="3.1 Thread的多线程示例"></a>3.1 Thread的多线程示例</h2><p>下面通过示例更好的理解Thread和Runnable，借鉴网上一个例子比较具有说服性的例子。</p>
<pre><code>// ThreadTest.java 源码
class MyThread extends Thread{
    private int ticket=10;  
    public void run(){
        for(int i=0;i&lt;20;i++){ 
            if(this.ticket&gt;0){
                System.out.println(this.getName()+&quot; 卖票：ticket&quot;+this.ticket--);
            }
        }
    } 
};

public class ThreadTest {  
    public static void main(String[] args) {  
        // 启动3个线程t1,t2,t3；每个线程各卖10张票！
        MyThread t1=new MyThread();
        MyThread t2=new MyThread();
        MyThread t3=new MyThread();
        t1.start();
        t2.start();
        t3.start();
    }  
} </code></pre><p>运行结果：</p>
<pre><code>Thread-0 卖票：ticket10
Thread-1 卖票：ticket10
Thread-2 卖票：ticket10
Thread-1 卖票：ticket9
Thread-0 卖票：ticket9
Thread-1 卖票：ticket8
Thread-2 卖票：ticket9
Thread-1 卖票：ticket7
Thread-0 卖票：ticket8
Thread-1 卖票：ticket6
Thread-2 卖票：ticket8
Thread-1 卖票：ticket5
Thread-0 卖票：ticket7
Thread-1 卖票：ticket4
Thread-2 卖票：ticket7
Thread-1 卖票：ticket3
Thread-0 卖票：ticket6
Thread-1 卖票：ticket2
Thread-2 卖票：ticket6
Thread-2 卖票：ticket5
Thread-2 卖票：ticket4
Thread-1 卖票：ticket1
Thread-0 卖票：ticket5
Thread-2 卖票：ticket3
Thread-0 卖票：ticket4
Thread-2 卖票：ticket2
Thread-0 卖票：ticket3
Thread-2 卖票：ticket1
Thread-0 卖票：ticket2
Thread-0 卖票：ticket1</code></pre><p>结果说明：<br>(01) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出10张票。<br>(02) 主线程main创建并启动3个MyThread子线程。每个子线程都各自卖出了10张票。</p>
<h2 id="3-2-Runnable的多线程示例"><a href="#3-2-Runnable的多线程示例" class="headerlink" title="3.2 Runnable的多线程示例"></a>3.2 Runnable的多线程示例</h2><p>下面，我们对上面的程序进行修改。通过Runnable实现一个接口，从而实现多线程。</p>
<pre><code>// RunnableTest.java 源码
class MyThread implements Runnable{  
    private int ticket=10;  
    public void run(){
        for(int i=0;i&lt;20;i++){ 
            if(this.ticket&gt;0){
                System.out.println(Thread.currentThread().getName()+&quot; 卖票：ticket&quot;+this.ticket--);
            }
        }
    } 
}; 

public class RunnableTest {  
    public static void main(String[] args) {  
        MyThread mt=new MyThread();

        // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！
        Thread t1=new Thread(mt);
        Thread t2=new Thread(mt);
        Thread t3=new Thread(mt);
        t1.start();
        t2.start();
        t3.start();
    }  
}</code></pre><p>运行结果：</p>
<pre><code>Thread-0 卖票：ticket10
Thread-2 卖票：ticket8
Thread-1 卖票：ticket9
Thread-2 卖票：ticket6
Thread-0 卖票：ticket7
Thread-2 卖票：ticket4
Thread-1 卖票：ticket5
Thread-2 卖票：ticket2
Thread-0 卖票：ticket3
Thread-1 卖票：ticket1</code></pre><p>结果说明：<br>(01) 和上面“MyThread继承于Thread”不同；这里的MyThread实现了Thread接口。<br>(02) 主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/01/java/threads/2012-08-01-threads-basic/" itemprop="url">Java多线程系列--“基础篇”01之 基本概念</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-08-01T01:01:00.000Z" itemprop="datePublished">8月 1 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            5 分钟 read (About 761 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>多线程是Java中不可避免的一个重要主体。从本章开始，我们将展开对多线程的学习。接下来的内容，是对“JDK中新增JUC包”之前的Java多线程内容的讲解，涉及到的内容包括，Object类中的wait(), notify()等接口；Thread类中的接口；synchronized关键字。</p>
</blockquote>
<blockquote>
<p>注：JUC包是指，Java.util.concurrent包，它是由Java大师Doug Lea完成并在JDK1.5版本添加到Java中的。</p>
</blockquote>
<p>在进入后面章节的学习之前，先对了解一些多线程的相关概念。</p>
<p>线程状态图</p>
<p><img src="/media/pic/java/threads/basic01.jpg" alt="img"></p>
<p>说明：<br>线程共包括以下5种状态。  </p>
<ol>
<li>新建状态(New)         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。  </li>
<li>就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。  </li>
<li>运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。  </li>
<li>阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<br>&nbsp;&nbsp;&nbsp;&nbsp; (01) 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。<br>&nbsp;&nbsp;&nbsp;&nbsp; (02) 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。<br>&nbsp;&nbsp;&nbsp;&nbsp; (03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。  </li>
<li>死亡状态(Dead)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<p>这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。<br>Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。<br>Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。<br>synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。<br>在后面详细介绍wait(),notify()等方法时，我们会分析为什么“wait(), notify()等方法要定义在Object类，而不是Thread类中”。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/08/01/java/threads/2012-08-01-threads-index/" itemprop="url">Java多线程系列--目录</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-07-31T16:01:00.000Z" itemprop="datePublished">8月 1 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            8 分钟 read (About 1126 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p><a href="/2012/08/01/threads-basic">Java多线程系列–“基础篇”01之 基本概念</a><br><a href="/2012/08/02/threads-basic">Java多线程系列–“基础篇”02之 常用的实现多线程的两种方式</a><br><a href="/2012/08/03/threads-basic">Java多线程系列–“基础篇”03之 Thread中start()和run()的区别</a><br><a href="/2012/08/04/threads-basic">Java多线程系列–“基础篇”04之 synchronized关键字</a><br><a href="/2012/08/05/threads-basic">Java多线程系列–“基础篇”05之 线程等待与唤醒</a><br><a href="/2012/08/06/threads-basic">Java多线程系列–“基础篇”06之 线程让步</a><br><a href="/2012/08/07/threads-basic">Java多线程系列–“基础篇”07之 线程休眠</a><br><a href="/2012/08/08/threads-basic">Java多线程系列–“基础篇”08之 join()</a><br><a href="/2012/08/09/threads-basic">Java多线程系列–“基础篇”09之 interrupt()和线程终止方式</a><br><a href="/2012/08/10/threads-basic">Java多线程系列–“基础篇”10之 线程优先级和守护线程</a><br><a href="/2012/08/11/threads-basic">Java多线程系列–“基础篇”11之 生产消费者问题</a></p>
<p><a href="/2012/08/12/juc-atomic01">Java多线程系列–“JUC原子类”01之 框架</a><br><a href="/2012/08/12/juc-atomic02">Java多线程系列–“JUC原子类”02之 AtomicLong原子类</a><br><a href="/2012/08/12/juc-atomic03">Java多线程系列–“JUC原子类”03之 AtomicLongArray原子类</a><br><a href="/2012/08/12/juc-atomic04">Java多线程系列–“JUC原子类”04之 AtomicReference原子类</a><br><a href="/2012/08/12/juc-atomic05">Java多线程系列–“JUC原子类”05之 AtomicLongFieldUpdater原子类</a></p>
<p><a href="/2012/08/13/juc-lock01">Java多线程系列–“JUC锁”01之 框架</a><br><a href="/2012/08/13/juc-lock02">Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock</a><br><a href="/2012/08/13/juc-lock03">Java多线程系列–“JUC锁”03之 公平锁(一)</a><br><a href="/2012/08/13/juc-lock04">Java多线程系列–“JUC锁”04之 公平锁(二)</a><br><a href="/2012/08/13/juc-lock05">Java多线程系列–“JUC锁”05之 非公平锁</a><br><a href="/2012/08/13/juc-lock06">Java多线程系列–“JUC锁”06之 Condition条件</a><br><a href="/2012/08/13/juc-lock07">Java多线程系列–“JUC锁”07之 LockSupport</a><br><a href="/2012/08/13/juc-lock08">Java多线程系列–“JUC锁”08之 共享锁和ReentrantReadWriteLock</a><br><a href="/2012/08/13/juc-lock09">Java多线程系列–“JUC锁”09之 CountDownLatch原理和示例</a><br><a href="/2012/08/13/juc-lock10">Java多线程系列–“JUC锁”10之 CyclicBarrier原理和示例</a><br><a href="/2012/08/13/juc-lock11">Java多线程系列–“JUC锁”11之 Semaphore信号量的原理和示例</a></p>
<p><a href="/2012/08/14/juc-col01">Java多线程系列–“JUC集合”01之 框架</a><br><a href="/2012/08/14/juc-col02">Java多线程系列–“JUC集合”02之 CopyOnWriteArrayList</a><br><a href="/2012/08/14/juc-col03">Java多线程系列–“JUC集合”03之 CopyOnWriteArraySet</a><br><a href="/2012/08/14/juc-col04">Java多线程系列–“JUC集合”04之 ConcurrentHashMap</a><br><a href="/2012/08/14/juc-col05">Java多线程系列–“JUC集合”05之 ConcurrentSkipListMap</a><br><a href="/2012/08/14/juc-col06">Java多线程系列–“JUC集合”06之 ConcurrentSkipListSet</a><br><a href="/2012/08/14/juc-col07">Java多线程系列–“JUC集合”07之 ArrayBlockingQueue</a><br><a href="/2012/08/14/juc-col08">Java多线程系列–“JUC集合”08之 LinkedBlockingQueue</a><br><a href="/2012/08/14/juc-col09">Java多线程系列–“JUC集合”09之 LinkedBlockingDeque</a><br><a href="/2012/08/14/juc-col10">Java多线程系列–“JUC集合”10之 ConcurrentHashMap</a></p>
<p><a href="/2012/08/15/juc-executor01">Java多线程系列–“JUC线程池”01之 线程池架构</a><br><a href="/2012/08/15/juc-executor02">Java多线程系列–“JUC线程池”02之 线程池原理(一)</a><br><a href="/2012/08/15/juc-executor03">Java多线程系列–“JUC线程池”03之 线程池原理(二)</a><br><a href="/2012/08/15/juc-executor04">Java多线程系列–“JUC线程池”04之 线程池原理(三)</a><br><a href="/2012/08/15/juc-executor05">Java多线程系列–“JUC线程池”05之 线程池原理(四)</a><br><a href="/2012/08/15/juc-executor06">Java多线程系列–“JUC线程池”06之 Callable和Future</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/07/01/java/ebook/2012-07-01-ebook-JavaMemoryMode/" itemprop="url">《深入理解Java内存模型》读书总结</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-07-01T01:01:00.000Z" itemprop="datePublished">7月 1 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            24 分钟 read (About 3600 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>文章是《深入理解Java内容模型》读书笔记，该书总共包括了3部分的知识。</p>
</blockquote>
<blockquote>
<p>第1部分，基本概念<br>&nbsp;&nbsp;&nbsp;&nbsp; 包括“并发、同步、主内存、本地内存、重排序、内存屏障、happens before规则、as-if-serial规则、数据依赖性、顺序一致性模型、JMM的含义和意义”。<br>第2部分，同步机制<br>&nbsp;&nbsp;&nbsp;&nbsp; 该部分中就介绍了“同步”的3种方式：volatile、锁、final。对于每一种方式，从该方式的“特性”、“建立的happens before关系”、“对应的内存语义”、“实现方式”等几个方面进行了分析说明。实际上，JMM保证“如果程序正确同步，则执行结果与顺序一致性内存模型的结果相同”的机制；而这部分这是确保程序正确同步的机制。<br>第3部分，JMM总结</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1"></a><br><a href="#anchor2"></a><br><a href="#anchor3"></a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-基本概念"><a href="#第1部分-基本概念" class="headerlink" title="第1部分 基本概念"></a>第1部分 基本概念</h1><h2 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h2><p>定义：即，并发(同时)发生。在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
<p>并发需要处理两个关键问题：线程之间如何通信及线程之间如何同步。<br>(01) <strong>通信</strong> —— 是指线程之间如何交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。<br>(02) <strong>同步</strong>—— 是指程序用于控制不同线程之间操作发生相对顺序的机制。在Java中，可以通过volatile，synchronized, 锁等方式实现同步。</p>
<h2 id="2-主内存和本地内存"><a href="#2-主内存和本地内存" class="headerlink" title="2.主内存和本地内存"></a>2.主内存和本地内存</h2><p><strong>主内存</strong>     —— 即main memory。在java中，实例域、静态域和数组元素是线程之间共享的数据，它们存储在主内存中。<br><strong>本地内存</strong> —— 即local memory。 局部变量，方法定义参数 和 异常处理器参数是不会在线程之间共享的，它们存储在线程的本地内存中。</p>
<h2 id="3-重排序"><a href="#3-重排序" class="headerlink" title="3.重排序"></a>3.重排序</h2><p>定义：重排序是指“编译器和处理器”为了提高性能，而在程序执行时会对程序进行的重排序。<br>说明：重排序分为——“编译器”和“处理器”两个方面，而“处理器”重排序又包括“指令级重排序”和“内存的重排序”。</p>
<p>关于重排序，我们需要理解它的思想：<strong>为了提高程序的并发度，从而提高性能！但是对于多线程程序，重排序可能会导致程序执行的结果不是我们需要的结果！因此，就需要我们通过“volatile，synchronize，锁等方式”作出正确的实现同步。</strong></p>
<h2 id="4-内存屏障"><a href="#4-内存屏障" class="headerlink" title="4.内存屏障"></a>4.内存屏障</h2><p>定义：包括LoadLoad, LoadStore, StoreLoad, StoreStore共4种内存屏障。内存屏障是与相应的内存重排序相对应的。</p>
<table frame="hsides" rules="groups" cellspacing="0" cellpadding="0">
     <colgroup span="1" width="160"></colgroup>
     <colgroup span="2" width="300"></colgroup>
     <colgroup span="3" width="300"></colgroup>

<!-- 表头部分 -->
<thead align="center" style="font-weight:bolder; background-color:#cccccc">
     <tr>
        <td>屏障类型</td>
        <td>指令示例</td>
        <td>说明</td>
     </tr>
</thead>

<tbody align="center">
    <tr>
        <td>LoadLoad Barriers</td>
        <td>Load1; LoadLoad; Load2</td>
        <td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
    </tr>
    <tr>
        <td>StoreStore Barriers</td>
        <td>Store1; StoreStore; Store2</td>
        <td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td>
    </tr>
    <tr>
        <td>LoadStore Barriers</td>
        <td>Load1; LoadStore; Store2</td>
        <td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td>
    </tr>
    <tr>
        <td>StoreLoad Barriers</td>
        <td>Store1; StoreLoad; Load2</td>
        <td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
    </tr>
</tbody>
</table>

<p>作用：通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。</p>
<h2 id="5-happens-before"><a href="#5-happens-before" class="headerlink" title="5. happens-before"></a>5. happens-before</h2><p>定义：JDK5(JSR-133)提供的概念，用于描述多线程操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</p>
<p>作用：描述多线程操作之间的内存可见性。</p>
<blockquote>
<p>[程序顺序规则]：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。<br>[监视器锁规则]：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。<br>[volatile变量规则]：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。<br>[传递性]：如果A happens- before B，且B happens- before C，那么A happens- before C。</p>
</blockquote>
<h2 id="6-数据依赖性"><a href="#6-数据依赖性" class="headerlink" title="6. 数据依赖性"></a>6. 数据依赖性</h2><p>定义：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。<br>作用：编译器和处理器不会对“存在数据依赖关系的两个操作”执行重排序。</p>
<h2 id="7-as-if-serial"><a href="#7-as-if-serial" class="headerlink" title="7.as-if-serial"></a>7.as-if-serial</h2><p>定义：不管怎么重排序，程序的执行结果不能被改变。</p>
<h2 id="8-顺序一致性内存模型"><a href="#8-顺序一致性内存模型" class="headerlink" title="8. 顺序一致性内存模型"></a>8. 顺序一致性内存模型</h2><p>定义：它是理想化的内存模型。有以下规则：<br>(01) 一个线程中的所有操作必须按照程序的顺序来执行。<br>(02) 所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</p>
<h2 id="9-JMM"><a href="#9-JMM" class="headerlink" title="9. JMM"></a>9. JMM</h2><p>定义：Java Memory Mode，即Java内存模型。它是Java线程之间通信的控制机制。<br>说明：JMM对Java程序作出保证——如果程序是正确同步的，程序的执行将具有顺序一致性。即，程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p>
<h2 id="10-可见性"><a href="#10-可见性" class="headerlink" title="10. 可见性"></a>10. 可见性</h2><p>可见性一般用于指不同线程之间的数据是否可见。</p>
<p>在java中， 实例域、静态域和数组元素这些数据是线程之间共享的数据，它们存储在主内存中；主内存中的所有数据对该内存中的线程都是可见的。而局部变量，方法定义参数 和 异常处理器参数这些数据是不会在线程之间共享的，它们存储在线程的本地内存中；它们对其它线程是不可见的。</p>
<p>此外，对于主内存中的数据，在本地内存中会对应的创建该数据的副本(相当于缓冲)；这些副本对于其它线程也是不可见的。</p>
<h2 id="11-原子性"><a href="#11-原子性" class="headerlink" title="11. 原子性"></a>11. 原子性</h2><p>是指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。</p>
<h1 id="第2部分-同步机制"><a href="#第2部分-同步机制" class="headerlink" title="第2部分 同步机制"></a>第2部分 同步机制</h1><h2 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1.volatile"></a>1.volatile</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p>如果一个变量是volatile类型，则对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。volatile变量自身具有下列特性：</p>
<p>[<strong>可见性</strong>]：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p>[<strong>原子性</strong>]：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</p>
<h3 id="1-2-volatile的内存语义"><a href="#1-2-volatile的内存语义" class="headerlink" title="1.2 volatile的内存语义"></a>1.2 volatile的内存语义</h3><p><strong>volatile写</strong>：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</p>
<p><strong>volatile读</strong>：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
<h3 id="1-3-JMM中的实现方式"><a href="#1-3-JMM中的实现方式" class="headerlink" title="1.3 JMM中的实现方式"></a>1.3 JMM中的实现方式</h3><p>JMM针对编译器制定的volatile重排序规则表：</p>
<table frame="hsides" rules="groups" cellspacing="0" cellpadding="0">
     <colgroup span="1" width="120"></colgroup>
     <colgroup span="2" width="120"></colgroup>
     <colgroup span="3" width="120"></colgroup>
     <colgroup span="4" width="120"></colgroup>

<!-- 表头部分 -->
<thead align="center" style="font-weight:bolder; background-color:#cccccc">
     <tr>
          <td>是否能重排序</td>
          <td colspan="3" align="center" style="font-weight:bolder">第二个操作</td>
     </tr>
</thead>

<tbody align="center">
    <tr>
        <td>第一个操作</td>
        <td>普通读/写</td>
        <td>volatile读</td>
        <td>volatile写</td>
    </tr>
    <tr>
        <td>普通读/写</td>
        <td></td>
        <td></td>
        <td>NO</td>
    </tr>
    <tr>
        <td>volatile读</td>
        <td>NO</td>
        <td>NO</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>volatile写</td>
        <td></td>
        <td>NO</td>
        <td>NO</td>
    </tr>
</tbody>
</table>

<p>下面是基于保守策略的JMM内存屏障插入策略：</p>
<blockquote>
<p>在每个volatile写操作的前面插入一个StoreStore屏障。<br>在每个volatile写操作的后面插入一个StoreLoad屏障。<br>在每个volatile读操作的后面插入一个LoadLoad屏障。<br>在每个volatile读操作的后面插入一个LoadStore屏障。</p>
</blockquote>
<p>　　</p>
<h3 id="1-4-volatile和-synchronize对比"><a href="#1-4-volatile和-synchronize对比" class="headerlink" title="1.4 volatile和 synchronize对比"></a>1.4 volatile和 synchronize对比</h3><p>在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。</p>
<p>volatile仅仅保证对单个volatile变量的读/写具有原子性；而synchronize锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。</p>
<h2 id="2-锁"><a href="#2-锁" class="headerlink" title="2.锁"></a>2.锁</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h3><p>锁是java并发编程中最重要的同步机制。</p>
<h3 id="2-2-锁的内存语义"><a href="#2-2-锁的内存语义" class="headerlink" title="2.2 锁的内存语义"></a>2.2 锁的内存语义</h3><p>(01) 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</p>
<p>(02) 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</p>
<p>(03) 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h3 id="2-3-JMM如何实现锁"><a href="#2-3-JMM如何实现锁" class="headerlink" title="2.3 JMM如何实现锁"></a>2.3 JMM如何实现锁</h3><p><strong>公平锁</strong><br>公平锁是通过“volatile”实现同步的。公平锁在释放锁的最后写volatile变量state；在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变的对获取锁的线程可见。</p>
<p><strong>非公平锁</strong><br>通过CAS实现的，CAS就是compare and swap。CAS实际上调用的JNI函数，也就是CAS依赖于本地实现。以Intel来说，对于CAS的JNI实现函数，它保证：(01)禁止该CAS之前和之后的读和写指令重排序。(02)把写缓冲区中的所有数据刷新到内存中。</p>
<h2 id="3-final"><a href="#3-final" class="headerlink" title="3.final"></a>3.final</h2><h3 id="3-1-特性"><a href="#3-1-特性" class="headerlink" title="3.1 特性"></a>3.1 特性</h3><p>对于基本类型的final域，编译器和处理器要遵守两个重排序规则：</p>
<p>(01) <strong>final写</strong>：“构造函数内对一个final域的写入”，与“随后把这个被构造对象的引用赋值给一个引用变量”，这两个操作之间不能重排序。</p>
<p>(02) <strong>final读</strong>：“初次读一个包含final域的对象的引用”，与“随后初次读对象的final域”，这两个操作之间不能重排序。</p>
<p>对于引用类型的final域，除上面两条之外，还有一条规则：</p>
<p>(03) <strong>final写</strong>：在“构造函数内对一个final引用的对象的成员域的写入”，与“随后在构造函数外把这个被构造对象的引用赋值给一个引用变量”，这两个操作之间不能重排序。</p>
<p><strong>注意</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp; 写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。</p>
<h2 id="3-2-JMM如何实现final"><a href="#3-2-JMM如何实现final" class="headerlink" title="3.2 JMM如何实现final"></a>3.2 JMM如何实现final</h2><p>通过“内存屏障”实现。</p>
<p>在final域的写之后，构造函数return之前，插入一个StoreStore障屏。在读final域的操作前面插入一个LoadLoad屏障。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分JMM总结"><a href="#第3部分JMM总结" class="headerlink" title="第3部分JMM总结"></a>第3部分JMM总结</h1><p><strong>JMM保证</strong>：如果程序是正确同步的，程序的执行将具有顺序一致性 。</p>
<p><strong>JMM设计</strong></p>
<p>从JMM设计者的角度来说，在设计JMM时，需要考虑两个关键因素：<br>&nbsp;&nbsp;&nbsp;&nbsp; (01) 程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型(程序尽可能的顺序执行)来编写代码。<br>&nbsp;&nbsp;&nbsp;&nbsp; (02) 编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化(对程序重排序，做尽可能多的并发)来提高性能。编译器和处理器希望实现一个弱内存模型。</p>
<p>JMM设计就需要在这两者之间作出协调。JMM对程序采取了不同的策略：<br>&nbsp;&nbsp;&nbsp;&nbsp; (01) 对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。<br>&nbsp;&nbsp;&nbsp;&nbsp; (02) 对于不会改变程序执行结果的重排序，JMM对编译器和处理器不作要求（JMM允许这种重排序）。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="noopener">1. 程晓明的“深入理解Java内存模型”的博客</a></p>
<p><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">2. The JSR-133 Cookbook for Compiler Writers</a></p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/04/16/java/exception/2012-04-16-exception/" itemprop="url">Java异常(三) 《Java Puzzles》中关于异常的几个谜题</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-04-16T01:01:00.000Z" itemprop="datePublished">4月 16 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            34 分钟 read (About 5132 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章介绍《Java Puzzles》中关于异常的几个谜题。这一章都是以代码为例，相比上一章看起来更有意思。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">谜题1: 优柔寡断</a><br><a href="#anchor2">谜题2: 极端不可思议</a><br><a href="#anchor3">谜题3: 不受欢迎的宾客</a><br><a href="#anchor4">谜题4: 您好,再见!</a><br><a href="#anchor5">谜题5: 不情愿的构造器</a><br><a href="#anchor6">谜题6: 域和流</a><br><a href="#anchor7">谜题7: 异常为循环而抛</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="谜题1-优柔寡断"><a href="#谜题1-优柔寡断" class="headerlink" title="谜题1: 优柔寡断"></a>谜题1: 优柔寡断</h1><p>看看下面的程序，它到底打印什么？</p>
<pre><code>public class Indecisive {

    public static void main(String[] args) {
        System.out.println(decision());
    }

    private static boolean decision() {
        try {
            return true;
        } finally {
            return false;
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>false</code></pre><p>结果说明：</p>
<p>在一个 try-finally 语句中,finally 语句块总是在控制权离开 try 语句块时执行的。无论 try 语句块是正常结束的,还是意外结束的, 情况都是如此。</p>
<p>一条语句或一个语句块在它抛出了一个异常,或者对某个封闭型语句执行了一个 break 或 continue,或是象这个程序一样在方法中执行了一个return 时,将发生意外结束。它们之所以被称为意外结束,是因为它们阻止程序去按顺序执行下面的语句。当 try 语句块和 finally 语句块都意外结束时, try 语句块中引发意外结束的原因将被丢弃, 而整个 try-finally 语句意外结束的原因将于 finally 语句块意外结束的原因相同。在这个程序中,在 try 语句块中的 return 语句所引发的意外结束将被丢弃, try-finally 语句意外结束是由 finally 语句块中的 return 而造成的。</p>
<p>简单地讲, 程序尝试着 (try) (return) 返回 true, 但是它最终 (finally) 返回(return)的是 false。丢弃意外结束的原因几乎永远都不是你想要的行为, 因为意外结束的最初原因可能对程序的行为来说会显得更重要。对于那些在 try 语句块中执行 break、continue 或 return 语句,只是为了使其行为被 finally 语句块所否决掉的程序,要理解其行为是特别困难的。总之,每一个 finally 语句块都应该正常结束,除非抛出的是不受检查的异常。 千万不要用一个 return、break、continue 或 throw 来退出一个 finally 语句块,并且千万不要允许将一个受检查的异常传播到一个 finally 语句块之外去。对于语言设计者, 也许应该要求 finally 语句块在未出现不受检查的异常时必须正常结束。朝着这个目标,try-finally 结构将要求 finally 语句块可以正常结束。return、break 或 continue 语句把控制权传递到 finally 语句块之外应该是被禁止的, 任何可以引发将被检查异常传播到 finally 语句块之外的语句也同样应该是被禁止的。</p>
<p><a name="anchor2"></a></p>
<h1 id="谜题2-极端不可思议"><a href="#谜题2-极端不可思议" class="headerlink" title="谜题2: 极端不可思议"></a>谜题2: 极端不可思议</h1><p>下面的三个程序每一个都会打印些什么? 不要假设它们都可以通过编译。</p>
<p><strong>第一个程序</strong></p>
<pre><code>import java.io.IOException;

public class Arcane1 {

    public static void main(String[] args) {
        try {
            System.out.println(&quot;Hello world&quot;);
        } catch(IOException e) {
            System.out.println(&quot;I&apos;ve never seen println fail!&quot;);
        }
    }
}</code></pre><p><strong>第二个程序</strong></p>
<pre><code>public class Arcane2 {
    public static void main(String[] args) {
        try {
            // If you have nothing nice to say, say nothing
        } catch(Exception e) {
            System.out.println(&quot;This can&apos;t happen&quot;);
        }
    }
}</code></pre><p><strong>第三个程序</strong></p>
<pre><code>interface Type1 {
    void f() throws CloneNotSupportedException;
}

interface Type2 {
    void f() throws InterruptedException;
}

interface Type3 extends Type1, Type2 {
}

public class Arcane3 implements Type3 {
    public void f() {
        System.out.println(&quot;Hello world&quot;);
    }
    public static void main(String[] args) {
        Type3 t3 = new Arcane3();
        t3.f();
    }
}</code></pre><p>运行结果：</p>
<p>(01) 第一个程序编译出错！</p>
<pre><code>Arcane1.java:9: exception java.io.IOException is never thrown in body of corresponding try statement
        } catch(IOException e) {
      ^
1 error</code></pre><p>(02) 第二个程序能正常编译和运行。</p>
<p>(03) 第三个程序能正常编译和运行。输出结果是: Hello world</p>
<p>结果说明：</p>
<p>(01) Arcane1展示了被检查异常的一个基本原则。它看起来应该是可以编译的:try 子句执行 I/O,并且 catch 子句捕获 IOException 异常。但是这个程序不能编译,因为 println 方法没有声明会抛出任何被检查异常,而IOException 却正是一个被检查异常。语言规范中描述道:如果一个 catch 子句要捕获一个类型为 E 的被检查异常, 而其相对应的 try 子句不能抛出 E 的某种子类型的异常,那么这就是一个编译期错误。</p>
<p>(02) 基于同样的理由,第二个程序,Arcane2,看起来应该是不可以编译的,但是它却可以。它之所以可以编译,是因为它唯一的 catch 子句检查了 Exception。尽管在这一点上十分含混不清,但是捕获 Exception 或 Throwble 的 catch 子句是合法的,不管与其相对应的 try 子句的内容为何。尽管 Arcane2 是一个合法的程序,但是 catch 子句的内容永远的不会被执行,这个程序什么都不会打印。</p>
<p>(03) 第三个程序,Arcane3,看起来它也不能编译。方法 f 在 Type1 接口中声明要抛出被检查异常 CloneNotSupportedException,并且在 Type2 接口中声明要抛出被检查异常 InterruptedException。Type3 接口继承了 Type1 和 Type2,因此, 看起来在静态类型为 Type3 的对象上调用方法 f 时, 有潜在可能会抛出这些异常。一个方法必须要么捕获其方法体可以抛出的所有被检查异常, 要么声明它将抛出这些异常。Arcane3 的 main 方法在静态类型为 Type3 的对象上调用了方法 f,但它对 CloneNotSupportedException 和 InterruptedExceptioin 并没有作这些处理。那么,为什么这个程序可以编译呢?</p>
<p>上述分析的缺陷在于对“Type3.f 可以抛出在 Type1.f 上声明的异常和在 Type2.f 上声明的异常”所做的假设。这并不正确,因为每一个接口都限制了方法 f 可以抛出的被检查异常集合。一个方法可以抛出的被检查异常集合是它所适用的所有类型声明要抛出的被检查异常集合的交集,而不是合集。因此,静态类型为 Type3 的对象上的 f 方法根本就不能抛出任何被检查异常。因此,Arcane3可以毫无错误地通过编译,并且打印 Hello world。</p>
<p><a name="anchor3"></a></p>
<h1 id="谜题3-不受欢迎的宾客"><a href="#谜题3-不受欢迎的宾客" class="headerlink" title="谜题3: 不受欢迎的宾客"></a>谜题3: 不受欢迎的宾客</h1><p>下面的程序会打印出什么呢?</p>
<pre><code>public class UnwelcomeGuest {
    public static final long GUEST_USER_ID = -1;
    private static final long USER_ID;

    static {
        try {
            USER_ID = getUserIdFromEnvironment();
        } catch (IdUnavailableException e) {
            USER_ID = GUEST_USER_ID;
            System.out.println(&quot;Logging in as guest&quot;);
        }
    }

    private static long getUserIdFromEnvironment() 
        throws IdUnavailableException {
        throw new IdUnavailableException();
    }

    public static void main(String[] args) {
        System.out.println(&quot;User ID: &quot; + USER_ID);
    }
}

class IdUnavailableException extends Exception {
}</code></pre><p>运行结果：</p>
<pre><code>UnwelcomeGuest.java:10: variable USER_ID might already have been assigned
            USER_ID = GUEST_USER_ID;
            ^
1 error</code></pre><p>结果说明：</p>
<p>该程序看起来很直观。对 getUserIdFromEnvironment 的调用将抛出一个异常, 从而使程序将 GUEST_USER_ID(-1L)赋值给 USER_ID, 并打印 Loggin in as guest。 然后 main 方法执行,使程序打印 User ID: -1。表象再次欺骗了我们,该程序并不能编译。如果你尝试着去编译它, 你将看到和一条错误信息。</p>
<p>问题出在哪里了?USER_ID 域是一个空 final(blank final),它是一个在声明中没有进行初始化操作的 final 域。很明显,只有在对 USER_ID 赋值失败时,才会在 try 语句块中抛出异常,因此,在 catch 语句块中赋值是相 当安全的。不管怎样执行静态初始化操作语句块,只会对 USER_ID 赋值一次,这正是空 final 所要求的。为什么编译器不知道这些呢? 要确定一个程序是否可以不止一次地对一个空 final 进行赋值是一个很困难的问题。事实上,这是不可能的。这等价于经典的停机问题,它通常被认为是不可能解决的。为了能够编写出一个编译器,语言规范在这一点上采用了保守的方式。在程序中,一个空 final 域只有在它是明确未赋过值的地方才可以被赋值。规范长篇大论,对此术语提供了一个准确的但保守的定义。 因为它是保守的,所以编译器必须拒绝某些可以证明是安全的程序。这个谜题就展示了这样的一个程序。幸运的是, 你不必为了编写 Java 程序而去学习那些骇人的用于明确赋值的细节。通常明确赋值规则不会有任何妨碍。如果碰巧你编写了一个真的可能会对一个空final 赋值超过一次的程序,编译器会帮你指出的。只有在极少的情况下,就像本谜题一样, 你才会编写出一个安全的程序, 但是它并不满足规范的形式化要求。编译器的抱怨就好像是你编写了一个不安全的程序一样,而且你必须修改你的程序以满足它。</p>
<p>解决这类问题的最好方式就是将这个烦人的域从空 final 类型改变为普通的final 类型,用一个静态域的初始化操作替换掉静态的初始化语句块。实现这一点的最佳方式是重构静态语句块中的代码为一个助手方法:</p>
<pre><code>public class UnwelcomeGuest {
    public static final long GUEST_USER_ID = -1;
    private static final long USER_ID = getUserIdOrGuest();
    private static long getUserIdOrGuest() {
        try {
            return getUserIdFromEnvironment();
        } catch (IdUnavailableException e) {
            System.out.println(&quot;Logging in as guest&quot;);
            return GUEST_USER_ID;
        }
    }

    private static long getUserIdFromEnvironment() 
        throws IdUnavailableException {
        throw new IdUnavailableException();
    }

    public static void main(String[] args) {
        System.out.println(&quot;User ID: &quot; + USER_ID);
    }
}

class IdUnavailableException extends Exception {
}</code></pre><p>程序的这个版本很显然是正确的,而且比最初的版本根据可读性,因为它为了域值的计算而增加了一个描述性的名字, 而最初的版本只有一个匿名的静态初始化操作语句块。将这样的修改作用于程序,它就可以如我们的期望来运行了。总之,大多数程序员都不需要学习明确赋值规则的细节。该规则的作为通常都是正确的。如果你必须重构一个程序,以消除由明确赋值规则所引发的错误,那么你应该考虑添加一个新方法。这样做除了可以解决明确赋值问题,还可以使程序的可读性提高。</p>
<p><a name="anchor4"></a></p>
<h1 id="谜题4-您好-再见"><a href="#谜题4-您好-再见" class="headerlink" title="谜题4: 您好,再见!"></a>谜题4: 您好,再见!</h1><p>下面的程序将会打印出什么呢?</p>
<pre><code>public class HelloGoodbye {
    public static void main(String[] args) {
        try {
            System.out.println(&quot;Hello world&quot;);
            System.exit(0);
        } finally {
            System.out.println(&quot;Goodbye world&quot;);
        }
    }
}</code></pre><p>运行结果:</p>
<pre><code>Hello world</code></pre><p>结果说明：</p>
<p>这个程序包含两个 println 语句: 一个在 try 语句块中, 另一个在相应的 finally语句块中。try 语句块执行它的 println 语句,并且通过调用 System.exit 来提前结束执行。在此时,你可能希望控制权会转交给 finally 语句块。然而,如果你运行该程序,就会发现它永远不会说再见:它只打印了 Hello world。这是否违背了”Indecisive示例” 中所解释的原则呢? 不论 try 语句块的执行是正常地还是意外地结束, finally 语句块确实都会执行。然而在这个程序中,try 语句块根本就没有结束其执行过程。System.exit 方法将停止当前线程和所有其他当场死亡的线程。finally 子句的出现并不能给予线程继续去执行的特殊权限。</p>
<p>当 System.exit 被调用时,虚拟机在关闭前要执行两项清理工作。首先,它执行所有的关闭挂钩操作,这些挂钩已经注册到了 Runtime.addShutdownHook 上。这对于释放 VM 之外的资源将很有帮助。务必要为那些必须在 VM 退出之前发生的行为关闭挂钩。下面的程序版本示范了这种技术,它可以如我们所期望地打印出 Hello world 和 Goodbye world:</p>
<pre><code>public class HelloGoodbye1 {
    public static void main(String[] args) {
        System.out.println(&quot;Hello world&quot;);
        Runtime.getRuntime().addShutdownHook(
        new Thread() {
            public void run() {
            System.out.println(&quot;Goodbye world&quot;);
            }
        });
        System.exit(0);
    }
}</code></pre><p>VM 执行在 System.exit 被调用时执行的第二个清理任务与终结器有关。如果System.runFinalizerOnExit 或它的魔鬼双胞胎 Runtime.runFinalizersOnExit被调用了,那么 VM 将在所有还未终结的对象上面调用终结器。这些方法很久以前就已经过时了,而且其原因也很合理。无论什么原因,永远不要调用System.runFinalizersOnExit 和 Runtime.runFinalizersOnExit: 它们属于 Java类库中最危险的方法之一[ThreadStop]。调用这些方法导致的结果是,终结器会在那些其他线程正在并发操作的对象上面运行, 从而导致不确定的行为或导致死锁。</p>
<p>总之,System.exit 将立即停止所有的程序线程,它并不会使 finally 语句块得到调用,但是它在停止 VM 之前会执行关闭挂钩操作。当 VM 被关闭时,请使用关闭挂钩来终止外部资源。通过调用 System.halt 可以在不执行关闭挂钩的情况下停止 VM,但是这个方法很少使用。</p>
<p><a name="anchor5"></a></p>
<h1 id="谜题5-不情愿的构造器"><a href="#谜题5-不情愿的构造器" class="headerlink" title="谜题5: 不情愿的构造器"></a>谜题5: 不情愿的构造器</h1><p>下面的程序将打印出什么呢?</p>
<pre><code>public class Reluctant {
    private Reluctant internalInstance = new Reluctant();
    public Reluctant() throws Exception {
        throw new Exception(&quot;I&apos;m not coming out&quot;);
    }
    public static void main(String[] args) {
        try {
            Reluctant b = new Reluctant();
            System.out.println(&quot;Surprise!&quot;);
        } catch (Exception ex) {
            System.out.println(&quot;I told you so&quot;);
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.StackOverflowError
    at Reluctant.&lt;init&gt;(Reluctant.java:3)
    ...</code></pre><p>结果说明：</p>
<p>main 方法调用了 Reluctant 构造器,它将抛出一个异常。你可能期望 catch 子句能够捕获这个异常,并且打印 I told you so。凑近仔细看看这个程序就会发现,Reluctant 实例还包含第二个内部实例,它的构造器也会抛出一个异常。无论抛出哪一个异常,看起来 main 中的 catch 子句都应该捕获它,因此预测该程序将打印 I told you 应该是一个安全的赌注。但是当你尝试着去运行它时,就会发现它压根没有去做这类的事情:它抛出了 StackOverflowError 异常,为什么呢?</p>
<p>与大多数抛出 StackOverflowError 异常的程序一样,本程序也包含了一个无限递归。当你调用一个构造器时,实例变量的初始化操作将先于构造器的程序体而运行[JLS 12.5]。在本谜题中, internalInstance 变量的初始化操作递归调用了构造器,而该构造器通过再次调用 Reluctant 构造器而初始化该变量自己的 internalInstance 域,如此无限递归下去。这些递归调用在构造器程序体获得执行机会之前就会抛出 StackOverflowError 异常,因为 StackOverflowError 是 Error 的子类型而不是 Exception 的子类型,所以 catch 子句无法捕获它。对于一个对象包含与它自己类型相同的实例的情况,并不少见。例如,链接列表节点、树节点和图节点都属于这种情况。你必须非常小心地初始化这样的包含实例,以避免 StackOverflowError 异常。</p>
<p>至于本谜题名义上的题目:声明将抛出异常的构造器,你需要注意,构造器必须声明其实例初始化操作会抛出的所有被检查异常。</p>
<p><a name="anchor6"></a></p>
<h1 id="谜题6-域和流"><a href="#谜题6-域和流" class="headerlink" title="谜题6: 域和流"></a>谜题6: 域和流</h1><p>下面的方法将一个文件拷贝到另一个文件,并且被设计为要关闭它所创建的每一个流,即使它碰到 I/O 错误也要如此。遗憾的是,它并非总是能够做到这一点。为什么不能呢,你如何才能订正它呢?</p>
<pre><code>static void copy(String src, String dest) throws IOException {
    InputStream in = null;
    OutputStream out = null;
    try {
        in = new FileInputStream(src);
        out = new FileOutputStream(dest);
        byte[] buf = new byte[1024];
        int n;
        while ((n = in.read(buf)) &gt; 0)
            out.write(buf, 0, n);
    } finally {
        if (in != null) in.close();
        if (out != null) out.close();
    }
}</code></pre><p>谜题分析：</p>
<p>这个程序看起来已经面面俱到了。其流域(in 和 out)被初始化为 null,并且新的流一旦被创建,它们马上就被设置为这些流域的新值。对于这些域所引用的流,如果不为空,则 finally 语句块会将其关闭。即便在拷贝操作引发了一个 IOException 的情况下,finally 语句块也会在方法返回之前执行。出什么错了呢?</p>
<p>问题在 finally 语句块自身中。close 方法也可能会抛出 IOException 异常。如果这正好发生在 in.close 被调用之时,那么这个异常就会阻止 out.close 被调用,从而使输出流仍保持在开放状态。请注意,该程序违反了”优柔寡断” 的建议:对 close 的调用可能会导致 finally 语句块意外结束。遗憾的是,编译器并不能帮助你发现此问题,因为 close 方法抛出的异常与 read 和 write 抛出的异常类型相同,而其外围方法(copy)声明将传播该异常。解决方式是将每一个 close 都包装在一个嵌套的 try 语句块中。</p>
<p>下面的 finally 语句块的版本可以保证在两个流上都会调用 close:</p>
<pre><code>try {
    // 和之前一样
} finally {
    if (in != null) {
        try {
            in.close();
        } catch (IOException ex) {
            // There is nothing we can do if close fails
        }
    }

    if (out != null) {
        try {
            out.close();
        } catch (IOException ex) {
            // There is nothing we can do if close fails
        }
    }
}</code></pre><p>总之,当你在 finally 语句块中调用 close 方法时,要用一个嵌套的 try-catch 语句来保护它,以防止 IOException 的传播。更一般地讲,对于任何在 finally 语句块中可能会抛出的被检查异常都要进行处理,而不是任其传播。</p>
<p><a name="anchor7"></a></p>
<h1 id="谜题7-异常为循环而抛"><a href="#谜题7-异常为循环而抛" class="headerlink" title="谜题7: 异常为循环而抛"></a>谜题7: 异常为循环而抛</h1><p>下面的程序会打印出什么呢?</p>
<pre><code>public class Loop {
    public static void main(String[] args) {
        int[][] tests = { { 6, 5, 4, 3, 2, 1 }, { 1, 2 },
            { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1 } };
        int successCount = 0;
        try {
            int i = 0;
            while (true) {
                if (thirdElementIsThree(tests[i++]))
                    successCount ++;
            }
        } catch(ArrayIndexOutOfBoundsException e) {
            // No more tests to process
        }
        System.out.println(successCount);
    }
    private static boolean thirdElementIsThree(int[] a) {
        return a.length &gt;= 3 &amp; a[2] == 3;
    }
}</code></pre><p>运行结果：</p>
<pre><code>0</code></pre><p>结果说明：</p>
<p>该程序主要说明了两个问题。</p>
<p><strong>第1个问题：不应该使用异常作为终止循环的手段！</strong></p>
<p>该程序用 thirdElementIsThree 方法测试了 tests 数组中的每一个元素。遍历这个数组的循环显然是非传统的循环:它不是在循环变量等于数组长度的时候终止,而是在它试图访问一个并不在数组中的元素时终止。尽管它是非传统的,但是这个循环应该可以工作。</p>
<p>如果传递给 thirdElementIsThree 的参数具有 3 个或更多的元素,并且其第三个元素等于 3,那么该方法将返回 true。对于 tests中的 5 个元素来说,有 2 个将返回 true,因此看起来该程序应该打印 2。如果你运行它,就会发现它打印的时 0。肯定是哪里出了问题,你能确定吗? 事实上,这个程序犯了两个错误。第一个错误是该程序使用了一种可怕的循环惯用法,该惯用法依赖的是对数组的访问会抛出异常。这种惯用法不仅难以阅读, 而且运行速度还非常地慢。不要使用异常来进行循环控制;应该只为异常条件而使用异常。为了纠正这个错误,可以将整个 try-finally 语句块替换为循环遍历数组的标准惯用法:</p>
<pre><code>for (int i = 0; i &lt; test.length; i++)
    if (thirdElementIsThree(tests[i]))
        successCount++;</code></pre><p>如果你使用的是 5.0 或者是更新的版本,那么你可以用 for 循环结构来代替:</p>
<pre><code>for (int[] test : tests)
    if(thirdElementIsThree(test))
        successCount++;</code></pre><p><strong>第2个问题: 主要比较”&amp;操作符” 和 “&amp;&amp;操作符”的区别。</strong>注意示例中的操作符是&amp;，这是按位进行”与”操作。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/04/15/java/exception/2012-04-15-exception/" itemprop="url">Java异常(二) 《Effective Java》中关于异常处理的几条建议</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-04-15T01:01:00.000Z" itemprop="datePublished">4月 15 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            21 分钟 read (About 3109 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章是从《Effective Java》摘录整理出来的关于异常处理的几条建议。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1条: 只针对不正常的情况才使用异常</a><br><a href="#anchor2">第2条: 对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常</a><br><a href="#anchor3">第3条: 避免不必要的使用被检查的异常</a><br><a href="#anchor4">第4条: 尽量使用标准的异常</a><br><a href="#anchor5">第5条: 抛出的异常要适合于相应的抽象</a><br><a href="#anchor6">第6条: 每个方法抛出的异常都要有文档</a><br><a href="#anchor7">第7条: 在细节消息中包含失败 – 捕获消息</a><br><a href="#anchor8">第8条: 努力使失败保持原子性</a><br><a href="#anchor9">第9条: 不要忽略异常</a>  </p>
</blockquote>
<p>它们对应原书中”第8章 异常”部分的第39-47条。</p>
<p><a name="anchor1"></a></p>
<h1 id="第1条-只针对不正常的情况才使用异常"><a href="#第1条-只针对不正常的情况才使用异常" class="headerlink" title="第1条: 只针对不正常的情况才使用异常"></a>第1条: 只针对不正常的情况才使用异常</h1><p>建议：异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。</p>
<p>通过比较下面的两份代码进行说明。</p>
<p><strong>代码1</strong></p>
<pre><code>try {
    int i=0;
    while (true) {
        arr[i]=0;
        i++;
    }
} catch (IndexOutOfBoundsException e) {
}</code></pre><p><strong>代码2</strong></p>
<pre><code>for (int i=0; i&lt;arr.length; i++) {
    arr[i]=0;
}</code></pre><p>两份代码的作用都是遍历arr数组，并设置数组中每一个元素的值为0。代码1的是通过异常来终止，看起来非常难懂，代码2是通过数组边界来终止。我们应该避免使用代码1这种方式，主要原因有三点：  </p>
<blockquote>
<ol>
<li>异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。  </li>
<li>把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。  </li>
<li>对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。</li>
</ol>
</blockquote>
<p>实际上，基于异常的模式比标准模式要慢得多。测试代码如下：</p>
<pre><code>public class Advice1 {

    private static int[] arr = new int[]{1,2,3,4,5};
    private static int SIZE = 10000;

    public static void main(String[] args) {

        long s1 = System.currentTimeMillis();
        for (int i=0; i&lt;SIZE; i++)
            endByRange(arr);
        long e1 = System.currentTimeMillis();
        System.out.println(&quot;endByRange time:&quot;+(e1-s1)+&quot;ms&quot; );

        long s2 = System.currentTimeMillis();
        for (int i=0; i&lt;SIZE; i++)
            endByException(arr);
        long e2 = System.currentTimeMillis();
        System.out.println(&quot;endByException time:&quot;+(e2-s2)+&quot;ms&quot; );
    }

    // 遍历arr数组: 通过异常的方式
    private static void endByException(int[] arr) {
        try {
            int i=0;
            while (true) {
                arr[i]=0;
                i++;
                //System.out.println(&quot;endByRange: arr[&quot;+i+&quot;]=&quot;+arr[i]);
            }
        } catch (IndexOutOfBoundsException e) {
        }
    }

    // 遍历arr数组: 通过边界的方式
    private static void endByRange(int[] arr) {
        for (int i=0; i&lt;arr.length; i++) {
            arr[i]=0;
            //System.out.println(&quot;endByException: arr[&quot;+i+&quot;]=&quot;+arr[i]);
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>endByRange time:8ms
endByException time:16ms</code></pre><p>结果说明：通过异常遍历的速度比普通方式遍历数组慢很多！</p>
<p><a name="anchor2"></a></p>
<h1 id="第2条-对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常"><a href="#第2条-对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常" class="headerlink" title="第2条: 对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常"></a>第2条: 对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常</h1><table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>运行时异常</td>
<td>RuntimeException类及其子类都被称为运行时异常。</td>
</tr>
<tr>
<td>被检查的异常</td>
<td>Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常</td>
</tr>
</tbody></table>
<p>它们的区别是：<strong>Java编译器会对”被检查的异常”进行检查，而对”运行时异常”不会检查。</strong></p>
<p>也就是说，对于被检查的异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。而对于运行时异常，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。当然，虽说Java编译器不会检查运行时异常，但是，我们同样可以通过throws对该异常进行说明，或通过try-catch进行捕获。</p>
<p>rithmeticException(例如，除数为0)，IndexOutOfBoundsException(例如，数组越界)等都属于运行时异常。对于这种异常，我们应该通过修改代码进行避免它的产生。而对于被检查的异常，则可以通过处理让程序恢复运行。例如，假设因为一个用户没有存储足够数量的前，所以他在企图在一个收费电话上进行呼叫就会失败；于是就将一个被检查异常抛出。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3条-避免不必要的使用被检查的异常"><a href="#第3条-避免不必要的使用被检查的异常" class="headerlink" title="第3条: 避免不必要的使用被检查的异常"></a>第3条: 避免不必要的使用被检查的异常</h1><p>“被检查的异常”是Java语言的一个很好的特性。与返回代码不同，”被检查的异常”会强迫程序员处理例外的条件，大大提高了程序的可靠性。</p>
<p>但是，过分使用被检查异常会使API用起来非常不方便。如果一个方法抛出一个或多个被检查的异常，那么调用该方法的代码则必须在一个或多个catch语句块中处理这些异常，或者必须通过throws声明抛出这些异常。 无论是通过catch处理，还是通过throws声明抛出，都给程序员添加了不可忽略的负担。</p>
<p>适用于”被检查的异常”必须同时满足两个条件：第一，即使正确使用API并不能阻止异常条件的发生。第二，一旦产生了异常，使用API的程序员可以采取有用的动作对程序进行处理。</p>
<p><a name="anchor4"></a></p>
<h1 id="第4条-尽量使用标准的异常"><a href="#第4条-尽量使用标准的异常" class="headerlink" title="第4条: 尽量使用标准的异常"></a>第4条: 尽量使用标准的异常</h1><p>代码重用是值得提倡的，这是一条通用规则，异常也不例外。重用现有的异常有几个好处：<br>第一，它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。<br>第二，对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。<br>第三，异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</p>
<p>Java标准异常中有几个是经常被使用的异常。如下表格：</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>使用场合</th>
</tr>
</thead>
<tbody><tr>
<td>IllegalArgumentException</td>
<td>参数的值不合适</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>参数的状态不合适</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>在null被禁止的情况下参数值为null</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>下标越界</td>
</tr>
<tr>
<td>ConcurrentModificationException</td>
<td>在禁止并发修改的情况下，对象检测到并发修改</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>对象不支持客户请求的方法</td>
</tr>
</tbody></table>
<p>虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上！</p>
<p>最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。</p>
<p><a name="anchor5"></a></p>
<h1 id="第5条-抛出的异常要适合于相应的抽象"><a href="#第5条-抛出的异常要适合于相应的抽象" class="headerlink" title="第5条: 抛出的异常要适合于相应的抽象"></a>第5条: 抛出的异常要适合于相应的抽象</h1><p>如果一个方法抛出的异常与它执行的任务没有明显的关联关系，这种情形会让人不知所措。当一个方法传递一个由低层抽象抛出的异常时，往往会发生这种情况。这种情况发生时，不仅让人困惑，而且也”污染”了高层API。</p>
<p>为了避免这个问题，高层实现应该捕获低层的异常，同时抛出一个可以按照高层抽象进行介绍的异常。这种做法被称为”异常转译(exception translation)”。</p>
<p>例如，在Java的集合框架AbstractSequentialList的get()方法如下(基于JDK1.7.0_40)：</p>
<pre><code>public E get(int index) {
    try {
        return listIterator(index).next();
    } catch (NoSuchElementException exc) {
        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);
    }
}</code></pre><p>listIterator(index)会返回ListIterator对象，调用该对象的next()方法可能会抛出NoSuchElementException异常。而在get()方法中，抛出NoSuchElementException异常会让人感到困惑。所以，get()对NoSuchElementException进行了捕获，并抛出了IndexOutOfBoundsException异常。即，相当于将NoSuchElementException转译成了IndexOutOfBoundsException异常。</p>
<p><a name="anchor6"></a></p>
<h1 id="第6条-每个方法抛出的异常都要有文档"><a href="#第6条-每个方法抛出的异常都要有文档" class="headerlink" title="第6条: 每个方法抛出的异常都要有文档"></a>第6条: 每个方法抛出的异常都要有文档</h1><p>要单独的声明被检查的异常，并且利用Javadoc的@throws标记，准确地记录下每个异常被抛出的条件。</p>
<p>如果一个类中的许多方法处于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的。</p>
<p><a name="anchor7"></a></p>
<h1 id="第7条-在细节消息中包含失败-–-捕获消息"><a href="#第7条-在细节消息中包含失败-–-捕获消息" class="headerlink" title="第7条: 在细节消息中包含失败 – 捕获消息"></a>第7条: 在细节消息中包含失败 – 捕获消息</h1><p>简而言之，当我们自定义异常或者抛出异常时，应该包含失败相关的信息。</p>
<p>当一个程序由于一个未被捕获的异常而失败的时候，系统会自动打印出该异常的栈轨迹。在栈轨迹中包含该异常的字符串表示。典型情况下它包含该异常类的类名，以及紧随其后的细节消息。</p>
<p><a name="anchor8"></a></p>
<h1 id="第8条-努力使失败保持原子性"><a href="#第8条-努力使失败保持原子性" class="headerlink" title="第8条: 努力使失败保持原子性"></a>第8条: 努力使失败保持原子性</h1><p>当一个对象抛出一个异常之后，我们总期望这个对象仍然保持在一种定义良好的可用状态之中。对于被检查的异常而言，这尤为重要，因为调用者通常期望从被检查的异常中恢复过来。</p>
<p>一般而言，一个失败的方法调用应该保持使对象保持在”它在被调用之前的状态”。具有这种属性的方法被称为具有”失败原子性(failure atomic)”。可以理解为，失败了还保持着原子性。对象保持”失败原子性”的方式有几种：</p>
<p>(01) 设计一个非可变对象。</p>
<p>(02) 对于在可变对象上执行操作的方法，获得”失败原子性”的最常见方法是，在执行操作之前检查参数的有效性。如下(Stack.java中的pop方法)：</p>
<pre><code>public Object pop() {
    if (size==0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null;
    return result;
}</code></pre><p>(03) 与上一种方法类似，可以对计算处理过程调整顺序，使得任何可能会失败的计算部分都发生在对象状态被修改之前。</p>
<p>(04) 编写一段恢复代码，由它来解释操作过程中发生的失败，以及使对象回滚到操作开始之前的状态上。</p>
<p>(05) 在对象的一份临时拷贝上执行操作，当操作完成之后再把临时拷贝中的结果复制给原来的对象。</p>
<p>虽然”保持对象的失败原子性”是期望目标，但它并不总是可以做得到。例如，如果多个线程企图在没有适当的同步机制的情况下，并发的访问一个对象，那么该对象就有可能被留在不一致的状态中。</p>
<p>即使在可以实现”失败原子性”的场合，它也不是总被期望的。对于某些操作，它会显著的增加开销或者复杂性。<br>总的规则是：作为方法规范的一部分，任何一个异常都不应该改变对象调用该方法之前的状态，如果这条规则被违反，则API文档中应该清楚的指明对象将会处于什么样的状态。</p>
<p><a name="anchor9"></a></p>
<h1 id="第9条-不要忽略异常"><a href="#第9条-不要忽略异常" class="headerlink" title="第9条: 不要忽略异常"></a>第9条: 不要忽略异常</h1><p>当一个API的设计者声明一个方法会抛出某个异常的时候，他们正在试图说明某些事情。所以，请不要忽略它！忽略异常的代码如下：</p>
<pre><code>try {
    ...
} catch (SomeException e) {
}</code></pre><p>空的catch块会使异常达不到应有的目的，异常的目的是强迫你处理不正常的条件。忽略一个异常，就如同忽略一个火警信号一样 – 若把火警信号器关闭了，那么当真正的火灾发生时，就没有人看到火警信号了。所以，至少catch块应该包含一条说明，用来解释为什么忽略这个异常是合适的。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/04/14/java/exception/2012-04-14-exception/" itemprop="url">Java异常(一) Java异常简介及其架构</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-04-14T01:01:00.000Z" itemprop="datePublished">4月 14 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 read (About 1991 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章对Java中的异常进行介绍。</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 Java异常简介</a><br><a href="#anchor2">第2部分 Java异常框架</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-Java异常简介"><a href="#第1部分-Java异常简介" class="headerlink" title="第1部分 Java异常简介"></a>第1部分 Java异常简介</h1><p>Java异常是Java提供的一种识别及响应错误的一致性机制。</p>
<p>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出。</p>
<p>Java异常机制用到的几个关键字：try、catch、finally、throw、throws。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>try</td>
<td>用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</td>
</tr>
<tr>
<td>catch</td>
<td>用于捕获异常。catch用来捕获try语句块中发生的异常。</td>
</tr>
<tr>
<td>finally</td>
<td>finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</td>
</tr>
<tr>
<td>throw</td>
<td>用于抛出异常。</td>
</tr>
<tr>
<td>throws</td>
<td>用在方法签名中，用于声明该方法可能抛出的异常。</td>
</tr>
</tbody></table>
<p>下面通过几个示例对这几个关键字进行简单了解。</p>
<h2 id="示例一-了解try和catch基本用法"><a href="#示例一-了解try和catch基本用法" class="headerlink" title="示例一: 了解try和catch基本用法"></a>示例一: 了解try和catch基本用法</h2><pre><code>public class Demo1 {

    public static void main(String[] args) {
        try {
            int i = 10/0;
              System.out.println(&quot;i=&quot;+i); 
        } catch (ArithmeticException e) {
              System.out.println(&quot;Caught Exception&quot;); 
            System.out.println(&quot;e.getMessage(): &quot; + e.getMessage()); 
            System.out.println(&quot;e.toString(): &quot; + e.toString()); 
            System.out.println(&quot;e.printStackTrace():&quot;);
            e.printStackTrace(); 
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>Caught Exception
e.getMessage(): / by zero
e.toString(): java.lang.ArithmeticException: / by zero
e.printStackTrace():
java.lang.ArithmeticException: / by zero
    at Demo1.main(Demo1.java:6)</code></pre><p>结果说明：在try语句块中有除数为0的操作，该操作会抛出java.lang.ArithmeticException异常。通过catch，对该异常进行捕获。<br>观察结果我们发现，并没有执行System.out.println(“i=”+i)。这说明try语句块发生异常之后，try语句块中的剩余内容就不会再被执行了。</p>
<h2 id="示例二-了解finally的基本用法"><a href="#示例二-了解finally的基本用法" class="headerlink" title="示例二: 了解finally的基本用法"></a>示例二: 了解finally的基本用法</h2><p>在”示例一”的基础上，我们添加finally语句。</p>
<pre><code>public class Demo2 {

    public static void main(String[] args) {
        try {
            int i = 10/0;
              System.out.println(&quot;i=&quot;+i); 
        } catch (ArithmeticException e) {
              System.out.println(&quot;Caught Exception&quot;); 
            System.out.println(&quot;e.getMessage(): &quot; + e.getMessage()); 
            System.out.println(&quot;e.toString(): &quot; + e.toString()); 
            System.out.println(&quot;e.printStackTrace():&quot;);
            e.printStackTrace(); 
        } finally {
            System.out.println(&quot;run finally&quot;);
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>Caught Exception
e.getMessage(): / by zero
e.toString(): java.lang.ArithmeticException: / by zero
e.printStackTrace():
java.lang.ArithmeticException: / by zero
    at Demo2.main(Demo2.java:6)
run finally</code></pre><p>结果说明：最终执行了finally语句块。</p>
<h2 id="示例三-了解throws和throw的基本用法"><a href="#示例三-了解throws和throw的基本用法" class="headerlink" title="示例三: 了解throws和throw的基本用法"></a>示例三: 了解throws和throw的基本用法</h2><p>throws是用于声明抛出的异常，而throw是用于抛出异常。</p>
<pre><code>class MyException extends Exception {
    public MyException() {}
    public MyException(String msg) {
        super(msg);
    }
}

public class Demo3 {

    public static void main(String[] args) {
        try {
            test();
        } catch (MyException e) {
            System.out.println(&quot;Catch My Exception&quot;);
            e.printStackTrace();
        }
    }
    public static void test() throws MyException{
        try {
            int i = 10/0;
              System.out.println(&quot;i=&quot;+i); 
        } catch (ArithmeticException e) {
            throw new MyException(&quot;This is MyException&quot;); 
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>Catch My Exception
MyException: This is MyException
    at Demo3.test(Demo3.java:24)
    at Demo3.main(Demo3.java:13)</code></pre><p>结果说明：MyException是继承于Exception的子类。test()的try语句块中产生ArithmeticException异常(除数为0)，并在catch中捕获该异常；接着抛出MyException异常。main()方法对test()中抛出的MyException进行捕获处理。</p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-Java异常框架"><a href="#第2部分-Java异常框架" class="headerlink" title="第2部分 Java异常框架"></a>第2部分 Java异常框架</h1><p>Java异常架构图</p>
<p><img src="/media/pic/java/exception/exception01-01.jpg" alt="img"></p>
<h2 id="1-Throwable"><a href="#1-Throwable" class="headerlink" title="1. Throwable"></a>1. Throwable</h2><p>Throwable是 Java 语言中所有错误或异常的超类。<br>Throwable包含两个子类: Error 和 Exception。它们通常用于指示发生了异常情况。<br>Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。</p>
<h2 id="2-Exception"><a href="#2-Exception" class="headerlink" title="2. Exception"></a>2. Exception</h2><p>Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。</p>
<h2 id="3-RuntimeException"><a href="#3-RuntimeException" class="headerlink" title="3. RuntimeException"></a>3. RuntimeException</h2><p>RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。</p>
<p>编译器不会检查RuntimeException异常。例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！<br>如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>
<h2 id="4-Error"><a href="#4-Error" class="headerlink" title="4. Error"></a>4. Error</h2><p>和Exception一样，Error也是Throwable的子类。它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。<br>和RuntimeException一样，编译器也不会检查Error。</p>
<p>Java将可抛出(Throwable)的结构分为三种类型：被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</p>
<br>
**(01) 运行时异常**

<p>定义: RuntimeException及其子类都被称为运行时异常。<br>特点: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。<br>&nbsp;&nbsp;&nbsp;&nbsp; 虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。<br>&nbsp;&nbsp;&nbsp;&nbsp; 如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>
<br>
**(02) 被检查的异常**

<p>定义: Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。<br>特点: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。<br>&nbsp;&nbsp;&nbsp;&nbsp; 被检查异常通常都是可以恢复的。</p>
<br>
**(03) 错误**

<p>定义: Error类及其子类。<br>特点: 和运行时异常一样，编译器也不会对错误进行检查。<br>&nbsp;&nbsp;&nbsp;&nbsp; 当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。<br>&nbsp;&nbsp;&nbsp;&nbsp; 按照Java惯例，我们是不应该是实现任何新的Error子类的！</p>
<p>对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是：对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/03/04/java/others/2012-03-04-reflection/" itemprop="url">Java 反射机制(包括组成、结构、示例说明等内容)</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-03-04T01:02:00.000Z" itemprop="datePublished">3月 4 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            38 分钟 read (About 5660 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 Java 反射机制介绍</a><br><a href="#anchor2">第2部分 Class 详细说明</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-Java-反射机制介绍"><a href="#第1部分-Java-反射机制介绍" class="headerlink" title="第1部分 Java 反射机制介绍"></a>第1部分 Java 反射机制介绍</h1><p>Java 反射机制。<br>通俗来讲呢，就是在运行状态中，我们可以根据“类的部分已经的信息”来还原“类的全部的信息”。这里“类的部分已经的信息”，可以是“类名”或“类的对象”等信息。“类的全部信息”就是指“类的属性，方法，继承关系和Annotation注解”等内容。</p>
<p>举个简单的例子：假设对于类ReflectionTest.java，我们知道的唯一信息是它的类名是“com.skywang.Reflection”。这时，我们想要知道ReflectionTest.java的其它信息(比如它的构造函数，它的成员变量等等)，要怎么办呢？</p>
<p>这就需要用到“反射”。通过反射，我们可以解析出ReflectionTest.java的完整信息，包括它的构造函数，成员变量，继承关系等等。</p>
<p>在了解了“java 反射机制”的概念之后，接下来思考一个问题：如何根据类的类名，来获取类的完整信息呢？</p>
<p>这个过程主要分为两步：<br>第1步：根据“类名”来获取对应类的Class对象。<br>第2步：通过Class对象的函数接口，来读取“类的构造函数，成员变量”等信息。</p>
<p>下面，我们根据示例来加深对这个概念的理解。示例如下(Demo1.java):</p>
<pre><code>package com.skywang.test;

import java.lang.Class;

public class Demo1 {

    public static void main(String[] args) {

        try {
            // 根据“类名”获取 对应的Class对象
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);

            // 新建对象。newInstance()会调用类不带参数的构造函数
            Object obj = cls.newInstance();

            System.out.println(&quot;cls=&quot;+cls);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Person {
    public Person() {
        System.out.println(&quot;create Person&quot;);
    }
}</code></pre><p>运行结果：</p>
<pre><code>create Person
cls=class com.skywang.test.Person</code></pre><p>说明：<br>(01) Person类的完整包名是”com.skywang.test.Person”。而 Class.forName(“com.skywang.test.Person”); 这一句的作用是，就是根据Person的包名来获取Person的Class对象。<br>(02) 接着，我们调用Class对象的newInstance()方法，创建Person对象。</p>
<p>现在，我们知道了“java反射机制”的概念以及它的原理。有了这个总体思想之后，接下来，我们可以开始对反射进行深入研究了。</p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-Class-详细说明"><a href="#第2部分-Class-详细说明" class="headerlink" title="第2部分 Class 详细说明"></a>第2部分 Class 详细说明</h1><h2 id="1-获取Class对象的方法"><a href="#1-获取Class对象的方法" class="headerlink" title="1. 获取Class对象的方法"></a>1. 获取Class对象的方法</h2><p>我这里总结了4种常用的“获取Class对象”的方法：<br><strong>方法1</strong>：Class.forName(“类名字符串”) （注意：类名字符串必须是全称，包名+类名）<br><strong>方法2</strong>：类名.class<br><strong>方法3</strong>：实例对象.getClass()<br><strong>方法4</strong>：”类名字符串”.getClass()</p>
<p>下面，我们通过示例演示这4种方法。示例如下(Demo2.java):</p>
<pre><code>package com.skywang.test;

import java.lang.Class;

public class Demo2 {

    public static void main(String[] args) {

        try {
            // 方法1：Class.forName(&quot;类名字符串&quot;)  （注意：类名字符串必须是全称，包名+类名）
            //Class cls1 = Class.forName(&quot;com.skywang.test.Person&quot;);
            Class&lt;?&gt; cls1 = Class.forName(&quot;com.skywang.test.Person&quot;);
            //Class&lt;Person&gt; cls1 = Class.forName(&quot;com.skywang.test.Person&quot;);

            // 方法2：类名.class
            Class cls2 = Person.class; 

            // 方法3：实例对象.getClass()
            Person person = new Person();
            Class cls3 = person.getClass();

            // 方法4：&quot;类名字符串&quot;.getClass()
            String str = &quot;com.skywang.test.Person&quot;; 
            Class cls4 = str.getClass();

            System.out.printf(&quot;cls1=%s, cls2=%s, cls3=%s, cls4=%s\n&quot;, cls1, cls2, cls3, cls4);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Person {
    public Person() {
        System.out.println(&quot;create Person&quot;);
    }
}</code></pre><p>运行结果：</p>
<pre><code>create Person
cls1=class com.skywang.test.Person, cls2=class com.skywang.test.Person, cls3=class com.skywang.test.Person, cls4=class java.lang.String</code></pre><h2 id="2-Class的API说明"><a href="#2-Class的API说明" class="headerlink" title="2 Class的API说明"></a>2 Class的API说明</h2><p>Class的全部API如下表:</p>
<pre><code>public static Class    forName(String className)
public static Class    forName(String name, boolean initialize, ClassLoader loader)
public Constructor    getConstructor(Class[] parameterTypes)
public Constructor[]    getConstructors()
public Constructor    getDeclaredConstructor(Class[] parameterTypes)
public Constructor[]    getDeclaredConstructors()
public Constructor    getEnclosingConstructor()
public Method    getMethod(String name, Class[] parameterTypes)
public Method[]    getMethods()
public Method    getDeclaredMethod(String name, Class[] parameterTypes)
public Method[]    getDeclaredMethods()
public Method    getEnclosingMethod()
public Field    getField(String name)
public Field[]    getFields()
public Field    getDeclaredField(String name)
public Field[]    getDeclaredFields()
public Type[]    getGenericInterfaces()
public Type    getGenericSuperclass()
public Annotation&lt;A&gt;    getAnnotation(Class annotationClass)
public Annotation[]    getAnnotations()
public Annotation[]    getDeclaredAnnotations()
public boolean    isAnnotation()
public boolean    isAnnotationPresent(Class annotationClass)
public boolean    isAnonymousClass()
public boolean    isArray()
public boolean    isAssignableFrom(Class cls)
public boolean    desiredAssertionStatus()
public Class&lt;U&gt;    asSubclass(Class clazz)
public Class    getSuperclass()
public Class    getComponentType()
public Class    getDeclaringClass()
public Class    getEnclosingClass()
public Class[]    getClasses()
public Class[]    getDeclaredClasses()
public Class[]    getInterfaces()
public boolean    isEnum()
public boolean    isInstance(Object obj)
public boolean    isInterface()
public boolean    isLocalClass()
public boolean    isMemberClass()
public boolean    isPrimitive()
public boolean    isSynthetic()
public String    getSimpleName()
public String    getName()
public String    getCanonicalName()
public String    toString()
public ClassLoader    getClassLoader()
public Package    getPackage()
public int    getModifiers()
public ProtectionDomain    getProtectionDomain()
public URL    getResource(String name)
public InputStream    getResourceAsStream(String name)
public Object    cast(Object obj)
public Object    newInstance()
public Object[]    getSigners()
public Object[]    getEnumConstants()
public TypeVariable[]    getTypeParameters()</code></pre><p>我们根据类的特性，将Class中的类分为4部分进行说明：构造函数，成员方法，成员变量，类的其它信息(如注解、包名、类名、继承关系等等)。Class中涉及到Annotation(注解)的相关API，可以点击查看前一章节关于Annotation的详细介绍。</p>
<h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><p>“构造函数”相关API</p>
<pre><code>// 获取“参数是parameterTypes”的public的构造函数
public Constructor    getConstructor(Class[] parameterTypes)
// 获取全部的public的构造函数
public Constructor[]    getConstructors()
// 获取“参数是parameterTypes”的，并且是类自身声明的构造函数，包含public、protected和private方法。
public Constructor    getDeclaredConstructor(Class[] parameterTypes)
// 获取类自身声明的全部的构造函数，包含public、protected和private方法。
public Constructor[]    getDeclaredConstructors()
// 如果这个类是“其它类的构造函数中的内部类”，调用getEnclosingConstructor()就是这个类所在的构造函数；若不存在，返回null。
public Constructor    getEnclosingConstructor()</code></pre><p>接下来，我们通过示例对这些API进行说明。示例代码(DemoClassContructor.java)如下：</p>
<pre><code>package com.skywang.test;

import java.lang.Class;
import java.lang.reflect.Constructor;

/**
 * java Class类的Constructor相关API的测试函数
 *
 * @author skywang
 */
public class DemoClassContructor {

    public static void main(String[] args) {

        // getDeclaredConstructor() 的测试函数
        testGetDeclaredConstructor() ;

        // getConstructor() 的测试函数
        testGetConstructor() ;

        // getEnclosingConstructor() 的测试函数
        testGetEnclosingConstructor() ;
    }

    /**
     * getDeclaredConstructor() 的测试函数
     */
    public static void testGetDeclaredConstructor() {
        try {
            // 获取Person类的Class
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);

            // 根据class，获取构造函数
            Constructor cst1 = cls.getDeclaredConstructor();
            Constructor cst2 = cls.getDeclaredConstructor(new Class[]{String.class});
            Constructor cst3 = cls.getDeclaredConstructor(new Class[]{String.class, int.class, Gender.class});

            // 根据构造函数，创建相应的对象
            cst1.setAccessible(true); // 因为Person中Person()是private的，所以这里要设置为可访问
            Object p1 = cst1.newInstance();
            Object p2 = cst2.newInstance(&quot;Juce&quot;);
            Object p3 = cst3.newInstance(&quot;Jody&quot;, 34, Gender.MALE);

            System.out.printf(&quot;%-30s: p1=%s, p2=%s, p3=%s\n&quot;, 
                    &quot;getConstructor()&quot;, p1, p2, p3);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    /**
     * getConstructor() 的测试函数
     */
    public static void testGetConstructor() {
        try {
            // 获取Person类的Class
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);

            // 根据class，获取构造函数
            //Constructor cst1 = cls.getConstructor(); // 抛出异常，因为默认构造函数是private权限。
            //Constructor cst2 = cls.getConstructor(new Class[]{String.class});// 抛出异常，因为该构造函数是protected权限。
            Constructor cst3 = cls.getConstructor(new Class[]{String.class, int.class, Gender.class});

            // 根据构造函数，创建相应的对象
            //Object p1 = cst1.newInstance();
            //cst1.setAccessible(true); // 因为Person中Person()是private的，所以这里要设置为可访问
            //Object p1 = cst1.newInstance();
            //Object p2 = cst2.newInstance(&quot;Kim&quot;);
            Object p3 = cst3.newInstance(&quot;Katter&quot;, 36, Gender.MALE);

            System.out.printf(&quot;%-30s: p3=%s\n&quot;, 
                    &quot;getConstructor()&quot;, p3);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * getEnclosingConstructor() 的测试函数
     */
    public static void testGetEnclosingConstructor() {
        try {
            // 获取Person类的Class
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);

            // 根据class，调用Person类中有内部类InnerA的构造函数
            Constructor cst = cls.getDeclaredConstructor(new Class[]{String.class, int.class});

            // 根据构造函数，创建相应的对象
            Object obj = cst.newInstance(&quot;Ammy&quot;, 18);

            System.out.printf(&quot;%-30s: obj=%s\n&quot;, 
                    &quot;getEnclosingConstructor()&quot;, obj);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


// 枚举类型。表示“性别”
enum Gender{  
    MALE, FEMALE
} 
// 人
class Person {
    private Gender gender;  // 性别
    private int age;        // 年龄
    private String name;    // 姓名

    private Person() {
        this.name = &quot;unknown&quot;;
        this.age = 0;
        this.gender = Gender.FEMALE;
        System.out.println(&quot;call--\&quot;private Person()\&quot;&quot;);
    }
    protected Person(String name) {
        this.name = name;
        this.age = 0;
        this.gender = Gender.FEMALE;
        System.out.println(&quot;call--\&quot;protected Person(String name)\&quot;&quot;);
    }
    public Person(String name, int age, Gender gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
        System.out.println(&quot;call--\&quot;public Person(String name, int age, Gender gender)\&quot;&quot;);
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        this.gender = Gender.FEMALE;
        //内部类在构造方法中
        class InnerA{
        }
        // 获取InnerA的Class对象
        Class cls = InnerA.class;

        // 获取“封闭该内部类(InnerA)”的构造方法
        Constructor cst = cls.getEnclosingConstructor();

        System.out.println(&quot;call--\&quot;public Person(String name, int age)\&quot; cst=&quot;+cst);
    }
    @Override
    public String toString() {
        return &quot;(&quot;+name+&quot;, &quot;+age+&quot;, &quot;+gender+&quot;)&quot;;
    }
}</code></pre><p>注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。</p>
<p>运行结果：</p>
<pre><code>call--&quot;private Person()&quot;
call--&quot;protected Person(String name)&quot;
call--&quot;public Person(String name, int age, Gender gender)&quot;
getConstructor() : p1=(unknown, 0, FEMALE), p2=(Juce, 0, FEMALE), p3=(Jody, 34, MALE)
call--&quot;public Person(String name, int age, Gender gender)&quot;
getConstructor() : p3=(Katter, 36, MALE)
call--&quot;public Person(String name, int age)&quot; cst=public com.skywang.test.Person(java.lang.String,int)
getEnclosingConstructor() : obj=(Ammy, 18, FEMALE)</code></pre><p>说明：<br>(01) 首先，要搞清楚Person类，它是我们自定义的类。专门用来测试这些API的。Person中有一个成员变量gender；它是Gender对象，Gender是一个枚举类。取值可以是MALE或者FEMALE。</p>
<p>(02) testGetDeclaredConstructor() 是“getDeclaredConstructor() 的测试函数”。getDeclaredConstructor()可以“获取类中任意的构造函数，包含public、protected和private方法”。</p>
<p>(03) testGetConstructor() 是“getConstructor() 的测试函数”。getConstructor()只能“获取类中public的构造函数”。</p>
<p>(04) testGetEnclosingConstructor() 是“getEnclosingConstructor() 的测试函数”。<br>关于getEnclosingConstructor()的介绍，官方说法是“如果该 Class 对象表示构造方法中的一个本地或匿名类，则返回 Constructor 对象，它表示底层类的立即封闭构造方法。否则返回 null。” 通俗点来说，就是<strong><em>“如果一个类A的构造函数中定义了一个内部类InnerA，则通过InnerA的Class对象调用getEnclosingConstructor()方法，可以获取类A的这个构造函数”。</em></strong></p>
<h3 id="2-2-成员方法"><a href="#2-2-成员方法" class="headerlink" title="2.2 成员方法"></a>2.2 成员方法</h3><p> “成员方法”相关API</p>
<pre><code>// 获取“名称是name，参数是parameterTypes”的public的函数(包括从基类继承的、从接口实现的所有public函数)
public Method    getMethod(String name, Class[] parameterTypes)
// 获取全部的public的函数(包括从基类继承的、从接口实现的所有public函数)
public Method[]    getMethods()
// 获取“名称是name，参数是parameterTypes”，并且是类自身声明的函数，包含public、protected和private方法。
public Method    getDeclaredMethod(String name, Class[] parameterTypes)
// 获取全部的类自身声明的函数，包含public、protected和private方法。
public Method[]    getDeclaredMethods()
// 如果这个类是“其它类中某个方法的内部类”，调用getEnclosingMethod()就是这个类所在的方法；若不存在，返回null。
public Method    getEnclosingMethod()</code></pre><p>接下来，我们通过示例对这些API进行说明。示例代码(DemoClassMethod.java)如下：</p>
<pre><code>package com.skywang.test;

import java.lang.Class;
import java.lang.reflect.Method;

/**
 * java Class类的Method相关API的测试函数
 *
 * @author skywang
 */
public class DemoClassMethod {

    public static void main(String[] args) {

            // getDeclaredMethod() 的测试函数
            testGetDeclaredMethod() ;

            // getMethod() 的测试函数
            testGetMethod() ;

            // getEnclosingMethod() 的测试函数
            testGetEnclosingMethod() ;
    }

    /**
     * getDeclaredMethod() 的测试函数
     */
    public static void testGetDeclaredMethod() {
        try {
            // 获取Person类的Class
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);
            // 根据class，调用类的默认构造函数(不带参数)
            Object person = cls.newInstance();

            // 获取Person中的方法
            Method mSetName = cls.getDeclaredMethod(&quot;setName&quot;, new Class[]{String.class});
            Method mGetName = cls.getDeclaredMethod(&quot;getName&quot;, new Class[]{});
            Method mSetAge  = cls.getDeclaredMethod(&quot;setAge&quot;, new Class[]{int.class});
            Method mGetAge  = cls.getDeclaredMethod(&quot;getAge&quot;, new Class[]{});
            Method mSetGender = cls.getDeclaredMethod(&quot;setGender&quot;, new Class[]{Gender.class});
            Method mGetGender = cls.getDeclaredMethod(&quot;getGender&quot;, new Class[]{});

            // 调用获取的方法
            mSetName.invoke(person, new Object[]{&quot;Jimmy&quot;});
            mSetAge.invoke(person, new Object[]{30});
            mSetGender.setAccessible(true);    // 因为Person中setGender()是private的，所以这里要设置为可访问
            mSetGender.invoke(person, new Object[]{Gender.MALE});
            String name = (String)mGetName.invoke(person, new Object[]{});
            Integer age = (Integer)mGetAge.invoke(person, new Object[]{});
            mGetGender.setAccessible(true);    // 因为Person中getGender()是private的，所以这里要设置为可访问
            Gender gender = (Gender)mGetGender.invoke(person, new Object[]{});

            // 打印输出
            System.out.printf(&quot;%-30s: person=%s, name=%s, age=%s, gender=%s\n&quot;, 
                    &quot;getDeclaredMethod()&quot;, person, name, age, gender);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    /**
     * getMethod() 的测试函数
     */
    public static void testGetMethod() {
        try {
            // 获取Person类的Class
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);
            // 根据class，调用类的默认构造函数(不带参数)
            Object person = cls.newInstance();

            // 获取Person中的方法
            Method mSetName = cls.getMethod(&quot;setName&quot;, new Class[]{String.class});
            Method mGetName = cls.getMethod(&quot;getName&quot;, new Class[]{});
            //Method mSetAge  = cls.getMethod(&quot;setAge&quot;, new Class[]{int.class});         // 抛出异常，因为setAge()是protected权限。
            //Method mGetAge  = cls.getMethod(&quot;getAge&quot;, new Class[]{});                  // 抛出异常，因为getAge()是protected权限。
            //Method mSetGender = cls.getMethod(&quot;setGender&quot;, new Class[]{Gender.class}); // 抛出异常，因为setGender()是private权限。
            //Method mGetGender = cls.getMethod(&quot;getGender&quot;, new Class[]{});             // 抛出异常，因为getGender()是private权限。

            // 调用获取的方法
            mSetName.invoke(person, new Object[]{&quot;Phobe&quot;});
            //mSetAge.invoke(person, new Object[]{38});
            //mSetGender.invoke(person, new Object[]{Gender.FEMALE});
            String name = (String)mGetName.invoke(person, new Object[]{});
            //Integer age = (Integer)mGetAge.invoke(person, new Object[]{});
            //Gender gender = (Gender)mGetGender.invoke(person, new Object[]{});

            // 打印输出
            System.out.printf(&quot;%-30s: person=%s\n&quot;, 
                    &quot;getMethod()&quot;, person);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    /**
     * getEnclosingMethod() 的测试函数
     */
    public static void testGetEnclosingMethod() {
        try {
            // 获取Person类的Class
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);
            // 根据class，调用类的默认构造函数(不带参数)
            Object person = cls.newInstance();

            // 根据class，调用Person类中有内部类InnerB的函数
            Method mGetInner = cls.getDeclaredMethod(&quot;getInner&quot;, new Class[]{});

            // 根据构造函数，创建相应的对象
            mGetInner.invoke(person, new Object[]{});

            System.out.printf(&quot;%-30s: person=%s\n&quot;,
                       &quot;getEnclosingMethod&quot;, person);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


}

enum Gender{  
    MALE, FEMALE
} 
class Person {
    private Gender gender;  // 性别
    private int age;        // 年龄
    private String name;    // 姓名

    public Person() {
        this(&quot;unknown&quot;, 0, Gender.FEMALE);
    }
    public Person(String name, int age, Gender gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    // 获取”姓名“。权限是 public
    public String getName() {
        return name;
    }
    // 设置”姓名“。权限是 public
    public void setName(String name) {
        this.name = name;
    }
    // 获取”年龄“。权限是 protected
    protected int getAge() {
        return age;
    }
    // 设置”年龄“。权限是 protected
    protected void setAge(int age) {
        this.age = age;
    }
    // 获取“性别”。权限是 private
    private Gender getGender() {
        return gender;
    }
    // 设置“性别”。权限是 private
    private void setGender(Gender gender) {
        this.gender = gender;
    }


    // getInner() 中有内部类InnerB，用来测试getEnclosingMethod()
    public void getInner() {
        // 内部类
        class InnerB{
        }
        // 获取InnerB的Class对象
        Class cls = InnerB.class;

        // 获取“封闭该内部类(InnerB)”的构造方法
        Method cst = cls.getEnclosingMethod();

        System.out.println(&quot;call--\&quot;getInner()\&quot; cst=&quot;+cst);
    }


    @Override
    public String toString() {
        return &quot;(&quot;+name+&quot;, &quot;+age+&quot;, &quot;+gender+&quot;)&quot;;
    }
}</code></pre><p>注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。</p>
<p>运行结果：</p>
<pre><code>getDeclaredMethod() : person=(Jimmy, 30, MALE), name=Jimmy, age=30, gender=MALE
getMethod() : person=(Phobe, 0, FEMALE)
call--&quot;getInner()&quot; cst=public void com.skywang.test.Person.getInner()
getEnclosingMethod : person=(unknown, 0, FEMALE)</code></pre><h3 id="2-3-成员变量"><a href="#2-3-成员变量" class="headerlink" title="2.3 成员变量"></a>2.3 成员变量</h3><p>“成员变量”的相关API</p>
<pre><code>// 获取“名称是name”的public的成员变量(包括从基类继承的、从接口实现的所有public成员变量)
public Field    getField(String name)
// 获取全部的public成员变量(包括从基类继承的、从接口实现的所有public成员变量)
public Field[]    getFields()
// 获取“名称是name”，并且是类自身声明的成员变量，包含public、protected和private成员变量。
public Field    getDeclaredField(String name)
// 获取全部的类自身声明的成员变量，包含public、protected和private成员变量。
public Field[]    getDeclaredFields()</code></pre><p>接下来，我们通过示例对这些API进行说明。示例代码(DemoClassField.java)如下：</p>
<pre><code>package com.skywang.test;

import java.lang.Class;
import java.lang.reflect.Field;

/**
 * java Class类的&quot;成员变量&quot;相关API的测试函数
 *
 * @author skywang
 */
public class DemoClassField {

    public static void main(String[] args) {
        // getDeclaredField() 的测试函数
        testGetDeclaredField() ;

        // getField() 的测试函数
        testGetField() ;
    }

    /**
     * getDeclaredField() 的测试函数
     * getDeclaredField() 用于获取的是类自身声明的所有成员遍历，包含public、protected和private方法。
     */
    public static void testGetDeclaredField() {
        try {
            // 获取Person类的Class
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);
            // 根据class，调用类的默认构造函数(不带参数)
            Object person = cls.newInstance();

            // 根据class，获取Filed
            Field fName = cls.getDeclaredField(&quot;name&quot;);
            Field fAge = cls.getDeclaredField(&quot;age&quot;);
            Field fGender = cls.getDeclaredField(&quot;gender&quot;);

            // 根据构造函数，创建相应的对象
            fName.set(person, &quot;Hamier&quot;);
            fAge.set(person, 31);
            fGender.setAccessible(true);  // 因为&quot;flag&quot;是private权限，所以要设置访问权限为true；否则，会抛出异常。
            fGender.set(person, Gender.FEMALE);

            System.out.printf(&quot;%-30s: person=%s\n&quot;, 
                    &quot;getDeclaredField()&quot;, person);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * getField() 的测试函数
     * getField() 用于获取的是public的“成员”
     */
    public static void testGetField() {
        try {
            // 获取Person类的Class
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);
            // 根据class，调用类的默认构造函数(不带参数)
            Object person = cls.newInstance();

            // 根据class，获取Filed
            Field fName = cls.getField(&quot;name&quot;);
            Field fAge = cls.getDeclaredField(&quot;age&quot;);       // 抛出异常，因为Person中age是protected权限。 
            Field fGender = cls.getDeclaredField(&quot;gender&quot;); // 抛出异常，因为Person中gender是private权限。 

            // 根据构造函数，创建相应的对象
            fName.set(person, &quot;Grace&quot;);
            //fAge.set(person, 26);
            //fGender.set(person, Gender.FEMALE);

            System.out.printf(&quot;%-30s: person=%s\n&quot;, 
                    &quot;getField()&quot;, person);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


// 枚举类型。表示“性别”
enum Gender{  
    MALE, FEMALE
} 
// 人
class Person {
    // private。性别
    private Gender gender;
    // protected。 年龄
    protected int age;
    // public。 姓名
    public String name;

    public Person() {
        this(&quot;unknown&quot;, 0, Gender.FEMALE);
    }

    public Person(String name, int age, Gender gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    @Override
    public String toString() {
        return &quot;(&quot;+name+&quot;, &quot;+age+&quot;, &quot;+gender+&quot;)&quot;;
    }
}</code></pre><p>注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。</p>
<p>运行结果：</p>
<pre><code>getDeclaredField() : person=(Hamier, 31, FEMALE)
getField() : person=(Grace, 0, FEMALE)</code></pre><h3 id="2-4-类的其它信息"><a href="#2-4-类的其它信息" class="headerlink" title="2.4 类的其它信息"></a>2.4 类的其它信息</h3><p><strong>2.4.1 “注解”相关的API</strong></p>
<pre><code>// 获取类的&quot;annotationClass&quot;类型的注解 (包括从基类继承的、从接口实现的所有public成员变量)
public Annotation&lt;A&gt;    getAnnotation(Class annotationClass)
// 获取类的全部注解 (包括从基类继承的、从接口实现的所有public成员变量)
public Annotation[]    getAnnotations()
// 获取类自身声明的全部注解 (包含public、protected和private成员变量)
public Annotation[]    getDeclaredAnnotations()</code></pre><p>接下来，我们通过示例对这些API进行说明。示例代码(DemoClassAnnotation.java)如下：</p>
<pre><code>package com.skywang.test;

import java.lang.Class;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * java Class类getAnnotation()的测试程序
 */
public class DemoClassAnnotation {

    public static void main(String[] args) {
        try {
            // 根据“类名”获取 对应的Class对象
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);

            // 获取“Person类”的注解
            MyAnnotation myann = cls.getAnnotation(MyAnnotation.class);

            System.out.println(&quot;myann=&quot;+myann);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

/**
 * MyAnnotation是自定义个一个Annotation
 */
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {
}

/**
 * MyAnnotation 是Person的注解。
 */
@MyAnnotation 
class Person {
}</code></pre><p>注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。</p>
<p>运行结果：</p>
<pre><code>myann=@com.skywang.test.MyAnnotation()</code></pre><p>说明：<br>(01) MyAnnotation 是我们自定义个一个Annotation注解。若读者不明白“注解”，可以参考博文“<a href="/2012/03/03/annotation">Java Annotation认知(包括框架图、详细介绍、示例说明)</a>”<br>(02) getAnnotation()就是获取这个类的注解。</p>
<p><strong>2.4.2 “父类”和“接口”相关的API</strong></p>
<pre><code>// 获取实现的全部接口
public Type[]    getGenericInterfaces()
// 获取父类
public Type    getGenericSuperclass()</code></pre><p>示例代码(DemoClassInterface.java)如下：</p>
<pre><code>package com.skywang.test;

import java.io.Serializable;
import java.lang.Runnable;
import java.lang.Thread;
import java.lang.Class;
import java.lang.reflect.Type;

/**
 * java Class类的有关父类和接口的测试
 */
public class DemoClassInterface {

    public static void main(String[] args) {

        try {
            // 根据“类名”获取 对应的Class对象
            Class&lt;?&gt; cls = Class.forName(&quot;com.skywang.test.Person&quot;);

            // 获取“Person”的父类
            Type father = cls.getGenericSuperclass();
            // 获取“Person”实现的全部接口
            Type[] intfs = cls.getGenericInterfaces();

            System.out.println(&quot;father=&quot;+father);
            for (Type t:intfs)
                System.out.println(&quot;t=&quot;+t);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

/**
 * Person 继承于 Object，并且实现了Serializable和Runnable接口
 */
class Person extends Object implements Serializable, Runnable{

    @Override
    public void run() {
    }

}</code></pre><p>注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。</p>
<p>运行结果：</p>
<pre><code>father=class java.lang.Object
t=interface java.io.Serializable
t=interface java.lang.Runnable</code></pre><p><strong>2.4.3 剩余的API</strong></p>
<pre><code>// 获取“类名”
public String    getSimpleName()
// 获取“完整类名”
public String    getName()
// 类是不是“枚举类”
public boolean    isEnum()
// obj是不是类的对象
public boolean    isInstance(Object obj)
// 类是不是“接口”
public boolean    isInterface()
// 类是不是“本地类”。本地类,就是定义在方法内部的类。
public boolean    isLocalClass()
// 类是不是“成员类”。成员类,是内部类的一种，但是它不是“内部类”或“匿名类”。
public boolean    isMemberClass()
// 类是不是“基本类型”。 基本类型，包括void和boolean、byte、char、short、int、long、float 和 double这几种类型。
public boolean    isPrimitive()
// 类是不是“复合类”。 JVM中才会产生复合类，在java应用程序中不存在“复合类”！
public boolean    isSynthetic()</code></pre><p>示例代码(DemoClassOtherAPIs.java)如下：</p>
<pre><code>package com.skywang.test;

import java.lang.Class;
import java.lang.Runnable;
import java.lang.annotation.ElementType;
import java.util.TreeMap;

/**
 * java Class类的getName(), isInterface()等测试程序
 *
 * @author skywang
 */
public class DemoClassOtherAPIs {
    public static void main(String[] args) {

        Class cls = DemoClassOtherAPIs.class;
        // 获取“类名”
        System.out.printf(&quot;%-50s:getSimpleName()=%s\n&quot;, cls, cls.getSimpleName());
        // 获取“完整类名”
        System.out.printf(&quot;%-50s:getName()=%s\n&quot;, cls, cls.getName());

        // 测试其它的API
        testOtherAPIs() ;
    }

    public static void testOtherAPIs() {
        // 本地类
        class LocalA {
        }

        // 测试枚举类型。ElementType是一个枚举类
        Class elementtypeCls = ElementType.class;
        System.out.printf(&quot;%-50s:isEnum()=%s\n&quot;, 
                elementtypeCls, elementtypeCls.isEnum());

        // 判断是不是类的对象
        Class demoCls = DemoClassOtherAPIs.class;
        DemoClassOtherAPIs demoObj = new DemoClassOtherAPIs();
        System.out.printf(&quot;%-50s:isInstance(obj)=%s\n&quot;, 
                demoCls, demoCls.isInstance(demoObj));

        // 类是不是“接口”
        Class runCls = Runnable.class;
        System.out.printf(&quot;%-50s:isInterface()=%s\n&quot;, 
                runCls, runCls.isInterface());

        // 类是不是“本地类”。本地类,就是定义在方法内部的类。
        Class localCls = LocalA.class;
        System.out.printf(&quot;%-50s:isLocalClass()=%s\n&quot;, 
                localCls, localCls.isLocalClass());

        // 类是不是“成员类”。成员类,是内部类的一种，但是它不是“内部类”或“匿名类”。
        Class memCls = MemberB.class;
        System.out.printf(&quot;%-50s:isMemberClass()=%s\n&quot;, 
                memCls, memCls.isMemberClass());

        // 类是不是“基本类型”。 基本类型，包括void和boolean、byte、char、short、int、long、float 和 double这几种类型。
        Class primCls = int.class;
        System.out.printf(&quot;%-50s:isPrimitive()=%s\n&quot;, 
                primCls, primCls.isPrimitive());

        // 类是不是“复合类”。 JVM中才会产生复合类，在java应用程序中不存在“复合类”！
        Class synCls = DemoClassOtherAPIs.class;
        System.out.printf(&quot;%-50s:isSynthetic()=%s\n&quot;, 
                synCls, synCls.isSynthetic());
    }

    // 内部成员类
    class MemberB {
    }
}</code></pre><p>注意：若程序无法运行，请检查“forName()”中的包名是否正确！forName()的参数必须是，Person类的完整包名。</p>
<p>运行结果：</p>
<pre><code>class com.skywang.test.DemoClassOtherAPIs :getSimpleName()=DemoClassOtherAPIs
class com.skywang.test.DemoClassOtherAPIs :getName()=com.skywang.test.DemoClassOtherAPIs
class java.lang.annotation.ElementType :isEnum()=true
class com.skywang.test.DemoClassOtherAPIs :isInstance(obj)=true
interface java.lang.Runnable :isInterface()=true
class com.skywang.test.DemoClassOtherAPIs$1LocalA :isLocalClass()=true
class com.skywang.test.DemoClassOtherAPIs$MemberB :isMemberClass()=true
int :isPrimitive()=true
class com.skywang.test.DemoClassOtherAPIs :isSynthetic()=false</code></pre><p>说明：isSynthetic()是用来判断Class是不是“复合类”。这在java应用程序中只会返回false，不会返回true。因为，JVM中才会产生复合类，在java应用程序中不存在“复合类”！</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/03/03/java/others/2012-03-03-annotation/" itemprop="url">Java Annotation认知(包括框架图、详细介绍、示例说明)</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-03-03T01:01:00.000Z" itemprop="datePublished">3月 3 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            32 分钟 read (About 4802 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>Java Annotation是JDK5.0引入的一种注释机制。</p>
</blockquote>
<blockquote>
<p>网上很多关于Java Annotation的文章，看得人眼花缭乱。Java Annotation本来很简单的，结果说的人没说清楚；弄的看的人更加迷糊。</p>
</blockquote>
<blockquote>
<p>我按照自己的思路，对Annotation进行了整理。理解 Annotation 的关键，是理解Annotation的语法和用法，对这些内容，我都进行了详细说明；理解Annotation的语法和用法之后，再看Annotation的框架图，可能有更深刻体会。废话就说这么多，下面开始对Annotation进行说明。若您发现文章中存在错误或不足的地方，希望您能指出！</p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1部分 Annotation架构</a><br><a href="#anchor2">第2部分 Annotation组成部分</a><br><a href="#anchor3">第3部分 java自带的Annotation</a><br><a href="#anchor4">第4部分 Annotation 的作用</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1部分-Annotation架构"><a href="#第1部分-Annotation架构" class="headerlink" title="第1部分 Annotation架构"></a>第1部分 Annotation架构</h1><p>先看看Annotation的架构图：</p>
<p><img src="/media/pic/java/basic/annotation01.jpg" alt="img"></p>
<p>从中，我们可以看出：<br>(01) 1个Annotation 和 1个RetentionPolicy关联。<br>&nbsp;&nbsp;&nbsp;&nbsp; 可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。</p>
<p>(02) 1个Annotation 和 1~n个ElementType关联。<br>&nbsp;&nbsp;&nbsp;&nbsp; 可以理解为：对于每1个Annotation对象，可以有若干个ElementType属性。</p>
<p>(03) Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override等等。<br>&nbsp;&nbsp;&nbsp;&nbsp; Annotation 的每一个实现类，都“和1个RetentionPolicy关联”并且“和1~n个ElementType关联”。</p>
<p>下面，我先介绍框架图的左半边(如下图)，即Annotation, RetentionPolicy, ElementType；然后在就Annotation的实现类进行举例说明。</p>
<p><img src="/media/pic/java/basic/annotation02.jpg" alt="img"></p>
<p><a name="anchor2"></a></p>
<h1 id="第2部分-Annotation组成部分"><a href="#第2部分-Annotation组成部分" class="headerlink" title="第2部分 Annotation组成部分"></a>第2部分 Annotation组成部分</h1><h2 id="1-annotation组成成分"><a href="#1-annotation组成成分" class="headerlink" title="1. annotation组成成分"></a>1. annotation组成成分</h2><p>java annotation 的组成中，有3个非常重要的主干类。它们分别是：</p>
<p><strong>(01) Annotation.java</strong></p>
<pre><code>package java.lang.annotation;
public interface Annotation {

    boolean equals(Object obj);

    int hashCode();

    String toString();

    Class&lt;? extends Annotation&gt; annotationType();
}</code></pre><p><strong>(02) ElementType.java</strong></p>
<pre><code>package java.lang.annotation;

public enum ElementType {
    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */

    FIELD,              /* 字段声明（包括枚举常量）  */

    METHOD,             /* 方法声明  */

    PARAMETER,          /* 参数声明  */

    CONSTRUCTOR,        /* 构造方法声明  */

    LOCAL_VARIABLE,     /* 局部变量声明  */

    ANNOTATION_TYPE,    /* 注释类型声明  */

    PACKAGE             /* 包声明  */
}</code></pre><p><strong>(03) RetentionPolicy.java</strong></p>
<pre><code>package java.lang.annotation;
public enum RetentionPolicy {
    SOURCE,            /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */

    CLASS,             /* 编译器将Annotation存储于类对应的.class文件中。默认行为  */

    RUNTIME            /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */
}</code></pre><p>说明：<br>(01) Annotation 就是个接口。<br>&nbsp;&nbsp;&nbsp;&nbsp; “每1个Annotation” 都与 “1个RetentionPolicy”关联，并且与 “1～n个ElementType”关联。可以通俗的理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性；至于ElementType属性，则有1~n个。  </p>
<p>(02) ElementType 是Enum枚举类型，它用来指定Annotation的类型。<br>&nbsp;&nbsp;&nbsp;&nbsp; “每1个Annotation” 都与 “1～n个ElementType”关联。当Annotation与某个ElementType关联时，就意味着：Annotation有了某种用途。<br>&nbsp;&nbsp;&nbsp;&nbsp; 例如，若一个Annotation对象是METHOD类型，则该Annotation只能用来修饰方法。  </p>
<p>(03) RetentionPolicy 是Enum枚举类型，它用来指定Annotation的策略。通俗点说，就是不同RetentionPolicy类型的Annotation的作用域不同。<br>&nbsp;&nbsp;&nbsp;&nbsp; “每1个Annotation” 都与 “1个RetentionPolicy”关联。<br>&nbsp;&nbsp;&nbsp;&nbsp; a) 若Annotation的类型为 SOURCE，则意味着：Annotation仅存在于编译器处理期间，编译器处理完之后，该Annotation就没用了。<br>&nbsp;&nbsp;&nbsp;&nbsp; 例如，“ @Override ”标志就是一个Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，“@Override”就没有任何作用了。<br>&nbsp;&nbsp;&nbsp;&nbsp; b) 若Annotation的类型为 CLASS，则意味着：编译器将Annotation存储于类对应的.class文件中，它是Annotation的默认行为。<br>&nbsp;&nbsp;&nbsp;&nbsp; c) 若Annotation的类型为 RUNTIME，则意味着：编译器将Annotation存储于class文件中，并且可由JVM读入。  </p>
<p>这时，只需要记住“每1个Annotation” 都与 “1个RetentionPolicy”关联，并且与 “1～n个ElementType”关联。学完后面的内容之后，再回头看这些内容，会更容易理解。</p>
<p><a name="anchor3"></a></p>
<h1 id="第3部分-java自带的Annotation"><a href="#第3部分-java自带的Annotation" class="headerlink" title="第3部分 java自带的Annotation"></a>第3部分 java自带的Annotation</h1><p>理解了上面的3个类的作用之后，我们接下来可以讲解Annotation实现类的语法定义了。</p>
<h2 id="1-Annotation通用定义"><a href="#1-Annotation通用定义" class="headerlink" title="1 Annotation通用定义"></a>1 Annotation通用定义</h2><pre><code>@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation1 {
}</code></pre><p>说明：<br>上面的作用是定义一个Annotation，它的名字是MyAnnotation1。定义了MyAnnotation1之后，我们可以在代码中通过“@MyAnnotation1”来使用它。</p>
<p>其它的，@Documented, @Target, @Retention, @interface都是来修饰MyAnnotation1的。下面分别说说它们的含义：<br>(01) @interface<br>&nbsp;&nbsp;&nbsp;&nbsp; 使用@interface定义注解时，意味着它实现了java.lang.annotation.Annotation接口，即该注解就是一个Annotation。<br>&nbsp;&nbsp;&nbsp;&nbsp; 定义Annotation时，@interface是必须的。<br>&nbsp;&nbsp;&nbsp;&nbsp; 注意：它和我们通常的implemented实现接口的方法不同。Annotation接口的实现细节都由编译器完成。通过@interface定义注解后，该注解不能继承其他的注解或接口。  </p>
<p>(02) @Documented<br>&nbsp;&nbsp;&nbsp;&nbsp; 类和方法的Annotation在缺省情况下是不出现在javadoc中的。如果使用@Documented修饰该Annotation，则表示它可以出现在javadoc中。<br>&nbsp;&nbsp;&nbsp;&nbsp; 定义Annotation时，@Documented可有可无；若没有定义，则Annotation不会出现在javadoc中。  </p>
<p>(03) @Target(ElementType.TYPE)<br>&nbsp;&nbsp;&nbsp;&nbsp; 前面我们说过，ElementType 是Annotation的类型属性。而@Target的作用，就是来指定Annotation的类型属性。<br>&nbsp;&nbsp;&nbsp;&nbsp; @Target(ElementType.TYPE) 的意思就是指定该Annotation的类型是ElementType.TYPE。这就意味着，MyAnnotation1是来修饰“类、接口（包括注释类型）或枚举声明”的注解。<br>&nbsp;&nbsp;&nbsp;&nbsp; 定义Annotation时，@Target可有可无。若有@Target，则该Annotation只能用于它所指定的地方；若没有@Target，则该Annotation可以用于任何地方。  </p>
<p>(04) @Retention(RetentionPolicy.RUNTIME)<br>&nbsp;&nbsp;&nbsp;&nbsp; 前面我们说过，RetentionPolicy 是Annotation的策略属性，而@Retention的作用，就是指定Annotation的策略属性。<br>&nbsp;&nbsp;&nbsp;&nbsp; @Retention(RetentionPolicy.RUNTIME) 的意思就是指定该Annotation的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将该Annotation信息保留在.class文件中，并且能被虚拟机读取。<br>&nbsp;&nbsp;&nbsp;&nbsp; 定义Annotation时，@Retention可有可无。若没有@Retention，则默认是RetentionPolicy.CLASS。</p>
<h2 id="2-java自带的Annotation"><a href="#2-java自带的Annotation" class="headerlink" title="2 java自带的Annotation"></a>2 java自带的Annotation</h2><p>通过上面的示例，我们能理解：@interface用来声明Annotation，@Documented用来表示该Annotation是否会出现在javadoc中， @Target用来指定Annotation的类型，@Retention用来指定Annotation的策略。</p>
<p>理解这一点之后，我们就很容易理解java中自带的Annotation的实现类，即Annotation架构图的右半边。如下图：</p>
<p><img src="/media/pic/java/basic/annotation03.jpg" alt="img"></p>
<p>java 常用的Annotation：</p>
<table>
<thead>
<tr>
<th>标注</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Deprecated</td>
<td>@Deprecated 所标注内容，不再被建议使用。</td>
</tr>
<tr>
<td>@Override</td>
<td>@Override 只能标注方法，表示该方法覆盖父类中的方法。</td>
</tr>
<tr>
<td>@Documented</td>
<td>@Documented 所标注内容，可以出现在javadoc中。</td>
</tr>
<tr>
<td>@Inherited</td>
<td>@Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。</td>
</tr>
<tr>
<td>@Retention</td>
<td>@Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。</td>
</tr>
<tr>
<td>@Target</td>
<td>@Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</td>
</tr>
<tr>
<td>@SuppressWarnings</td>
<td>@SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</td>
</tr>
</tbody></table>
<p>由于“@Deprecated和@Override”类似，“@Documented, @Inherited, @Retention, @Target”类似；下面，我们只对@Deprecated, @Inherited, @SuppressWarnings 这3个Annotation进行说明。</p>
<h3 id="2-1-Deprecated"><a href="#2-1-Deprecated" class="headerlink" title="2.1 @Deprecated"></a>2.1 @Deprecated</h3><p>@Deprecated 的定义如下：</p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface Deprecated {
}</code></pre><p>说明：<br>(01) @interface – 它的用来修饰Deprecated，意味着Deprecated实现了java.lang.annotation.Annotation接口；即Deprecated就是一个注解。  </p>
<p>(02) @Documented – 它的作用是说明该注解能出现在javadoc中。  </p>
<p>(03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Deprecated的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated的信息保留在.class文件中，并且能被虚拟机读取。  </p>
<p>(04) @Deprecated 所标注内容，不再被建议使用。<br>&nbsp;&nbsp;&nbsp;&nbsp; 例如，若某个方法被 @Deprecated 标注，则该方法不再被建议使用。如果有开发人员试图使用或重写被@Deprecated标示的方法，编译器会给相应的提示信息。示例如下:</p>
<p><img src="/media/pic/java/basic/annotation04.jpg" alt="img"></p>
<p>源码如下(DeprecatedTest.java)：</p>
<pre><code>package com.skywang.annotation;

import java.util.Date;
import java.util.Calendar;

public class DeprecatedTest {
    // @Deprecated 修饰 getString1(),表示 它是建议不被使用的函数
    @Deprecated
    private static void getString1(){
        System.out.println(&quot;Deprecated Method&quot;);
    }

    private static void getString2(){
        System.out.println(&quot;Normal Method&quot;);
    }

    // Date是日期/时间类。java已经不建议使用该类了
    private static void testDate() {
        Date date = new Date(113, 8, 25);
        System.out.println(date.getYear());
    }
    // Calendar是日期/时间类。java建议使用Calendar取代Date表示“日期/时间”
    private static void testCalendar() {
        Calendar cal = Calendar.getInstance();
        System.out.println(cal.get(Calendar.YEAR));
    }

    public static void main(String[] args) {
        getString1(); 
        getString2();
        testDate(); 
        testCalendar();
    }
}</code></pre><p>说明：<br>上面是eclipse中的截图，比较类中 “getString1() 和 getString2()” 以及 “testDate() 和 testCalendar()” 。</p>
<p>(01) getString1() 被@Deprecated标注，意味着建议不再使用getString1()；所以getString1()的定义和调用时，都会一横线。这一横线是eclipse()对@Deprecated方法的处理。<br>getString2() 没有被@Deprecated标注，它的显示正常。  </p>
<p>(02) testDate() 调用了Date的相关方法，而java已经建议不再使用Date操作日期/时间。因此，在调用Date的API时，会产生警告信息，途中的warnings。<br>testCalendar() 调用了Calendar的API来操作日期/时间，java建议用Calendar取代Date。因此，操作Calendar不回产生warning。</p>
<h3 id="2-2-Inherited"><a href="#2-2-Inherited" class="headerlink" title="2.2 @Inherited"></a>2.2 @Inherited</h3><p>@Inherited 的定义如下：</p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Inherited {
}</code></pre><p>说明：<br>(01) @interface – 它的用来修饰Inherited，意味着Inherited实现了java.lang.annotation.Annotation接口；即Inherited就是一个注解。  </p>
<p>(02) @Documented – 它的作用是说明该注解能出现在javadoc中。  </p>
<p>(03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定Inherited的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Inherited的信息保留在.class文件中，并且能被虚拟机读取。  </p>
<p>(04) @Target(ElementType.ANNOTATION_TYPE) – 它的作用是指定Inherited的类型是ANNOTATION_TYPE。这就意味着，@Inherited只能被用来标注“Annotation类型”。  </p>
<p>(05) @Inherited 的含义是，它所标注的Annotation将具有继承性。<br>&nbsp;&nbsp;&nbsp;&nbsp; 假设，我们定义了某个Annotaion，它的名称是MyAnnotation，并且MyAnnotation被标注为@Inherited。现在，某个类Base使用了MyAnnotation，则Base具有了“具有了注解MyAnnotation”；现在，Sub继承了Base，由于MyAnnotation是@Inherited的(具有继承性)，所以，Sub也“具有了注解MyAnnotation”。</p>
<p>@Inherited的使用示例<br>源码如下(InheritableSon.java)：</p>
<pre><code>/**
 * @Inherited 演示示例
 * 
 * @author skywang
 * @email kuiwu-wang@163.com
 */
package com.skywang.annotation;

import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Inherited;

/**
 * 自定义的Annotation。
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@interface Inheritable
{
}

@Inheritable
class InheritableFather
{
    public InheritableFather() {
        // InheritableBase是否具有 Inheritable Annotation
        System.out.println(&quot;InheritableFather:&quot;+InheritableFather.class.isAnnotationPresent(Inheritable.class));
    }
}

/**
 * InheritableSon 类只是继承于 InheritableFather，
 */
public class InheritableSon extends InheritableFather
{
    public InheritableSon() {
        super();    // 调用父类的构造函数
        // InheritableSon类是否具有 Inheritable Annotation
        System.out.println(&quot;InheritableSon:&quot;+InheritableSon.class.isAnnotationPresent(Inheritable.class));
    }

    public static void main(String[] args)
    {
        InheritableSon is = new InheritableSon();
    }
}</code></pre><p>运行结果：</p>
<pre><code>InheritableFather:true
InheritableSon:true</code></pre><p>现在，我们对InheritableSon.java进行修改：注释掉“Inheritable的@Inherited注解”。<br>源码如下(InheritableSon.java)：</p>
<pre><code>/**
 * @Inherited 演示示例
 * 
 * @author skywang
 * @email kuiwu-wang@163.com
 */
package com.skywang.annotation;

import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Inherited;

/**
 * 自定义的Annotation。
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
//@Inherited
@interface Inheritable
{
}

@Inheritable
class InheritableFather
{
    public InheritableFather() {
        // InheritableBase是否具有 Inheritable Annotation
        System.out.println(&quot;InheritableFather:&quot;+InheritableFather.class.isAnnotationPresent(Inheritable.class));
    }
}

/**
 * InheritableSon 类只是继承于 InheritableFather，
 */
public class InheritableSon extends InheritableFather
{
    public InheritableSon() {
        super();    // 调用父类的构造函数
        // InheritableSon类是否具有 Inheritable Annotation
        System.out.println(&quot;InheritableSon:&quot;+InheritableSon.class.isAnnotationPresent(Inheritable.class));
    }

    public static void main(String[] args)
    {
        InheritableSon is = new InheritableSon();
    }
}</code></pre><p>运行结果：</p>
<pre><code>InheritableFather:true
InheritableSon:false</code></pre><p>对比上面的两个结果，我们发现：当注解Inheritable被@Inherited标注时，它具有继承性。否则，没有继承性。</p>
<h3 id="2-3-SuppressWarnings"><a href="#2-3-SuppressWarnings" class="headerlink" title="2.3 @SuppressWarnings"></a>2.3 @SuppressWarnings</h3><p>@SuppressWarnings 的定义如下：</p>
<pre><code>@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}</code></pre><p>说明：<br>(01) @interface – 它的用来修饰SuppressWarnings，意味着SuppressWarnings实现了java.lang.annotation.Annotation接口；即SuppressWarnings就是一个注解。  </p>
<p>(02) @Retention(RetentionPolicy.SOURCE) – 它的作用是指定SuppressWarnings的策略是RetentionPolicy.SOURCE。这就意味着，SuppressWarnings信息仅存在于编译器处理期间，编译器处理完之后SuppressWarnings就没有作用了。  </p>
<p>(03) @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) – 它的作用是指定SuppressWarnings的类型同时包括TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE。  </p>
<blockquote>
<p>TYPE意味着，它能标注“类、接口（包括注释类型）或枚举声明”。<br>FIELD意味着，它能标注“字段声明”。<br>METHOD意味着，它能标注“方法”。<br>PARAMETER意味着，它能标注“参数”。<br>CONSTRUCTOR意味着，它能标注“构造方法”。<br>LOCAL_VARIABLE意味着，它能标注“局部变量”。</p>
</blockquote>
<p>(04) String[] value(); 意味着，SuppressWarnings能指定参数  </p>
<p>(05) SuppressWarnings 的作用是，让编译器对“它所标注的内容”的某些警告保持静默。例如，”@SuppressWarnings(value={“deprecation”, “unchecked”})” 表示对“它所标注的内容”中的 “SuppressWarnings不再建议使用警告”和“未检查的转换时的警告”保持沉默。示例如下：</p>
<p><img src="/media/pic/java/basic/annotation05.jpg" alt="img"></p>
<p>源码如下(SuppressWarningTest.java)：</p>
<pre><code>package com.skywang.annotation;

import java.util.Date;

public class SuppressWarningTest {

    //@SuppressWarnings(value={&quot;deprecation&quot;})
    public static void doSomething(){
        Date date = new Date(113, 8, 26);
        System.out.println(date);
    }

    public static void main(String[] args) {
        doSomething();
    }
}</code></pre><p>说明：<br>(01) 左边的图中，没有使用 @SuppressWarnings(value={“deprecation”}) , 而Date属于java不再建议使用的类。因此，调用Date的API时，会产生警告。<br>而右边的图中，使用了 @SuppressWarnings(value={“deprecation”})。因此，编译器对“调用Date的API产生的警告”保持沉默。</p>
<p>补充：SuppressWarnings 常用的关键字的表格</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>deprecation</td>
<td>使用了不赞成使用的类或方法时的警告</td>
</tr>
<tr>
<td>unchecked</td>
<td>执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</td>
</tr>
<tr>
<td>fallthrough</td>
<td>当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</td>
</tr>
<tr>
<td>path</td>
<td>在类路径、源文件路径等中有不存在的路径时的警告。</td>
</tr>
<tr>
<td>serial</td>
<td>当在可序列化的类上缺少 serialVersionUID 定义时的警告。</td>
</tr>
<tr>
<td>finally</td>
<td>任何 finally 子句不能正常完成时的警告。</td>
</tr>
<tr>
<td>all</td>
<td>关于以上所有情况的警告。</td>
</tr>
</tbody></table>
<p><a name="anchor4"></a></p>
<h1 id="第4部分-Annotation-的作用"><a href="#第4部分-Annotation-的作用" class="headerlink" title="第4部分 Annotation 的作用"></a>第4部分 Annotation 的作用</h1><p>Annotation 是一个辅助类，它在Junit、Struts、Spring等工具框架中被广泛使用。</p>
<p>我们在编程中经常会使用到的Annotation作用有：</p>
<h2 id="1-编译检查"><a href="#1-编译检查" class="headerlink" title="1 编译检查"></a>1 编译检查</h2><p>Annotation具有“让编译器进行编译检查的作用”。</p>
<p>例如，@SuppressWarnings, @Deprecated和@Override都具有编译检查作用。  </p>
<p>(01) 关于@SuppressWarnings和@Deprecated，已经在“第3部分”中详细介绍过了。这里就不再举例说明了。  </p>
<p>(02) 若某个方法被 @Override的 标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被@Override标示，但父类中却没有“被@Override标注”的同名方法，则编译器会报错。示例如下：</p>
<p><img src="/media/pic/java/basic/annotation06.jpg" alt="img"></p>
<p>源码(OverrideTest.java):</p>
<pre><code>package com.skywang.annotation;

/**
 * @Override测试程序
 * 
 * @author skywang
 * @email kuiwu-wang@163.com
 */
public class OverrideTest {

    /**
     * toString() 在java.lang.Object中定义；
     * 因此，这里用 @Override 标注是对的。
     */
    @Override
    public String toString(){
        return &quot;Override toString&quot;;
    }

    /**
     * getString() 没有在OverrideTest的任何父类中定义；
     * 但是，这里却用 @Override 标注，因此会产生编译错误！
     */
    @Override
    public String getString(){
        return &quot;get toString&quot;;
    }

    public static void main(String[] args) {
    }
}</code></pre><p>上面是该程序在eclipse中的截图。从中，我们可以发现“getString()”函数会报错。这是因为“getString() 被@Override所标注，但在OverrideTest的任何父类中都没有定义getString1()函数”。<br>“将getString() 上面的@Override注释掉”，即可解决该错误。</p>
<h2 id="2-在反射中使用Annotation"><a href="#2-在反射中使用Annotation" class="headerlink" title="2 在反射中使用Annotation"></a>2 在反射中使用Annotation</h2><p>在反射的Class, Method, Field等函数中，有许多于Annotation相关的接口。<br>这也意味着，我们可以在反射中解析并使用Annotation。<br>源码如下(AnnotationTest.java)：</p>
<pre><code>package com.skywang.annotation;

import java.lang.annotation.Annotation;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Inherited;
import java.lang.reflect.Method;

/**
 * Annotation在反射函数中的使用示例
 * 
 * @author skywang
 * @email kuiwu-wang@163.com
 */
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {
    String[] value() default &quot;unknown&quot;;
}

/**
 * Person类。它会使用MyAnnotation注解。
 */
class Person {

    /**
     * empty()方法同时被 &quot;@Deprecated&quot; 和 “@MyAnnotation(value={&quot;a&quot;,&quot;b&quot;})”所标注 
     * (01) @Deprecated，意味着empty()方法，不再被建议使用
     * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;
     */
    @MyAnnotation
    @Deprecated
    public void empty(){
        System.out.println(&quot;\nempty&quot;);
    }

    /**
     * sombody() 被 @MyAnnotation(value={&quot;girl&quot;,&quot;boy&quot;}) 所标注，
     * @MyAnnotation(value={&quot;girl&quot;,&quot;boy&quot;}), 意味着MyAnnotation的value值是{&quot;girl&quot;,&quot;boy&quot;}
     */
    @MyAnnotation(value={&quot;girl&quot;,&quot;boy&quot;})
    public void somebody(String name, int age){
        System.out.println(&quot;\nsomebody: &quot;+name+&quot;, &quot;+age);
    }
}

public class AnnotationTest {

    public static void main(String[] args) throws Exception {

        // 新建Person
        Person person = new Person();
        // 获取Person的Class实例
        Class&lt;Person&gt; c = Person.class;
        // 获取 somebody() 方法的Method实例
        Method mSomebody = c.getMethod(&quot;somebody&quot;, new Class[]{String.class, int.class});
        // 执行该方法
        mSomebody.invoke(person, new Object[]{&quot;lily&quot;, 18});
        iteratorAnnotations(mSomebody);


        // 获取 somebody() 方法的Method实例
        Method mEmpty = c.getMethod(&quot;empty&quot;, new Class[]{});
        // 执行该方法
        mEmpty.invoke(person, new Object[]{});        
        iteratorAnnotations(mEmpty);
    }

    public static void iteratorAnnotations(Method method) {

        // 判断 somebody() 方法是否包含MyAnnotation注解
        if(method.isAnnotationPresent(MyAnnotation.class)){
            // 获取该方法的MyAnnotation注解实例
            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);
            // 获取 myAnnotation的值，并打印出来
            String[] values = myAnnotation.value();
            for (String str:values)
                System.out.printf(str+&quot;, &quot;);
            System.out.println();
        }

        // 获取方法上的所有注解，并打印出来
        Annotation[] annotations = method.getAnnotations();
        for(Annotation annotation : annotations){
            System.out.println(annotation);
        }
    }
}</code></pre><p>运行结果：</p>
<pre><code>somebody: lily, 18
girl, boy,
@com.skywang.annotation.MyAnnotation(value=[girl, boy])

empty
unknown,
@com.skywang.annotation.MyAnnotation(value=[unknown])
@java.lang.Deprecated()</code></pre><h2 id="3-根据Annotation生成帮助文档"><a href="#3-根据Annotation生成帮助文档" class="headerlink" title="3 根据Annotation生成帮助文档"></a>3 根据Annotation生成帮助文档</h2><p>通过给Annotation注解加上@Documented标签，能使该Annotation标签出现在javadoc中。</p>
<h2 id="4-能够帮忙查看查看代码"><a href="#4-能够帮忙查看查看代码" class="headerlink" title="4 能够帮忙查看查看代码"></a>4 能够帮忙查看查看代码</h2><p>通过@Override, @Deprecated等，我们能很方便的了解程序的大致结构。<br>另外，我们也可以通过自定义Annotation来实现一些功能。</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/03/02/java/others/2012-03-02-reference/" itemprop="url">Java引用总结--StrongReference、SoftReference、WeakReference、PhantomReference</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-03-02T01:02:00.000Z" itemprop="datePublished">3月 2 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            13 分钟 read (About 1963 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p><strong>目录</strong><br><a href="#anchor1">1. Java引用介绍</a><br><a href="#anchor2">2. 内存回收</a><br><a href="#anchor3">3. Java对引用的分类</a>  </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="1-Java引用介绍"><a href="#1-Java引用介绍" class="headerlink" title="1. Java引用介绍"></a>1. Java引用介绍</h1><p>Java从1.2版本开始引入了4种引用，这4种引用的级别由高到低依次为：</p>
<blockquote>
<p>强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用</p>
</blockquote>
<p><strong>(01) 强引用（StrongReference）</strong><br>&nbsp;&nbsp;&nbsp;&nbsp; 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p>
<p><strong>(02) 软引用（SoftReference）</strong><br>&nbsp;&nbsp;&nbsp;&nbsp; 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>&nbsp;&nbsp;&nbsp;&nbsp; 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>(03) 弱引用（WeakReference）</strong><br>&nbsp;&nbsp;&nbsp;&nbsp; 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>&nbsp;&nbsp;&nbsp;&nbsp; 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>(04) 虚引用（PhantomReference）</strong><br>&nbsp;&nbsp;&nbsp;&nbsp; “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>&nbsp;&nbsp;&nbsp;&nbsp; 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p>
<p>由于引用和内存回收关系紧密。下面，先通过实例对内存回收有个认识；然后，进一步通过引用实例加深对引用的了解。</p>
<p><a name="anchor2"></a></p>
<h1 id="2-内存回收"><a href="#2-内存回收" class="headerlink" title="2. 内存回收"></a>2. 内存回收</h1><p>创建公共类MyDate，它的作用是覆盖finalize()函数：在finalize()中输出打印信息，方便追踪。</p>
<p>说明：finalize()函数是在JVM回收内存时执行的，但JVM并不保证在回收内存时一定会调用finalize()。</p>
<p>MyDate代码如下：</p>
<pre><code>package com.skywang.java;

import java.util.Date;

public class MyDate extends Date { 

    /** Creates a new instance of MyDate */
    public MyDate() {
    }
    // 覆盖finalize()方法
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(&quot;obj [Date: &quot; + this.getTime() + &quot;] is gc&quot;);
    }   

    public String toString() {
        return &quot;Date: &quot; + this.getTime();
    }
}</code></pre><p>在这个类中，对java.util.Date类进行了扩展，并重写了finalize()和toString()方法。</p>
<br>
创建公共类ReferenceTest，它的作用是定义一个方法drainMemory()：消耗大量内存，以此来引发JVM回收内存。

<p>ReferenceTest代码如下：</p>
<pre><code>package com.skywang.java;

public class ReferenceTest {   
    /** Creates a new instance of ReferenceTest */
    public ReferenceTest() {
    }   

    // 消耗大量内存
    public static void drainMemory() {
        String[] array = new String[1024 * 10];
        for(int i = 0; i &lt; 1024 * 10; i++) {
            for(int j = &apos;a&apos;; j &lt;= &apos;z&apos;; j++) {
                array[i] += (char)j;
            }           
        }
    }
} </code></pre><p>在这个类中定义了一个静态方法drainMemory()，此方法旨在消耗大量的内存，促使JVM运行垃圾回收。</p>
<br>
有了上面两个公共类之后，我们即可测试JVM什么时候进行垃圾回收。下面分3种情况进行测试：

<p><strong>情况1：清除对象</strong></p>
<p>实现代码：</p>
<pre><code>package com.skywang.java;

public class NoGarbageRetrieve {

    public static void main(String[] args) {
        MyDate date = new MyDate();
        date = null;
    }
}</code></pre><p>运行结果：</p>
<pre><code>&lt;无任何输出&gt;</code></pre><p>结果分析：date虽然设为null，但由于JVM没有执行垃圾回收操作，MyDate的finalize()方法没有被运行。</p>
<p><strong>情况2：显式调用垃圾回收</strong></p>
<p>实现代码： </p>
<pre><code>package com.skywang.java;

public class ExplicitGarbageRetrieve {

    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        MyDate date = new MyDate();
        date = null;
        System.gc();
    }

}</code></pre><p>运行结果：</p>
<pre><code>obj [Date: 1372137067328] is gc</code></pre><p>结果分析：调用了System.gc()，使JVM运行垃圾回收，MyDate的finalize()方法被运行。</p>
<p><strong>情况3：隐式调用垃圾回收</strong></p>
<p>实现代码： </p>
<pre><code>package com.skywang.java;

public class ImplicitGarbageRetrieve {

    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        MyDate date = new MyDate();
        date = null;
        ReferenceTest.drainMemory();
    }

} </code></pre><p>运行结果：</p>
<pre><code>obj [Date: 1372137171965] is gc</code></pre><p>结果分析：虽然没有显式调用垃圾回收方法System.gc()，但是由于运行了耗费大量内存的方法，触发JVM进行垃圾回收。</p>
<p>总结：JVM的垃圾回收机制，在内存充足的情况下，除非你显式调用System.gc()，否则它不会进行垃圾回收；在内存不足的情况下，垃圾回收将自动运行</p>
<p><a name="anchor3"></a></p>
<h1 id="3-Java对引用的分类"><a href="#3-Java对引用的分类" class="headerlink" title="3. Java对引用的分类"></a>3. Java对引用的分类</h1><h2 id="3-1-强引用"><a href="#3-1-强引用" class="headerlink" title="3.1 强引用"></a>3.1 强引用</h2><p>实例代码：</p>
<pre><code>package com.skywang.java;

public class StrongReferenceTest {

    public static void main(String[] args) {
        MyDate date = new MyDate();
        System.gc();
    }
}</code></pre><p>运行结果：</p>
<pre><code>&lt;无任何输出&gt;</code></pre><p>结果说明：即使显式调用了垃圾回收，但是用于date是强引用，date没有被回收。</p>
<h2 id="3-2-软引用"><a href="#3-2-软引用" class="headerlink" title="3.2 软引用"></a>3.2 软引用</h2><p>实例代码：</p>
<pre><code>package com.skywang.java;

import java.lang.ref.SoftReference;

public class SoftReferenceTest {

    public static void main(String[] args) {
        SoftReference ref = new SoftReference(new MyDate());
        ReferenceTest.drainMemory();
    }
}</code></pre><p>运行结果：</p>
<pre><code>&lt;无任何输出&gt;</code></pre><p>结果说明：在内存不足时，软引用被终止。软引用被禁止时，</p>
<pre><code>SoftReference ref = new SoftReference(new MyDate());
ReferenceTest.drainMemory();</code></pre><p>等价于</p>
<pre><code>MyDate date = new MyDate();

// 由JVM决定运行
if(JVM.内存不足()) {
    date = null;
    System.gc();
}</code></pre><h2 id="3-3-弱引用"><a href="#3-3-弱引用" class="headerlink" title="3.3 弱引用"></a>3.3 弱引用</h2><p>示例代码： </p>
<pre><code>package com.skywang.java;

import java.lang.ref.WeakReference;

public class WeakReferenceTest {

    public static void main(String[] args) {
        WeakReference ref = new WeakReference(new MyDate());
        System.gc(); 
    }
}</code></pre><p>运行结果：</p>
<pre><code>obj [Date: 1372142034360] is gc</code></pre><p>结果说明：在JVM垃圾回收运行时，弱引用被终止.</p>
<pre><code>WeakReference ref = new WeakReference(new MyDate());
System.gc();</code></pre><p>等同于：</p>
<pre><code>MyDate date = new MyDate();

// 垃圾回收
if(JVM.内存不足()) {
    date = null;
    System.gc();
}</code></pre><h2 id="3-4-假象引用"><a href="#3-4-假象引用" class="headerlink" title="3.4 假象引用"></a>3.4 假象引用</h2><p>示例代码： </p>
<pre><code>package com.skywang.java;

import java.lang.ref.ReferenceQueue;
import java.lang.ref.PhantomReference;

public class PhantomReferenceTest {

    public static void main(String[] args) {
        ReferenceQueue queue = new ReferenceQueue();
        PhantomReference ref = new PhantomReference(new MyDate(), queue);
        System.gc();
    }
}</code></pre><p>运行结果：</p>
<pre><code>obj [Date: 1372142282558] is gc</code></pre><p>结果说明：假象引用，在实例化后，就被终止了。</p>
<pre><code>ReferenceQueue queue = new ReferenceQueue();
PhantomReference ref = new PhantomReference(new MyDate(), queue);
System.gc();</code></pre><p>等同于：</p>
<pre><code>MyDate date = new MyDate();
date = null;</code></pre><p>可以用以下表格总结上面的内容： </p>
<table>
<thead>
<tr>
<th>级别</th>
<th>什么时候被垃圾回收</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td>软引用</td>
<td>在内存不足时</td>
<td>对象简单？缓存</td>
<td>内存不足时终止</td>
</tr>
<tr>
<td>弱引用</td>
<td>在垃圾回收时</td>
<td>对象缓存</td>
<td>gc运行后终止</td>
</tr>
<tr>
<td>虚引用</td>
<td>Unknown</td>
<td>Unknown</td>
<td>Unknown</td>
</tr>
</tbody></table>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/2012/03/01/java/others/2012-03-01-random/" itemprop="url">Java 随机数</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2012-03-01T01:01:00.000Z" itemprop="datePublished">3月 1 2012</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/java/">java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            9 分钟 read (About 1325 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>本章先讲解Java随机数的几种产生方式，然后通过示例对其进行演示。</p>
</blockquote>
<blockquote>
<p>广义上讲，Java中的随机数的有三种产生方式：<br>(01). 通过System.currentTimeMillis()来获取一个当前时间毫秒数的long型数字。<br>(02). 通过Math.random()返回一个0到1之间的double值。<br>(03). 通过Random类来产生一个随机数，这个是专业的Random工具类，功能强大。  </p>
</blockquote>
<blockquote>
<p><strong>目录</strong><br><a href="#anchor1">第1种 利用System.currentTimeMillis()获取随机数</a><br><a href="#anchor2">第2种 利用Math.random()获取随机数</a><br><a href="#anchor3">第3种 利用Random类来获取随机数</a><br><a href="#anchor4">获取随机数示例</a>   </p>
</blockquote>
<p><a name="anchor1"></a></p>
<h1 id="第1种-利用System-currentTimeMillis-获取随机数"><a href="#第1种-利用System-currentTimeMillis-获取随机数" class="headerlink" title="第1种 利用System.currentTimeMillis()获取随机数"></a>第1种 利用System.currentTimeMillis()获取随机数</h1><p>通过System.currentTimeMillis()来获取随机数。实际上是获取当前时间毫秒数，它是long类型。使用方法如下：</p>
<pre><code>final long l = System.currentTimeMillis();</code></pre><p>若要获取int类型的整数，只需要将上面的结果转行成int类型即可。比如，获取[0, 100)之间的int整数。方法如下：</p>
<pre><code>final long l = System.currentTimeMillis();
final int i = (int)( l % 100 );</code></pre><p><a name="anchor2"></a></p>
<h1 id="第2种-利用Math-random-获取随机数"><a href="#第2种-利用Math-random-获取随机数" class="headerlink" title="第2种 利用Math.random()获取随机数"></a>第2种 利用Math.random()获取随机数</h1><p>通过Math.random()来获取随机数。实际上，它返回的是0(包含)到1(不包含)之间的double值。使用方法如下：</p>
<pre><code>final double d = Math.random();</code></pre><p>若要获取int类型的整数，只需要将上面的结果转行成int类型即可。比如，获取[0, 100)之间的int整数。方法如下：</p>
<pre><code>final double d = Math.random();
final int i = (int)(d*100);</code></pre><p><a name="anchor3"></a></p>
<h1 id="第3种-利用Random类来获取随机数"><a href="#第3种-利用Random类来获取随机数" class="headerlink" title="第3种 利用Random类来获取随机数"></a>第3种 利用Random类来获取随机数</h1><p>通过Random类来获取随机数。</p>
<p>使用方法如下：<br>(01) 创建Random对象。有两种方法可以创建Random对象，如下：</p>
<pre><code>Random random = new Random();//默认构造方法
Random random = new Random(1000);//指定种子数字</code></pre><p>(02) 通过Random对象获取随机数。Random支持的随机值类型包括：boolean, byte, int, long, float, double。<br>比如，获取[0, 100)之间的int整数。方法如下：</p>
<pre><code>int i2 = random.nextInt(100);</code></pre><p>Random 的函数接口</p>
<pre><code>// 构造函数(一)： 创建一个新的随机数生成器。 
Random() 
// 构造函数(二)： 使用单个 long 种子创建一个新随机数生成器： public Random(long seed) { setSeed(seed); } next 方法使用它来保存随机数生成器的状态。
Random(long seed) 

boolean nextBoolean()         // 返回下一个“boolean类型”伪随机数。 
void    nextBytes(byte[] buf) // 生成随机字节并将其置于字节数组buf中。 
double  nextDouble()          // 返回一个“[0.0, 1.0) 之间的double类型”的随机数。 
float   nextFloat()           // 返回一个“[0.0, 1.0) 之间的float类型”的随机数。 
int     nextInt()             // 返回下一个“int类型”随机数。 
int     nextInt(int n)        // 返回一个“[0, n) 之间的int类型”的随机数。 
long    nextLong()            // 返回下一个“long类型”随机数。 
synchronized double nextGaussian()   // 返回下一个“double类型”的随机数，它是呈高斯（“正常地”）分布的 double 值，其平均值是 0.0，标准偏差是 1.0。 
synchronized void setSeed(long seed) // 使用单个 long 种子设置此随机数生成器的种子。</code></pre><p><a name="anchor4"></a></p>
<h1 id="获取随机数示例"><a href="#获取随机数示例" class="headerlink" title="获取随机数示例"></a>获取随机数示例</h1><p>下面通过示例演示上面3种获取随机数的使用方法。<br>源码如下(RandomTest.java)：</p>
<pre><code>import java.util.Random;
import java.lang.Math;

/**
 * java 的随机数测试程序。共3种获取随机数的方法：
 *   (01)、通过System.currentTimeMillis()来获取一个当前时间毫秒数的long型数字。
 *   (02)、通过Math.random()返回一个0到1之间的double值。
 *   (03)、通过Random类来产生一个随机数，这个是专业的Random工具类，功能强大。
 *
 * @author skywang
 * @email kuiwu-wang@163.com
 */
public class RandomTest{

    public static void main(String args[]){

        // 通过System的currentTimeMillis()返回随机数
        testSystemTimeMillis();

        // 通过Math的random()返回随机数
        testMathRandom();

        // 新建“种子为1000”的Random对象，并通过该种子去测试Random的API
        testRandomAPIs(new Random(1000), &quot; 1st Random(1000)&quot;);
        testRandomAPIs(new Random(1000), &quot; 2nd Random(1000)&quot;);
        // 新建“默认种子”的Random对象，并通过该种子去测试Random的API
        testRandomAPIs(new Random(), &quot; 1st Random()&quot;);
        testRandomAPIs(new Random(), &quot; 2nd Random()&quot;);
    }

    /**
     * 返回随机数-01：测试System的currentTimeMillis()
     */
    private static void testSystemTimeMillis() {
        // 通过
        final long l = System.currentTimeMillis();
        // 通过l获取一个[0, 100)之间的整数
        final int i = (int)( l % 100 );

        System.out.printf(&quot;\n---- System.currentTimeMillis() ----\n l=%s i=%s\n&quot;, l, i);
    }


    /**
     * 返回随机数-02：测试Math的random()
     */
    private static void testMathRandom() {
        // 通过Math的random()函数返回一个double类型随机数，范围[0.0, 1.0)
        final double d = Math.random();
        // 通过d获取一个[0, 100)之间的整数
        final int i = (int)(d*100);

        System.out.printf(&quot;\n---- Math.random() ----\n d=%s i=%s\n&quot;, d, i);
    }


    /**
     * 返回随机数-03：测试Random的API
     */
    private static void testRandomAPIs(Random random, String title) {
        final int BUFFER_LEN = 5;

        // 获取随机的boolean值
        boolean b = random.nextBoolean();
        // 获取随机的数组buf[]
        byte[] buf = new byte[BUFFER_LEN];
        random.nextBytes(buf);
        // 获取随机的Double值，范围[0.0, 1.0)
        double d = random.nextDouble();
        // 获取随机的float值，范围[0.0, 1.0)
        float f = random.nextFloat();
        // 获取随机的int值
        int i1 = random.nextInt();
        // 获取随机的[0,100)之间的int值
        int i2 = random.nextInt(100);
        // 获取随机的高斯分布的double值
        double g = random.nextGaussian();
        // 获取随机的long值
        long l = random.nextLong();

        System.out.printf(&quot;\n---- %s ----\nb=%s, d=%s, f=%s, i1=%s, i2=%s, g=%s, l=%s, buf=[&quot;,
                title, b, d, f, i1, i2, g, l);
        for (byte bt:buf) 
            System.out.printf(&quot;%s, &quot;, bt);
        System.out.println(&quot;]&quot;);
    }
}</code></pre>
    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous is-invisible is-hidden-mobile">
        <a href="/tags/java/page/0/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/tags/java/page/2/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link is-current" href="/tags/java/">1</a></li>
        
        <li><a class="pagination-link" href="/tags/java/page/2/">2</a></li>
        
        <li><a class="pagination-link" href="/tags/java/page/3/">3</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 炸鸡叔&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>